var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (e.__esModule)
    return e;
  var o = e.default;
  if (typeof o == "function") {
    var S = function g() {
      return this instanceof g ? Reflect.construct(o, arguments, this.constructor) : o.apply(this, arguments);
    };
    S.prototype = o.prototype;
  } else
    S = {};
  return Object.defineProperty(S, "__esModule", { value: !0 }), Object.keys(e).forEach(function(g) {
    var U = Object.getOwnPropertyDescriptor(e, g);
    Object.defineProperty(S, g, U.get ? U : {
      enumerable: !0,
      get: function() {
        return e[g];
      }
    });
  }), S;
}
var buffer$3 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength;
base64Js$1.toByteArray = toByteArray;
base64Js$1.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2)
  lookup[i$2] = code[i$2], revLookup[code.charCodeAt(i$2)] = i$2;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(e) {
  var o = e.length;
  if (o % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var S = e.indexOf("=");
  S === -1 && (S = o);
  var g = S === o ? 0 : 4 - S % 4;
  return [S, g];
}
function byteLength(e) {
  var o = getLens(e), S = o[0], g = o[1];
  return (S + g) * 3 / 4 - g;
}
function _byteLength(e, o, S) {
  return (o + S) * 3 / 4 - S;
}
function toByteArray(e) {
  var o, S = getLens(e), g = S[0], U = S[1], h = new Arr(_byteLength(e, g, U)), q = 0, A = U > 0 ? g - 4 : g, P;
  for (P = 0; P < A; P += 4)
    o = revLookup[e.charCodeAt(P)] << 18 | revLookup[e.charCodeAt(P + 1)] << 12 | revLookup[e.charCodeAt(P + 2)] << 6 | revLookup[e.charCodeAt(P + 3)], h[q++] = o >> 16 & 255, h[q++] = o >> 8 & 255, h[q++] = o & 255;
  return U === 2 && (o = revLookup[e.charCodeAt(P)] << 2 | revLookup[e.charCodeAt(P + 1)] >> 4, h[q++] = o & 255), U === 1 && (o = revLookup[e.charCodeAt(P)] << 10 | revLookup[e.charCodeAt(P + 1)] << 4 | revLookup[e.charCodeAt(P + 2)] >> 2, h[q++] = o >> 8 & 255, h[q++] = o & 255), h;
}
function tripletToBase64(e) {
  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[e & 63];
}
function encodeChunk(e, o, S) {
  for (var g, U = [], h = o; h < S; h += 3)
    g = (e[h] << 16 & 16711680) + (e[h + 1] << 8 & 65280) + (e[h + 2] & 255), U.push(tripletToBase64(g));
  return U.join("");
}
function fromByteArray(e) {
  for (var o, S = e.length, g = S % 3, U = [], h = 16383, q = 0, A = S - g; q < A; q += h)
    U.push(encodeChunk(e, q, q + h > A ? A : q + h));
  return g === 1 ? (o = e[S - 1], U.push(
    lookup[o >> 2] + lookup[o << 4 & 63] + "=="
  )) : g === 2 && (o = (e[S - 2] << 8) + e[S - 1], U.push(
    lookup[o >> 10] + lookup[o >> 4 & 63] + lookup[o << 2 & 63] + "="
  )), U.join("");
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(e, o, S, g, U) {
  var h, q, A = U * 8 - g - 1, P = (1 << A) - 1, I = P >> 1, B = -7, H = S ? U - 1 : 0, V = S ? -1 : 1, X = e[o + H];
  for (H += V, h = X & (1 << -B) - 1, X >>= -B, B += A; B > 0; h = h * 256 + e[o + H], H += V, B -= 8)
    ;
  for (q = h & (1 << -B) - 1, h >>= -B, B += g; B > 0; q = q * 256 + e[o + H], H += V, B -= 8)
    ;
  if (h === 0)
    h = 1 - I;
  else {
    if (h === P)
      return q ? NaN : (X ? -1 : 1) * (1 / 0);
    q = q + Math.pow(2, g), h = h - I;
  }
  return (X ? -1 : 1) * q * Math.pow(2, h - g);
};
ieee754$1.write = function(e, o, S, g, U, h) {
  var q, A, P, I = h * 8 - U - 1, B = (1 << I) - 1, H = B >> 1, V = U === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, X = g ? 0 : h - 1, Q = g ? 1 : -1, ee = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
  for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (A = isNaN(o) ? 1 : 0, q = B) : (q = Math.floor(Math.log(o) / Math.LN2), o * (P = Math.pow(2, -q)) < 1 && (q--, P *= 2), q + H >= 1 ? o += V / P : o += V * Math.pow(2, 1 - H), o * P >= 2 && (q++, P /= 2), q + H >= B ? (A = 0, q = B) : q + H >= 1 ? (A = (o * P - 1) * Math.pow(2, U), q = q + H) : (A = o * Math.pow(2, H - 1) * Math.pow(2, U), q = 0)); U >= 8; e[S + X] = A & 255, X += Q, A /= 256, U -= 8)
    ;
  for (q = q << U | A, I += U; I > 0; e[S + X] = q & 255, X += Q, q /= 256, I -= 8)
    ;
  e[S + X - Q] |= ee * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var o = base64Js$1, S = ieee754$1, g = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = A, e.SlowBuffer = se, e.INSPECT_MAX_BYTES = 50;
  var U = 2147483647;
  e.kMaxLength = U, A.TYPED_ARRAY_SUPPORT = h(), !A.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function h() {
    try {
      var he = new Uint8Array(1), ue = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ue, Uint8Array.prototype), Object.setPrototypeOf(he, ue), he.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(A.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (A.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(A.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (A.isBuffer(this))
        return this.byteOffset;
    }
  });
  function q(he) {
    if (he > U)
      throw new RangeError('The value "' + he + '" is invalid for option "size"');
    var ue = new Uint8Array(he);
    return Object.setPrototypeOf(ue, A.prototype), ue;
  }
  function A(he, ue, de) {
    if (typeof he == "number") {
      if (typeof ue == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return H(he);
    }
    return P(he, ue, de);
  }
  A.poolSize = 8192;
  function P(he, ue, de) {
    if (typeof he == "string")
      return V(he, ue);
    if (ArrayBuffer.isView(he))
      return Q(he);
    if (he == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof he
      );
    if (qe(he, ArrayBuffer) || he && qe(he.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (qe(he, SharedArrayBuffer) || he && qe(he.buffer, SharedArrayBuffer)))
      return ee(he, ue, de);
    if (typeof he == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var _e = he.valueOf && he.valueOf();
    if (_e != null && _e !== he)
      return A.from(_e, ue, de);
    var Pe = ie(he);
    if (Pe)
      return Pe;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof he[Symbol.toPrimitive] == "function")
      return A.from(
        he[Symbol.toPrimitive]("string"),
        ue,
        de
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof he
    );
  }
  A.from = function(he, ue, de) {
    return P(he, ue, de);
  }, Object.setPrototypeOf(A.prototype, Uint8Array.prototype), Object.setPrototypeOf(A, Uint8Array);
  function I(he) {
    if (typeof he != "number")
      throw new TypeError('"size" argument must be of type number');
    if (he < 0)
      throw new RangeError('The value "' + he + '" is invalid for option "size"');
  }
  function B(he, ue, de) {
    return I(he), he <= 0 ? q(he) : ue !== void 0 ? typeof de == "string" ? q(he).fill(ue, de) : q(he).fill(ue) : q(he);
  }
  A.alloc = function(he, ue, de) {
    return B(he, ue, de);
  };
  function H(he) {
    return I(he), q(he < 0 ? 0 : te(he) | 0);
  }
  A.allocUnsafe = function(he) {
    return H(he);
  }, A.allocUnsafeSlow = function(he) {
    return H(he);
  };
  function V(he, ue) {
    if ((typeof ue != "string" || ue === "") && (ue = "utf8"), !A.isEncoding(ue))
      throw new TypeError("Unknown encoding: " + ue);
    var de = le(he, ue) | 0, _e = q(de), Pe = _e.write(he, ue);
    return Pe !== de && (_e = _e.slice(0, Pe)), _e;
  }
  function X(he) {
    for (var ue = he.length < 0 ? 0 : te(he.length) | 0, de = q(ue), _e = 0; _e < ue; _e += 1)
      de[_e] = he[_e] & 255;
    return de;
  }
  function Q(he) {
    if (qe(he, Uint8Array)) {
      var ue = new Uint8Array(he);
      return ee(ue.buffer, ue.byteOffset, ue.byteLength);
    }
    return X(he);
  }
  function ee(he, ue, de) {
    if (ue < 0 || he.byteLength < ue)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (he.byteLength < ue + (de || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var _e;
    return ue === void 0 && de === void 0 ? _e = new Uint8Array(he) : de === void 0 ? _e = new Uint8Array(he, ue) : _e = new Uint8Array(he, ue, de), Object.setPrototypeOf(_e, A.prototype), _e;
  }
  function ie(he) {
    if (A.isBuffer(he)) {
      var ue = te(he.length) | 0, de = q(ue);
      return de.length === 0 || he.copy(de, 0, 0, ue), de;
    }
    if (he.length !== void 0)
      return typeof he.length != "number" || De(he.length) ? q(0) : X(he);
    if (he.type === "Buffer" && Array.isArray(he.data))
      return X(he.data);
  }
  function te(he) {
    if (he >= U)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + U.toString(16) + " bytes");
    return he | 0;
  }
  function se(he) {
    return +he != he && (he = 0), A.alloc(+he);
  }
  A.isBuffer = function(ue) {
    return ue != null && ue._isBuffer === !0 && ue !== A.prototype;
  }, A.compare = function(ue, de) {
    if (qe(ue, Uint8Array) && (ue = A.from(ue, ue.offset, ue.byteLength)), qe(de, Uint8Array) && (de = A.from(de, de.offset, de.byteLength)), !A.isBuffer(ue) || !A.isBuffer(de))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ue === de)
      return 0;
    for (var _e = ue.length, Pe = de.length, He = 0, Ve = Math.min(_e, Pe); He < Ve; ++He)
      if (ue[He] !== de[He]) {
        _e = ue[He], Pe = de[He];
        break;
      }
    return _e < Pe ? -1 : Pe < _e ? 1 : 0;
  }, A.isEncoding = function(ue) {
    switch (String(ue).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, A.concat = function(ue, de) {
    if (!Array.isArray(ue))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ue.length === 0)
      return A.alloc(0);
    var _e;
    if (de === void 0)
      for (de = 0, _e = 0; _e < ue.length; ++_e)
        de += ue[_e].length;
    var Pe = A.allocUnsafe(de), He = 0;
    for (_e = 0; _e < ue.length; ++_e) {
      var Ve = ue[_e];
      if (qe(Ve, Uint8Array))
        He + Ve.length > Pe.length ? A.from(Ve).copy(Pe, He) : Uint8Array.prototype.set.call(
          Pe,
          Ve,
          He
        );
      else if (A.isBuffer(Ve))
        Ve.copy(Pe, He);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      He += Ve.length;
    }
    return Pe;
  };
  function le(he, ue) {
    if (A.isBuffer(he))
      return he.length;
    if (ArrayBuffer.isView(he) || qe(he, ArrayBuffer))
      return he.byteLength;
    if (typeof he != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof he
      );
    var de = he.length, _e = arguments.length > 2 && arguments[2] === !0;
    if (!_e && de === 0)
      return 0;
    for (var Pe = !1; ; )
      switch (ue) {
        case "ascii":
        case "latin1":
        case "binary":
          return de;
        case "utf8":
        case "utf-8":
          return fe(he).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return de * 2;
        case "hex":
          return de >>> 1;
        case "base64":
          return be(he).length;
        default:
          if (Pe)
            return _e ? -1 : fe(he).length;
          ue = ("" + ue).toLowerCase(), Pe = !0;
      }
  }
  A.byteLength = le;
  function ce(he, ue, de) {
    var _e = !1;
    if ((ue === void 0 || ue < 0) && (ue = 0), ue > this.length || ((de === void 0 || de > this.length) && (de = this.length), de <= 0) || (de >>>= 0, ue >>>= 0, de <= ue))
      return "";
    for (he || (he = "utf8"); ; )
      switch (he) {
        case "hex":
          return z(this, ue, de);
        case "utf8":
        case "utf-8":
          return $(this, ue, de);
        case "ascii":
          return Z(this, ue, de);
        case "latin1":
        case "binary":
          return K(this, ue, de);
        case "base64":
          return M(this, ue, de);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, ue, de);
        default:
          if (_e)
            throw new TypeError("Unknown encoding: " + he);
          he = (he + "").toLowerCase(), _e = !0;
      }
  }
  A.prototype._isBuffer = !0;
  function pe(he, ue, de) {
    var _e = he[ue];
    he[ue] = he[de], he[de] = _e;
  }
  A.prototype.swap16 = function() {
    var ue = this.length;
    if (ue % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var de = 0; de < ue; de += 2)
      pe(this, de, de + 1);
    return this;
  }, A.prototype.swap32 = function() {
    var ue = this.length;
    if (ue % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var de = 0; de < ue; de += 4)
      pe(this, de, de + 3), pe(this, de + 1, de + 2);
    return this;
  }, A.prototype.swap64 = function() {
    var ue = this.length;
    if (ue % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var de = 0; de < ue; de += 8)
      pe(this, de, de + 7), pe(this, de + 1, de + 6), pe(this, de + 2, de + 5), pe(this, de + 3, de + 4);
    return this;
  }, A.prototype.toString = function() {
    var ue = this.length;
    return ue === 0 ? "" : arguments.length === 0 ? $(this, 0, ue) : ce.apply(this, arguments);
  }, A.prototype.toLocaleString = A.prototype.toString, A.prototype.equals = function(ue) {
    if (!A.isBuffer(ue))
      throw new TypeError("Argument must be a Buffer");
    return this === ue ? !0 : A.compare(this, ue) === 0;
  }, A.prototype.inspect = function() {
    var ue = "", de = e.INSPECT_MAX_BYTES;
    return ue = this.toString("hex", 0, de).replace(/(.{2})/g, "$1 ").trim(), this.length > de && (ue += " ... "), "<Buffer " + ue + ">";
  }, g && (A.prototype[g] = A.prototype.inspect), A.prototype.compare = function(ue, de, _e, Pe, He) {
    if (qe(ue, Uint8Array) && (ue = A.from(ue, ue.offset, ue.byteLength)), !A.isBuffer(ue))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ue
      );
    if (de === void 0 && (de = 0), _e === void 0 && (_e = ue ? ue.length : 0), Pe === void 0 && (Pe = 0), He === void 0 && (He = this.length), de < 0 || _e > ue.length || Pe < 0 || He > this.length)
      throw new RangeError("out of range index");
    if (Pe >= He && de >= _e)
      return 0;
    if (Pe >= He)
      return -1;
    if (de >= _e)
      return 1;
    if (de >>>= 0, _e >>>= 0, Pe >>>= 0, He >>>= 0, this === ue)
      return 0;
    for (var Ve = He - Pe, nt = _e - de, Ie = Math.min(Ve, nt), Fe = this.slice(Pe, He), je = ue.slice(de, _e), Ke = 0; Ke < Ie; ++Ke)
      if (Fe[Ke] !== je[Ke]) {
        Ve = Fe[Ke], nt = je[Ke];
        break;
      }
    return Ve < nt ? -1 : nt < Ve ? 1 : 0;
  };
  function me(he, ue, de, _e, Pe) {
    if (he.length === 0)
      return -1;
    if (typeof de == "string" ? (_e = de, de = 0) : de > 2147483647 ? de = 2147483647 : de < -2147483648 && (de = -2147483648), de = +de, De(de) && (de = Pe ? 0 : he.length - 1), de < 0 && (de = he.length + de), de >= he.length) {
      if (Pe)
        return -1;
      de = he.length - 1;
    } else if (de < 0)
      if (Pe)
        de = 0;
      else
        return -1;
    if (typeof ue == "string" && (ue = A.from(ue, _e)), A.isBuffer(ue))
      return ue.length === 0 ? -1 : Me(he, ue, de, _e, Pe);
    if (typeof ue == "number")
      return ue = ue & 255, typeof Uint8Array.prototype.indexOf == "function" ? Pe ? Uint8Array.prototype.indexOf.call(he, ue, de) : Uint8Array.prototype.lastIndexOf.call(he, ue, de) : Me(he, [ue], de, _e, Pe);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Me(he, ue, de, _e, Pe) {
    var He = 1, Ve = he.length, nt = ue.length;
    if (_e !== void 0 && (_e = String(_e).toLowerCase(), _e === "ucs2" || _e === "ucs-2" || _e === "utf16le" || _e === "utf-16le")) {
      if (he.length < 2 || ue.length < 2)
        return -1;
      He = 2, Ve /= 2, nt /= 2, de /= 2;
    }
    function Ie(ut, pt) {
      return He === 1 ? ut[pt] : ut.readUInt16BE(pt * He);
    }
    var Fe;
    if (Pe) {
      var je = -1;
      for (Fe = de; Fe < Ve; Fe++)
        if (Ie(he, Fe) === Ie(ue, je === -1 ? 0 : Fe - je)) {
          if (je === -1 && (je = Fe), Fe - je + 1 === nt)
            return je * He;
        } else
          je !== -1 && (Fe -= Fe - je), je = -1;
    } else
      for (de + nt > Ve && (de = Ve - nt), Fe = de; Fe >= 0; Fe--) {
        for (var Ke = !0, ot = 0; ot < nt; ot++)
          if (Ie(he, Fe + ot) !== Ie(ue, ot)) {
            Ke = !1;
            break;
          }
        if (Ke)
          return Fe;
      }
    return -1;
  }
  A.prototype.includes = function(ue, de, _e) {
    return this.indexOf(ue, de, _e) !== -1;
  }, A.prototype.indexOf = function(ue, de, _e) {
    return me(this, ue, de, _e, !0);
  }, A.prototype.lastIndexOf = function(ue, de, _e) {
    return me(this, ue, de, _e, !1);
  };
  function Ee(he, ue, de, _e) {
    de = Number(de) || 0;
    var Pe = he.length - de;
    _e ? (_e = Number(_e), _e > Pe && (_e = Pe)) : _e = Pe;
    var He = ue.length;
    _e > He / 2 && (_e = He / 2);
    for (var Ve = 0; Ve < _e; ++Ve) {
      var nt = parseInt(ue.substr(Ve * 2, 2), 16);
      if (De(nt))
        return Ve;
      he[de + Ve] = nt;
    }
    return Ve;
  }
  function Re(he, ue, de, _e) {
    return ve(fe(ue, he.length - de), he, de, _e);
  }
  function Ne(he, ue, de, _e) {
    return ve($e(ue), he, de, _e);
  }
  function ne(he, ue, de, _e) {
    return ve(be(ue), he, de, _e);
  }
  function Y(he, ue, de, _e) {
    return ve(Be(ue, he.length - de), he, de, _e);
  }
  A.prototype.write = function(ue, de, _e, Pe) {
    if (de === void 0)
      Pe = "utf8", _e = this.length, de = 0;
    else if (_e === void 0 && typeof de == "string")
      Pe = de, _e = this.length, de = 0;
    else if (isFinite(de))
      de = de >>> 0, isFinite(_e) ? (_e = _e >>> 0, Pe === void 0 && (Pe = "utf8")) : (Pe = _e, _e = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var He = this.length - de;
    if ((_e === void 0 || _e > He) && (_e = He), ue.length > 0 && (_e < 0 || de < 0) || de > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Pe || (Pe = "utf8");
    for (var Ve = !1; ; )
      switch (Pe) {
        case "hex":
          return Ee(this, ue, de, _e);
        case "utf8":
        case "utf-8":
          return Re(this, ue, de, _e);
        case "ascii":
        case "latin1":
        case "binary":
          return Ne(this, ue, de, _e);
        case "base64":
          return ne(this, ue, de, _e);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Y(this, ue, de, _e);
        default:
          if (Ve)
            throw new TypeError("Unknown encoding: " + Pe);
          Pe = ("" + Pe).toLowerCase(), Ve = !0;
      }
  }, A.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function M(he, ue, de) {
    return ue === 0 && de === he.length ? o.fromByteArray(he) : o.fromByteArray(he.slice(ue, de));
  }
  function $(he, ue, de) {
    de = Math.min(he.length, de);
    for (var _e = [], Pe = ue; Pe < de; ) {
      var He = he[Pe], Ve = null, nt = He > 239 ? 4 : He > 223 ? 3 : He > 191 ? 2 : 1;
      if (Pe + nt <= de) {
        var Ie, Fe, je, Ke;
        switch (nt) {
          case 1:
            He < 128 && (Ve = He);
            break;
          case 2:
            Ie = he[Pe + 1], (Ie & 192) === 128 && (Ke = (He & 31) << 6 | Ie & 63, Ke > 127 && (Ve = Ke));
            break;
          case 3:
            Ie = he[Pe + 1], Fe = he[Pe + 2], (Ie & 192) === 128 && (Fe & 192) === 128 && (Ke = (He & 15) << 12 | (Ie & 63) << 6 | Fe & 63, Ke > 2047 && (Ke < 55296 || Ke > 57343) && (Ve = Ke));
            break;
          case 4:
            Ie = he[Pe + 1], Fe = he[Pe + 2], je = he[Pe + 3], (Ie & 192) === 128 && (Fe & 192) === 128 && (je & 192) === 128 && (Ke = (He & 15) << 18 | (Ie & 63) << 12 | (Fe & 63) << 6 | je & 63, Ke > 65535 && Ke < 1114112 && (Ve = Ke));
        }
      }
      Ve === null ? (Ve = 65533, nt = 1) : Ve > 65535 && (Ve -= 65536, _e.push(Ve >>> 10 & 1023 | 55296), Ve = 56320 | Ve & 1023), _e.push(Ve), Pe += nt;
    }
    return J(_e);
  }
  var O = 4096;
  function J(he) {
    var ue = he.length;
    if (ue <= O)
      return String.fromCharCode.apply(String, he);
    for (var de = "", _e = 0; _e < ue; )
      de += String.fromCharCode.apply(
        String,
        he.slice(_e, _e += O)
      );
    return de;
  }
  function Z(he, ue, de) {
    var _e = "";
    de = Math.min(he.length, de);
    for (var Pe = ue; Pe < de; ++Pe)
      _e += String.fromCharCode(he[Pe] & 127);
    return _e;
  }
  function K(he, ue, de) {
    var _e = "";
    de = Math.min(he.length, de);
    for (var Pe = ue; Pe < de; ++Pe)
      _e += String.fromCharCode(he[Pe]);
    return _e;
  }
  function z(he, ue, de) {
    var _e = he.length;
    (!ue || ue < 0) && (ue = 0), (!de || de < 0 || de > _e) && (de = _e);
    for (var Pe = "", He = ue; He < de; ++He)
      Pe += Ye[he[He]];
    return Pe;
  }
  function G(he, ue, de) {
    for (var _e = he.slice(ue, de), Pe = "", He = 0; He < _e.length - 1; He += 2)
      Pe += String.fromCharCode(_e[He] + _e[He + 1] * 256);
    return Pe;
  }
  A.prototype.slice = function(ue, de) {
    var _e = this.length;
    ue = ~~ue, de = de === void 0 ? _e : ~~de, ue < 0 ? (ue += _e, ue < 0 && (ue = 0)) : ue > _e && (ue = _e), de < 0 ? (de += _e, de < 0 && (de = 0)) : de > _e && (de = _e), de < ue && (de = ue);
    var Pe = this.subarray(ue, de);
    return Object.setPrototypeOf(Pe, A.prototype), Pe;
  };
  function D(he, ue, de) {
    if (he % 1 !== 0 || he < 0)
      throw new RangeError("offset is not uint");
    if (he + ue > de)
      throw new RangeError("Trying to access beyond buffer length");
  }
  A.prototype.readUintLE = A.prototype.readUIntLE = function(ue, de, _e) {
    ue = ue >>> 0, de = de >>> 0, _e || D(ue, de, this.length);
    for (var Pe = this[ue], He = 1, Ve = 0; ++Ve < de && (He *= 256); )
      Pe += this[ue + Ve] * He;
    return Pe;
  }, A.prototype.readUintBE = A.prototype.readUIntBE = function(ue, de, _e) {
    ue = ue >>> 0, de = de >>> 0, _e || D(ue, de, this.length);
    for (var Pe = this[ue + --de], He = 1; de > 0 && (He *= 256); )
      Pe += this[ue + --de] * He;
    return Pe;
  }, A.prototype.readUint8 = A.prototype.readUInt8 = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 1, this.length), this[ue];
  }, A.prototype.readUint16LE = A.prototype.readUInt16LE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 2, this.length), this[ue] | this[ue + 1] << 8;
  }, A.prototype.readUint16BE = A.prototype.readUInt16BE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 2, this.length), this[ue] << 8 | this[ue + 1];
  }, A.prototype.readUint32LE = A.prototype.readUInt32LE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 4, this.length), (this[ue] | this[ue + 1] << 8 | this[ue + 2] << 16) + this[ue + 3] * 16777216;
  }, A.prototype.readUint32BE = A.prototype.readUInt32BE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 4, this.length), this[ue] * 16777216 + (this[ue + 1] << 16 | this[ue + 2] << 8 | this[ue + 3]);
  }, A.prototype.readIntLE = function(ue, de, _e) {
    ue = ue >>> 0, de = de >>> 0, _e || D(ue, de, this.length);
    for (var Pe = this[ue], He = 1, Ve = 0; ++Ve < de && (He *= 256); )
      Pe += this[ue + Ve] * He;
    return He *= 128, Pe >= He && (Pe -= Math.pow(2, 8 * de)), Pe;
  }, A.prototype.readIntBE = function(ue, de, _e) {
    ue = ue >>> 0, de = de >>> 0, _e || D(ue, de, this.length);
    for (var Pe = de, He = 1, Ve = this[ue + --Pe]; Pe > 0 && (He *= 256); )
      Ve += this[ue + --Pe] * He;
    return He *= 128, Ve >= He && (Ve -= Math.pow(2, 8 * de)), Ve;
  }, A.prototype.readInt8 = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 1, this.length), this[ue] & 128 ? (255 - this[ue] + 1) * -1 : this[ue];
  }, A.prototype.readInt16LE = function(ue, de) {
    ue = ue >>> 0, de || D(ue, 2, this.length);
    var _e = this[ue] | this[ue + 1] << 8;
    return _e & 32768 ? _e | 4294901760 : _e;
  }, A.prototype.readInt16BE = function(ue, de) {
    ue = ue >>> 0, de || D(ue, 2, this.length);
    var _e = this[ue + 1] | this[ue] << 8;
    return _e & 32768 ? _e | 4294901760 : _e;
  }, A.prototype.readInt32LE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 4, this.length), this[ue] | this[ue + 1] << 8 | this[ue + 2] << 16 | this[ue + 3] << 24;
  }, A.prototype.readInt32BE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 4, this.length), this[ue] << 24 | this[ue + 1] << 16 | this[ue + 2] << 8 | this[ue + 3];
  }, A.prototype.readFloatLE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 4, this.length), S.read(this, ue, !0, 23, 4);
  }, A.prototype.readFloatBE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 4, this.length), S.read(this, ue, !1, 23, 4);
  }, A.prototype.readDoubleLE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 8, this.length), S.read(this, ue, !0, 52, 8);
  }, A.prototype.readDoubleBE = function(ue, de) {
    return ue = ue >>> 0, de || D(ue, 8, this.length), S.read(this, ue, !1, 52, 8);
  };
  function F(he, ue, de, _e, Pe, He) {
    if (!A.isBuffer(he))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ue > Pe || ue < He)
      throw new RangeError('"value" argument is out of bounds');
    if (de + _e > he.length)
      throw new RangeError("Index out of range");
  }
  A.prototype.writeUintLE = A.prototype.writeUIntLE = function(ue, de, _e, Pe) {
    if (ue = +ue, de = de >>> 0, _e = _e >>> 0, !Pe) {
      var He = Math.pow(2, 8 * _e) - 1;
      F(this, ue, de, _e, He, 0);
    }
    var Ve = 1, nt = 0;
    for (this[de] = ue & 255; ++nt < _e && (Ve *= 256); )
      this[de + nt] = ue / Ve & 255;
    return de + _e;
  }, A.prototype.writeUintBE = A.prototype.writeUIntBE = function(ue, de, _e, Pe) {
    if (ue = +ue, de = de >>> 0, _e = _e >>> 0, !Pe) {
      var He = Math.pow(2, 8 * _e) - 1;
      F(this, ue, de, _e, He, 0);
    }
    var Ve = _e - 1, nt = 1;
    for (this[de + Ve] = ue & 255; --Ve >= 0 && (nt *= 256); )
      this[de + Ve] = ue / nt & 255;
    return de + _e;
  }, A.prototype.writeUint8 = A.prototype.writeUInt8 = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 1, 255, 0), this[de] = ue & 255, de + 1;
  }, A.prototype.writeUint16LE = A.prototype.writeUInt16LE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 2, 65535, 0), this[de] = ue & 255, this[de + 1] = ue >>> 8, de + 2;
  }, A.prototype.writeUint16BE = A.prototype.writeUInt16BE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 2, 65535, 0), this[de] = ue >>> 8, this[de + 1] = ue & 255, de + 2;
  }, A.prototype.writeUint32LE = A.prototype.writeUInt32LE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 4, 4294967295, 0), this[de + 3] = ue >>> 24, this[de + 2] = ue >>> 16, this[de + 1] = ue >>> 8, this[de] = ue & 255, de + 4;
  }, A.prototype.writeUint32BE = A.prototype.writeUInt32BE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 4, 4294967295, 0), this[de] = ue >>> 24, this[de + 1] = ue >>> 16, this[de + 2] = ue >>> 8, this[de + 3] = ue & 255, de + 4;
  }, A.prototype.writeIntLE = function(ue, de, _e, Pe) {
    if (ue = +ue, de = de >>> 0, !Pe) {
      var He = Math.pow(2, 8 * _e - 1);
      F(this, ue, de, _e, He - 1, -He);
    }
    var Ve = 0, nt = 1, Ie = 0;
    for (this[de] = ue & 255; ++Ve < _e && (nt *= 256); )
      ue < 0 && Ie === 0 && this[de + Ve - 1] !== 0 && (Ie = 1), this[de + Ve] = (ue / nt >> 0) - Ie & 255;
    return de + _e;
  }, A.prototype.writeIntBE = function(ue, de, _e, Pe) {
    if (ue = +ue, de = de >>> 0, !Pe) {
      var He = Math.pow(2, 8 * _e - 1);
      F(this, ue, de, _e, He - 1, -He);
    }
    var Ve = _e - 1, nt = 1, Ie = 0;
    for (this[de + Ve] = ue & 255; --Ve >= 0 && (nt *= 256); )
      ue < 0 && Ie === 0 && this[de + Ve + 1] !== 0 && (Ie = 1), this[de + Ve] = (ue / nt >> 0) - Ie & 255;
    return de + _e;
  }, A.prototype.writeInt8 = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 1, 127, -128), ue < 0 && (ue = 255 + ue + 1), this[de] = ue & 255, de + 1;
  }, A.prototype.writeInt16LE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 2, 32767, -32768), this[de] = ue & 255, this[de + 1] = ue >>> 8, de + 2;
  }, A.prototype.writeInt16BE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 2, 32767, -32768), this[de] = ue >>> 8, this[de + 1] = ue & 255, de + 2;
  }, A.prototype.writeInt32LE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 4, 2147483647, -2147483648), this[de] = ue & 255, this[de + 1] = ue >>> 8, this[de + 2] = ue >>> 16, this[de + 3] = ue >>> 24, de + 4;
  }, A.prototype.writeInt32BE = function(ue, de, _e) {
    return ue = +ue, de = de >>> 0, _e || F(this, ue, de, 4, 2147483647, -2147483648), ue < 0 && (ue = 4294967295 + ue + 1), this[de] = ue >>> 24, this[de + 1] = ue >>> 16, this[de + 2] = ue >>> 8, this[de + 3] = ue & 255, de + 4;
  };
  function ae(he, ue, de, _e, Pe, He) {
    if (de + _e > he.length)
      throw new RangeError("Index out of range");
    if (de < 0)
      throw new RangeError("Index out of range");
  }
  function ge(he, ue, de, _e, Pe) {
    return ue = +ue, de = de >>> 0, Pe || ae(he, ue, de, 4), S.write(he, ue, de, _e, 23, 4), de + 4;
  }
  A.prototype.writeFloatLE = function(ue, de, _e) {
    return ge(this, ue, de, !0, _e);
  }, A.prototype.writeFloatBE = function(ue, de, _e) {
    return ge(this, ue, de, !1, _e);
  };
  function xe(he, ue, de, _e, Pe) {
    return ue = +ue, de = de >>> 0, Pe || ae(he, ue, de, 8), S.write(he, ue, de, _e, 52, 8), de + 8;
  }
  A.prototype.writeDoubleLE = function(ue, de, _e) {
    return xe(this, ue, de, !0, _e);
  }, A.prototype.writeDoubleBE = function(ue, de, _e) {
    return xe(this, ue, de, !1, _e);
  }, A.prototype.copy = function(ue, de, _e, Pe) {
    if (!A.isBuffer(ue))
      throw new TypeError("argument should be a Buffer");
    if (_e || (_e = 0), !Pe && Pe !== 0 && (Pe = this.length), de >= ue.length && (de = ue.length), de || (de = 0), Pe > 0 && Pe < _e && (Pe = _e), Pe === _e || ue.length === 0 || this.length === 0)
      return 0;
    if (de < 0)
      throw new RangeError("targetStart out of bounds");
    if (_e < 0 || _e >= this.length)
      throw new RangeError("Index out of range");
    if (Pe < 0)
      throw new RangeError("sourceEnd out of bounds");
    Pe > this.length && (Pe = this.length), ue.length - de < Pe - _e && (Pe = ue.length - de + _e);
    var He = Pe - _e;
    return this === ue && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(de, _e, Pe) : Uint8Array.prototype.set.call(
      ue,
      this.subarray(_e, Pe),
      de
    ), He;
  }, A.prototype.fill = function(ue, de, _e, Pe) {
    if (typeof ue == "string") {
      if (typeof de == "string" ? (Pe = de, de = 0, _e = this.length) : typeof _e == "string" && (Pe = _e, _e = this.length), Pe !== void 0 && typeof Pe != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Pe == "string" && !A.isEncoding(Pe))
        throw new TypeError("Unknown encoding: " + Pe);
      if (ue.length === 1) {
        var He = ue.charCodeAt(0);
        (Pe === "utf8" && He < 128 || Pe === "latin1") && (ue = He);
      }
    } else
      typeof ue == "number" ? ue = ue & 255 : typeof ue == "boolean" && (ue = Number(ue));
    if (de < 0 || this.length < de || this.length < _e)
      throw new RangeError("Out of range index");
    if (_e <= de)
      return this;
    de = de >>> 0, _e = _e === void 0 ? this.length : _e >>> 0, ue || (ue = 0);
    var Ve;
    if (typeof ue == "number")
      for (Ve = de; Ve < _e; ++Ve)
        this[Ve] = ue;
    else {
      var nt = A.isBuffer(ue) ? ue : A.from(ue, Pe), Ie = nt.length;
      if (Ie === 0)
        throw new TypeError('The value "' + ue + '" is invalid for argument "value"');
      for (Ve = 0; Ve < _e - de; ++Ve)
        this[Ve + de] = nt[Ve % Ie];
    }
    return this;
  };
  var ye = /[^+/0-9A-Za-z-_]/g;
  function oe(he) {
    if (he = he.split("=")[0], he = he.trim().replace(ye, ""), he.length < 2)
      return "";
    for (; he.length % 4 !== 0; )
      he = he + "=";
    return he;
  }
  function fe(he, ue) {
    ue = ue || 1 / 0;
    for (var de, _e = he.length, Pe = null, He = [], Ve = 0; Ve < _e; ++Ve) {
      if (de = he.charCodeAt(Ve), de > 55295 && de < 57344) {
        if (!Pe) {
          if (de > 56319) {
            (ue -= 3) > -1 && He.push(239, 191, 189);
            continue;
          } else if (Ve + 1 === _e) {
            (ue -= 3) > -1 && He.push(239, 191, 189);
            continue;
          }
          Pe = de;
          continue;
        }
        if (de < 56320) {
          (ue -= 3) > -1 && He.push(239, 191, 189), Pe = de;
          continue;
        }
        de = (Pe - 55296 << 10 | de - 56320) + 65536;
      } else
        Pe && (ue -= 3) > -1 && He.push(239, 191, 189);
      if (Pe = null, de < 128) {
        if ((ue -= 1) < 0)
          break;
        He.push(de);
      } else if (de < 2048) {
        if ((ue -= 2) < 0)
          break;
        He.push(
          de >> 6 | 192,
          de & 63 | 128
        );
      } else if (de < 65536) {
        if ((ue -= 3) < 0)
          break;
        He.push(
          de >> 12 | 224,
          de >> 6 & 63 | 128,
          de & 63 | 128
        );
      } else if (de < 1114112) {
        if ((ue -= 4) < 0)
          break;
        He.push(
          de >> 18 | 240,
          de >> 12 & 63 | 128,
          de >> 6 & 63 | 128,
          de & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return He;
  }
  function $e(he) {
    for (var ue = [], de = 0; de < he.length; ++de)
      ue.push(he.charCodeAt(de) & 255);
    return ue;
  }
  function Be(he, ue) {
    for (var de, _e, Pe, He = [], Ve = 0; Ve < he.length && !((ue -= 2) < 0); ++Ve)
      de = he.charCodeAt(Ve), _e = de >> 8, Pe = de % 256, He.push(Pe), He.push(_e);
    return He;
  }
  function be(he) {
    return o.toByteArray(oe(he));
  }
  function ve(he, ue, de, _e) {
    for (var Pe = 0; Pe < _e && !(Pe + de >= ue.length || Pe >= he.length); ++Pe)
      ue[Pe + de] = he[Pe];
    return Pe;
  }
  function qe(he, ue) {
    return he instanceof ue || he != null && he.constructor != null && he.constructor.name != null && he.constructor.name === ue.name;
  }
  function De(he) {
    return he !== he;
  }
  var Ye = function() {
    for (var he = "0123456789abcdef", ue = new Array(256), de = 0; de < 16; ++de)
      for (var _e = de * 16, Pe = 0; Pe < 16; ++Pe)
        ue[_e + Pe] = he[de] + he[Pe];
    return ue;
  }();
})(buffer$3);
var browser$f = { exports: {} }, process$2 = browser$f.exports = {}, cachedSetTimeout$1, cachedClearTimeout$1;
function defaultSetTimout$1() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout$1() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout$1 = setTimeout : cachedSetTimeout$1 = defaultSetTimout$1;
  } catch {
    cachedSetTimeout$1 = defaultSetTimout$1;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout$1 = clearTimeout : cachedClearTimeout$1 = defaultClearTimeout$1;
  } catch {
    cachedClearTimeout$1 = defaultClearTimeout$1;
  }
})();
function runTimeout$1(e) {
  if (cachedSetTimeout$1 === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout)
    return cachedSetTimeout$1 = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout$1(e, 0);
  } catch {
    try {
      return cachedSetTimeout$1.call(null, e, 0);
    } catch {
      return cachedSetTimeout$1.call(this, e, 0);
    }
  }
}
function runClearTimeout$1(e) {
  if (cachedClearTimeout$1 === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout)
    return cachedClearTimeout$1 = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout$1(e);
  } catch {
    try {
      return cachedClearTimeout$1.call(null, e);
    } catch {
      return cachedClearTimeout$1.call(this, e);
    }
  }
}
var queue$1 = [], draining$1 = !1, currentQueue$1, queueIndex$1 = -1;
function cleanUpNextTick$1() {
  !draining$1 || !currentQueue$1 || (draining$1 = !1, currentQueue$1.length ? queue$1 = currentQueue$1.concat(queue$1) : queueIndex$1 = -1, queue$1.length && drainQueue$1());
}
function drainQueue$1() {
  if (!draining$1) {
    var e = runTimeout$1(cleanUpNextTick$1);
    draining$1 = !0;
    for (var o = queue$1.length; o; ) {
      for (currentQueue$1 = queue$1, queue$1 = []; ++queueIndex$1 < o; )
        currentQueue$1 && currentQueue$1[queueIndex$1].run();
      queueIndex$1 = -1, o = queue$1.length;
    }
    currentQueue$1 = null, draining$1 = !1, runClearTimeout$1(e);
  }
}
process$2.nextTick = function(e) {
  var o = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var S = 1; S < arguments.length; S++)
      o[S - 1] = arguments[S];
  queue$1.push(new Item$1(e, o)), queue$1.length === 1 && !draining$1 && runTimeout$1(drainQueue$1);
};
function Item$1(e, o) {
  this.fun = e, this.array = o;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$2.title = "browser";
process$2.browser = !0;
process$2.env = {};
process$2.argv = [];
process$2.version = "";
process$2.versions = {};
function noop$1() {
}
process$2.on = noop$1;
process$2.addListener = noop$1;
process$2.once = noop$1;
process$2.off = noop$1;
process$2.removeListener = noop$1;
process$2.removeAllListeners = noop$1;
process$2.emit = noop$1;
process$2.prependListener = noop$1;
process$2.prependOnceListener = noop$1;
process$2.listeners = function(e) {
  return [];
};
process$2.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process$2.cwd = function() {
  return "/";
};
process$2.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process$2.umask = function() {
  return 0;
};
var browserExports$2 = browser$f.exports;
const process$3 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$2);
var _globalThis = function(e) {
  function o() {
    var g = this || self;
    return delete e.prototype.__magic__, g;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return o();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: o
  });
  var S = __magic__;
  return S;
}(Object), _global = _globalThis;
const name$1$1 = "@wepin/fetch-js", version$1$1 = "0.0.1", description$1$1 = "Wepin fetch library for Web", author$1$1 = "IoTrust, Co., Ltd.", license$1$1 = "MIT", main$1$1 = "./dist/wepin-fetch-js.mjs", types$1$1 = "./dist/src/index.d.ts", files$1$1 = [
  "dist"
], scripts$1$1 = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, dependencies$1$1 = {
  "@wepin/storage-js": "link:../storage",
  bcryptjs: "^2.4.3",
  eventemitter2: "^6.4.9",
  "jwt-decode": "^4.0.0"
}, devDependencies$1$1 = {
  "@types/bcryptjs": "^2.4.6"
}, keywords$1$1 = [
  "wepin",
  "wepinwallet",
  "wallet",
  "wepin-fetch"
], packageJson = {
  name: name$1$1,
  version: version$1$1,
  description: description$1$1,
  author: author$1$1,
  license: license$1$1,
  main: main$1$1,
  types: types$1$1,
  files: files$1$1,
  scripts: scripts$1$1,
  dependencies: dependencies$1$1,
  devDependencies: devDependencies$1$1,
  keywords: keywords$1$1
};
class APIResponse {
  constructor({
    data: o,
    status: S,
    headers: g,
    request: U
  }) {
    this.data = o, this.status = S, this.headers = g, this.request = U;
  }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof _global < "u" ? _global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var buffer$1 = {}, base64Js = {}, hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js)
    return base64Js;
  hasRequiredBase64Js = 1, base64Js.byteLength = A, base64Js.toByteArray = I, base64Js.fromByteArray = V;
  for (var e = [], o = [], S = typeof Uint8Array < "u" ? Uint8Array : Array, g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", U = 0, h = g.length; U < h; ++U)
    e[U] = g[U], o[g.charCodeAt(U)] = U;
  o[45] = 62, o[95] = 63;
  function q(X) {
    var Q = X.length;
    if (Q % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var ee = X.indexOf("=");
    ee === -1 && (ee = Q);
    var ie = ee === Q ? 0 : 4 - ee % 4;
    return [ee, ie];
  }
  function A(X) {
    var Q = q(X), ee = Q[0], ie = Q[1];
    return (ee + ie) * 3 / 4 - ie;
  }
  function P(X, Q, ee) {
    return (Q + ee) * 3 / 4 - ee;
  }
  function I(X) {
    var Q, ee = q(X), ie = ee[0], te = ee[1], se = new S(P(X, ie, te)), le = 0, ce = te > 0 ? ie - 4 : ie, pe;
    for (pe = 0; pe < ce; pe += 4)
      Q = o[X.charCodeAt(pe)] << 18 | o[X.charCodeAt(pe + 1)] << 12 | o[X.charCodeAt(pe + 2)] << 6 | o[X.charCodeAt(pe + 3)], se[le++] = Q >> 16 & 255, se[le++] = Q >> 8 & 255, se[le++] = Q & 255;
    return te === 2 && (Q = o[X.charCodeAt(pe)] << 2 | o[X.charCodeAt(pe + 1)] >> 4, se[le++] = Q & 255), te === 1 && (Q = o[X.charCodeAt(pe)] << 10 | o[X.charCodeAt(pe + 1)] << 4 | o[X.charCodeAt(pe + 2)] >> 2, se[le++] = Q >> 8 & 255, se[le++] = Q & 255), se;
  }
  function B(X) {
    return e[X >> 18 & 63] + e[X >> 12 & 63] + e[X >> 6 & 63] + e[X & 63];
  }
  function H(X, Q, ee) {
    for (var ie, te = [], se = Q; se < ee; se += 3)
      ie = (X[se] << 16 & 16711680) + (X[se + 1] << 8 & 65280) + (X[se + 2] & 255), te.push(B(ie));
    return te.join("");
  }
  function V(X) {
    for (var Q, ee = X.length, ie = ee % 3, te = [], se = 16383, le = 0, ce = ee - ie; le < ce; le += se)
      te.push(H(X, le, le + se > ce ? ce : le + se));
    return ie === 1 ? (Q = X[ee - 1], te.push(
      e[Q >> 2] + e[Q << 4 & 63] + "=="
    )) : ie === 2 && (Q = (X[ee - 2] << 8) + X[ee - 1], te.push(
      e[Q >> 10] + e[Q >> 4 & 63] + e[Q << 2 & 63] + "="
    )), te.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  return hasRequiredIeee754 || (hasRequiredIeee754 = 1, ieee754.read = function(e, o, S, g, U) {
    var h, q, A = U * 8 - g - 1, P = (1 << A) - 1, I = P >> 1, B = -7, H = S ? U - 1 : 0, V = S ? -1 : 1, X = e[o + H];
    for (H += V, h = X & (1 << -B) - 1, X >>= -B, B += A; B > 0; h = h * 256 + e[o + H], H += V, B -= 8)
      ;
    for (q = h & (1 << -B) - 1, h >>= -B, B += g; B > 0; q = q * 256 + e[o + H], H += V, B -= 8)
      ;
    if (h === 0)
      h = 1 - I;
    else {
      if (h === P)
        return q ? NaN : (X ? -1 : 1) * (1 / 0);
      q = q + Math.pow(2, g), h = h - I;
    }
    return (X ? -1 : 1) * q * Math.pow(2, h - g);
  }, ieee754.write = function(e, o, S, g, U, h) {
    var q, A, P, I = h * 8 - U - 1, B = (1 << I) - 1, H = B >> 1, V = U === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, X = g ? 0 : h - 1, Q = g ? 1 : -1, ee = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
    for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (A = isNaN(o) ? 1 : 0, q = B) : (q = Math.floor(Math.log(o) / Math.LN2), o * (P = Math.pow(2, -q)) < 1 && (q--, P *= 2), q + H >= 1 ? o += V / P : o += V * Math.pow(2, 1 - H), o * P >= 2 && (q++, P /= 2), q + H >= B ? (A = 0, q = B) : q + H >= 1 ? (A = (o * P - 1) * Math.pow(2, U), q = q + H) : (A = o * Math.pow(2, H - 1) * Math.pow(2, U), q = 0)); U >= 8; e[S + X] = A & 255, X += Q, A /= 256, U -= 8)
      ;
    for (q = q << U | A, I += U; I > 0; e[S + X] = q & 255, X += Q, q /= 256, I -= 8)
      ;
    e[S + X - Q] |= ee * 128;
  }), ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer$1;
function requireBuffer$1() {
  return hasRequiredBuffer$1 || (hasRequiredBuffer$1 = 1, function(e) {
    var o = requireBase64Js(), S = requireIeee754(), g = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = A, e.SlowBuffer = se, e.INSPECT_MAX_BYTES = 50;
    var U = 2147483647;
    e.kMaxLength = U, A.TYPED_ARRAY_SUPPORT = h(), !A.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function h() {
      try {
        var he = new Uint8Array(1), ue = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(ue, Uint8Array.prototype), Object.setPrototypeOf(he, ue), he.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(A.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (A.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(A.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (A.isBuffer(this))
          return this.byteOffset;
      }
    });
    function q(he) {
      if (he > U)
        throw new RangeError('The value "' + he + '" is invalid for option "size"');
      var ue = new Uint8Array(he);
      return Object.setPrototypeOf(ue, A.prototype), ue;
    }
    function A(he, ue, de) {
      if (typeof he == "number") {
        if (typeof ue == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return H(he);
      }
      return P(he, ue, de);
    }
    A.poolSize = 8192;
    function P(he, ue, de) {
      if (typeof he == "string")
        return V(he, ue);
      if (ArrayBuffer.isView(he))
        return Q(he);
      if (he == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof he
        );
      if (qe(he, ArrayBuffer) || he && qe(he.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (qe(he, SharedArrayBuffer) || he && qe(he.buffer, SharedArrayBuffer)))
        return ee(he, ue, de);
      if (typeof he == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var _e = he.valueOf && he.valueOf();
      if (_e != null && _e !== he)
        return A.from(_e, ue, de);
      var Pe = ie(he);
      if (Pe)
        return Pe;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof he[Symbol.toPrimitive] == "function")
        return A.from(
          he[Symbol.toPrimitive]("string"),
          ue,
          de
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof he
      );
    }
    A.from = function(he, ue, de) {
      return P(he, ue, de);
    }, Object.setPrototypeOf(A.prototype, Uint8Array.prototype), Object.setPrototypeOf(A, Uint8Array);
    function I(he) {
      if (typeof he != "number")
        throw new TypeError('"size" argument must be of type number');
      if (he < 0)
        throw new RangeError('The value "' + he + '" is invalid for option "size"');
    }
    function B(he, ue, de) {
      return I(he), he <= 0 ? q(he) : ue !== void 0 ? typeof de == "string" ? q(he).fill(ue, de) : q(he).fill(ue) : q(he);
    }
    A.alloc = function(he, ue, de) {
      return B(he, ue, de);
    };
    function H(he) {
      return I(he), q(he < 0 ? 0 : te(he) | 0);
    }
    A.allocUnsafe = function(he) {
      return H(he);
    }, A.allocUnsafeSlow = function(he) {
      return H(he);
    };
    function V(he, ue) {
      if ((typeof ue != "string" || ue === "") && (ue = "utf8"), !A.isEncoding(ue))
        throw new TypeError("Unknown encoding: " + ue);
      var de = le(he, ue) | 0, _e = q(de), Pe = _e.write(he, ue);
      return Pe !== de && (_e = _e.slice(0, Pe)), _e;
    }
    function X(he) {
      for (var ue = he.length < 0 ? 0 : te(he.length) | 0, de = q(ue), _e = 0; _e < ue; _e += 1)
        de[_e] = he[_e] & 255;
      return de;
    }
    function Q(he) {
      if (qe(he, Uint8Array)) {
        var ue = new Uint8Array(he);
        return ee(ue.buffer, ue.byteOffset, ue.byteLength);
      }
      return X(he);
    }
    function ee(he, ue, de) {
      if (ue < 0 || he.byteLength < ue)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (he.byteLength < ue + (de || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var _e;
      return ue === void 0 && de === void 0 ? _e = new Uint8Array(he) : de === void 0 ? _e = new Uint8Array(he, ue) : _e = new Uint8Array(he, ue, de), Object.setPrototypeOf(_e, A.prototype), _e;
    }
    function ie(he) {
      if (A.isBuffer(he)) {
        var ue = te(he.length) | 0, de = q(ue);
        return de.length === 0 || he.copy(de, 0, 0, ue), de;
      }
      if (he.length !== void 0)
        return typeof he.length != "number" || De(he.length) ? q(0) : X(he);
      if (he.type === "Buffer" && Array.isArray(he.data))
        return X(he.data);
    }
    function te(he) {
      if (he >= U)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + U.toString(16) + " bytes");
      return he | 0;
    }
    function se(he) {
      return +he != he && (he = 0), A.alloc(+he);
    }
    A.isBuffer = function(he) {
      return he != null && he._isBuffer === !0 && he !== A.prototype;
    }, A.compare = function(he, ue) {
      if (qe(he, Uint8Array) && (he = A.from(he, he.offset, he.byteLength)), qe(ue, Uint8Array) && (ue = A.from(ue, ue.offset, ue.byteLength)), !A.isBuffer(he) || !A.isBuffer(ue))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (he === ue)
        return 0;
      for (var de = he.length, _e = ue.length, Pe = 0, He = Math.min(de, _e); Pe < He; ++Pe)
        if (he[Pe] !== ue[Pe]) {
          de = he[Pe], _e = ue[Pe];
          break;
        }
      return de < _e ? -1 : _e < de ? 1 : 0;
    }, A.isEncoding = function(he) {
      switch (String(he).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, A.concat = function(he, ue) {
      if (!Array.isArray(he))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (he.length === 0)
        return A.alloc(0);
      var de;
      if (ue === void 0)
        for (ue = 0, de = 0; de < he.length; ++de)
          ue += he[de].length;
      var _e = A.allocUnsafe(ue), Pe = 0;
      for (de = 0; de < he.length; ++de) {
        var He = he[de];
        if (qe(He, Uint8Array))
          Pe + He.length > _e.length ? A.from(He).copy(_e, Pe) : Uint8Array.prototype.set.call(
            _e,
            He,
            Pe
          );
        else if (A.isBuffer(He))
          He.copy(_e, Pe);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Pe += He.length;
      }
      return _e;
    };
    function le(he, ue) {
      if (A.isBuffer(he))
        return he.length;
      if (ArrayBuffer.isView(he) || qe(he, ArrayBuffer))
        return he.byteLength;
      if (typeof he != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof he
        );
      var de = he.length, _e = arguments.length > 2 && arguments[2] === !0;
      if (!_e && de === 0)
        return 0;
      for (var Pe = !1; ; )
        switch (ue) {
          case "ascii":
          case "latin1":
          case "binary":
            return de;
          case "utf8":
          case "utf-8":
            return fe(he).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return de * 2;
          case "hex":
            return de >>> 1;
          case "base64":
            return be(he).length;
          default:
            if (Pe)
              return _e ? -1 : fe(he).length;
            ue = ("" + ue).toLowerCase(), Pe = !0;
        }
    }
    A.byteLength = le;
    function ce(he, ue, de) {
      var _e = !1;
      if ((ue === void 0 || ue < 0) && (ue = 0), ue > this.length || ((de === void 0 || de > this.length) && (de = this.length), de <= 0) || (de >>>= 0, ue >>>= 0, de <= ue))
        return "";
      for (he || (he = "utf8"); ; )
        switch (he) {
          case "hex":
            return z(this, ue, de);
          case "utf8":
          case "utf-8":
            return $(this, ue, de);
          case "ascii":
            return Z(this, ue, de);
          case "latin1":
          case "binary":
            return K(this, ue, de);
          case "base64":
            return M(this, ue, de);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return G(this, ue, de);
          default:
            if (_e)
              throw new TypeError("Unknown encoding: " + he);
            he = (he + "").toLowerCase(), _e = !0;
        }
    }
    A.prototype._isBuffer = !0;
    function pe(he, ue, de) {
      var _e = he[ue];
      he[ue] = he[de], he[de] = _e;
    }
    A.prototype.swap16 = function() {
      var he = this.length;
      if (he % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var ue = 0; ue < he; ue += 2)
        pe(this, ue, ue + 1);
      return this;
    }, A.prototype.swap32 = function() {
      var he = this.length;
      if (he % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var ue = 0; ue < he; ue += 4)
        pe(this, ue, ue + 3), pe(this, ue + 1, ue + 2);
      return this;
    }, A.prototype.swap64 = function() {
      var he = this.length;
      if (he % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var ue = 0; ue < he; ue += 8)
        pe(this, ue, ue + 7), pe(this, ue + 1, ue + 6), pe(this, ue + 2, ue + 5), pe(this, ue + 3, ue + 4);
      return this;
    }, A.prototype.toString = function() {
      var he = this.length;
      return he === 0 ? "" : arguments.length === 0 ? $(this, 0, he) : ce.apply(this, arguments);
    }, A.prototype.toLocaleString = A.prototype.toString, A.prototype.equals = function(he) {
      if (!A.isBuffer(he))
        throw new TypeError("Argument must be a Buffer");
      return this === he ? !0 : A.compare(this, he) === 0;
    }, A.prototype.inspect = function() {
      var he = "", ue = e.INSPECT_MAX_BYTES;
      return he = this.toString("hex", 0, ue).replace(/(.{2})/g, "$1 ").trim(), this.length > ue && (he += " ... "), "<Buffer " + he + ">";
    }, g && (A.prototype[g] = A.prototype.inspect), A.prototype.compare = function(he, ue, de, _e, Pe) {
      if (qe(he, Uint8Array) && (he = A.from(he, he.offset, he.byteLength)), !A.isBuffer(he))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof he
        );
      if (ue === void 0 && (ue = 0), de === void 0 && (de = he ? he.length : 0), _e === void 0 && (_e = 0), Pe === void 0 && (Pe = this.length), ue < 0 || de > he.length || _e < 0 || Pe > this.length)
        throw new RangeError("out of range index");
      if (_e >= Pe && ue >= de)
        return 0;
      if (_e >= Pe)
        return -1;
      if (ue >= de)
        return 1;
      if (ue >>>= 0, de >>>= 0, _e >>>= 0, Pe >>>= 0, this === he)
        return 0;
      for (var He = Pe - _e, Ve = de - ue, nt = Math.min(He, Ve), Ie = this.slice(_e, Pe), Fe = he.slice(ue, de), je = 0; je < nt; ++je)
        if (Ie[je] !== Fe[je]) {
          He = Ie[je], Ve = Fe[je];
          break;
        }
      return He < Ve ? -1 : Ve < He ? 1 : 0;
    };
    function me(he, ue, de, _e, Pe) {
      if (he.length === 0)
        return -1;
      if (typeof de == "string" ? (_e = de, de = 0) : de > 2147483647 ? de = 2147483647 : de < -2147483648 && (de = -2147483648), de = +de, De(de) && (de = Pe ? 0 : he.length - 1), de < 0 && (de = he.length + de), de >= he.length) {
        if (Pe)
          return -1;
        de = he.length - 1;
      } else if (de < 0)
        if (Pe)
          de = 0;
        else
          return -1;
      if (typeof ue == "string" && (ue = A.from(ue, _e)), A.isBuffer(ue))
        return ue.length === 0 ? -1 : Me(he, ue, de, _e, Pe);
      if (typeof ue == "number")
        return ue = ue & 255, typeof Uint8Array.prototype.indexOf == "function" ? Pe ? Uint8Array.prototype.indexOf.call(he, ue, de) : Uint8Array.prototype.lastIndexOf.call(he, ue, de) : Me(he, [ue], de, _e, Pe);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Me(he, ue, de, _e, Pe) {
      var He = 1, Ve = he.length, nt = ue.length;
      if (_e !== void 0 && (_e = String(_e).toLowerCase(), _e === "ucs2" || _e === "ucs-2" || _e === "utf16le" || _e === "utf-16le")) {
        if (he.length < 2 || ue.length < 2)
          return -1;
        He = 2, Ve /= 2, nt /= 2, de /= 2;
      }
      function Ie(ut, pt) {
        return He === 1 ? ut[pt] : ut.readUInt16BE(pt * He);
      }
      var Fe;
      if (Pe) {
        var je = -1;
        for (Fe = de; Fe < Ve; Fe++)
          if (Ie(he, Fe) === Ie(ue, je === -1 ? 0 : Fe - je)) {
            if (je === -1 && (je = Fe), Fe - je + 1 === nt)
              return je * He;
          } else
            je !== -1 && (Fe -= Fe - je), je = -1;
      } else
        for (de + nt > Ve && (de = Ve - nt), Fe = de; Fe >= 0; Fe--) {
          for (var Ke = !0, ot = 0; ot < nt; ot++)
            if (Ie(he, Fe + ot) !== Ie(ue, ot)) {
              Ke = !1;
              break;
            }
          if (Ke)
            return Fe;
        }
      return -1;
    }
    A.prototype.includes = function(he, ue, de) {
      return this.indexOf(he, ue, de) !== -1;
    }, A.prototype.indexOf = function(he, ue, de) {
      return me(this, he, ue, de, !0);
    }, A.prototype.lastIndexOf = function(he, ue, de) {
      return me(this, he, ue, de, !1);
    };
    function Ee(he, ue, de, _e) {
      de = Number(de) || 0;
      var Pe = he.length - de;
      _e ? (_e = Number(_e), _e > Pe && (_e = Pe)) : _e = Pe;
      var He = ue.length;
      _e > He / 2 && (_e = He / 2);
      for (var Ve = 0; Ve < _e; ++Ve) {
        var nt = parseInt(ue.substr(Ve * 2, 2), 16);
        if (De(nt))
          return Ve;
        he[de + Ve] = nt;
      }
      return Ve;
    }
    function Re(he, ue, de, _e) {
      return ve(fe(ue, he.length - de), he, de, _e);
    }
    function Ne(he, ue, de, _e) {
      return ve($e(ue), he, de, _e);
    }
    function ne(he, ue, de, _e) {
      return ve(be(ue), he, de, _e);
    }
    function Y(he, ue, de, _e) {
      return ve(Be(ue, he.length - de), he, de, _e);
    }
    A.prototype.write = function(he, ue, de, _e) {
      if (ue === void 0)
        _e = "utf8", de = this.length, ue = 0;
      else if (de === void 0 && typeof ue == "string")
        _e = ue, de = this.length, ue = 0;
      else if (isFinite(ue))
        ue = ue >>> 0, isFinite(de) ? (de = de >>> 0, _e === void 0 && (_e = "utf8")) : (_e = de, de = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var Pe = this.length - ue;
      if ((de === void 0 || de > Pe) && (de = Pe), he.length > 0 && (de < 0 || ue < 0) || ue > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      _e || (_e = "utf8");
      for (var He = !1; ; )
        switch (_e) {
          case "hex":
            return Ee(this, he, ue, de);
          case "utf8":
          case "utf-8":
            return Re(this, he, ue, de);
          case "ascii":
          case "latin1":
          case "binary":
            return Ne(this, he, ue, de);
          case "base64":
            return ne(this, he, ue, de);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Y(this, he, ue, de);
          default:
            if (He)
              throw new TypeError("Unknown encoding: " + _e);
            _e = ("" + _e).toLowerCase(), He = !0;
        }
    }, A.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function M(he, ue, de) {
      return ue === 0 && de === he.length ? o.fromByteArray(he) : o.fromByteArray(he.slice(ue, de));
    }
    function $(he, ue, de) {
      de = Math.min(he.length, de);
      for (var _e = [], Pe = ue; Pe < de; ) {
        var He = he[Pe], Ve = null, nt = He > 239 ? 4 : He > 223 ? 3 : He > 191 ? 2 : 1;
        if (Pe + nt <= de) {
          var Ie, Fe, je, Ke;
          switch (nt) {
            case 1:
              He < 128 && (Ve = He);
              break;
            case 2:
              Ie = he[Pe + 1], (Ie & 192) === 128 && (Ke = (He & 31) << 6 | Ie & 63, Ke > 127 && (Ve = Ke));
              break;
            case 3:
              Ie = he[Pe + 1], Fe = he[Pe + 2], (Ie & 192) === 128 && (Fe & 192) === 128 && (Ke = (He & 15) << 12 | (Ie & 63) << 6 | Fe & 63, Ke > 2047 && (Ke < 55296 || Ke > 57343) && (Ve = Ke));
              break;
            case 4:
              Ie = he[Pe + 1], Fe = he[Pe + 2], je = he[Pe + 3], (Ie & 192) === 128 && (Fe & 192) === 128 && (je & 192) === 128 && (Ke = (He & 15) << 18 | (Ie & 63) << 12 | (Fe & 63) << 6 | je & 63, Ke > 65535 && Ke < 1114112 && (Ve = Ke));
          }
        }
        Ve === null ? (Ve = 65533, nt = 1) : Ve > 65535 && (Ve -= 65536, _e.push(Ve >>> 10 & 1023 | 55296), Ve = 56320 | Ve & 1023), _e.push(Ve), Pe += nt;
      }
      return J(_e);
    }
    var O = 4096;
    function J(he) {
      var ue = he.length;
      if (ue <= O)
        return String.fromCharCode.apply(String, he);
      for (var de = "", _e = 0; _e < ue; )
        de += String.fromCharCode.apply(
          String,
          he.slice(_e, _e += O)
        );
      return de;
    }
    function Z(he, ue, de) {
      var _e = "";
      de = Math.min(he.length, de);
      for (var Pe = ue; Pe < de; ++Pe)
        _e += String.fromCharCode(he[Pe] & 127);
      return _e;
    }
    function K(he, ue, de) {
      var _e = "";
      de = Math.min(he.length, de);
      for (var Pe = ue; Pe < de; ++Pe)
        _e += String.fromCharCode(he[Pe]);
      return _e;
    }
    function z(he, ue, de) {
      var _e = he.length;
      (!ue || ue < 0) && (ue = 0), (!de || de < 0 || de > _e) && (de = _e);
      for (var Pe = "", He = ue; He < de; ++He)
        Pe += Ye[he[He]];
      return Pe;
    }
    function G(he, ue, de) {
      for (var _e = he.slice(ue, de), Pe = "", He = 0; He < _e.length - 1; He += 2)
        Pe += String.fromCharCode(_e[He] + _e[He + 1] * 256);
      return Pe;
    }
    A.prototype.slice = function(he, ue) {
      var de = this.length;
      he = ~~he, ue = ue === void 0 ? de : ~~ue, he < 0 ? (he += de, he < 0 && (he = 0)) : he > de && (he = de), ue < 0 ? (ue += de, ue < 0 && (ue = 0)) : ue > de && (ue = de), ue < he && (ue = he);
      var _e = this.subarray(he, ue);
      return Object.setPrototypeOf(_e, A.prototype), _e;
    };
    function D(he, ue, de) {
      if (he % 1 !== 0 || he < 0)
        throw new RangeError("offset is not uint");
      if (he + ue > de)
        throw new RangeError("Trying to access beyond buffer length");
    }
    A.prototype.readUintLE = A.prototype.readUIntLE = function(he, ue, de) {
      he = he >>> 0, ue = ue >>> 0, de || D(he, ue, this.length);
      for (var _e = this[he], Pe = 1, He = 0; ++He < ue && (Pe *= 256); )
        _e += this[he + He] * Pe;
      return _e;
    }, A.prototype.readUintBE = A.prototype.readUIntBE = function(he, ue, de) {
      he = he >>> 0, ue = ue >>> 0, de || D(he, ue, this.length);
      for (var _e = this[he + --ue], Pe = 1; ue > 0 && (Pe *= 256); )
        _e += this[he + --ue] * Pe;
      return _e;
    }, A.prototype.readUint8 = A.prototype.readUInt8 = function(he, ue) {
      return he = he >>> 0, ue || D(he, 1, this.length), this[he];
    }, A.prototype.readUint16LE = A.prototype.readUInt16LE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 2, this.length), this[he] | this[he + 1] << 8;
    }, A.prototype.readUint16BE = A.prototype.readUInt16BE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 2, this.length), this[he] << 8 | this[he + 1];
    }, A.prototype.readUint32LE = A.prototype.readUInt32LE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 4, this.length), (this[he] | this[he + 1] << 8 | this[he + 2] << 16) + this[he + 3] * 16777216;
    }, A.prototype.readUint32BE = A.prototype.readUInt32BE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 4, this.length), this[he] * 16777216 + (this[he + 1] << 16 | this[he + 2] << 8 | this[he + 3]);
    }, A.prototype.readIntLE = function(he, ue, de) {
      he = he >>> 0, ue = ue >>> 0, de || D(he, ue, this.length);
      for (var _e = this[he], Pe = 1, He = 0; ++He < ue && (Pe *= 256); )
        _e += this[he + He] * Pe;
      return Pe *= 128, _e >= Pe && (_e -= Math.pow(2, 8 * ue)), _e;
    }, A.prototype.readIntBE = function(he, ue, de) {
      he = he >>> 0, ue = ue >>> 0, de || D(he, ue, this.length);
      for (var _e = ue, Pe = 1, He = this[he + --_e]; _e > 0 && (Pe *= 256); )
        He += this[he + --_e] * Pe;
      return Pe *= 128, He >= Pe && (He -= Math.pow(2, 8 * ue)), He;
    }, A.prototype.readInt8 = function(he, ue) {
      return he = he >>> 0, ue || D(he, 1, this.length), this[he] & 128 ? (255 - this[he] + 1) * -1 : this[he];
    }, A.prototype.readInt16LE = function(he, ue) {
      he = he >>> 0, ue || D(he, 2, this.length);
      var de = this[he] | this[he + 1] << 8;
      return de & 32768 ? de | 4294901760 : de;
    }, A.prototype.readInt16BE = function(he, ue) {
      he = he >>> 0, ue || D(he, 2, this.length);
      var de = this[he + 1] | this[he] << 8;
      return de & 32768 ? de | 4294901760 : de;
    }, A.prototype.readInt32LE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 4, this.length), this[he] | this[he + 1] << 8 | this[he + 2] << 16 | this[he + 3] << 24;
    }, A.prototype.readInt32BE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 4, this.length), this[he] << 24 | this[he + 1] << 16 | this[he + 2] << 8 | this[he + 3];
    }, A.prototype.readFloatLE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 4, this.length), S.read(this, he, !0, 23, 4);
    }, A.prototype.readFloatBE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 4, this.length), S.read(this, he, !1, 23, 4);
    }, A.prototype.readDoubleLE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 8, this.length), S.read(this, he, !0, 52, 8);
    }, A.prototype.readDoubleBE = function(he, ue) {
      return he = he >>> 0, ue || D(he, 8, this.length), S.read(this, he, !1, 52, 8);
    };
    function F(he, ue, de, _e, Pe, He) {
      if (!A.isBuffer(he))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (ue > Pe || ue < He)
        throw new RangeError('"value" argument is out of bounds');
      if (de + _e > he.length)
        throw new RangeError("Index out of range");
    }
    A.prototype.writeUintLE = A.prototype.writeUIntLE = function(he, ue, de, _e) {
      if (he = +he, ue = ue >>> 0, de = de >>> 0, !_e) {
        var Pe = Math.pow(2, 8 * de) - 1;
        F(this, he, ue, de, Pe, 0);
      }
      var He = 1, Ve = 0;
      for (this[ue] = he & 255; ++Ve < de && (He *= 256); )
        this[ue + Ve] = he / He & 255;
      return ue + de;
    }, A.prototype.writeUintBE = A.prototype.writeUIntBE = function(he, ue, de, _e) {
      if (he = +he, ue = ue >>> 0, de = de >>> 0, !_e) {
        var Pe = Math.pow(2, 8 * de) - 1;
        F(this, he, ue, de, Pe, 0);
      }
      var He = de - 1, Ve = 1;
      for (this[ue + He] = he & 255; --He >= 0 && (Ve *= 256); )
        this[ue + He] = he / Ve & 255;
      return ue + de;
    }, A.prototype.writeUint8 = A.prototype.writeUInt8 = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 1, 255, 0), this[ue] = he & 255, ue + 1;
    }, A.prototype.writeUint16LE = A.prototype.writeUInt16LE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 2, 65535, 0), this[ue] = he & 255, this[ue + 1] = he >>> 8, ue + 2;
    }, A.prototype.writeUint16BE = A.prototype.writeUInt16BE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 2, 65535, 0), this[ue] = he >>> 8, this[ue + 1] = he & 255, ue + 2;
    }, A.prototype.writeUint32LE = A.prototype.writeUInt32LE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 4, 4294967295, 0), this[ue + 3] = he >>> 24, this[ue + 2] = he >>> 16, this[ue + 1] = he >>> 8, this[ue] = he & 255, ue + 4;
    }, A.prototype.writeUint32BE = A.prototype.writeUInt32BE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 4, 4294967295, 0), this[ue] = he >>> 24, this[ue + 1] = he >>> 16, this[ue + 2] = he >>> 8, this[ue + 3] = he & 255, ue + 4;
    }, A.prototype.writeIntLE = function(he, ue, de, _e) {
      if (he = +he, ue = ue >>> 0, !_e) {
        var Pe = Math.pow(2, 8 * de - 1);
        F(this, he, ue, de, Pe - 1, -Pe);
      }
      var He = 0, Ve = 1, nt = 0;
      for (this[ue] = he & 255; ++He < de && (Ve *= 256); )
        he < 0 && nt === 0 && this[ue + He - 1] !== 0 && (nt = 1), this[ue + He] = (he / Ve >> 0) - nt & 255;
      return ue + de;
    }, A.prototype.writeIntBE = function(he, ue, de, _e) {
      if (he = +he, ue = ue >>> 0, !_e) {
        var Pe = Math.pow(2, 8 * de - 1);
        F(this, he, ue, de, Pe - 1, -Pe);
      }
      var He = de - 1, Ve = 1, nt = 0;
      for (this[ue + He] = he & 255; --He >= 0 && (Ve *= 256); )
        he < 0 && nt === 0 && this[ue + He + 1] !== 0 && (nt = 1), this[ue + He] = (he / Ve >> 0) - nt & 255;
      return ue + de;
    }, A.prototype.writeInt8 = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 1, 127, -128), he < 0 && (he = 255 + he + 1), this[ue] = he & 255, ue + 1;
    }, A.prototype.writeInt16LE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 2, 32767, -32768), this[ue] = he & 255, this[ue + 1] = he >>> 8, ue + 2;
    }, A.prototype.writeInt16BE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 2, 32767, -32768), this[ue] = he >>> 8, this[ue + 1] = he & 255, ue + 2;
    }, A.prototype.writeInt32LE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 4, 2147483647, -2147483648), this[ue] = he & 255, this[ue + 1] = he >>> 8, this[ue + 2] = he >>> 16, this[ue + 3] = he >>> 24, ue + 4;
    }, A.prototype.writeInt32BE = function(he, ue, de) {
      return he = +he, ue = ue >>> 0, de || F(this, he, ue, 4, 2147483647, -2147483648), he < 0 && (he = 4294967295 + he + 1), this[ue] = he >>> 24, this[ue + 1] = he >>> 16, this[ue + 2] = he >>> 8, this[ue + 3] = he & 255, ue + 4;
    };
    function ae(he, ue, de, _e, Pe, He) {
      if (de + _e > he.length)
        throw new RangeError("Index out of range");
      if (de < 0)
        throw new RangeError("Index out of range");
    }
    function ge(he, ue, de, _e, Pe) {
      return ue = +ue, de = de >>> 0, Pe || ae(he, ue, de, 4), S.write(he, ue, de, _e, 23, 4), de + 4;
    }
    A.prototype.writeFloatLE = function(he, ue, de) {
      return ge(this, he, ue, !0, de);
    }, A.prototype.writeFloatBE = function(he, ue, de) {
      return ge(this, he, ue, !1, de);
    };
    function xe(he, ue, de, _e, Pe) {
      return ue = +ue, de = de >>> 0, Pe || ae(he, ue, de, 8), S.write(he, ue, de, _e, 52, 8), de + 8;
    }
    A.prototype.writeDoubleLE = function(he, ue, de) {
      return xe(this, he, ue, !0, de);
    }, A.prototype.writeDoubleBE = function(he, ue, de) {
      return xe(this, he, ue, !1, de);
    }, A.prototype.copy = function(he, ue, de, _e) {
      if (!A.isBuffer(he))
        throw new TypeError("argument should be a Buffer");
      if (de || (de = 0), !_e && _e !== 0 && (_e = this.length), ue >= he.length && (ue = he.length), ue || (ue = 0), _e > 0 && _e < de && (_e = de), _e === de || he.length === 0 || this.length === 0)
        return 0;
      if (ue < 0)
        throw new RangeError("targetStart out of bounds");
      if (de < 0 || de >= this.length)
        throw new RangeError("Index out of range");
      if (_e < 0)
        throw new RangeError("sourceEnd out of bounds");
      _e > this.length && (_e = this.length), he.length - ue < _e - de && (_e = he.length - ue + de);
      var Pe = _e - de;
      return this === he && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(ue, de, _e) : Uint8Array.prototype.set.call(
        he,
        this.subarray(de, _e),
        ue
      ), Pe;
    }, A.prototype.fill = function(he, ue, de, _e) {
      if (typeof he == "string") {
        if (typeof ue == "string" ? (_e = ue, ue = 0, de = this.length) : typeof de == "string" && (_e = de, de = this.length), _e !== void 0 && typeof _e != "string")
          throw new TypeError("encoding must be a string");
        if (typeof _e == "string" && !A.isEncoding(_e))
          throw new TypeError("Unknown encoding: " + _e);
        if (he.length === 1) {
          var Pe = he.charCodeAt(0);
          (_e === "utf8" && Pe < 128 || _e === "latin1") && (he = Pe);
        }
      } else
        typeof he == "number" ? he = he & 255 : typeof he == "boolean" && (he = Number(he));
      if (ue < 0 || this.length < ue || this.length < de)
        throw new RangeError("Out of range index");
      if (de <= ue)
        return this;
      ue = ue >>> 0, de = de === void 0 ? this.length : de >>> 0, he || (he = 0);
      var He;
      if (typeof he == "number")
        for (He = ue; He < de; ++He)
          this[He] = he;
      else {
        var Ve = A.isBuffer(he) ? he : A.from(he, _e), nt = Ve.length;
        if (nt === 0)
          throw new TypeError('The value "' + he + '" is invalid for argument "value"');
        for (He = 0; He < de - ue; ++He)
          this[He + ue] = Ve[He % nt];
      }
      return this;
    };
    var ye = /[^+/0-9A-Za-z-_]/g;
    function oe(he) {
      if (he = he.split("=")[0], he = he.trim().replace(ye, ""), he.length < 2)
        return "";
      for (; he.length % 4 !== 0; )
        he = he + "=";
      return he;
    }
    function fe(he, ue) {
      ue = ue || 1 / 0;
      for (var de, _e = he.length, Pe = null, He = [], Ve = 0; Ve < _e; ++Ve) {
        if (de = he.charCodeAt(Ve), de > 55295 && de < 57344) {
          if (!Pe) {
            if (de > 56319) {
              (ue -= 3) > -1 && He.push(239, 191, 189);
              continue;
            } else if (Ve + 1 === _e) {
              (ue -= 3) > -1 && He.push(239, 191, 189);
              continue;
            }
            Pe = de;
            continue;
          }
          if (de < 56320) {
            (ue -= 3) > -1 && He.push(239, 191, 189), Pe = de;
            continue;
          }
          de = (Pe - 55296 << 10 | de - 56320) + 65536;
        } else
          Pe && (ue -= 3) > -1 && He.push(239, 191, 189);
        if (Pe = null, de < 128) {
          if ((ue -= 1) < 0)
            break;
          He.push(de);
        } else if (de < 2048) {
          if ((ue -= 2) < 0)
            break;
          He.push(
            de >> 6 | 192,
            de & 63 | 128
          );
        } else if (de < 65536) {
          if ((ue -= 3) < 0)
            break;
          He.push(
            de >> 12 | 224,
            de >> 6 & 63 | 128,
            de & 63 | 128
          );
        } else if (de < 1114112) {
          if ((ue -= 4) < 0)
            break;
          He.push(
            de >> 18 | 240,
            de >> 12 & 63 | 128,
            de >> 6 & 63 | 128,
            de & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return He;
    }
    function $e(he) {
      for (var ue = [], de = 0; de < he.length; ++de)
        ue.push(he.charCodeAt(de) & 255);
      return ue;
    }
    function Be(he, ue) {
      for (var de, _e, Pe, He = [], Ve = 0; Ve < he.length && !((ue -= 2) < 0); ++Ve)
        de = he.charCodeAt(Ve), _e = de >> 8, Pe = de % 256, He.push(Pe), He.push(_e);
      return He;
    }
    function be(he) {
      return o.toByteArray(oe(he));
    }
    function ve(he, ue, de, _e) {
      for (var Pe = 0; Pe < _e && !(Pe + de >= ue.length || Pe >= he.length); ++Pe)
        ue[Pe + de] = he[Pe];
      return Pe;
    }
    function qe(he, ue) {
      return he instanceof ue || he != null && he.constructor != null && he.constructor.name != null && he.constructor.name === ue.name;
    }
    function De(he) {
      return he !== he;
    }
    var Ye = function() {
      for (var he = "0123456789abcdef", ue = new Array(256), de = 0; de < 16; ++de)
        for (var _e = de * 16, Pe = 0; Pe < 16; ++Pe)
          ue[_e + Pe] = he[de] + he[Pe];
      return ue;
    }();
  }(buffer$1)), buffer$1;
}
var bufferExports = requireBuffer$1(), browser$c$1 = { exports: {} }, process = browser$c$1.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(e) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout(e, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, e, 0);
    } catch {
      return cachedSetTimeout.call(this, e, 0);
    }
  }
}
function runClearTimeout(e) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout(e);
  } catch {
    try {
      return cachedClearTimeout.call(null, e);
    } catch {
      return cachedClearTimeout.call(this, e);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var e = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var o = queue.length; o; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < o; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, o = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(e);
  }
}
process.nextTick = function(e) {
  var o = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var S = 1; S < arguments.length; S++)
      o[S - 1] = arguments[S];
  queue.push(new Item(e, o)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(e, o) {
  this.fun = e, this.array = o;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(e) {
  return [];
};
process.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$c$1.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
(function(e) {
  function o() {
    var g = this || self;
    return delete e.prototype.__magic__, g;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return o();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: o
  });
  var S = __magic__;
  return S;
})(Object);
var eventemitter2 = { exports: {} };
(function(e, o) {
  (function(S) {
    var g = Object.hasOwnProperty, U = Array.isArray ? Array.isArray : function(K) {
      return Object.prototype.toString.call(K) === "[object Array]";
    }, h = 10, q = typeof process$1 == "object" && typeof process$1.nextTick == "function", A = typeof Symbol == "function", P = typeof Reflect == "object", I = typeof setImmediate == "function", B = I ? setImmediate : setTimeout, H = A ? P && typeof Reflect.ownKeys == "function" ? Reflect.ownKeys : function(K) {
      var z = Object.getOwnPropertyNames(K);
      return z.push.apply(z, Object.getOwnPropertySymbols(K)), z;
    } : Object.keys;
    function V() {
      this._events = {}, this._conf && X.call(this, this._conf);
    }
    function X(K) {
      K && (this._conf = K, K.delimiter && (this.delimiter = K.delimiter), K.maxListeners !== S && (this._maxListeners = K.maxListeners), K.wildcard && (this.wildcard = K.wildcard), K.newListener && (this._newListener = K.newListener), K.removeListener && (this._removeListener = K.removeListener), K.verboseMemoryLeak && (this.verboseMemoryLeak = K.verboseMemoryLeak), K.ignoreErrors && (this.ignoreErrors = K.ignoreErrors), this.wildcard && (this.listenerTree = {}));
    }
    function Q(K, z) {
      var G = "(node) warning: possible EventEmitter memory leak detected. " + K + " listeners added. Use emitter.setMaxListeners() to increase limit.";
      if (this.verboseMemoryLeak && (G += " Event name: " + z + "."), typeof process$1 < "u" && process$1.emitWarning) {
        var D = new Error(G);
        D.name = "MaxListenersExceededWarning", D.emitter = this, D.count = K, process$1.emitWarning(D);
      } else
        console.error(G), console.trace && console.trace();
    }
    var ee = function(K, z, G) {
      var D = arguments.length;
      switch (D) {
        case 0:
          return [];
        case 1:
          return [K];
        case 2:
          return [K, z];
        case 3:
          return [K, z, G];
        default:
          for (var F = new Array(D); D--; )
            F[D] = arguments[D];
          return F;
      }
    };
    function ie(K, z) {
      for (var G = {}, D, F = K.length, ae = z ? z.length : 0, ge = 0; ge < F; ge++)
        D = K[ge], G[D] = ge < ae ? z[ge] : S;
      return G;
    }
    function te(K, z, G) {
      this._emitter = K, this._target = z, this._listeners = {}, this._listenersCount = 0;
      var D, F;
      if ((G.on || G.off) && (D = G.on, F = G.off), z.addEventListener ? (D = z.addEventListener, F = z.removeEventListener) : z.addListener ? (D = z.addListener, F = z.removeListener) : z.on && (D = z.on, F = z.off), !D && !F)
        throw Error("target does not implement any known event API");
      if (typeof D != "function")
        throw TypeError("on method must be a function");
      if (typeof F != "function")
        throw TypeError("off method must be a function");
      this._on = D, this._off = F;
      var ae = K._observers;
      ae ? ae.push(this) : K._observers = [this];
    }
    Object.assign(te.prototype, {
      subscribe: function(K, z, G) {
        var D = this, F = this._target, ae = this._emitter, ge = this._listeners, xe = function() {
          var ye = ee.apply(null, arguments), oe = {
            data: ye,
            name: z,
            original: K
          };
          if (G) {
            var fe = G.call(F, oe);
            fe !== !1 && ae.emit.apply(ae, [oe.name].concat(ye));
            return;
          }
          ae.emit.apply(ae, [z].concat(ye));
        };
        if (ge[K])
          throw Error("Event '" + K + "' is already listening");
        this._listenersCount++, ae._newListener && ae._removeListener && !D._onNewListener ? (this._onNewListener = function(ye) {
          ye === z && ge[K] === null && (ge[K] = xe, D._on.call(F, K, xe));
        }, ae.on("newListener", this._onNewListener), this._onRemoveListener = function(ye) {
          ye === z && !ae.hasListeners(ye) && ge[K] && (ge[K] = null, D._off.call(F, K, xe));
        }, ge[K] = null, ae.on("removeListener", this._onRemoveListener)) : (ge[K] = xe, D._on.call(F, K, xe));
      },
      unsubscribe: function(K) {
        var z = this, G = this._listeners, D = this._emitter, F, ae, ge = this._off, xe = this._target, ye;
        if (K && typeof K != "string")
          throw TypeError("event must be a string");
        function oe() {
          z._onNewListener && (D.off("newListener", z._onNewListener), D.off("removeListener", z._onRemoveListener), z._onNewListener = null, z._onRemoveListener = null);
          var fe = Ee.call(D, z);
          D._observers.splice(fe, 1);
        }
        if (K) {
          if (F = G[K], !F)
            return;
          ge.call(xe, K, F), delete G[K], --this._listenersCount || oe();
        } else {
          for (ae = H(G), ye = ae.length; ye-- > 0; )
            K = ae[ye], ge.call(xe, K, G[K]);
          this._listeners = {}, this._listenersCount = 0, oe();
        }
      }
    });
    function se(K, z, G, D) {
      var F = Object.assign({}, z);
      if (!K)
        return F;
      if (typeof K != "object")
        throw TypeError("options must be an object");
      var ae = Object.keys(K), ge = ae.length, xe, ye, oe;
      function fe(Be) {
        throw Error('Invalid "' + xe + '" option value' + (Be ? ". Reason: " + Be : ""));
      }
      for (var $e = 0; $e < ge; $e++) {
        if (xe = ae[$e], !D && !g.call(z, xe))
          throw Error('Unknown "' + xe + '" option');
        ye = K[xe], ye !== S && (oe = G[xe], F[xe] = oe ? oe(ye, fe) : ye);
      }
      return F;
    }
    function le(K, z) {
      return (typeof K != "function" || !K.hasOwnProperty("prototype")) && z("value must be a constructor"), K;
    }
    function ce(K) {
      var z = "value must be type of " + K.join("|"), G = K.length, D = K[0], F = K[1];
      return G === 1 ? function(ae, ge) {
        if (typeof ae === D)
          return ae;
        ge(z);
      } : G === 2 ? function(ae, ge) {
        var xe = typeof ae;
        if (xe === D || xe === F)
          return ae;
        ge(z);
      } : function(ae, ge) {
        for (var xe = typeof ae, ye = G; ye-- > 0; )
          if (xe === K[ye])
            return ae;
        ge(z);
      };
    }
    var pe = ce(["function"]), me = ce(["object", "function"]);
    function Me(K, z, G) {
      var D, F, ae = 0, ge, xe = new K(function(ye, oe, fe) {
        G = se(G, {
          timeout: 0,
          overload: !1
        }, {
          timeout: function(ve, qe) {
            return ve *= 1, (typeof ve != "number" || ve < 0 || !Number.isFinite(ve)) && qe("timeout must be a positive number"), ve;
          }
        }), D = !G.overload && typeof K.prototype.cancel == "function" && typeof fe == "function";
        function $e() {
          F && (F = null), ae && (clearTimeout(ae), ae = 0);
        }
        var Be = function(ve) {
          $e(), ye(ve);
        }, be = function(ve) {
          $e(), oe(ve);
        };
        D ? z(Be, be, fe) : (F = [function(ve) {
          be(ve || Error("canceled"));
        }], z(Be, be, function(ve) {
          if (ge)
            throw Error("Unable to subscribe on cancel event asynchronously");
          if (typeof ve != "function")
            throw TypeError("onCancel callback must be a function");
          F.push(ve);
        }), ge = !0), G.timeout > 0 && (ae = setTimeout(function() {
          var ve = Error("timeout");
          ve.code = "ETIMEDOUT", ae = 0, xe.cancel(ve), oe(ve);
        }, G.timeout));
      });
      return D || (xe.cancel = function(ye) {
        if (F) {
          for (var oe = F.length, fe = 1; fe < oe; fe++)
            F[fe](ye);
          F[0](ye), F = null;
        }
      }), xe;
    }
    function Ee(K) {
      var z = this._observers;
      if (!z)
        return -1;
      for (var G = z.length, D = 0; D < G; D++)
        if (z[D]._target === K)
          return D;
      return -1;
    }
    function Re(K, z, G, D, F) {
      if (!G)
        return null;
      if (D === 0) {
        var ae = typeof z;
        if (ae === "string") {
          var ge, xe, ye = 0, oe = 0, fe = this.delimiter, $e = fe.length;
          if ((xe = z.indexOf(fe)) !== -1) {
            ge = new Array(5);
            do
              ge[ye++] = z.slice(oe, xe), oe = xe + $e;
            while ((xe = z.indexOf(fe, oe)) !== -1);
            ge[ye++] = z.slice(oe), z = ge, F = ye;
          } else
            z = [z], F = 1;
        } else
          ae === "object" ? F = z.length : (z = [z], F = 1);
      }
      var Be = null, be, ve, qe, De, Ye, he = z[D], ue = z[D + 1], de, _e;
      if (D === F)
        G._listeners && (typeof G._listeners == "function" ? (K && K.push(G._listeners), Be = [G]) : (K && K.push.apply(K, G._listeners), Be = [G]));
      else if (he === "*") {
        for (de = H(G), xe = de.length; xe-- > 0; )
          be = de[xe], be !== "_listeners" && (_e = Re(K, z, G[be], D + 1, F), _e && (Be ? Be.push.apply(Be, _e) : Be = _e));
        return Be;
      } else if (he === "**") {
        for (Ye = D + 1 === F || D + 2 === F && ue === "*", Ye && G._listeners && (Be = Re(K, z, G, F, F)), de = H(G), xe = de.length; xe-- > 0; )
          be = de[xe], be !== "_listeners" && (be === "*" || be === "**" ? (G[be]._listeners && !Ye && (_e = Re(K, z, G[be], F, F), _e && (Be ? Be.push.apply(Be, _e) : Be = _e)), _e = Re(K, z, G[be], D, F)) : be === ue ? _e = Re(K, z, G[be], D + 2, F) : _e = Re(K, z, G[be], D, F), _e && (Be ? Be.push.apply(Be, _e) : Be = _e));
        return Be;
      } else
        G[he] && (Be = Re(K, z, G[he], D + 1, F));
      if (ve = G["*"], ve && Re(K, z, ve, D + 1, F), qe = G["**"], qe)
        if (D < F)
          for (qe._listeners && Re(K, z, qe, F, F), de = H(qe), xe = de.length; xe-- > 0; )
            be = de[xe], be !== "_listeners" && (be === ue ? Re(K, z, qe[be], D + 2, F) : be === he ? Re(K, z, qe[be], D + 1, F) : (De = {}, De[be] = qe[be], Re(K, z, { "**": De }, D + 1, F)));
        else
          qe._listeners ? Re(K, z, qe, F, F) : qe["*"] && qe["*"]._listeners && Re(K, z, qe["*"], F, F);
      return Be;
    }
    function Ne(K, z, G) {
      var D = 0, F = 0, ae, ge = this.delimiter, xe = ge.length, ye;
      if (typeof K == "string")
        if ((ae = K.indexOf(ge)) !== -1) {
          ye = new Array(5);
          do
            ye[D++] = K.slice(F, ae), F = ae + xe;
          while ((ae = K.indexOf(ge, F)) !== -1);
          ye[D++] = K.slice(F);
        } else
          ye = [K], D = 1;
      else
        ye = K, D = K.length;
      if (D > 1) {
        for (ae = 0; ae + 1 < D; ae++)
          if (ye[ae] === "**" && ye[ae + 1] === "**")
            return;
      }
      var oe = this.listenerTree, fe;
      for (ae = 0; ae < D; ae++)
        if (fe = ye[ae], oe = oe[fe] || (oe[fe] = {}), ae === D - 1)
          return oe._listeners ? (typeof oe._listeners == "function" && (oe._listeners = [oe._listeners]), G ? oe._listeners.unshift(z) : oe._listeners.push(z), !oe._listeners.warned && this._maxListeners > 0 && oe._listeners.length > this._maxListeners && (oe._listeners.warned = !0, Q.call(this, oe._listeners.length, fe))) : oe._listeners = z, !0;
      return !0;
    }
    function ne(K, z, G, D) {
      for (var F = H(K), ae = F.length, ge, xe, ye, oe = K._listeners, fe; ae-- > 0; )
        xe = F[ae], ge = K[xe], xe === "_listeners" ? ye = G : ye = G ? G.concat(xe) : [xe], fe = D || typeof xe == "symbol", oe && z.push(fe ? ye : ye.join(this.delimiter)), typeof ge == "object" && ne.call(this, ge, z, ye, fe);
      return z;
    }
    function Y(K) {
      for (var z = H(K), G = z.length, D, F, ae; G-- > 0; )
        F = z[G], D = K[F], D && (ae = !0, F !== "_listeners" && !Y(D) && delete K[F]);
      return ae;
    }
    function M(K, z, G) {
      this.emitter = K, this.event = z, this.listener = G;
    }
    M.prototype.off = function() {
      return this.emitter.off(this.event, this.listener), this;
    };
    function $(K, z, G) {
      if (G === !0)
        F = !0;
      else if (G === !1)
        D = !0;
      else {
        if (!G || typeof G != "object")
          throw TypeError("options should be an object or true");
        var D = G.async, F = G.promisify, ae = G.nextTick, ge = G.objectify;
      }
      if (D || ae || F) {
        var xe = z, ye = z._origin || z;
        if (ae && !q)
          throw Error("process.nextTick is not supported");
        F === S && (F = z.constructor.name === "AsyncFunction"), z = function() {
          var oe = arguments, fe = this, $e = this.event;
          return F ? ae ? Promise.resolve() : new Promise(function(Be) {
            B(Be);
          }).then(function() {
            return fe.event = $e, xe.apply(fe, oe);
          }) : (ae ? process$1.nextTick : B)(function() {
            fe.event = $e, xe.apply(fe, oe);
          });
        }, z._async = !0, z._origin = ye;
      }
      return [z, ge ? new M(this, K, z) : this];
    }
    function O(K) {
      this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1, X.call(this, K);
    }
    O.EventEmitter2 = O, O.prototype.listenTo = function(K, z, G) {
      if (typeof K != "object")
        throw TypeError("target musts be an object");
      var D = this;
      G = se(G, {
        on: S,
        off: S,
        reducers: S
      }, {
        on: pe,
        off: pe,
        reducers: me
      });
      function F(ae) {
        if (typeof ae != "object")
          throw TypeError("events must be an object");
        var ge = G.reducers, xe = Ee.call(D, K), ye;
        xe === -1 ? ye = new te(D, K, G) : ye = D._observers[xe];
        for (var oe = H(ae), fe = oe.length, $e, Be = typeof ge == "function", be = 0; be < fe; be++)
          $e = oe[be], ye.subscribe(
            $e,
            ae[$e] || $e,
            Be ? ge : ge && ge[$e]
          );
      }
      return U(z) ? F(ie(z)) : F(typeof z == "string" ? ie(z.split(/\s+/)) : z), this;
    }, O.prototype.stopListeningTo = function(K, z) {
      var G = this._observers;
      if (!G)
        return !1;
      var D = G.length, F, ae = !1;
      if (K && typeof K != "object")
        throw TypeError("target should be an object");
      for (; D-- > 0; )
        F = G[D], (!K || F._target === K) && (F.unsubscribe(z), ae = !0);
      return ae;
    }, O.prototype.delimiter = ".", O.prototype.setMaxListeners = function(K) {
      K !== S && (this._maxListeners = K, this._conf || (this._conf = {}), this._conf.maxListeners = K);
    }, O.prototype.getMaxListeners = function() {
      return this._maxListeners;
    }, O.prototype.event = "", O.prototype.once = function(K, z, G) {
      return this._once(K, z, !1, G);
    }, O.prototype.prependOnceListener = function(K, z, G) {
      return this._once(K, z, !0, G);
    }, O.prototype._once = function(K, z, G, D) {
      return this._many(K, 1, z, G, D);
    }, O.prototype.many = function(K, z, G, D) {
      return this._many(K, z, G, !1, D);
    }, O.prototype.prependMany = function(K, z, G, D) {
      return this._many(K, z, G, !0, D);
    }, O.prototype._many = function(K, z, G, D, F) {
      var ae = this;
      if (typeof G != "function")
        throw new Error("many only accepts instances of Function");
      function ge() {
        return --z === 0 && ae.off(K, ge), G.apply(this, arguments);
      }
      return ge._origin = G, this._on(K, ge, D, F);
    }, O.prototype.emit = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || V.call(this);
      var K = arguments[0], z, G = this.wildcard, D, F, ae, ge, xe;
      if (K === "newListener" && !this._newListener && !this._events.newListener)
        return !1;
      if (G && (z = K, K !== "newListener" && K !== "removeListener" && typeof K == "object")) {
        if (F = K.length, A) {
          for (ae = 0; ae < F; ae++)
            if (typeof K[ae] == "symbol") {
              xe = !0;
              break;
            }
        }
        xe || (K = K.join(this.delimiter));
      }
      var ye = arguments.length, oe;
      if (this._all && this._all.length)
        for (oe = this._all.slice(), ae = 0, F = oe.length; ae < F; ae++)
          switch (this.event = K, ye) {
            case 1:
              oe[ae].call(this, K);
              break;
            case 2:
              oe[ae].call(this, K, arguments[1]);
              break;
            case 3:
              oe[ae].call(this, K, arguments[1], arguments[2]);
              break;
            default:
              oe[ae].apply(this, arguments);
          }
      if (G)
        oe = [], Re.call(this, oe, z, this.listenerTree, 0, F);
      else if (oe = this._events[K], typeof oe == "function") {
        switch (this.event = K, ye) {
          case 1:
            oe.call(this);
            break;
          case 2:
            oe.call(this, arguments[1]);
            break;
          case 3:
            oe.call(this, arguments[1], arguments[2]);
            break;
          default:
            for (D = new Array(ye - 1), ge = 1; ge < ye; ge++)
              D[ge - 1] = arguments[ge];
            oe.apply(this, D);
        }
        return !0;
      } else
        oe && (oe = oe.slice());
      if (oe && oe.length) {
        if (ye > 3)
          for (D = new Array(ye - 1), ge = 1; ge < ye; ge++)
            D[ge - 1] = arguments[ge];
        for (ae = 0, F = oe.length; ae < F; ae++)
          switch (this.event = K, ye) {
            case 1:
              oe[ae].call(this);
              break;
            case 2:
              oe[ae].call(this, arguments[1]);
              break;
            case 3:
              oe[ae].call(this, arguments[1], arguments[2]);
              break;
            default:
              oe[ae].apply(this, D);
          }
        return !0;
      } else if (!this.ignoreErrors && !this._all && K === "error")
        throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
      return !!this._all;
    }, O.prototype.emitAsync = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || V.call(this);
      var K = arguments[0], z = this.wildcard, G, D, F, ae, ge, xe;
      if (K === "newListener" && !this._newListener && !this._events.newListener)
        return Promise.resolve([!1]);
      if (z && (G = K, K !== "newListener" && K !== "removeListener" && typeof K == "object")) {
        if (ae = K.length, A) {
          for (ge = 0; ge < ae; ge++)
            if (typeof K[ge] == "symbol") {
              D = !0;
              break;
            }
        }
        D || (K = K.join(this.delimiter));
      }
      var ye = [], oe = arguments.length, fe;
      if (this._all)
        for (ge = 0, ae = this._all.length; ge < ae; ge++)
          switch (this.event = K, oe) {
            case 1:
              ye.push(this._all[ge].call(this, K));
              break;
            case 2:
              ye.push(this._all[ge].call(this, K, arguments[1]));
              break;
            case 3:
              ye.push(this._all[ge].call(this, K, arguments[1], arguments[2]));
              break;
            default:
              ye.push(this._all[ge].apply(this, arguments));
          }
      if (z ? (fe = [], Re.call(this, fe, G, this.listenerTree, 0)) : fe = this._events[K], typeof fe == "function")
        switch (this.event = K, oe) {
          case 1:
            ye.push(fe.call(this));
            break;
          case 2:
            ye.push(fe.call(this, arguments[1]));
            break;
          case 3:
            ye.push(fe.call(this, arguments[1], arguments[2]));
            break;
          default:
            for (F = new Array(oe - 1), xe = 1; xe < oe; xe++)
              F[xe - 1] = arguments[xe];
            ye.push(fe.apply(this, F));
        }
      else if (fe && fe.length) {
        if (fe = fe.slice(), oe > 3)
          for (F = new Array(oe - 1), xe = 1; xe < oe; xe++)
            F[xe - 1] = arguments[xe];
        for (ge = 0, ae = fe.length; ge < ae; ge++)
          switch (this.event = K, oe) {
            case 1:
              ye.push(fe[ge].call(this));
              break;
            case 2:
              ye.push(fe[ge].call(this, arguments[1]));
              break;
            case 3:
              ye.push(fe[ge].call(this, arguments[1], arguments[2]));
              break;
            default:
              ye.push(fe[ge].apply(this, F));
          }
      } else if (!this.ignoreErrors && !this._all && K === "error")
        return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
      return Promise.all(ye);
    }, O.prototype.on = function(K, z, G) {
      return this._on(K, z, !1, G);
    }, O.prototype.prependListener = function(K, z, G) {
      return this._on(K, z, !0, G);
    }, O.prototype.onAny = function(K) {
      return this._onAny(K, !1);
    }, O.prototype.prependAny = function(K) {
      return this._onAny(K, !0);
    }, O.prototype.addListener = O.prototype.on, O.prototype._onAny = function(K, z) {
      if (typeof K != "function")
        throw new Error("onAny only accepts instances of Function");
      return this._all || (this._all = []), z ? this._all.unshift(K) : this._all.push(K), this;
    }, O.prototype._on = function(K, z, G, D) {
      if (typeof K == "function")
        return this._onAny(K, z), this;
      if (typeof z != "function")
        throw new Error("on only accepts instances of Function");
      this._events || V.call(this);
      var F = this, ae;
      return D !== S && (ae = $.call(this, K, z, D), z = ae[0], F = ae[1]), this._newListener && this.emit("newListener", K, z), this.wildcard ? (Ne.call(this, K, z, G), F) : (this._events[K] ? (typeof this._events[K] == "function" && (this._events[K] = [this._events[K]]), G ? this._events[K].unshift(z) : this._events[K].push(z), !this._events[K].warned && this._maxListeners > 0 && this._events[K].length > this._maxListeners && (this._events[K].warned = !0, Q.call(this, this._events[K].length, K))) : this._events[K] = z, F);
    }, O.prototype.off = function(K, z) {
      if (typeof z != "function")
        throw new Error("removeListener only takes instances of Function");
      var G, D = [];
      if (this.wildcard) {
        var F = typeof K == "string" ? K.split(this.delimiter) : K.slice();
        if (D = Re.call(this, null, F, this.listenerTree, 0), !D)
          return this;
      } else {
        if (!this._events[K])
          return this;
        G = this._events[K], D.push({ _listeners: G });
      }
      for (var ae = 0; ae < D.length; ae++) {
        var ge = D[ae];
        if (G = ge._listeners, U(G)) {
          for (var xe = -1, ye = 0, oe = G.length; ye < oe; ye++)
            if (G[ye] === z || G[ye].listener && G[ye].listener === z || G[ye]._origin && G[ye]._origin === z) {
              xe = ye;
              break;
            }
          if (xe < 0)
            continue;
          return this.wildcard ? ge._listeners.splice(xe, 1) : this._events[K].splice(xe, 1), G.length === 0 && (this.wildcard ? delete ge._listeners : delete this._events[K]), this._removeListener && this.emit("removeListener", K, z), this;
        } else
          (G === z || G.listener && G.listener === z || G._origin && G._origin === z) && (this.wildcard ? delete ge._listeners : delete this._events[K], this._removeListener && this.emit("removeListener", K, z));
      }
      return this.listenerTree && Y(this.listenerTree), this;
    }, O.prototype.offAny = function(K) {
      var z = 0, G = 0, D;
      if (K && this._all && this._all.length > 0) {
        for (D = this._all, z = 0, G = D.length; z < G; z++)
          if (K === D[z])
            return D.splice(z, 1), this._removeListener && this.emit("removeListenerAny", K), this;
      } else {
        if (D = this._all, this._removeListener)
          for (z = 0, G = D.length; z < G; z++)
            this.emit("removeListenerAny", D[z]);
        this._all = [];
      }
      return this;
    }, O.prototype.removeListener = O.prototype.off, O.prototype.removeAllListeners = function(K) {
      if (K === S)
        return !this._events || V.call(this), this;
      if (this.wildcard) {
        var z = Re.call(this, null, K, this.listenerTree, 0), G, D;
        if (!z)
          return this;
        for (D = 0; D < z.length; D++)
          G = z[D], G._listeners = null;
        this.listenerTree && Y(this.listenerTree);
      } else
        this._events && (this._events[K] = null);
      return this;
    }, O.prototype.listeners = function(K) {
      var z = this._events, G, D, F, ae, ge;
      if (K === S) {
        if (this.wildcard)
          throw Error("event name required for wildcard emitter");
        if (!z)
          return [];
        for (G = H(z), ae = G.length, F = []; ae-- > 0; )
          D = z[G[ae]], typeof D == "function" ? F.push(D) : F.push.apply(F, D);
        return F;
      } else {
        if (this.wildcard) {
          if (ge = this.listenerTree, !ge)
            return [];
          var xe = [], ye = typeof K == "string" ? K.split(this.delimiter) : K.slice();
          return Re.call(this, xe, ye, ge, 0), xe;
        }
        return z ? (D = z[K], D ? typeof D == "function" ? [D] : D : []) : [];
      }
    }, O.prototype.eventNames = function(K) {
      var z = this._events;
      return this.wildcard ? ne.call(this, this.listenerTree, [], null, K) : z ? H(z) : [];
    }, O.prototype.listenerCount = function(K) {
      return this.listeners(K).length;
    }, O.prototype.hasListeners = function(K) {
      if (this.wildcard) {
        var z = [], G = typeof K == "string" ? K.split(this.delimiter) : K.slice();
        return Re.call(this, z, G, this.listenerTree, 0), z.length > 0;
      }
      var D = this._events, F = this._all;
      return !!(F && F.length || D && (K === S ? H(D).length : D[K]));
    }, O.prototype.listenersAny = function() {
      return this._all ? this._all : [];
    }, O.prototype.waitFor = function(K, z) {
      var G = this, D = typeof z;
      return D === "number" ? z = { timeout: z } : D === "function" && (z = { filter: z }), z = se(z, {
        timeout: 0,
        filter: S,
        handleError: !1,
        Promise,
        overload: !1
      }, {
        filter: pe,
        Promise: le
      }), Me(z.Promise, function(F, ae, ge) {
        function xe() {
          var ye = z.filter;
          if (!(ye && !ye.apply(G, arguments)))
            if (G.off(K, xe), z.handleError) {
              var oe = arguments[0];
              oe ? ae(oe) : F(ee.apply(null, arguments).slice(1));
            } else
              F(ee.apply(null, arguments));
        }
        ge(function() {
          G.off(K, xe);
        }), G._on(K, xe, !1);
      }, {
        timeout: z.timeout,
        overload: z.overload
      });
    };
    function J(K, z, G) {
      G = se(G, {
        Promise,
        timeout: 0,
        overload: !1
      }, {
        Promise: le
      });
      var D = G.Promise;
      return Me(D, function(F, ae, ge) {
        var xe;
        if (typeof K.addEventListener == "function") {
          xe = function() {
            F(ee.apply(null, arguments));
          }, ge(function() {
            K.removeEventListener(z, xe);
          }), K.addEventListener(
            z,
            xe,
            { once: !0 }
          );
          return;
        }
        var ye = function() {
          oe && K.removeListener("error", oe), F(ee.apply(null, arguments));
        }, oe;
        z !== "error" && (oe = function(fe) {
          K.removeListener(z, ye), ae(fe);
        }, K.once("error", oe)), ge(function() {
          oe && K.removeListener("error", oe), K.removeListener(z, ye);
        }), K.once(z, ye);
      }, {
        timeout: G.timeout,
        overload: G.overload
      });
    }
    var Z = O.prototype;
    Object.defineProperties(O, {
      defaultMaxListeners: {
        get: function() {
          return Z._maxListeners;
        },
        set: function(K) {
          if (typeof K != "number" || K < 0 || Number.isNaN(K))
            throw TypeError("n must be a non-negative number");
          Z._maxListeners = K;
        },
        enumerable: !0
      },
      once: {
        value: J,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperties(Z, {
      _maxListeners: {
        value: h,
        writable: !0,
        configurable: !0
      },
      _observers: { value: null, writable: !0, configurable: !0 }
    }), typeof S == "function" && S.amd ? S(function() {
      return O;
    }) : e.exports = O;
  })();
})(eventemitter2);
var eventemitter2Exports = eventemitter2.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter2Exports);
class FetchAPI extends EventEmitter$1 {
  constructor(o) {
    super(), this.baseUrl = o;
  }
  async send(o, S) {
    const { url: g, query: U, method: h, data: q, headers: A } = o, [P, I] = q instanceof FormData ? [q, {}] : [
      typeof q != "string" ? JSON.stringify(q) : q,
      {
        "Content-Type": "application/json"
      }
    ], B = this.baseUrl + g, H = this.getUrlWithParams(B, U), V = await fetch(H, {
      method: h,
      headers: Object.assign(A || {}, I),
      body: P,
      credentials: o.withCredentials ? "include" : "same-origin"
    }), X = await V.json(), Q = this.convertHeadersToPlainObject(V.headers);
    return new APIResponse({
      data: X,
      status: V.status,
      headers: Q,
      request: o
    });
  }
  getUrlWithParams(o, S) {
    if (!S)
      return o;
    const g = new URL(o);
    return Object.entries(S).forEach(
      ([U, h]) => {
        g.searchParams.append(U, h);
      }
    ), g.toString();
  }
  convertHeadersToPlainObject(o) {
    const S = {};
    for (const g of Object.keys(o))
      S[g] = o.get(g);
    return S;
  }
  // type override    class    ..
  addListener(o, S) {
    return super.addListener(o, S);
  }
  on(o, S, g) {
    return super.on(o, S, g);
  }
  prependListener(o, S, g) {
    return super.prependListener(o, S, g);
  }
  once(o, S, g) {
    return super.once(o, S, g);
  }
  emit(o, ...S) {
    return super.emit(o, ...S);
  }
  emitAsync(o, ...S) {
    return super.emitAsync(o, ...S);
  }
}
function commonjsRequire$1(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var bcrypt$1 = { exports: {} }, cryptoBrowserify$1 = {}, browser$b$1 = { exports: {} }, safeBuffer$1$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1$1;
function requireSafeBuffer$1$1() {
  return hasRequiredSafeBuffer$1$1 || (hasRequiredSafeBuffer$1$1 = 1, function(e, o) {
    var S = requireBuffer$1(), g = S.Buffer;
    function U(q, A) {
      for (var P in q)
        A[P] = q[P];
    }
    g.from && g.alloc && g.allocUnsafe && g.allocUnsafeSlow ? e.exports = S : (U(S, o), o.Buffer = h);
    function h(q, A, P) {
      return g(q, A, P);
    }
    h.prototype = Object.create(g.prototype), U(g, h), h.from = function(q, A, P) {
      if (typeof q == "number")
        throw new TypeError("Argument must not be a number");
      return g(q, A, P);
    }, h.alloc = function(q, A, P) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      var I = g(q);
      return A !== void 0 ? typeof P == "string" ? I.fill(A, P) : I.fill(A) : I.fill(0), I;
    }, h.allocUnsafe = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return g(q);
    }, h.allocUnsafeSlow = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return S.SlowBuffer(q);
    };
  }(safeBuffer$1$1, safeBuffer$1$1.exports)), safeBuffer$1$1.exports;
}
var hasRequiredBrowser$b$1;
function requireBrowser$b$1() {
  if (hasRequiredBrowser$b$1)
    return browser$b$1.exports;
  hasRequiredBrowser$b$1 = 1;
  var e = 65536, o = 4294967295;
  function S() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var g = requireSafeBuffer$1$1().Buffer, U = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  U && U.getRandomValues ? browser$b$1.exports = h : browser$b$1.exports = S;
  function h(q, A) {
    if (q > o)
      throw new RangeError("requested too many random bytes");
    var P = g.allocUnsafe(q);
    if (q > 0)
      if (q > e)
        for (var I = 0; I < q; I += e)
          U.getRandomValues(P.slice(I, I + e));
      else
        U.getRandomValues(P);
    return typeof A == "function" ? process$1.nextTick(function() {
      A(null, P);
    }) : P;
  }
  return browser$b$1.exports;
}
var inherits_browser$1 = { exports: {} }, hasRequiredInherits_browser$1;
function requireInherits_browser$1() {
  return hasRequiredInherits_browser$1 || (hasRequiredInherits_browser$1 = 1, typeof Object.create == "function" ? inherits_browser$1.exports = function(e, o) {
    o && (e.super_ = o, e.prototype = Object.create(o.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser$1.exports = function(e, o) {
    if (o) {
      e.super_ = o;
      var S = function() {
      };
      S.prototype = o.prototype, e.prototype = new S(), e.prototype.constructor = e;
    }
  }), inherits_browser$1.exports;
}
var readableBrowser$1$1 = { exports: {} }, events$1 = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents)
    return events$1.exports;
  hasRequiredEvents = 1;
  var e = typeof Reflect == "object" ? Reflect : null, o = e && typeof e.apply == "function" ? e.apply : function(ce, pe, me) {
    return Function.prototype.apply.call(ce, pe, me);
  }, S;
  e && typeof e.ownKeys == "function" ? S = e.ownKeys : Object.getOwnPropertySymbols ? S = function(ce) {
    return Object.getOwnPropertyNames(ce).concat(Object.getOwnPropertySymbols(ce));
  } : S = function(ce) {
    return Object.getOwnPropertyNames(ce);
  };
  function g(ce) {
    console && console.warn && console.warn(ce);
  }
  var U = Number.isNaN || function(ce) {
    return ce !== ce;
  };
  function h() {
    h.init.call(this);
  }
  events$1.exports = h, events$1.exports.once = te, h.EventEmitter = h, h.prototype._events = void 0, h.prototype._eventsCount = 0, h.prototype._maxListeners = void 0;
  var q = 10;
  function A(ce) {
    if (typeof ce != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof ce);
  }
  Object.defineProperty(h, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return q;
    },
    set: function(ce) {
      if (typeof ce != "number" || ce < 0 || U(ce))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + ce + ".");
      q = ce;
    }
  }), h.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, h.prototype.setMaxListeners = function(ce) {
    if (typeof ce != "number" || ce < 0 || U(ce))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + ce + ".");
    return this._maxListeners = ce, this;
  };
  function P(ce) {
    return ce._maxListeners === void 0 ? h.defaultMaxListeners : ce._maxListeners;
  }
  h.prototype.getMaxListeners = function() {
    return P(this);
  }, h.prototype.emit = function(ce) {
    for (var pe = [], me = 1; me < arguments.length; me++)
      pe.push(arguments[me]);
    var Me = ce === "error", Ee = this._events;
    if (Ee !== void 0)
      Me = Me && Ee.error === void 0;
    else if (!Me)
      return !1;
    if (Me) {
      var Re;
      if (pe.length > 0 && (Re = pe[0]), Re instanceof Error)
        throw Re;
      var Ne = new Error("Unhandled error." + (Re ? " (" + Re.message + ")" : ""));
      throw Ne.context = Re, Ne;
    }
    var ne = Ee[ce];
    if (ne === void 0)
      return !1;
    if (typeof ne == "function")
      o(ne, this, pe);
    else
      for (var Y = ne.length, M = Q(ne, Y), me = 0; me < Y; ++me)
        o(M[me], this, pe);
    return !0;
  };
  function I(ce, pe, me, Me) {
    var Ee, Re, Ne;
    if (A(me), Re = ce._events, Re === void 0 ? (Re = ce._events = /* @__PURE__ */ Object.create(null), ce._eventsCount = 0) : (Re.newListener !== void 0 && (ce.emit(
      "newListener",
      pe,
      me.listener ? me.listener : me
    ), Re = ce._events), Ne = Re[pe]), Ne === void 0)
      Ne = Re[pe] = me, ++ce._eventsCount;
    else if (typeof Ne == "function" ? Ne = Re[pe] = Me ? [me, Ne] : [Ne, me] : Me ? Ne.unshift(me) : Ne.push(me), Ee = P(ce), Ee > 0 && Ne.length > Ee && !Ne.warned) {
      Ne.warned = !0;
      var ne = new Error("Possible EventEmitter memory leak detected. " + Ne.length + " " + String(pe) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      ne.name = "MaxListenersExceededWarning", ne.emitter = ce, ne.type = pe, ne.count = Ne.length, g(ne);
    }
    return ce;
  }
  h.prototype.addListener = function(ce, pe) {
    return I(this, ce, pe, !1);
  }, h.prototype.on = h.prototype.addListener, h.prototype.prependListener = function(ce, pe) {
    return I(this, ce, pe, !0);
  };
  function B() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function H(ce, pe, me) {
    var Me = { fired: !1, wrapFn: void 0, target: ce, type: pe, listener: me }, Ee = B.bind(Me);
    return Ee.listener = me, Me.wrapFn = Ee, Ee;
  }
  h.prototype.once = function(ce, pe) {
    return A(pe), this.on(ce, H(this, ce, pe)), this;
  }, h.prototype.prependOnceListener = function(ce, pe) {
    return A(pe), this.prependListener(ce, H(this, ce, pe)), this;
  }, h.prototype.removeListener = function(ce, pe) {
    var me, Me, Ee, Re, Ne;
    if (A(pe), Me = this._events, Me === void 0)
      return this;
    if (me = Me[ce], me === void 0)
      return this;
    if (me === pe || me.listener === pe)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Me[ce], Me.removeListener && this.emit("removeListener", ce, me.listener || pe));
    else if (typeof me != "function") {
      for (Ee = -1, Re = me.length - 1; Re >= 0; Re--)
        if (me[Re] === pe || me[Re].listener === pe) {
          Ne = me[Re].listener, Ee = Re;
          break;
        }
      if (Ee < 0)
        return this;
      Ee === 0 ? me.shift() : ee(me, Ee), me.length === 1 && (Me[ce] = me[0]), Me.removeListener !== void 0 && this.emit("removeListener", ce, Ne || pe);
    }
    return this;
  }, h.prototype.off = h.prototype.removeListener, h.prototype.removeAllListeners = function(ce) {
    var pe, me, Me;
    if (me = this._events, me === void 0)
      return this;
    if (me.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : me[ce] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete me[ce]), this;
    if (arguments.length === 0) {
      var Ee = Object.keys(me), Re;
      for (Me = 0; Me < Ee.length; ++Me)
        Re = Ee[Me], Re !== "removeListener" && this.removeAllListeners(Re);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (pe = me[ce], typeof pe == "function")
      this.removeListener(ce, pe);
    else if (pe !== void 0)
      for (Me = pe.length - 1; Me >= 0; Me--)
        this.removeListener(ce, pe[Me]);
    return this;
  };
  function V(ce, pe, me) {
    var Me = ce._events;
    if (Me === void 0)
      return [];
    var Ee = Me[pe];
    return Ee === void 0 ? [] : typeof Ee == "function" ? me ? [Ee.listener || Ee] : [Ee] : me ? ie(Ee) : Q(Ee, Ee.length);
  }
  h.prototype.listeners = function(ce) {
    return V(this, ce, !0);
  }, h.prototype.rawListeners = function(ce) {
    return V(this, ce, !1);
  }, h.listenerCount = function(ce, pe) {
    return typeof ce.listenerCount == "function" ? ce.listenerCount(pe) : X.call(ce, pe);
  }, h.prototype.listenerCount = X;
  function X(ce) {
    var pe = this._events;
    if (pe !== void 0) {
      var me = pe[ce];
      if (typeof me == "function")
        return 1;
      if (me !== void 0)
        return me.length;
    }
    return 0;
  }
  h.prototype.eventNames = function() {
    return this._eventsCount > 0 ? S(this._events) : [];
  };
  function Q(ce, pe) {
    for (var me = new Array(pe), Me = 0; Me < pe; ++Me)
      me[Me] = ce[Me];
    return me;
  }
  function ee(ce, pe) {
    for (; pe + 1 < ce.length; pe++)
      ce[pe] = ce[pe + 1];
    ce.pop();
  }
  function ie(ce) {
    for (var pe = new Array(ce.length), me = 0; me < pe.length; ++me)
      pe[me] = ce[me].listener || ce[me];
    return pe;
  }
  function te(ce, pe) {
    return new Promise(function(me, Me) {
      function Ee(Ne) {
        ce.removeListener(pe, Re), Me(Ne);
      }
      function Re() {
        typeof ce.removeListener == "function" && ce.removeListener("error", Ee), me([].slice.call(arguments));
      }
      le(ce, pe, Re, { once: !0 }), pe !== "error" && se(ce, Ee, { once: !0 });
    });
  }
  function se(ce, pe, me) {
    typeof ce.on == "function" && le(ce, "error", pe, me);
  }
  function le(ce, pe, me, Me) {
    if (typeof ce.on == "function")
      Me.once ? ce.once(pe, me) : ce.on(pe, me);
    else if (typeof ce.addEventListener == "function")
      ce.addEventListener(pe, function Ee(Re) {
        Me.once && ce.removeEventListener(pe, Ee), me(Re);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof ce);
  }
  return events$1.exports;
}
var streamBrowser$1$1, hasRequiredStreamBrowser$1$1;
function requireStreamBrowser$1$1() {
  return hasRequiredStreamBrowser$1$1 || (hasRequiredStreamBrowser$1$1 = 1, streamBrowser$1$1 = requireEvents().EventEmitter), streamBrowser$1$1;
}
var util$1$1 = {}, types$3 = {}, shams$1$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, o = Symbol("test"), S = Object(o);
    if (typeof o == "string" || Object.prototype.toString.call(o) !== "[object Symbol]" || Object.prototype.toString.call(S) !== "[object Symbol]")
      return !1;
    var g = 42;
    e[o] = g;
    for (o in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var U = Object.getOwnPropertySymbols(e);
    if (U.length !== 1 || U[0] !== o || !Object.prototype.propertyIsEnumerable.call(e, o))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var h = Object.getOwnPropertyDescriptor(e, o);
      if (h.value !== g || h.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1$1;
}
var shams$2, hasRequiredShams$2;
function requireShams$2() {
  if (hasRequiredShams$2)
    return shams$2;
  hasRequiredShams$2 = 1;
  var e = requireShams$1();
  return shams$2 = function() {
    return e() && !!Symbol.toStringTag;
  }, shams$2;
}
var esErrors$1, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors$1 = Error), esErrors$1;
}
var _eval$1, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval$1 = EvalError), _eval$1;
}
var range$2, hasRequiredRange$1;
function requireRange$1() {
  return hasRequiredRange$1 || (hasRequiredRange$1 = 1, range$2 = RangeError), range$2;
}
var ref$1, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref$1 = ReferenceError), ref$1;
}
var syntax$1, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax$1 = SyntaxError), syntax$1;
}
var type$2, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type$2 = TypeError), type$2;
}
var uri$1, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri$1 = URIError), uri$1;
}
var hasSymbols$2, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols$2;
  hasRequiredHasSymbols = 1;
  var e = typeof Symbol < "u" && Symbol, o = requireShams$1();
  return hasSymbols$2 = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : o();
  }, hasSymbols$2;
}
var hasProto$2, hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto)
    return hasProto$2;
  hasRequiredHasProto = 1;
  var e = {
    __proto__: null,
    foo: {}
  }, o = Object;
  return hasProto$2 = function() {
    return { __proto__: e }.foo === e.foo && !(e instanceof o);
  }, hasProto$2;
}
var implementation$6, hasRequiredImplementation$4;
function requireImplementation$4() {
  if (hasRequiredImplementation$4)
    return implementation$6;
  hasRequiredImplementation$4 = 1;
  var e = "Function.prototype.bind called on incompatible ", o = Object.prototype.toString, S = Math.max, g = "[object Function]", U = function(A, P) {
    for (var I = [], B = 0; B < A.length; B += 1)
      I[B] = A[B];
    for (var H = 0; H < P.length; H += 1)
      I[H + A.length] = P[H];
    return I;
  }, h = function(A, P) {
    for (var I = [], B = P || 0, H = 0; B < A.length; B += 1, H += 1)
      I[H] = A[B];
    return I;
  }, q = function(A, P) {
    for (var I = "", B = 0; B < A.length; B += 1)
      I += A[B], B + 1 < A.length && (I += P);
    return I;
  };
  return implementation$6 = function(A) {
    var P = this;
    if (typeof P != "function" || o.apply(P) !== g)
      throw new TypeError(e + P);
    for (var I = h(arguments, 1), B, H = function() {
      if (this instanceof B) {
        var ie = P.apply(
          this,
          U(I, arguments)
        );
        return Object(ie) === ie ? ie : this;
      }
      return P.apply(
        A,
        U(I, arguments)
      );
    }, V = S(0, P.length - I.length), X = [], Q = 0; Q < V; Q++)
      X[Q] = "$" + Q;
    if (B = Function("binder", "return function (" + q(X, ",") + "){ return binder.apply(this,arguments); }")(H), P.prototype) {
      var ee = function() {
      };
      ee.prototype = P.prototype, B.prototype = new ee(), ee.prototype = null;
    }
    return B;
  }, implementation$6;
}
var functionBind$1, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind$1;
  hasRequiredFunctionBind = 1;
  var e = requireImplementation$4();
  return functionBind$1 = Function.prototype.bind || e, functionBind$1;
}
var hasown$1, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown)
    return hasown$1;
  hasRequiredHasown = 1;
  var e = Function.prototype.call, o = Object.prototype.hasOwnProperty, S = requireFunctionBind();
  return hasown$1 = S.call(e, o), hasown$1;
}
var getIntrinsic$1, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic$1;
  hasRequiredGetIntrinsic = 1;
  var e, o = requireEsErrors(), S = require_eval(), g = requireRange$1(), U = requireRef(), h = requireSyntax(), q = requireType(), A = requireUri(), P = Function, I = function(Z) {
    try {
      return P('"use strict"; return (' + Z + ").constructor;")();
    } catch {
    }
  }, B = Object.getOwnPropertyDescriptor;
  if (B)
    try {
      B({}, "");
    } catch {
      B = null;
    }
  var H = function() {
    throw new q();
  }, V = B ? function() {
    try {
      return arguments.callee, H;
    } catch {
      try {
        return B(arguments, "callee").get;
      } catch {
        return H;
      }
    }
  }() : H, X = requireHasSymbols()(), Q = requireHasProto()(), ee = Object.getPrototypeOf || (Q ? function(Z) {
    return Z.__proto__;
  } : null), ie = {}, te = typeof Uint8Array > "u" || !ee ? e : ee(Uint8Array), se = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": X && ee ? ee([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": ie,
    "%AsyncGenerator%": ie,
    "%AsyncGeneratorFunction%": ie,
    "%AsyncIteratorPrototype%": ie,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": o,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": S,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": P,
    "%GeneratorFunction%": ie,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": X && ee ? ee(ee([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !X || !ee ? e : ee((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": g,
    "%ReferenceError%": U,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !X || !ee ? e : ee((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": X && ee ? ee(""[Symbol.iterator]()) : e,
    "%Symbol%": X ? Symbol : e,
    "%SyntaxError%": h,
    "%ThrowTypeError%": V,
    "%TypedArray%": te,
    "%TypeError%": q,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": A,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet
  };
  if (ee)
    try {
      null.error;
    } catch (Z) {
      var le = ee(ee(Z));
      se["%Error.prototype%"] = le;
    }
  var ce = function Z(K) {
    var z;
    if (K === "%AsyncFunction%")
      z = I("async function () {}");
    else if (K === "%GeneratorFunction%")
      z = I("function* () {}");
    else if (K === "%AsyncGeneratorFunction%")
      z = I("async function* () {}");
    else if (K === "%AsyncGenerator%") {
      var G = Z("%AsyncGeneratorFunction%");
      G && (z = G.prototype);
    } else if (K === "%AsyncIteratorPrototype%") {
      var D = Z("%AsyncGenerator%");
      D && ee && (z = ee(D.prototype));
    }
    return se[K] = z, z;
  }, pe = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, me = requireFunctionBind(), Me = requireHasown(), Ee = me.call(Function.call, Array.prototype.concat), Re = me.call(Function.apply, Array.prototype.splice), Ne = me.call(Function.call, String.prototype.replace), ne = me.call(Function.call, String.prototype.slice), Y = me.call(Function.call, RegExp.prototype.exec), M = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, $ = /\\(\\)?/g, O = function(Z) {
    var K = ne(Z, 0, 1), z = ne(Z, -1);
    if (K === "%" && z !== "%")
      throw new h("invalid intrinsic syntax, expected closing `%`");
    if (z === "%" && K !== "%")
      throw new h("invalid intrinsic syntax, expected opening `%`");
    var G = [];
    return Ne(Z, M, function(D, F, ae, ge) {
      G[G.length] = ae ? Ne(ge, $, "$1") : F || D;
    }), G;
  }, J = function(Z, K) {
    var z = Z, G;
    if (Me(pe, z) && (G = pe[z], z = "%" + G[0] + "%"), Me(se, z)) {
      var D = se[z];
      if (D === ie && (D = ce(z)), typeof D > "u" && !K)
        throw new q("intrinsic " + Z + " exists, but is not available. Please file an issue!");
      return {
        alias: G,
        name: z,
        value: D
      };
    }
    throw new h("intrinsic " + Z + " does not exist!");
  };
  return getIntrinsic$1 = function(Z, K) {
    if (typeof Z != "string" || Z.length === 0)
      throw new q("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof K != "boolean")
      throw new q('"allowMissing" argument must be a boolean');
    if (Y(/^%?[^%]*%?$/, Z) === null)
      throw new h("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var z = O(Z), G = z.length > 0 ? z[0] : "", D = J("%" + G + "%", K), F = D.name, ae = D.value, ge = !1, xe = D.alias;
    xe && (G = xe[0], Re(z, Ee([0, 1], xe)));
    for (var ye = 1, oe = !0; ye < z.length; ye += 1) {
      var fe = z[ye], $e = ne(fe, 0, 1), Be = ne(fe, -1);
      if (($e === '"' || $e === "'" || $e === "`" || Be === '"' || Be === "'" || Be === "`") && $e !== Be)
        throw new h("property names with quotes must have matching quotes");
      if ((fe === "constructor" || !oe) && (ge = !0), G += "." + fe, F = "%" + G + "%", Me(se, F))
        ae = se[F];
      else if (ae != null) {
        if (!(fe in ae)) {
          if (!K)
            throw new q("base intrinsic for " + Z + " exists, but the property is not available.");
          return;
        }
        if (B && ye + 1 >= z.length) {
          var be = B(ae, fe);
          oe = !!be, oe && "get" in be && !("originalValue" in be.get) ? ae = be.get : ae = ae[fe];
        } else
          oe = Me(ae, fe), ae = ae[fe];
        oe && !ge && (se[F] = ae);
      }
    }
    return ae;
  }, getIntrinsic$1;
}
var callBind$3 = { exports: {} }, esDefineProperty$1, hasRequiredEsDefineProperty$1;
function requireEsDefineProperty$1() {
  if (hasRequiredEsDefineProperty$1)
    return esDefineProperty$1;
  hasRequiredEsDefineProperty$1 = 1;
  var e = requireGetIntrinsic(), o = e("%Object.defineProperty%", !0) || !1;
  if (o)
    try {
      o({}, "a", { value: 1 });
    } catch {
      o = !1;
    }
  return esDefineProperty$1 = o, esDefineProperty$1;
}
var gopd$2, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd$2;
  hasRequiredGopd = 1;
  var e = requireGetIntrinsic(), o = e("%Object.getOwnPropertyDescriptor%", !0);
  if (o)
    try {
      o([], "length");
    } catch {
      o = null;
    }
  return gopd$2 = o, gopd$2;
}
var defineDataProperty$1, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty)
    return defineDataProperty$1;
  hasRequiredDefineDataProperty = 1;
  var e = requireEsDefineProperty$1(), o = requireSyntax(), S = requireType(), g = requireGopd();
  return defineDataProperty$1 = function(U, h, q) {
    if (!U || typeof U != "object" && typeof U != "function")
      throw new S("`obj` must be an object or a function`");
    if (typeof h != "string" && typeof h != "symbol")
      throw new S("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new S("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new S("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new S("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new S("`loose`, if provided, must be a boolean");
    var A = arguments.length > 3 ? arguments[3] : null, P = arguments.length > 4 ? arguments[4] : null, I = arguments.length > 5 ? arguments[5] : null, B = arguments.length > 6 ? arguments[6] : !1, H = !!g && g(U, h);
    if (e)
      e(U, h, {
        configurable: I === null && H ? H.configurable : !I,
        enumerable: A === null && H ? H.enumerable : !A,
        value: q,
        writable: P === null && H ? H.writable : !P
      });
    else if (B || !A && !P && !I)
      U[h] = q;
    else
      throw new o("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty$1;
}
var hasPropertyDescriptors_1$1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1$1;
  hasRequiredHasPropertyDescriptors = 1;
  var e = requireEsDefineProperty$1(), o = function() {
    return !!e;
  };
  return o.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1$1 = o, hasPropertyDescriptors_1$1;
}
var setFunctionLength$1, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength)
    return setFunctionLength$1;
  hasRequiredSetFunctionLength = 1;
  var e = requireGetIntrinsic(), o = requireDefineDataProperty(), S = requireHasPropertyDescriptors()(), g = requireGopd(), U = requireType(), h = e("%Math.floor%");
  return setFunctionLength$1 = function(q, A) {
    if (typeof q != "function")
      throw new U("`fn` is not a function");
    if (typeof A != "number" || A < 0 || A > 4294967295 || h(A) !== A)
      throw new U("`length` must be a positive 32-bit integer");
    var P = arguments.length > 2 && !!arguments[2], I = !0, B = !0;
    if ("length" in q && g) {
      var H = g(q, "length");
      H && !H.configurable && (I = !1), H && !H.writable && (B = !1);
    }
    return (I || B || !P) && (S ? o(
      /** @type {Parameters<define>[0]} */
      q,
      "length",
      A,
      !0,
      !0
    ) : o(
      /** @type {Parameters<define>[0]} */
      q,
      "length",
      A
    )), q;
  }, setFunctionLength$1;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(e) {
    var o = requireFunctionBind(), S = requireGetIntrinsic(), g = requireSetFunctionLength(), U = requireType(), h = S("%Function.prototype.apply%"), q = S("%Function.prototype.call%"), A = S("%Reflect.apply%", !0) || o.call(q, h), P = requireEsDefineProperty$1(), I = S("%Math.max%");
    e.exports = function(H) {
      if (typeof H != "function")
        throw new U("a function is required");
      var V = A(o, q, arguments);
      return g(
        V,
        1 + I(0, H.length - (arguments.length - 1)),
        !0
      );
    };
    var B = function() {
      return A(o, h, arguments);
    };
    P ? P(e.exports, "apply", { value: B }) : e.exports.apply = B;
  }(callBind$3)), callBind$3.exports;
}
var callBound$2, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound$2;
  hasRequiredCallBound = 1;
  var e = requireGetIntrinsic(), o = requireCallBind(), S = o(e("String.prototype.indexOf"));
  return callBound$2 = function(g, U) {
    var h = e(g, !!U);
    return typeof h == "function" && S(g, ".prototype.") > -1 ? o(h) : h;
  }, callBound$2;
}
var isArguments$2, hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1)
    return isArguments$2;
  hasRequiredIsArguments$1 = 1;
  var e = requireShams$2()(), o = requireCallBound(), S = o("Object.prototype.toString"), g = function(q) {
    return e && q && typeof q == "object" && Symbol.toStringTag in q ? !1 : S(q) === "[object Arguments]";
  }, U = function(q) {
    return g(q) ? !0 : q !== null && typeof q == "object" && typeof q.length == "number" && q.length >= 0 && S(q) !== "[object Array]" && S(q.callee) === "[object Function]";
  }, h = function() {
    return g(arguments);
  }();
  return g.isLegacyArguments = U, isArguments$2 = h ? g : U, isArguments$2;
}
var isGeneratorFunction$1, hasRequiredIsGeneratorFunction$1;
function requireIsGeneratorFunction$1() {
  if (hasRequiredIsGeneratorFunction$1)
    return isGeneratorFunction$1;
  hasRequiredIsGeneratorFunction$1 = 1;
  var e = Object.prototype.toString, o = Function.prototype.toString, S = /^\s*(?:function)?\*/, g = requireShams$2()(), U = Object.getPrototypeOf, h = function() {
    if (!g)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, q;
  return isGeneratorFunction$1 = function(A) {
    if (typeof A != "function")
      return !1;
    if (S.test(o.call(A)))
      return !0;
    if (!g) {
      var P = e.call(A);
      return P === "[object GeneratorFunction]";
    }
    if (!U)
      return !1;
    if (typeof q > "u") {
      var I = h();
      q = I ? U(I) : !1;
    }
    return U(A) === q;
  }, isGeneratorFunction$1;
}
var isCallable$1, hasRequiredIsCallable$1;
function requireIsCallable$1() {
  if (hasRequiredIsCallable$1)
    return isCallable$1;
  hasRequiredIsCallable$1 = 1;
  var e = Function.prototype.toString, o = typeof Reflect == "object" && Reflect !== null && Reflect.apply, S, g;
  if (typeof o == "function" && typeof Object.defineProperty == "function")
    try {
      S = Object.defineProperty({}, "length", {
        get: function() {
          throw g;
        }
      }), g = {}, o(function() {
        throw 42;
      }, null, S);
    } catch (se) {
      se !== g && (o = null);
    }
  else
    o = null;
  var U = /^\s*class\b/, h = function(se) {
    try {
      var le = e.call(se);
      return U.test(le);
    } catch {
      return !1;
    }
  }, q = function(se) {
    try {
      return h(se) ? !1 : (e.call(se), !0);
    } catch {
      return !1;
    }
  }, A = Object.prototype.toString, P = "[object Object]", I = "[object Function]", B = "[object GeneratorFunction]", H = "[object HTMLAllCollection]", V = "[object HTML document.all class]", X = "[object HTMLCollection]", Q = typeof Symbol == "function" && !!Symbol.toStringTag, ee = !(0 in [,]), ie = function() {
    return !1;
  };
  if (typeof document == "object") {
    var te = document.all;
    A.call(te) === A.call(document.all) && (ie = function(se) {
      if ((ee || !se) && (typeof se > "u" || typeof se == "object"))
        try {
          var le = A.call(se);
          return (le === H || le === V || le === X || le === P) && se("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable$1 = o ? function(se) {
    if (ie(se))
      return !0;
    if (!se || typeof se != "function" && typeof se != "object")
      return !1;
    try {
      o(se, null, S);
    } catch (le) {
      if (le !== g)
        return !1;
    }
    return !h(se) && q(se);
  } : function(se) {
    if (ie(se))
      return !0;
    if (!se || typeof se != "function" && typeof se != "object")
      return !1;
    if (Q)
      return q(se);
    if (h(se))
      return !1;
    var le = A.call(se);
    return le !== I && le !== B && !/^\[object HTML/.test(le) ? !1 : q(se);
  }, isCallable$1;
}
var forEach_1$1, hasRequiredForEach$1;
function requireForEach$1() {
  if (hasRequiredForEach$1)
    return forEach_1$1;
  hasRequiredForEach$1 = 1;
  var e = requireIsCallable$1(), o = Object.prototype.toString, S = Object.prototype.hasOwnProperty, g = function(A, P, I) {
    for (var B = 0, H = A.length; B < H; B++)
      S.call(A, B) && (I == null ? P(A[B], B, A) : P.call(I, A[B], B, A));
  }, U = function(A, P, I) {
    for (var B = 0, H = A.length; B < H; B++)
      I == null ? P(A.charAt(B), B, A) : P.call(I, A.charAt(B), B, A);
  }, h = function(A, P, I) {
    for (var B in A)
      S.call(A, B) && (I == null ? P(A[B], B, A) : P.call(I, A[B], B, A));
  }, q = function(A, P, I) {
    if (!e(P))
      throw new TypeError("iterator must be a function");
    var B;
    arguments.length >= 3 && (B = I), o.call(A) === "[object Array]" ? g(A, P, B) : typeof A == "string" ? U(A, P, B) : h(A, P, B);
  };
  return forEach_1$1 = q, forEach_1$1;
}
var possibleTypedArrayNames$1, hasRequiredPossibleTypedArrayNames$1;
function requirePossibleTypedArrayNames$1() {
  return hasRequiredPossibleTypedArrayNames$1 || (hasRequiredPossibleTypedArrayNames$1 = 1, possibleTypedArrayNames$1 = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames$1;
}
var availableTypedArrays$1, hasRequiredAvailableTypedArrays$1;
function requireAvailableTypedArrays$1() {
  if (hasRequiredAvailableTypedArrays$1)
    return availableTypedArrays$1;
  hasRequiredAvailableTypedArrays$1 = 1;
  var e = requirePossibleTypedArrayNames$1(), o = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays$1 = function() {
    for (var S = [], g = 0; g < e.length; g++)
      typeof o[e[g]] == "function" && (S[S.length] = e[g]);
    return S;
  }, availableTypedArrays$1;
}
var whichTypedArray$1, hasRequiredWhichTypedArray$1;
function requireWhichTypedArray$1() {
  if (hasRequiredWhichTypedArray$1)
    return whichTypedArray$1;
  hasRequiredWhichTypedArray$1 = 1;
  var e = requireForEach$1(), o = requireAvailableTypedArrays$1(), S = requireCallBind(), g = requireCallBound(), U = requireGopd(), h = g("Object.prototype.toString"), q = requireShams$2()(), A = typeof globalThis > "u" ? commonjsGlobal : globalThis, P = o(), I = g("String.prototype.slice"), B = Object.getPrototypeOf, H = g("Array.prototype.indexOf", !0) || function(ee, ie) {
    for (var te = 0; te < ee.length; te += 1)
      if (ee[te] === ie)
        return te;
    return -1;
  }, V = { __proto__: null };
  q && U && B ? e(P, function(ee) {
    var ie = new A[ee]();
    if (Symbol.toStringTag in ie) {
      var te = B(ie), se = U(te, Symbol.toStringTag);
      if (!se) {
        var le = B(te);
        se = U(le, Symbol.toStringTag);
      }
      V["$" + ee] = S(se.get);
    }
  }) : e(P, function(ee) {
    var ie = new A[ee](), te = ie.slice || ie.set;
    te && (V["$" + ee] = S(te));
  });
  var X = function(ee) {
    var ie = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      V,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(te, se) {
        if (!ie)
          try {
            "$" + te(ee) === se && (ie = I(se, 1));
          } catch {
          }
      }
    ), ie;
  }, Q = function(ee) {
    var ie = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      V,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(te, se) {
        if (!ie)
          try {
            te(ee), ie = I(se, 1);
          } catch {
          }
      }
    ), ie;
  };
  return whichTypedArray$1 = function(ee) {
    if (!ee || typeof ee != "object")
      return !1;
    if (!q) {
      var ie = I(h(ee), 8, -1);
      return H(P, ie) > -1 ? ie : ie !== "Object" ? !1 : Q(ee);
    }
    return U ? X(ee) : null;
  }, whichTypedArray$1;
}
var isTypedArray$1, hasRequiredIsTypedArray$1;
function requireIsTypedArray$1() {
  if (hasRequiredIsTypedArray$1)
    return isTypedArray$1;
  hasRequiredIsTypedArray$1 = 1;
  var e = requireWhichTypedArray$1();
  return isTypedArray$1 = function(o) {
    return !!e(o);
  }, isTypedArray$1;
}
var hasRequiredTypes$1;
function requireTypes$1() {
  return hasRequiredTypes$1 || (hasRequiredTypes$1 = 1, function(e) {
    var o = requireIsArguments$1(), S = requireIsGeneratorFunction$1(), g = requireWhichTypedArray$1(), U = requireIsTypedArray$1();
    function h(_e) {
      return _e.call.bind(_e);
    }
    var q = typeof BigInt < "u", A = typeof Symbol < "u", P = h(Object.prototype.toString), I = h(Number.prototype.valueOf), B = h(String.prototype.valueOf), H = h(Boolean.prototype.valueOf);
    if (q)
      var V = h(BigInt.prototype.valueOf);
    if (A)
      var X = h(Symbol.prototype.valueOf);
    function Q(_e, Pe) {
      if (typeof _e != "object")
        return !1;
      try {
        return Pe(_e), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = o, e.isGeneratorFunction = S, e.isTypedArray = U;
    function ee(_e) {
      return typeof Promise < "u" && _e instanceof Promise || _e !== null && typeof _e == "object" && typeof _e.then == "function" && typeof _e.catch == "function";
    }
    e.isPromise = ee;
    function ie(_e) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(_e) : U(_e) || ae(_e);
    }
    e.isArrayBufferView = ie;
    function te(_e) {
      return g(_e) === "Uint8Array";
    }
    e.isUint8Array = te;
    function se(_e) {
      return g(_e) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = se;
    function le(_e) {
      return g(_e) === "Uint16Array";
    }
    e.isUint16Array = le;
    function ce(_e) {
      return g(_e) === "Uint32Array";
    }
    e.isUint32Array = ce;
    function pe(_e) {
      return g(_e) === "Int8Array";
    }
    e.isInt8Array = pe;
    function me(_e) {
      return g(_e) === "Int16Array";
    }
    e.isInt16Array = me;
    function Me(_e) {
      return g(_e) === "Int32Array";
    }
    e.isInt32Array = Me;
    function Ee(_e) {
      return g(_e) === "Float32Array";
    }
    e.isFloat32Array = Ee;
    function Re(_e) {
      return g(_e) === "Float64Array";
    }
    e.isFloat64Array = Re;
    function Ne(_e) {
      return g(_e) === "BigInt64Array";
    }
    e.isBigInt64Array = Ne;
    function ne(_e) {
      return g(_e) === "BigUint64Array";
    }
    e.isBigUint64Array = ne;
    function Y(_e) {
      return P(_e) === "[object Map]";
    }
    Y.working = typeof Map < "u" && Y(/* @__PURE__ */ new Map());
    function M(_e) {
      return typeof Map > "u" ? !1 : Y.working ? Y(_e) : _e instanceof Map;
    }
    e.isMap = M;
    function $(_e) {
      return P(_e) === "[object Set]";
    }
    $.working = typeof Set < "u" && $(/* @__PURE__ */ new Set());
    function O(_e) {
      return typeof Set > "u" ? !1 : $.working ? $(_e) : _e instanceof Set;
    }
    e.isSet = O;
    function J(_e) {
      return P(_e) === "[object WeakMap]";
    }
    J.working = typeof WeakMap < "u" && J(/* @__PURE__ */ new WeakMap());
    function Z(_e) {
      return typeof WeakMap > "u" ? !1 : J.working ? J(_e) : _e instanceof WeakMap;
    }
    e.isWeakMap = Z;
    function K(_e) {
      return P(_e) === "[object WeakSet]";
    }
    K.working = typeof WeakSet < "u" && K(/* @__PURE__ */ new WeakSet());
    function z(_e) {
      return K(_e);
    }
    e.isWeakSet = z;
    function G(_e) {
      return P(_e) === "[object ArrayBuffer]";
    }
    G.working = typeof ArrayBuffer < "u" && G(new ArrayBuffer());
    function D(_e) {
      return typeof ArrayBuffer > "u" ? !1 : G.working ? G(_e) : _e instanceof ArrayBuffer;
    }
    e.isArrayBuffer = D;
    function F(_e) {
      return P(_e) === "[object DataView]";
    }
    F.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && F(new DataView(new ArrayBuffer(1), 0, 1));
    function ae(_e) {
      return typeof DataView > "u" ? !1 : F.working ? F(_e) : _e instanceof DataView;
    }
    e.isDataView = ae;
    var ge = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function xe(_e) {
      return P(_e) === "[object SharedArrayBuffer]";
    }
    function ye(_e) {
      return typeof ge > "u" ? !1 : (typeof xe.working > "u" && (xe.working = xe(new ge())), xe.working ? xe(_e) : _e instanceof ge);
    }
    e.isSharedArrayBuffer = ye;
    function oe(_e) {
      return P(_e) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = oe;
    function fe(_e) {
      return P(_e) === "[object Map Iterator]";
    }
    e.isMapIterator = fe;
    function $e(_e) {
      return P(_e) === "[object Set Iterator]";
    }
    e.isSetIterator = $e;
    function Be(_e) {
      return P(_e) === "[object Generator]";
    }
    e.isGeneratorObject = Be;
    function be(_e) {
      return P(_e) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = be;
    function ve(_e) {
      return Q(_e, I);
    }
    e.isNumberObject = ve;
    function qe(_e) {
      return Q(_e, B);
    }
    e.isStringObject = qe;
    function De(_e) {
      return Q(_e, H);
    }
    e.isBooleanObject = De;
    function Ye(_e) {
      return q && Q(_e, V);
    }
    e.isBigIntObject = Ye;
    function he(_e) {
      return A && Q(_e, X);
    }
    e.isSymbolObject = he;
    function ue(_e) {
      return ve(_e) || qe(_e) || De(_e) || Ye(_e) || he(_e);
    }
    e.isBoxedPrimitive = ue;
    function de(_e) {
      return typeof Uint8Array < "u" && (D(_e) || ye(_e));
    }
    e.isAnyArrayBuffer = de, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(_e) {
      Object.defineProperty(e, _e, {
        enumerable: !1,
        value: function() {
          throw new Error(_e + " is not supported in userland");
        }
      });
    });
  }(types$3)), types$3;
}
var isBufferBrowser$1, hasRequiredIsBufferBrowser$1;
function requireIsBufferBrowser$1() {
  return hasRequiredIsBufferBrowser$1 || (hasRequiredIsBufferBrowser$1 = 1, isBufferBrowser$1 = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  }), isBufferBrowser$1;
}
var hasRequiredUtil$1$1;
function requireUtil$1$1() {
  return hasRequiredUtil$1$1 || (hasRequiredUtil$1$1 = 1, function(e) {
    var o = Object.getOwnPropertyDescriptors || function(F) {
      for (var ae = Object.keys(F), ge = {}, xe = 0; xe < ae.length; xe++)
        ge[ae[xe]] = Object.getOwnPropertyDescriptor(F, ae[xe]);
      return ge;
    }, S = /%[sdj%]/g;
    e.format = function(F) {
      if (!pe(F)) {
        for (var ae = [], ge = 0; ge < arguments.length; ge++)
          ae.push(q(arguments[ge]));
        return ae.join(" ");
      }
      for (var ge = 1, xe = arguments, ye = xe.length, oe = String(F).replace(S, function(Be) {
        if (Be === "%%")
          return "%";
        if (ge >= ye)
          return Be;
        switch (Be) {
          case "%s":
            return String(xe[ge++]);
          case "%d":
            return Number(xe[ge++]);
          case "%j":
            try {
              return JSON.stringify(xe[ge++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Be;
        }
      }), fe = xe[ge]; ge < ye; fe = xe[++ge])
        se(fe) || !Re(fe) ? oe += " " + fe : oe += " " + q(fe);
      return oe;
    }, e.deprecate = function(F, ae) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return F;
      if (typeof process$1 > "u")
        return function() {
          return e.deprecate(F, ae).apply(this, arguments);
        };
      var ge = !1;
      function xe() {
        if (!ge) {
          if (process$1.throwDeprecation)
            throw new Error(ae);
          process$1.traceDeprecation ? console.trace(ae) : console.error(ae), ge = !0;
        }
        return F.apply(this, arguments);
      }
      return xe;
    };
    var g = {}, U = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var h = process$1.env.NODE_DEBUG;
      h = h.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), U = new RegExp("^" + h + "$", "i");
    }
    e.debuglog = function(F) {
      if (F = F.toUpperCase(), !g[F])
        if (U.test(F)) {
          var ae = process$1.pid;
          g[F] = function() {
            var ge = e.format.apply(e, arguments);
            console.error("%s %d: %s", F, ae, ge);
          };
        } else
          g[F] = function() {
          };
      return g[F];
    };
    function q(F, ae) {
      var ge = {
        seen: [],
        stylize: P
      };
      return arguments.length >= 3 && (ge.depth = arguments[2]), arguments.length >= 4 && (ge.colors = arguments[3]), te(ae) ? ge.showHidden = ae : ae && e._extend(ge, ae), Me(ge.showHidden) && (ge.showHidden = !1), Me(ge.depth) && (ge.depth = 2), Me(ge.colors) && (ge.colors = !1), Me(ge.customInspect) && (ge.customInspect = !0), ge.colors && (ge.stylize = A), B(ge, F, ge.depth);
    }
    e.inspect = q, q.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, q.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function A(F, ae) {
      var ge = q.styles[ae];
      return ge ? "\x1B[" + q.colors[ge][0] + "m" + F + "\x1B[" + q.colors[ge][1] + "m" : F;
    }
    function P(F, ae) {
      return F;
    }
    function I(F) {
      var ae = {};
      return F.forEach(function(ge, xe) {
        ae[ge] = !0;
      }), ae;
    }
    function B(F, ae, ge) {
      if (F.customInspect && ae && Y(ae.inspect) && // Filter out the util module, it's inspect function is special
      ae.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(ae.constructor && ae.constructor.prototype === ae)) {
        var xe = ae.inspect(ge, F);
        return pe(xe) || (xe = B(F, xe, ge)), xe;
      }
      var ye = H(F, ae);
      if (ye)
        return ye;
      var oe = Object.keys(ae), fe = I(oe);
      if (F.showHidden && (oe = Object.getOwnPropertyNames(ae)), ne(ae) && (oe.indexOf("message") >= 0 || oe.indexOf("description") >= 0))
        return V(ae);
      if (oe.length === 0) {
        if (Y(ae)) {
          var $e = ae.name ? ": " + ae.name : "";
          return F.stylize("[Function" + $e + "]", "special");
        }
        if (Ee(ae))
          return F.stylize(RegExp.prototype.toString.call(ae), "regexp");
        if (Ne(ae))
          return F.stylize(Date.prototype.toString.call(ae), "date");
        if (ne(ae))
          return V(ae);
      }
      var Be = "", be = !1, ve = ["{", "}"];
      if (ie(ae) && (be = !0, ve = ["[", "]"]), Y(ae)) {
        var qe = ae.name ? ": " + ae.name : "";
        Be = " [Function" + qe + "]";
      }
      if (Ee(ae) && (Be = " " + RegExp.prototype.toString.call(ae)), Ne(ae) && (Be = " " + Date.prototype.toUTCString.call(ae)), ne(ae) && (Be = " " + V(ae)), oe.length === 0 && (!be || ae.length == 0))
        return ve[0] + Be + ve[1];
      if (ge < 0)
        return Ee(ae) ? F.stylize(RegExp.prototype.toString.call(ae), "regexp") : F.stylize("[Object]", "special");
      F.seen.push(ae);
      var De;
      return be ? De = X(F, ae, ge, fe, oe) : De = oe.map(function(Ye) {
        return Q(F, ae, ge, fe, Ye, be);
      }), F.seen.pop(), ee(De, Be, ve);
    }
    function H(F, ae) {
      if (Me(ae))
        return F.stylize("undefined", "undefined");
      if (pe(ae)) {
        var ge = "'" + JSON.stringify(ae).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return F.stylize(ge, "string");
      }
      if (ce(ae))
        return F.stylize("" + ae, "number");
      if (te(ae))
        return F.stylize("" + ae, "boolean");
      if (se(ae))
        return F.stylize("null", "null");
    }
    function V(F) {
      return "[" + Error.prototype.toString.call(F) + "]";
    }
    function X(F, ae, ge, xe, ye) {
      for (var oe = [], fe = 0, $e = ae.length; fe < $e; ++fe)
        K(ae, String(fe)) ? oe.push(Q(
          F,
          ae,
          ge,
          xe,
          String(fe),
          !0
        )) : oe.push("");
      return ye.forEach(function(Be) {
        Be.match(/^\d+$/) || oe.push(Q(
          F,
          ae,
          ge,
          xe,
          Be,
          !0
        ));
      }), oe;
    }
    function Q(F, ae, ge, xe, ye, oe) {
      var fe, $e, Be;
      if (Be = Object.getOwnPropertyDescriptor(ae, ye) || { value: ae[ye] }, Be.get ? Be.set ? $e = F.stylize("[Getter/Setter]", "special") : $e = F.stylize("[Getter]", "special") : Be.set && ($e = F.stylize("[Setter]", "special")), K(xe, ye) || (fe = "[" + ye + "]"), $e || (F.seen.indexOf(Be.value) < 0 ? (se(ge) ? $e = B(F, Be.value, null) : $e = B(F, Be.value, ge - 1), $e.indexOf(`
`) > -1 && (oe ? $e = $e.split(`
`).map(function(be) {
        return "  " + be;
      }).join(`
`).slice(2) : $e = `
` + $e.split(`
`).map(function(be) {
        return "   " + be;
      }).join(`
`))) : $e = F.stylize("[Circular]", "special")), Me(fe)) {
        if (oe && ye.match(/^\d+$/))
          return $e;
        fe = JSON.stringify("" + ye), fe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (fe = fe.slice(1, -1), fe = F.stylize(fe, "name")) : (fe = fe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), fe = F.stylize(fe, "string"));
      }
      return fe + ": " + $e;
    }
    function ee(F, ae, ge) {
      var xe = F.reduce(function(ye, oe) {
        return oe.indexOf(`
`) >= 0, ye + oe.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return xe > 60 ? ge[0] + (ae === "" ? "" : ae + `
 `) + " " + F.join(`,
  `) + " " + ge[1] : ge[0] + ae + " " + F.join(", ") + " " + ge[1];
    }
    e.types = requireTypes$1();
    function ie(F) {
      return Array.isArray(F);
    }
    e.isArray = ie;
    function te(F) {
      return typeof F == "boolean";
    }
    e.isBoolean = te;
    function se(F) {
      return F === null;
    }
    e.isNull = se;
    function le(F) {
      return F == null;
    }
    e.isNullOrUndefined = le;
    function ce(F) {
      return typeof F == "number";
    }
    e.isNumber = ce;
    function pe(F) {
      return typeof F == "string";
    }
    e.isString = pe;
    function me(F) {
      return typeof F == "symbol";
    }
    e.isSymbol = me;
    function Me(F) {
      return F === void 0;
    }
    e.isUndefined = Me;
    function Ee(F) {
      return Re(F) && $(F) === "[object RegExp]";
    }
    e.isRegExp = Ee, e.types.isRegExp = Ee;
    function Re(F) {
      return typeof F == "object" && F !== null;
    }
    e.isObject = Re;
    function Ne(F) {
      return Re(F) && $(F) === "[object Date]";
    }
    e.isDate = Ne, e.types.isDate = Ne;
    function ne(F) {
      return Re(F) && ($(F) === "[object Error]" || F instanceof Error);
    }
    e.isError = ne, e.types.isNativeError = ne;
    function Y(F) {
      return typeof F == "function";
    }
    e.isFunction = Y;
    function M(F) {
      return F === null || typeof F == "boolean" || typeof F == "number" || typeof F == "string" || typeof F == "symbol" || // ES6 symbol
      typeof F > "u";
    }
    e.isPrimitive = M, e.isBuffer = requireIsBufferBrowser$1();
    function $(F) {
      return Object.prototype.toString.call(F);
    }
    function O(F) {
      return F < 10 ? "0" + F.toString(10) : F.toString(10);
    }
    var J = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Z() {
      var F = /* @__PURE__ */ new Date(), ae = [
        O(F.getHours()),
        O(F.getMinutes()),
        O(F.getSeconds())
      ].join(":");
      return [F.getDate(), J[F.getMonth()], ae].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", Z(), e.format.apply(e, arguments));
    }, e.inherits = requireInherits_browser$1(), e._extend = function(F, ae) {
      if (!ae || !Re(ae))
        return F;
      for (var ge = Object.keys(ae), xe = ge.length; xe--; )
        F[ge[xe]] = ae[ge[xe]];
      return F;
    };
    function K(F, ae) {
      return Object.prototype.hasOwnProperty.call(F, ae);
    }
    var z = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(F) {
      if (typeof F != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (z && F[z]) {
        var ae = F[z];
        if (typeof ae != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(ae, z, {
          value: ae,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ae;
      }
      function ae() {
        for (var ge, xe, ye = new Promise(function($e, Be) {
          ge = $e, xe = Be;
        }), oe = [], fe = 0; fe < arguments.length; fe++)
          oe.push(arguments[fe]);
        oe.push(function($e, Be) {
          $e ? xe($e) : ge(Be);
        });
        try {
          F.apply(this, oe);
        } catch ($e) {
          xe($e);
        }
        return ye;
      }
      return Object.setPrototypeOf(ae, Object.getPrototypeOf(F)), z && Object.defineProperty(ae, z, {
        value: ae,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        ae,
        o(F)
      );
    }, e.promisify.custom = z;
    function G(F, ae) {
      if (!F) {
        var ge = new Error("Promise was rejected with a falsy value");
        ge.reason = F, F = ge;
      }
      return ae(F);
    }
    function D(F) {
      if (typeof F != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function ae() {
        for (var ge = [], xe = 0; xe < arguments.length; xe++)
          ge.push(arguments[xe]);
        var ye = ge.pop();
        if (typeof ye != "function")
          throw new TypeError("The last argument must be of type Function");
        var oe = this, fe = function() {
          return ye.apply(oe, arguments);
        };
        F.apply(this, ge).then(
          function($e) {
            process$1.nextTick(fe.bind(null, null, $e));
          },
          function($e) {
            process$1.nextTick(G.bind(null, $e, fe));
          }
        );
      }
      return Object.setPrototypeOf(ae, Object.getPrototypeOf(F)), Object.defineProperties(
        ae,
        o(F)
      ), ae;
    }
    e.callbackify = D;
  }(util$1$1)), util$1$1;
}
var buffer_list$1, hasRequiredBuffer_list$1;
function requireBuffer_list$1() {
  if (hasRequiredBuffer_list$1)
    return buffer_list$1;
  hasRequiredBuffer_list$1 = 1;
  function e(Q, ee) {
    var ie = Object.keys(Q);
    if (Object.getOwnPropertySymbols) {
      var te = Object.getOwnPropertySymbols(Q);
      ee && (te = te.filter(function(se) {
        return Object.getOwnPropertyDescriptor(Q, se).enumerable;
      })), ie.push.apply(ie, te);
    }
    return ie;
  }
  function o(Q) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var ie = arguments[ee] != null ? arguments[ee] : {};
      ee % 2 ? e(Object(ie), !0).forEach(function(te) {
        S(Q, te, ie[te]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Q, Object.getOwnPropertyDescriptors(ie)) : e(Object(ie)).forEach(function(te) {
        Object.defineProperty(Q, te, Object.getOwnPropertyDescriptor(ie, te));
      });
    }
    return Q;
  }
  function S(Q, ee, ie) {
    return ee = q(ee), ee in Q ? Object.defineProperty(Q, ee, { value: ie, enumerable: !0, configurable: !0, writable: !0 }) : Q[ee] = ie, Q;
  }
  function g(Q, ee) {
    if (!(Q instanceof ee))
      throw new TypeError("Cannot call a class as a function");
  }
  function U(Q, ee) {
    for (var ie = 0; ie < ee.length; ie++) {
      var te = ee[ie];
      te.enumerable = te.enumerable || !1, te.configurable = !0, "value" in te && (te.writable = !0), Object.defineProperty(Q, q(te.key), te);
    }
  }
  function h(Q, ee, ie) {
    return ee && U(Q.prototype, ee), ie && U(Q, ie), Object.defineProperty(Q, "prototype", { writable: !1 }), Q;
  }
  function q(Q) {
    var ee = A(Q, "string");
    return typeof ee == "symbol" ? ee : String(ee);
  }
  function A(Q, ee) {
    if (typeof Q != "object" || Q === null)
      return Q;
    var ie = Q[Symbol.toPrimitive];
    if (ie !== void 0) {
      var te = ie.call(Q, ee || "default");
      if (typeof te != "object")
        return te;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ee === "string" ? String : Number)(Q);
  }
  var P = requireBuffer$1(), I = P.Buffer, B = requireUtil$1$1(), H = B.inspect, V = H && H.custom || "inspect";
  function X(Q, ee, ie) {
    I.prototype.copy.call(Q, ee, ie);
  }
  return buffer_list$1 = /* @__PURE__ */ function() {
    function Q() {
      g(this, Q), this.head = null, this.tail = null, this.length = 0;
    }
    return h(Q, [{
      key: "push",
      value: function(ee) {
        var ie = {
          data: ee,
          next: null
        };
        this.length > 0 ? this.tail.next = ie : this.head = ie, this.tail = ie, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ee) {
        var ie = {
          data: ee,
          next: this.head
        };
        this.length === 0 && (this.tail = ie), this.head = ie, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ee = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ee;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ee) {
        if (this.length === 0)
          return "";
        for (var ie = this.head, te = "" + ie.data; ie = ie.next; )
          te += ee + ie.data;
        return te;
      }
    }, {
      key: "concat",
      value: function(ee) {
        if (this.length === 0)
          return I.alloc(0);
        for (var ie = I.allocUnsafe(ee >>> 0), te = this.head, se = 0; te; )
          X(te.data, ie, se), se += te.data.length, te = te.next;
        return ie;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ee, ie) {
        var te;
        return ee < this.head.data.length ? (te = this.head.data.slice(0, ee), this.head.data = this.head.data.slice(ee)) : ee === this.head.data.length ? te = this.shift() : te = ie ? this._getString(ee) : this._getBuffer(ee), te;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ee) {
        var ie = this.head, te = 1, se = ie.data;
        for (ee -= se.length; ie = ie.next; ) {
          var le = ie.data, ce = ee > le.length ? le.length : ee;
          if (ce === le.length ? se += le : se += le.slice(0, ee), ee -= ce, ee === 0) {
            ce === le.length ? (++te, ie.next ? this.head = ie.next : this.head = this.tail = null) : (this.head = ie, ie.data = le.slice(ce));
            break;
          }
          ++te;
        }
        return this.length -= te, se;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ee) {
        var ie = I.allocUnsafe(ee), te = this.head, se = 1;
        for (te.data.copy(ie), ee -= te.data.length; te = te.next; ) {
          var le = te.data, ce = ee > le.length ? le.length : ee;
          if (le.copy(ie, ie.length - ee, 0, ce), ee -= ce, ee === 0) {
            ce === le.length ? (++se, te.next ? this.head = te.next : this.head = this.tail = null) : (this.head = te, te.data = le.slice(ce));
            break;
          }
          ++se;
        }
        return this.length -= se, ie;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: V,
      value: function(ee, ie) {
        return H(this, o(o({}, ie), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Q;
  }(), buffer_list$1;
}
var destroy_1$1$1, hasRequiredDestroy$1$1;
function requireDestroy$1$1() {
  if (hasRequiredDestroy$1$1)
    return destroy_1$1$1;
  hasRequiredDestroy$1$1 = 1;
  function e(q, A) {
    var P = this, I = this._readableState && this._readableState.destroyed, B = this._writableState && this._writableState.destroyed;
    return I || B ? (A ? A(q) : q && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(U, this, q)) : process$1.nextTick(U, this, q)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(q || null, function(H) {
      !A && H ? P._writableState ? P._writableState.errorEmitted ? process$1.nextTick(S, P) : (P._writableState.errorEmitted = !0, process$1.nextTick(o, P, H)) : process$1.nextTick(o, P, H) : A ? (process$1.nextTick(S, P), A(H)) : process$1.nextTick(S, P);
    }), this);
  }
  function o(q, A) {
    U(q, A), S(q);
  }
  function S(q) {
    q._writableState && !q._writableState.emitClose || q._readableState && !q._readableState.emitClose || q.emit("close");
  }
  function g() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function U(q, A) {
    q.emit("error", A);
  }
  function h(q, A) {
    var P = q._readableState, I = q._writableState;
    P && P.autoDestroy || I && I.autoDestroy ? q.destroy(A) : q.emit("error", A);
  }
  return destroy_1$1$1 = {
    destroy: e,
    undestroy: g,
    errorOrDestroy: h
  }, destroy_1$1$1;
}
var errorsBrowser$1 = {}, hasRequiredErrorsBrowser$1;
function requireErrorsBrowser$1() {
  if (hasRequiredErrorsBrowser$1)
    return errorsBrowser$1;
  hasRequiredErrorsBrowser$1 = 1;
  function e(A, P) {
    A.prototype = Object.create(P.prototype), A.prototype.constructor = A, A.__proto__ = P;
  }
  var o = {};
  function S(A, P, I) {
    I || (I = Error);
    function B(V, X, Q) {
      return typeof P == "string" ? P : P(V, X, Q);
    }
    var H = /* @__PURE__ */ function(V) {
      e(X, V);
      function X(Q, ee, ie) {
        return V.call(this, B(Q, ee, ie)) || this;
      }
      return X;
    }(I);
    H.prototype.name = I.name, H.prototype.code = A, o[A] = H;
  }
  function g(A, P) {
    if (Array.isArray(A)) {
      var I = A.length;
      return A = A.map(function(B) {
        return String(B);
      }), I > 2 ? "one of ".concat(P, " ").concat(A.slice(0, I - 1).join(", "), ", or ") + A[I - 1] : I === 2 ? "one of ".concat(P, " ").concat(A[0], " or ").concat(A[1]) : "of ".concat(P, " ").concat(A[0]);
    } else
      return "of ".concat(P, " ").concat(String(A));
  }
  function U(A, P, I) {
    return A.substr(!I || I < 0 ? 0 : +I, P.length) === P;
  }
  function h(A, P, I) {
    return (I === void 0 || I > A.length) && (I = A.length), A.substring(I - P.length, I) === P;
  }
  function q(A, P, I) {
    return typeof I != "number" && (I = 0), I + P.length > A.length ? !1 : A.indexOf(P, I) !== -1;
  }
  return S("ERR_INVALID_OPT_VALUE", function(A, P) {
    return 'The value "' + P + '" is invalid for option "' + A + '"';
  }, TypeError), S("ERR_INVALID_ARG_TYPE", function(A, P, I) {
    var B;
    typeof P == "string" && U(P, "not ") ? (B = "must not be", P = P.replace(/^not /, "")) : B = "must be";
    var H;
    if (h(A, " argument"))
      H = "The ".concat(A, " ").concat(B, " ").concat(g(P, "type"));
    else {
      var V = q(A, ".") ? "property" : "argument";
      H = 'The "'.concat(A, '" ').concat(V, " ").concat(B, " ").concat(g(P, "type"));
    }
    return H += ". Received type ".concat(typeof I), H;
  }, TypeError), S("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), S("ERR_METHOD_NOT_IMPLEMENTED", function(A) {
    return "The " + A + " method is not implemented";
  }), S("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), S("ERR_STREAM_DESTROYED", function(A) {
    return "Cannot call " + A + " after a stream was destroyed";
  }), S("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), S("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), S("ERR_STREAM_WRITE_AFTER_END", "write after end"), S("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), S("ERR_UNKNOWN_ENCODING", function(A) {
    return "Unknown encoding: " + A;
  }, TypeError), S("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser$1.codes = o, errorsBrowser$1;
}
var state$1, hasRequiredState$1;
function requireState$1() {
  if (hasRequiredState$1)
    return state$1;
  hasRequiredState$1 = 1;
  var e = requireErrorsBrowser$1().codes.ERR_INVALID_OPT_VALUE;
  function o(g, U, h) {
    return g.highWaterMark != null ? g.highWaterMark : U ? g[h] : null;
  }
  function S(g, U, h, q) {
    var A = o(U, q, h);
    if (A != null) {
      if (!(isFinite(A) && Math.floor(A) === A) || A < 0) {
        var P = q ? h : "highWaterMark";
        throw new e(P, A);
      }
      return Math.floor(A);
    }
    return g.objectMode ? 16 : 16 * 1024;
  }
  return state$1 = {
    getHighWaterMark: S
  }, state$1;
}
var browser$a$1, hasRequiredBrowser$a$1;
function requireBrowser$a$1() {
  if (hasRequiredBrowser$a$1)
    return browser$a$1;
  hasRequiredBrowser$a$1 = 1, browser$a$1 = e;
  function e(S, g) {
    if (o("noDeprecation"))
      return S;
    var U = !1;
    function h() {
      if (!U) {
        if (o("throwDeprecation"))
          throw new Error(g);
        o("traceDeprecation") ? console.trace(g) : console.warn(g), U = !0;
      }
      return S.apply(this, arguments);
    }
    return h;
  }
  function o(S) {
    try {
      if (!commonjsGlobal.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var g = commonjsGlobal.localStorage[S];
    return g == null ? !1 : String(g).toLowerCase() === "true";
  }
  return browser$a$1;
}
var _stream_writable$1$1, hasRequired_stream_writable$1$1;
function require_stream_writable$1$1() {
  if (hasRequired_stream_writable$1$1)
    return _stream_writable$1$1;
  hasRequired_stream_writable$1$1 = 1, _stream_writable$1$1 = Ee;
  function e(ye) {
    var oe = this;
    this.next = null, this.entry = null, this.finish = function() {
      xe(oe, ye);
    };
  }
  var o;
  Ee.WritableState = me;
  var S = {
    deprecate: requireBrowser$a$1()
  }, g = requireStreamBrowser$1$1(), U = requireBuffer$1().Buffer, h = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function q(ye) {
    return U.from(ye);
  }
  function A(ye) {
    return U.isBuffer(ye) || ye instanceof h;
  }
  var P = requireDestroy$1$1(), I = requireState$1(), B = I.getHighWaterMark, H = requireErrorsBrowser$1().codes, V = H.ERR_INVALID_ARG_TYPE, X = H.ERR_METHOD_NOT_IMPLEMENTED, Q = H.ERR_MULTIPLE_CALLBACK, ee = H.ERR_STREAM_CANNOT_PIPE, ie = H.ERR_STREAM_DESTROYED, te = H.ERR_STREAM_NULL_VALUES, se = H.ERR_STREAM_WRITE_AFTER_END, le = H.ERR_UNKNOWN_ENCODING, ce = P.errorOrDestroy;
  requireInherits_browser$1()(Ee, g);
  function pe() {
  }
  function me(ye, oe, fe) {
    o = o || require_stream_duplex$1$1(), ye = ye || {}, typeof fe != "boolean" && (fe = oe instanceof o), this.objectMode = !!ye.objectMode, fe && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = B(this, ye, "writableHighWaterMark", fe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var $e = ye.decodeStrings === !1;
    this.decodeStrings = !$e, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Be) {
      J(oe, Be);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  me.prototype.getBuffer = function() {
    for (var ye = this.bufferedRequest, oe = []; ye; )
      oe.push(ye), ye = ye.next;
    return oe;
  }, function() {
    try {
      Object.defineProperty(me.prototype, "buffer", {
        get: S.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Me;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Me = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ee, Symbol.hasInstance, {
    value: function(ye) {
      return Me.call(this, ye) ? !0 : this !== Ee ? !1 : ye && ye._writableState instanceof me;
    }
  })) : Me = function(ye) {
    return ye instanceof this;
  };
  function Ee(ye) {
    o = o || require_stream_duplex$1$1();
    var oe = this instanceof o;
    if (!oe && !Me.call(Ee, this))
      return new Ee(ye);
    this._writableState = new me(ye, this, oe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), g.call(this);
  }
  Ee.prototype.pipe = function() {
    ce(this, new ee());
  };
  function Re(ye, oe) {
    var fe = new se();
    ce(ye, fe), process$1.nextTick(oe, fe);
  }
  function Ne(ye, oe, fe, $e) {
    var Be;
    return fe === null ? Be = new te() : typeof fe != "string" && !oe.objectMode && (Be = new V("chunk", ["string", "Buffer"], fe)), Be ? (ce(ye, Be), process$1.nextTick($e, Be), !1) : !0;
  }
  Ee.prototype.write = function(ye, oe, fe) {
    var $e = this._writableState, Be = !1, be = !$e.objectMode && A(ye);
    return be && !U.isBuffer(ye) && (ye = q(ye)), typeof oe == "function" && (fe = oe, oe = null), be ? oe = "buffer" : oe || (oe = $e.defaultEncoding), typeof fe != "function" && (fe = pe), $e.ending ? Re(this, fe) : (be || Ne(this, $e, ye, fe)) && ($e.pendingcb++, Be = Y(this, $e, be, ye, oe, fe)), Be;
  }, Ee.prototype.cork = function() {
    this._writableState.corked++;
  }, Ee.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && z(this, ye));
  }, Ee.prototype.setDefaultEncoding = function(ye) {
    if (typeof ye == "string" && (ye = ye.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ye + "").toLowerCase()) > -1))
      throw new le(ye);
    return this._writableState.defaultEncoding = ye, this;
  }, Object.defineProperty(Ee.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function ne(ye, oe, fe) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof oe == "string" && (oe = U.from(oe, fe)), oe;
  }
  Object.defineProperty(Ee.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Y(ye, oe, fe, $e, Be, be) {
    if (!fe) {
      var ve = ne(oe, $e, Be);
      $e !== ve && (fe = !0, Be = "buffer", $e = ve);
    }
    var qe = oe.objectMode ? 1 : $e.length;
    oe.length += qe;
    var De = oe.length < oe.highWaterMark;
    if (De || (oe.needDrain = !0), oe.writing || oe.corked) {
      var Ye = oe.lastBufferedRequest;
      oe.lastBufferedRequest = {
        chunk: $e,
        encoding: Be,
        isBuf: fe,
        callback: be,
        next: null
      }, Ye ? Ye.next = oe.lastBufferedRequest : oe.bufferedRequest = oe.lastBufferedRequest, oe.bufferedRequestCount += 1;
    } else
      M(ye, oe, !1, qe, $e, Be, be);
    return De;
  }
  function M(ye, oe, fe, $e, Be, be, ve) {
    oe.writelen = $e, oe.writecb = ve, oe.writing = !0, oe.sync = !0, oe.destroyed ? oe.onwrite(new ie("write")) : fe ? ye._writev(Be, oe.onwrite) : ye._write(Be, be, oe.onwrite), oe.sync = !1;
  }
  function $(ye, oe, fe, $e, Be) {
    --oe.pendingcb, fe ? (process$1.nextTick(Be, $e), process$1.nextTick(ae, ye, oe), ye._writableState.errorEmitted = !0, ce(ye, $e)) : (Be($e), ye._writableState.errorEmitted = !0, ce(ye, $e), ae(ye, oe));
  }
  function O(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function J(ye, oe) {
    var fe = ye._writableState, $e = fe.sync, Be = fe.writecb;
    if (typeof Be != "function")
      throw new Q();
    if (O(fe), oe)
      $(ye, fe, $e, oe, Be);
    else {
      var be = G(fe) || ye.destroyed;
      !be && !fe.corked && !fe.bufferProcessing && fe.bufferedRequest && z(ye, fe), $e ? process$1.nextTick(Z, ye, fe, be, Be) : Z(ye, fe, be, Be);
    }
  }
  function Z(ye, oe, fe, $e) {
    fe || K(ye, oe), oe.pendingcb--, $e(), ae(ye, oe);
  }
  function K(ye, oe) {
    oe.length === 0 && oe.needDrain && (oe.needDrain = !1, ye.emit("drain"));
  }
  function z(ye, oe) {
    oe.bufferProcessing = !0;
    var fe = oe.bufferedRequest;
    if (ye._writev && fe && fe.next) {
      var $e = oe.bufferedRequestCount, Be = new Array($e), be = oe.corkedRequestsFree;
      be.entry = fe;
      for (var ve = 0, qe = !0; fe; )
        Be[ve] = fe, fe.isBuf || (qe = !1), fe = fe.next, ve += 1;
      Be.allBuffers = qe, M(ye, oe, !0, oe.length, Be, "", be.finish), oe.pendingcb++, oe.lastBufferedRequest = null, be.next ? (oe.corkedRequestsFree = be.next, be.next = null) : oe.corkedRequestsFree = new e(oe), oe.bufferedRequestCount = 0;
    } else {
      for (; fe; ) {
        var De = fe.chunk, Ye = fe.encoding, he = fe.callback, ue = oe.objectMode ? 1 : De.length;
        if (M(ye, oe, !1, ue, De, Ye, he), fe = fe.next, oe.bufferedRequestCount--, oe.writing)
          break;
      }
      fe === null && (oe.lastBufferedRequest = null);
    }
    oe.bufferedRequest = fe, oe.bufferProcessing = !1;
  }
  Ee.prototype._write = function(ye, oe, fe) {
    fe(new X("_write()"));
  }, Ee.prototype._writev = null, Ee.prototype.end = function(ye, oe, fe) {
    var $e = this._writableState;
    return typeof ye == "function" ? (fe = ye, ye = null, oe = null) : typeof oe == "function" && (fe = oe, oe = null), ye != null && this.write(ye, oe), $e.corked && ($e.corked = 1, this.uncork()), $e.ending || ge(this, $e, fe), this;
  }, Object.defineProperty(Ee.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function G(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function D(ye, oe) {
    ye._final(function(fe) {
      oe.pendingcb--, fe && ce(ye, fe), oe.prefinished = !0, ye.emit("prefinish"), ae(ye, oe);
    });
  }
  function F(ye, oe) {
    !oe.prefinished && !oe.finalCalled && (typeof ye._final == "function" && !oe.destroyed ? (oe.pendingcb++, oe.finalCalled = !0, process$1.nextTick(D, ye, oe)) : (oe.prefinished = !0, ye.emit("prefinish")));
  }
  function ae(ye, oe) {
    var fe = G(oe);
    if (fe && (F(ye, oe), oe.pendingcb === 0 && (oe.finished = !0, ye.emit("finish"), oe.autoDestroy))) {
      var $e = ye._readableState;
      (!$e || $e.autoDestroy && $e.endEmitted) && ye.destroy();
    }
    return fe;
  }
  function ge(ye, oe, fe) {
    oe.ending = !0, ae(ye, oe), fe && (oe.finished ? process$1.nextTick(fe) : ye.once("finish", fe)), oe.ended = !0, ye.writable = !1;
  }
  function xe(ye, oe, fe) {
    var $e = ye.entry;
    for (ye.entry = null; $e; ) {
      var Be = $e.callback;
      oe.pendingcb--, Be(fe), $e = $e.next;
    }
    oe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(Ee.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ye) {
      this._writableState && (this._writableState.destroyed = ye);
    }
  }), Ee.prototype.destroy = P.destroy, Ee.prototype._undestroy = P.undestroy, Ee.prototype._destroy = function(ye, oe) {
    oe(ye);
  }, _stream_writable$1$1;
}
var _stream_duplex$1$1, hasRequired_stream_duplex$1$1;
function require_stream_duplex$1$1() {
  if (hasRequired_stream_duplex$1$1)
    return _stream_duplex$1$1;
  hasRequired_stream_duplex$1$1 = 1;
  var e = Object.keys || function(I) {
    var B = [];
    for (var H in I)
      B.push(H);
    return B;
  };
  _stream_duplex$1$1 = q;
  var o = require_stream_readable$1$1(), S = require_stream_writable$1$1();
  requireInherits_browser$1()(q, o);
  for (var g = e(S.prototype), U = 0; U < g.length; U++) {
    var h = g[U];
    q.prototype[h] || (q.prototype[h] = S.prototype[h]);
  }
  function q(I) {
    if (!(this instanceof q))
      return new q(I);
    o.call(this, I), S.call(this, I), this.allowHalfOpen = !0, I && (I.readable === !1 && (this.readable = !1), I.writable === !1 && (this.writable = !1), I.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", A)));
  }
  Object.defineProperty(q.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(q.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function A() {
    this._writableState.ended || process$1.nextTick(P, this);
  }
  function P(I) {
    I.end();
  }
  return Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(I) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = I, this._writableState.destroyed = I);
    }
  }), _stream_duplex$1$1;
}
var string_decoder$1 = {}, hasRequiredString_decoder$1;
function requireString_decoder$1() {
  if (hasRequiredString_decoder$1)
    return string_decoder$1;
  hasRequiredString_decoder$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = e.isEncoding || function(te) {
    switch (te = "" + te, te && te.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function S(te) {
    if (!te)
      return "utf8";
    for (var se; ; )
      switch (te) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return te;
        default:
          if (se)
            return;
          te = ("" + te).toLowerCase(), se = !0;
      }
  }
  function g(te) {
    var se = S(te);
    if (typeof se != "string" && (e.isEncoding === o || !o(te)))
      throw new Error("Unknown encoding: " + te);
    return se || te;
  }
  string_decoder$1.StringDecoder = U;
  function U(te) {
    this.encoding = g(te);
    var se;
    switch (this.encoding) {
      case "utf16le":
        this.text = H, this.end = V, se = 4;
        break;
      case "utf8":
        this.fillLast = P, se = 4;
        break;
      case "base64":
        this.text = X, this.end = Q, se = 3;
        break;
      default:
        this.write = ee, this.end = ie;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(se);
  }
  U.prototype.write = function(te) {
    if (te.length === 0)
      return "";
    var se, le;
    if (this.lastNeed) {
      if (se = this.fillLast(te), se === void 0)
        return "";
      le = this.lastNeed, this.lastNeed = 0;
    } else
      le = 0;
    return le < te.length ? se ? se + this.text(te, le) : this.text(te, le) : se || "";
  }, U.prototype.end = B, U.prototype.text = I, U.prototype.fillLast = function(te) {
    if (this.lastNeed <= te.length)
      return te.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    te.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, te.length), this.lastNeed -= te.length;
  };
  function h(te) {
    return te <= 127 ? 0 : te >> 5 === 6 ? 2 : te >> 4 === 14 ? 3 : te >> 3 === 30 ? 4 : te >> 6 === 2 ? -1 : -2;
  }
  function q(te, se, le) {
    var ce = se.length - 1;
    if (ce < le)
      return 0;
    var pe = h(se[ce]);
    return pe >= 0 ? (pe > 0 && (te.lastNeed = pe - 1), pe) : --ce < le || pe === -2 ? 0 : (pe = h(se[ce]), pe >= 0 ? (pe > 0 && (te.lastNeed = pe - 2), pe) : --ce < le || pe === -2 ? 0 : (pe = h(se[ce]), pe >= 0 ? (pe > 0 && (pe === 2 ? pe = 0 : te.lastNeed = pe - 3), pe) : 0));
  }
  function A(te, se, le) {
    if ((se[0] & 192) !== 128)
      return te.lastNeed = 0, "";
    if (te.lastNeed > 1 && se.length > 1) {
      if ((se[1] & 192) !== 128)
        return te.lastNeed = 1, "";
      if (te.lastNeed > 2 && se.length > 2 && (se[2] & 192) !== 128)
        return te.lastNeed = 2, "";
    }
  }
  function P(te) {
    var se = this.lastTotal - this.lastNeed, le = A(this, te);
    if (le !== void 0)
      return le;
    if (this.lastNeed <= te.length)
      return te.copy(this.lastChar, se, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    te.copy(this.lastChar, se, 0, te.length), this.lastNeed -= te.length;
  }
  function I(te, se) {
    var le = q(this, te, se);
    if (!this.lastNeed)
      return te.toString("utf8", se);
    this.lastTotal = le;
    var ce = te.length - (le - this.lastNeed);
    return te.copy(this.lastChar, 0, ce), te.toString("utf8", se, ce);
  }
  function B(te) {
    var se = te && te.length ? this.write(te) : "";
    return this.lastNeed ? se + "" : se;
  }
  function H(te, se) {
    if ((te.length - se) % 2 === 0) {
      var le = te.toString("utf16le", se);
      if (le) {
        var ce = le.charCodeAt(le.length - 1);
        if (ce >= 55296 && ce <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = te[te.length - 2], this.lastChar[1] = te[te.length - 1], le.slice(0, -1);
      }
      return le;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = te[te.length - 1], te.toString("utf16le", se, te.length - 1);
  }
  function V(te) {
    var se = te && te.length ? this.write(te) : "";
    if (this.lastNeed) {
      var le = this.lastTotal - this.lastNeed;
      return se + this.lastChar.toString("utf16le", 0, le);
    }
    return se;
  }
  function X(te, se) {
    var le = (te.length - se) % 3;
    return le === 0 ? te.toString("base64", se) : (this.lastNeed = 3 - le, this.lastTotal = 3, le === 1 ? this.lastChar[0] = te[te.length - 1] : (this.lastChar[0] = te[te.length - 2], this.lastChar[1] = te[te.length - 1]), te.toString("base64", se, te.length - le));
  }
  function Q(te) {
    var se = te && te.length ? this.write(te) : "";
    return this.lastNeed ? se + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : se;
  }
  function ee(te) {
    return te.toString(this.encoding);
  }
  function ie(te) {
    return te && te.length ? this.write(te) : "";
  }
  return string_decoder$1;
}
var endOfStream$1, hasRequiredEndOfStream$1;
function requireEndOfStream$1() {
  if (hasRequiredEndOfStream$1)
    return endOfStream$1;
  hasRequiredEndOfStream$1 = 1;
  var e = requireErrorsBrowser$1().codes.ERR_STREAM_PREMATURE_CLOSE;
  function o(h) {
    var q = !1;
    return function() {
      if (!q) {
        q = !0;
        for (var A = arguments.length, P = new Array(A), I = 0; I < A; I++)
          P[I] = arguments[I];
        h.apply(this, P);
      }
    };
  }
  function S() {
  }
  function g(h) {
    return h.setHeader && typeof h.abort == "function";
  }
  function U(h, q, A) {
    if (typeof q == "function")
      return U(h, null, q);
    q || (q = {}), A = o(A || S);
    var P = q.readable || q.readable !== !1 && h.readable, I = q.writable || q.writable !== !1 && h.writable, B = function() {
      h.writable || V();
    }, H = h._writableState && h._writableState.finished, V = function() {
      I = !1, H = !0, P || A.call(h);
    }, X = h._readableState && h._readableState.endEmitted, Q = function() {
      P = !1, X = !0, I || A.call(h);
    }, ee = function(se) {
      A.call(h, se);
    }, ie = function() {
      var se;
      if (P && !X)
        return (!h._readableState || !h._readableState.ended) && (se = new e()), A.call(h, se);
      if (I && !H)
        return (!h._writableState || !h._writableState.ended) && (se = new e()), A.call(h, se);
    }, te = function() {
      h.req.on("finish", V);
    };
    return g(h) ? (h.on("complete", V), h.on("abort", ie), h.req ? te() : h.on("request", te)) : I && !h._writableState && (h.on("end", B), h.on("close", B)), h.on("end", Q), h.on("finish", V), q.error !== !1 && h.on("error", ee), h.on("close", ie), function() {
      h.removeListener("complete", V), h.removeListener("abort", ie), h.removeListener("request", te), h.req && h.req.removeListener("finish", V), h.removeListener("end", B), h.removeListener("close", B), h.removeListener("finish", V), h.removeListener("end", Q), h.removeListener("error", ee), h.removeListener("close", ie);
    };
  }
  return endOfStream$1 = U, endOfStream$1;
}
var async_iterator$1, hasRequiredAsync_iterator$1;
function requireAsync_iterator$1() {
  if (hasRequiredAsync_iterator$1)
    return async_iterator$1;
  hasRequiredAsync_iterator$1 = 1;
  var e;
  function o(le, ce, pe) {
    return ce = S(ce), ce in le ? Object.defineProperty(le, ce, { value: pe, enumerable: !0, configurable: !0, writable: !0 }) : le[ce] = pe, le;
  }
  function S(le) {
    var ce = g(le, "string");
    return typeof ce == "symbol" ? ce : String(ce);
  }
  function g(le, ce) {
    if (typeof le != "object" || le === null)
      return le;
    var pe = le[Symbol.toPrimitive];
    if (pe !== void 0) {
      var me = pe.call(le, ce || "default");
      if (typeof me != "object")
        return me;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ce === "string" ? String : Number)(le);
  }
  var U = requireEndOfStream$1(), h = Symbol("lastResolve"), q = Symbol("lastReject"), A = Symbol("error"), P = Symbol("ended"), I = Symbol("lastPromise"), B = Symbol("handlePromise"), H = Symbol("stream");
  function V(le, ce) {
    return {
      value: le,
      done: ce
    };
  }
  function X(le) {
    var ce = le[h];
    if (ce !== null) {
      var pe = le[H].read();
      pe !== null && (le[I] = null, le[h] = null, le[q] = null, ce(V(pe, !1)));
    }
  }
  function Q(le) {
    process$1.nextTick(X, le);
  }
  function ee(le, ce) {
    return function(pe, me) {
      le.then(function() {
        if (ce[P]) {
          pe(V(void 0, !0));
          return;
        }
        ce[B](pe, me);
      }, me);
    };
  }
  var ie = Object.getPrototypeOf(function() {
  }), te = Object.setPrototypeOf((e = {
    get stream() {
      return this[H];
    },
    next: function() {
      var le = this, ce = this[A];
      if (ce !== null)
        return Promise.reject(ce);
      if (this[P])
        return Promise.resolve(V(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(Ee, Re) {
          process$1.nextTick(function() {
            le[A] ? Re(le[A]) : Ee(V(void 0, !0));
          });
        });
      var pe = this[I], me;
      if (pe)
        me = new Promise(ee(pe, this));
      else {
        var Me = this[H].read();
        if (Me !== null)
          return Promise.resolve(V(Me, !1));
        me = new Promise(this[B]);
      }
      return this[I] = me, me;
    }
  }, o(e, Symbol.asyncIterator, function() {
    return this;
  }), o(e, "return", function() {
    var le = this;
    return new Promise(function(ce, pe) {
      le[H].destroy(null, function(me) {
        if (me) {
          pe(me);
          return;
        }
        ce(V(void 0, !0));
      });
    });
  }), e), ie), se = function(le) {
    var ce, pe = Object.create(te, (ce = {}, o(ce, H, {
      value: le,
      writable: !0
    }), o(ce, h, {
      value: null,
      writable: !0
    }), o(ce, q, {
      value: null,
      writable: !0
    }), o(ce, A, {
      value: null,
      writable: !0
    }), o(ce, P, {
      value: le._readableState.endEmitted,
      writable: !0
    }), o(ce, B, {
      value: function(me, Me) {
        var Ee = pe[H].read();
        Ee ? (pe[I] = null, pe[h] = null, pe[q] = null, me(V(Ee, !1))) : (pe[h] = me, pe[q] = Me);
      },
      writable: !0
    }), ce));
    return pe[I] = null, U(le, function(me) {
      if (me && me.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Me = pe[q];
        Me !== null && (pe[I] = null, pe[h] = null, pe[q] = null, Me(me)), pe[A] = me;
        return;
      }
      var Ee = pe[h];
      Ee !== null && (pe[I] = null, pe[h] = null, pe[q] = null, Ee(V(void 0, !0))), pe[P] = !0;
    }), le.on("readable", Q.bind(null, pe)), pe;
  };
  return async_iterator$1 = se, async_iterator$1;
}
var fromBrowser$1, hasRequiredFromBrowser$1;
function requireFromBrowser$1() {
  return hasRequiredFromBrowser$1 || (hasRequiredFromBrowser$1 = 1, fromBrowser$1 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$1;
}
var _stream_readable$1$1, hasRequired_stream_readable$1$1;
function require_stream_readable$1$1() {
  if (hasRequired_stream_readable$1$1)
    return _stream_readable$1$1;
  hasRequired_stream_readable$1$1 = 1, _stream_readable$1$1 = Re;
  var e;
  Re.ReadableState = Ee, requireEvents().EventEmitter;
  var o = function(be, ve) {
    return be.listeners(ve).length;
  }, S = requireStreamBrowser$1$1(), g = requireBuffer$1().Buffer, U = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function h(be) {
    return g.from(be);
  }
  function q(be) {
    return g.isBuffer(be) || be instanceof U;
  }
  var A = requireUtil$1$1(), P;
  A && A.debuglog ? P = A.debuglog("stream") : P = function() {
  };
  var I = requireBuffer_list$1(), B = requireDestroy$1$1(), H = requireState$1(), V = H.getHighWaterMark, X = requireErrorsBrowser$1().codes, Q = X.ERR_INVALID_ARG_TYPE, ee = X.ERR_STREAM_PUSH_AFTER_EOF, ie = X.ERR_METHOD_NOT_IMPLEMENTED, te = X.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, se, le, ce;
  requireInherits_browser$1()(Re, S);
  var pe = B.errorOrDestroy, me = ["error", "close", "destroy", "pause", "resume"];
  function Me(be, ve, qe) {
    if (typeof be.prependListener == "function")
      return be.prependListener(ve, qe);
    !be._events || !be._events[ve] ? be.on(ve, qe) : Array.isArray(be._events[ve]) ? be._events[ve].unshift(qe) : be._events[ve] = [qe, be._events[ve]];
  }
  function Ee(be, ve, qe) {
    e = e || require_stream_duplex$1$1(), be = be || {}, typeof qe != "boolean" && (qe = ve instanceof e), this.objectMode = !!be.objectMode, qe && (this.objectMode = this.objectMode || !!be.readableObjectMode), this.highWaterMark = V(this, be, "readableHighWaterMark", qe), this.buffer = new I(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = be.emitClose !== !1, this.autoDestroy = !!be.autoDestroy, this.destroyed = !1, this.defaultEncoding = be.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, be.encoding && (se || (se = requireString_decoder$1().StringDecoder), this.decoder = new se(be.encoding), this.encoding = be.encoding);
  }
  function Re(be) {
    if (e = e || require_stream_duplex$1$1(), !(this instanceof Re))
      return new Re(be);
    var ve = this instanceof e;
    this._readableState = new Ee(be, this, ve), this.readable = !0, be && (typeof be.read == "function" && (this._read = be.read), typeof be.destroy == "function" && (this._destroy = be.destroy)), S.call(this);
  }
  Object.defineProperty(Re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(be) {
      this._readableState && (this._readableState.destroyed = be);
    }
  }), Re.prototype.destroy = B.destroy, Re.prototype._undestroy = B.undestroy, Re.prototype._destroy = function(be, ve) {
    ve(be);
  }, Re.prototype.push = function(be, ve) {
    var qe = this._readableState, De;
    return qe.objectMode ? De = !0 : typeof be == "string" && (ve = ve || qe.defaultEncoding, ve !== qe.encoding && (be = g.from(be, ve), ve = ""), De = !0), Ne(this, be, ve, !1, De);
  }, Re.prototype.unshift = function(be) {
    return Ne(this, be, null, !0, !1);
  };
  function Ne(be, ve, qe, De, Ye) {
    P("readableAddChunk", ve);
    var he = be._readableState;
    if (ve === null)
      he.reading = !1, J(be, he);
    else {
      var ue;
      if (Ye || (ue = Y(he, ve)), ue)
        pe(be, ue);
      else if (he.objectMode || ve && ve.length > 0)
        if (typeof ve != "string" && !he.objectMode && Object.getPrototypeOf(ve) !== g.prototype && (ve = h(ve)), De)
          he.endEmitted ? pe(be, new te()) : ne(be, he, ve, !0);
        else if (he.ended)
          pe(be, new ee());
        else {
          if (he.destroyed)
            return !1;
          he.reading = !1, he.decoder && !qe ? (ve = he.decoder.write(ve), he.objectMode || ve.length !== 0 ? ne(be, he, ve, !1) : z(be, he)) : ne(be, he, ve, !1);
        }
      else
        De || (he.reading = !1, z(be, he));
    }
    return !he.ended && (he.length < he.highWaterMark || he.length === 0);
  }
  function ne(be, ve, qe, De) {
    ve.flowing && ve.length === 0 && !ve.sync ? (ve.awaitDrain = 0, be.emit("data", qe)) : (ve.length += ve.objectMode ? 1 : qe.length, De ? ve.buffer.unshift(qe) : ve.buffer.push(qe), ve.needReadable && Z(be)), z(be, ve);
  }
  function Y(be, ve) {
    var qe;
    return !q(ve) && typeof ve != "string" && ve !== void 0 && !be.objectMode && (qe = new Q("chunk", ["string", "Buffer", "Uint8Array"], ve)), qe;
  }
  Re.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Re.prototype.setEncoding = function(be) {
    se || (se = requireString_decoder$1().StringDecoder);
    var ve = new se(be);
    this._readableState.decoder = ve, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var qe = this._readableState.buffer.head, De = ""; qe !== null; )
      De += ve.write(qe.data), qe = qe.next;
    return this._readableState.buffer.clear(), De !== "" && this._readableState.buffer.push(De), this._readableState.length = De.length, this;
  };
  var M = 1073741824;
  function $(be) {
    return be >= M ? be = M : (be--, be |= be >>> 1, be |= be >>> 2, be |= be >>> 4, be |= be >>> 8, be |= be >>> 16, be++), be;
  }
  function O(be, ve) {
    return be <= 0 || ve.length === 0 && ve.ended ? 0 : ve.objectMode ? 1 : be !== be ? ve.flowing && ve.length ? ve.buffer.head.data.length : ve.length : (be > ve.highWaterMark && (ve.highWaterMark = $(be)), be <= ve.length ? be : ve.ended ? ve.length : (ve.needReadable = !0, 0));
  }
  Re.prototype.read = function(be) {
    P("read", be), be = parseInt(be, 10);
    var ve = this._readableState, qe = be;
    if (be !== 0 && (ve.emittedReadable = !1), be === 0 && ve.needReadable && ((ve.highWaterMark !== 0 ? ve.length >= ve.highWaterMark : ve.length > 0) || ve.ended))
      return P("read: emitReadable", ve.length, ve.ended), ve.length === 0 && ve.ended ? fe(this) : Z(this), null;
    if (be = O(be, ve), be === 0 && ve.ended)
      return ve.length === 0 && fe(this), null;
    var De = ve.needReadable;
    P("need readable", De), (ve.length === 0 || ve.length - be < ve.highWaterMark) && (De = !0, P("length less than watermark", De)), ve.ended || ve.reading ? (De = !1, P("reading or ended", De)) : De && (P("do read"), ve.reading = !0, ve.sync = !0, ve.length === 0 && (ve.needReadable = !0), this._read(ve.highWaterMark), ve.sync = !1, ve.reading || (be = O(qe, ve)));
    var Ye;
    return be > 0 ? Ye = oe(be, ve) : Ye = null, Ye === null ? (ve.needReadable = ve.length <= ve.highWaterMark, be = 0) : (ve.length -= be, ve.awaitDrain = 0), ve.length === 0 && (ve.ended || (ve.needReadable = !0), qe !== be && ve.ended && fe(this)), Ye !== null && this.emit("data", Ye), Ye;
  };
  function J(be, ve) {
    if (P("onEofChunk"), !ve.ended) {
      if (ve.decoder) {
        var qe = ve.decoder.end();
        qe && qe.length && (ve.buffer.push(qe), ve.length += ve.objectMode ? 1 : qe.length);
      }
      ve.ended = !0, ve.sync ? Z(be) : (ve.needReadable = !1, ve.emittedReadable || (ve.emittedReadable = !0, K(be)));
    }
  }
  function Z(be) {
    var ve = be._readableState;
    P("emitReadable", ve.needReadable, ve.emittedReadable), ve.needReadable = !1, ve.emittedReadable || (P("emitReadable", ve.flowing), ve.emittedReadable = !0, process$1.nextTick(K, be));
  }
  function K(be) {
    var ve = be._readableState;
    P("emitReadable_", ve.destroyed, ve.length, ve.ended), !ve.destroyed && (ve.length || ve.ended) && (be.emit("readable"), ve.emittedReadable = !1), ve.needReadable = !ve.flowing && !ve.ended && ve.length <= ve.highWaterMark, ye(be);
  }
  function z(be, ve) {
    ve.readingMore || (ve.readingMore = !0, process$1.nextTick(G, be, ve));
  }
  function G(be, ve) {
    for (; !ve.reading && !ve.ended && (ve.length < ve.highWaterMark || ve.flowing && ve.length === 0); ) {
      var qe = ve.length;
      if (P("maybeReadMore read 0"), be.read(0), qe === ve.length)
        break;
    }
    ve.readingMore = !1;
  }
  Re.prototype._read = function(be) {
    pe(this, new ie("_read()"));
  }, Re.prototype.pipe = function(be, ve) {
    var qe = this, De = this._readableState;
    switch (De.pipesCount) {
      case 0:
        De.pipes = be;
        break;
      case 1:
        De.pipes = [De.pipes, be];
        break;
      default:
        De.pipes.push(be);
        break;
    }
    De.pipesCount += 1, P("pipe count=%d opts=%j", De.pipesCount, ve);
    var Ye = (!ve || ve.end !== !1) && be !== process$1.stdout && be !== process$1.stderr, he = Ye ? de : je;
    De.endEmitted ? process$1.nextTick(he) : qe.once("end", he), be.on("unpipe", ue);
    function ue(Ke, ot) {
      P("onunpipe"), Ke === qe && ot && ot.hasUnpiped === !1 && (ot.hasUnpiped = !0, He());
    }
    function de() {
      P("onend"), be.end();
    }
    var _e = D(qe);
    be.on("drain", _e);
    var Pe = !1;
    function He() {
      P("cleanup"), be.removeListener("close", Ie), be.removeListener("finish", Fe), be.removeListener("drain", _e), be.removeListener("error", nt), be.removeListener("unpipe", ue), qe.removeListener("end", de), qe.removeListener("end", je), qe.removeListener("data", Ve), Pe = !0, De.awaitDrain && (!be._writableState || be._writableState.needDrain) && _e();
    }
    qe.on("data", Ve);
    function Ve(Ke) {
      P("ondata");
      var ot = be.write(Ke);
      P("dest.write", ot), ot === !1 && ((De.pipesCount === 1 && De.pipes === be || De.pipesCount > 1 && Be(De.pipes, be) !== -1) && !Pe && (P("false write response, pause", De.awaitDrain), De.awaitDrain++), qe.pause());
    }
    function nt(Ke) {
      P("onerror", Ke), je(), be.removeListener("error", nt), o(be, "error") === 0 && pe(be, Ke);
    }
    Me(be, "error", nt);
    function Ie() {
      be.removeListener("finish", Fe), je();
    }
    be.once("close", Ie);
    function Fe() {
      P("onfinish"), be.removeListener("close", Ie), je();
    }
    be.once("finish", Fe);
    function je() {
      P("unpipe"), qe.unpipe(be);
    }
    return be.emit("pipe", qe), De.flowing || (P("pipe resume"), qe.resume()), be;
  };
  function D(be) {
    return function() {
      var ve = be._readableState;
      P("pipeOnDrain", ve.awaitDrain), ve.awaitDrain && ve.awaitDrain--, ve.awaitDrain === 0 && o(be, "data") && (ve.flowing = !0, ye(be));
    };
  }
  Re.prototype.unpipe = function(be) {
    var ve = this._readableState, qe = {
      hasUnpiped: !1
    };
    if (ve.pipesCount === 0)
      return this;
    if (ve.pipesCount === 1)
      return be && be !== ve.pipes ? this : (be || (be = ve.pipes), ve.pipes = null, ve.pipesCount = 0, ve.flowing = !1, be && be.emit("unpipe", this, qe), this);
    if (!be) {
      var De = ve.pipes, Ye = ve.pipesCount;
      ve.pipes = null, ve.pipesCount = 0, ve.flowing = !1;
      for (var he = 0; he < Ye; he++)
        De[he].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var ue = Be(ve.pipes, be);
    return ue === -1 ? this : (ve.pipes.splice(ue, 1), ve.pipesCount -= 1, ve.pipesCount === 1 && (ve.pipes = ve.pipes[0]), be.emit("unpipe", this, qe), this);
  }, Re.prototype.on = function(be, ve) {
    var qe = S.prototype.on.call(this, be, ve), De = this._readableState;
    return be === "data" ? (De.readableListening = this.listenerCount("readable") > 0, De.flowing !== !1 && this.resume()) : be === "readable" && !De.endEmitted && !De.readableListening && (De.readableListening = De.needReadable = !0, De.flowing = !1, De.emittedReadable = !1, P("on readable", De.length, De.reading), De.length ? Z(this) : De.reading || process$1.nextTick(ae, this)), qe;
  }, Re.prototype.addListener = Re.prototype.on, Re.prototype.removeListener = function(be, ve) {
    var qe = S.prototype.removeListener.call(this, be, ve);
    return be === "readable" && process$1.nextTick(F, this), qe;
  }, Re.prototype.removeAllListeners = function(be) {
    var ve = S.prototype.removeAllListeners.apply(this, arguments);
    return (be === "readable" || be === void 0) && process$1.nextTick(F, this), ve;
  };
  function F(be) {
    var ve = be._readableState;
    ve.readableListening = be.listenerCount("readable") > 0, ve.resumeScheduled && !ve.paused ? ve.flowing = !0 : be.listenerCount("data") > 0 && be.resume();
  }
  function ae(be) {
    P("readable nexttick read 0"), be.read(0);
  }
  Re.prototype.resume = function() {
    var be = this._readableState;
    return be.flowing || (P("resume"), be.flowing = !be.readableListening, ge(this, be)), be.paused = !1, this;
  };
  function ge(be, ve) {
    ve.resumeScheduled || (ve.resumeScheduled = !0, process$1.nextTick(xe, be, ve));
  }
  function xe(be, ve) {
    P("resume", ve.reading), ve.reading || be.read(0), ve.resumeScheduled = !1, be.emit("resume"), ye(be), ve.flowing && !ve.reading && be.read(0);
  }
  Re.prototype.pause = function() {
    return P("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (P("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(be) {
    var ve = be._readableState;
    for (P("flow", ve.flowing); ve.flowing && be.read() !== null; )
      ;
  }
  Re.prototype.wrap = function(be) {
    var ve = this, qe = this._readableState, De = !1;
    be.on("end", function() {
      if (P("wrapped end"), qe.decoder && !qe.ended) {
        var ue = qe.decoder.end();
        ue && ue.length && ve.push(ue);
      }
      ve.push(null);
    }), be.on("data", function(ue) {
      if (P("wrapped data"), qe.decoder && (ue = qe.decoder.write(ue)), !(qe.objectMode && ue == null) && !(!qe.objectMode && (!ue || !ue.length))) {
        var de = ve.push(ue);
        de || (De = !0, be.pause());
      }
    });
    for (var Ye in be)
      this[Ye] === void 0 && typeof be[Ye] == "function" && (this[Ye] = /* @__PURE__ */ function(ue) {
        return function() {
          return be[ue].apply(be, arguments);
        };
      }(Ye));
    for (var he = 0; he < me.length; he++)
      be.on(me[he], this.emit.bind(this, me[he]));
    return this._read = function(ue) {
      P("wrapped _read", ue), De && (De = !1, be.resume());
    }, this;
  }, typeof Symbol == "function" && (Re.prototype[Symbol.asyncIterator] = function() {
    return le === void 0 && (le = requireAsync_iterator$1()), le(this);
  }), Object.defineProperty(Re.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Re.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Re.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(be) {
      this._readableState && (this._readableState.flowing = be);
    }
  }), Re._fromList = oe, Object.defineProperty(Re.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function oe(be, ve) {
    if (ve.length === 0)
      return null;
    var qe;
    return ve.objectMode ? qe = ve.buffer.shift() : !be || be >= ve.length ? (ve.decoder ? qe = ve.buffer.join("") : ve.buffer.length === 1 ? qe = ve.buffer.first() : qe = ve.buffer.concat(ve.length), ve.buffer.clear()) : qe = ve.buffer.consume(be, ve.decoder), qe;
  }
  function fe(be) {
    var ve = be._readableState;
    P("endReadable", ve.endEmitted), ve.endEmitted || (ve.ended = !0, process$1.nextTick($e, ve, be));
  }
  function $e(be, ve) {
    if (P("endReadableNT", be.endEmitted, be.length), !be.endEmitted && be.length === 0 && (be.endEmitted = !0, ve.readable = !1, ve.emit("end"), be.autoDestroy)) {
      var qe = ve._writableState;
      (!qe || qe.autoDestroy && qe.finished) && ve.destroy();
    }
  }
  typeof Symbol == "function" && (Re.from = function(be, ve) {
    return ce === void 0 && (ce = requireFromBrowser$1()), ce(Re, be, ve);
  });
  function Be(be, ve) {
    for (var qe = 0, De = be.length; qe < De; qe++)
      if (be[qe] === ve)
        return qe;
    return -1;
  }
  return _stream_readable$1$1;
}
var _stream_transform$1$1, hasRequired_stream_transform$1$1;
function require_stream_transform$1$1() {
  if (hasRequired_stream_transform$1$1)
    return _stream_transform$1$1;
  hasRequired_stream_transform$1$1 = 1, _stream_transform$1$1 = A;
  var e = requireErrorsBrowser$1().codes, o = e.ERR_METHOD_NOT_IMPLEMENTED, S = e.ERR_MULTIPLE_CALLBACK, g = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, U = e.ERR_TRANSFORM_WITH_LENGTH_0, h = require_stream_duplex$1$1();
  requireInherits_browser$1()(A, h);
  function q(B, H) {
    var V = this._transformState;
    V.transforming = !1;
    var X = V.writecb;
    if (X === null)
      return this.emit("error", new S());
    V.writechunk = null, V.writecb = null, H != null && this.push(H), X(B);
    var Q = this._readableState;
    Q.reading = !1, (Q.needReadable || Q.length < Q.highWaterMark) && this._read(Q.highWaterMark);
  }
  function A(B) {
    if (!(this instanceof A))
      return new A(B);
    h.call(this, B), this._transformState = {
      afterTransform: q.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", P);
  }
  function P() {
    var B = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(H, V) {
      I(B, H, V);
    }) : I(this, null, null);
  }
  A.prototype.push = function(B, H) {
    return this._transformState.needTransform = !1, h.prototype.push.call(this, B, H);
  }, A.prototype._transform = function(B, H, V) {
    V(new o("_transform()"));
  }, A.prototype._write = function(B, H, V) {
    var X = this._transformState;
    if (X.writecb = V, X.writechunk = B, X.writeencoding = H, !X.transforming) {
      var Q = this._readableState;
      (X.needTransform || Q.needReadable || Q.length < Q.highWaterMark) && this._read(Q.highWaterMark);
    }
  }, A.prototype._read = function(B) {
    var H = this._transformState;
    H.writechunk !== null && !H.transforming ? (H.transforming = !0, this._transform(H.writechunk, H.writeencoding, H.afterTransform)) : H.needTransform = !0;
  }, A.prototype._destroy = function(B, H) {
    h.prototype._destroy.call(this, B, function(V) {
      H(V);
    });
  };
  function I(B, H, V) {
    if (H)
      return B.emit("error", H);
    if (V != null && B.push(V), B._writableState.length)
      throw new U();
    if (B._transformState.transforming)
      throw new g();
    return B.push(null);
  }
  return _stream_transform$1$1;
}
var _stream_passthrough$1$1, hasRequired_stream_passthrough$1$1;
function require_stream_passthrough$1$1() {
  if (hasRequired_stream_passthrough$1$1)
    return _stream_passthrough$1$1;
  hasRequired_stream_passthrough$1$1 = 1, _stream_passthrough$1$1 = o;
  var e = require_stream_transform$1$1();
  requireInherits_browser$1()(o, e);
  function o(S) {
    if (!(this instanceof o))
      return new o(S);
    e.call(this, S);
  }
  return o.prototype._transform = function(S, g, U) {
    U(null, S);
  }, _stream_passthrough$1$1;
}
var pipeline_1$1, hasRequiredPipeline$1;
function requirePipeline$1() {
  if (hasRequiredPipeline$1)
    return pipeline_1$1;
  hasRequiredPipeline$1 = 1;
  var e;
  function o(V) {
    var X = !1;
    return function() {
      X || (X = !0, V.apply(void 0, arguments));
    };
  }
  var S = requireErrorsBrowser$1().codes, g = S.ERR_MISSING_ARGS, U = S.ERR_STREAM_DESTROYED;
  function h(V) {
    if (V)
      throw V;
  }
  function q(V) {
    return V.setHeader && typeof V.abort == "function";
  }
  function A(V, X, Q, ee) {
    ee = o(ee);
    var ie = !1;
    V.on("close", function() {
      ie = !0;
    }), e === void 0 && (e = requireEndOfStream$1()), e(V, {
      readable: X,
      writable: Q
    }, function(se) {
      if (se)
        return ee(se);
      ie = !0, ee();
    });
    var te = !1;
    return function(se) {
      if (!ie && !te) {
        if (te = !0, q(V))
          return V.abort();
        if (typeof V.destroy == "function")
          return V.destroy();
        ee(se || new U("pipe"));
      }
    };
  }
  function P(V) {
    V();
  }
  function I(V, X) {
    return V.pipe(X);
  }
  function B(V) {
    return !V.length || typeof V[V.length - 1] != "function" ? h : V.pop();
  }
  function H() {
    for (var V = arguments.length, X = new Array(V), Q = 0; Q < V; Q++)
      X[Q] = arguments[Q];
    var ee = B(X);
    if (Array.isArray(X[0]) && (X = X[0]), X.length < 2)
      throw new g("streams");
    var ie, te = X.map(function(se, le) {
      var ce = le < X.length - 1, pe = le > 0;
      return A(se, ce, pe, function(me) {
        ie || (ie = me), me && te.forEach(P), !ce && (te.forEach(P), ee(ie));
      });
    });
    return X.reduce(I);
  }
  return pipeline_1$1 = H, pipeline_1$1;
}
var hasRequiredReadableBrowser$1$1;
function requireReadableBrowser$1$1() {
  return hasRequiredReadableBrowser$1$1 || (hasRequiredReadableBrowser$1$1 = 1, function(e, o) {
    o = e.exports = require_stream_readable$1$1(), o.Stream = o, o.Readable = o, o.Writable = require_stream_writable$1$1(), o.Duplex = require_stream_duplex$1$1(), o.Transform = require_stream_transform$1$1(), o.PassThrough = require_stream_passthrough$1$1(), o.finished = requireEndOfStream$1(), o.pipeline = requirePipeline$1();
  }(readableBrowser$1$1, readableBrowser$1$1.exports)), readableBrowser$1$1.exports;
}
var hashBase$1$1, hasRequiredHashBase$1$1;
function requireHashBase$1$1() {
  if (hasRequiredHashBase$1$1)
    return hashBase$1$1;
  hasRequiredHashBase$1$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireReadableBrowser$1$1().Transform, S = requireInherits_browser$1();
  function g(h, q) {
    if (!e.isBuffer(h) && typeof h != "string")
      throw new TypeError(q + " must be a string or a buffer");
  }
  function U(h) {
    o.call(this), this._block = e.allocUnsafe(h), this._blockSize = h, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return S(U, o), U.prototype._transform = function(h, q, A) {
    var P = null;
    try {
      this.update(h, q);
    } catch (I) {
      P = I;
    }
    A(P);
  }, U.prototype._flush = function(h) {
    var q = null;
    try {
      this.push(this.digest());
    } catch (A) {
      q = A;
    }
    h(q);
  }, U.prototype.update = function(h, q) {
    if (g(h, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(h) || (h = e.from(h, q));
    for (var A = this._block, P = 0; this._blockOffset + h.length - P >= this._blockSize; ) {
      for (var I = this._blockOffset; I < this._blockSize; )
        A[I++] = h[P++];
      this._update(), this._blockOffset = 0;
    }
    for (; P < h.length; )
      A[this._blockOffset++] = h[P++];
    for (var B = 0, H = h.length * 8; H > 0; ++B)
      this._length[B] += H, H = this._length[B] / 4294967296 | 0, H > 0 && (this._length[B] -= 4294967296 * H);
    return this;
  }, U.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, U.prototype.digest = function(h) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var q = this._digest();
    h !== void 0 && (q = q.toString(h)), this._block.fill(0), this._blockOffset = 0;
    for (var A = 0; A < 4; ++A)
      this._length[A] = 0;
    return q;
  }, U.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase$1$1 = U, hashBase$1$1;
}
var md5_js$1, hasRequiredMd5_js$1;
function requireMd5_js$1() {
  if (hasRequiredMd5_js$1)
    return md5_js$1;
  hasRequiredMd5_js$1 = 1;
  var e = requireInherits_browser$1(), o = requireHashBase$1$1(), S = requireSafeBuffer$1$1().Buffer, g = new Array(16);
  function U() {
    o.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(U, o), U.prototype._update = function() {
    for (var B = g, H = 0; H < 16; ++H)
      B[H] = this._block.readInt32LE(H * 4);
    var V = this._a, X = this._b, Q = this._c, ee = this._d;
    V = q(V, X, Q, ee, B[0], 3614090360, 7), ee = q(ee, V, X, Q, B[1], 3905402710, 12), Q = q(Q, ee, V, X, B[2], 606105819, 17), X = q(X, Q, ee, V, B[3], 3250441966, 22), V = q(V, X, Q, ee, B[4], 4118548399, 7), ee = q(ee, V, X, Q, B[5], 1200080426, 12), Q = q(Q, ee, V, X, B[6], 2821735955, 17), X = q(X, Q, ee, V, B[7], 4249261313, 22), V = q(V, X, Q, ee, B[8], 1770035416, 7), ee = q(ee, V, X, Q, B[9], 2336552879, 12), Q = q(Q, ee, V, X, B[10], 4294925233, 17), X = q(X, Q, ee, V, B[11], 2304563134, 22), V = q(V, X, Q, ee, B[12], 1804603682, 7), ee = q(ee, V, X, Q, B[13], 4254626195, 12), Q = q(Q, ee, V, X, B[14], 2792965006, 17), X = q(X, Q, ee, V, B[15], 1236535329, 22), V = A(V, X, Q, ee, B[1], 4129170786, 5), ee = A(ee, V, X, Q, B[6], 3225465664, 9), Q = A(Q, ee, V, X, B[11], 643717713, 14), X = A(X, Q, ee, V, B[0], 3921069994, 20), V = A(V, X, Q, ee, B[5], 3593408605, 5), ee = A(ee, V, X, Q, B[10], 38016083, 9), Q = A(Q, ee, V, X, B[15], 3634488961, 14), X = A(X, Q, ee, V, B[4], 3889429448, 20), V = A(V, X, Q, ee, B[9], 568446438, 5), ee = A(ee, V, X, Q, B[14], 3275163606, 9), Q = A(Q, ee, V, X, B[3], 4107603335, 14), X = A(X, Q, ee, V, B[8], 1163531501, 20), V = A(V, X, Q, ee, B[13], 2850285829, 5), ee = A(ee, V, X, Q, B[2], 4243563512, 9), Q = A(Q, ee, V, X, B[7], 1735328473, 14), X = A(X, Q, ee, V, B[12], 2368359562, 20), V = P(V, X, Q, ee, B[5], 4294588738, 4), ee = P(ee, V, X, Q, B[8], 2272392833, 11), Q = P(Q, ee, V, X, B[11], 1839030562, 16), X = P(X, Q, ee, V, B[14], 4259657740, 23), V = P(V, X, Q, ee, B[1], 2763975236, 4), ee = P(ee, V, X, Q, B[4], 1272893353, 11), Q = P(Q, ee, V, X, B[7], 4139469664, 16), X = P(X, Q, ee, V, B[10], 3200236656, 23), V = P(V, X, Q, ee, B[13], 681279174, 4), ee = P(ee, V, X, Q, B[0], 3936430074, 11), Q = P(Q, ee, V, X, B[3], 3572445317, 16), X = P(X, Q, ee, V, B[6], 76029189, 23), V = P(V, X, Q, ee, B[9], 3654602809, 4), ee = P(ee, V, X, Q, B[12], 3873151461, 11), Q = P(Q, ee, V, X, B[15], 530742520, 16), X = P(X, Q, ee, V, B[2], 3299628645, 23), V = I(V, X, Q, ee, B[0], 4096336452, 6), ee = I(ee, V, X, Q, B[7], 1126891415, 10), Q = I(Q, ee, V, X, B[14], 2878612391, 15), X = I(X, Q, ee, V, B[5], 4237533241, 21), V = I(V, X, Q, ee, B[12], 1700485571, 6), ee = I(ee, V, X, Q, B[3], 2399980690, 10), Q = I(Q, ee, V, X, B[10], 4293915773, 15), X = I(X, Q, ee, V, B[1], 2240044497, 21), V = I(V, X, Q, ee, B[8], 1873313359, 6), ee = I(ee, V, X, Q, B[15], 4264355552, 10), Q = I(Q, ee, V, X, B[6], 2734768916, 15), X = I(X, Q, ee, V, B[13], 1309151649, 21), V = I(V, X, Q, ee, B[4], 4149444226, 6), ee = I(ee, V, X, Q, B[11], 3174756917, 10), Q = I(Q, ee, V, X, B[2], 718787259, 15), X = I(X, Q, ee, V, B[9], 3951481745, 21), this._a = this._a + V | 0, this._b = this._b + X | 0, this._c = this._c + Q | 0, this._d = this._d + ee | 0;
  }, U.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var B = S.allocUnsafe(16);
    return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B;
  };
  function h(B, H) {
    return B << H | B >>> 32 - H;
  }
  function q(B, H, V, X, Q, ee, ie) {
    return h(B + (H & V | ~H & X) + Q + ee | 0, ie) + H | 0;
  }
  function A(B, H, V, X, Q, ee, ie) {
    return h(B + (H & X | V & ~X) + Q + ee | 0, ie) + H | 0;
  }
  function P(B, H, V, X, Q, ee, ie) {
    return h(B + (H ^ V ^ X) + Q + ee | 0, ie) + H | 0;
  }
  function I(B, H, V, X, Q, ee, ie) {
    return h(B + (V ^ (H | ~X)) + Q + ee | 0, ie) + H | 0;
  }
  return md5_js$1 = U, md5_js$1;
}
var hashBase$2, hasRequiredHashBase$2;
function requireHashBase$2() {
  if (hasRequiredHashBase$2)
    return hashBase$2;
  hasRequiredHashBase$2 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireReadableBrowser$1$1().Transform, S = requireInherits_browser$1();
  function g(h, q) {
    if (!e.isBuffer(h) && typeof h != "string")
      throw new TypeError(q + " must be a string or a buffer");
  }
  function U(h) {
    o.call(this), this._block = e.allocUnsafe(h), this._blockSize = h, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return S(U, o), U.prototype._transform = function(h, q, A) {
    var P = null;
    try {
      this.update(h, q);
    } catch (I) {
      P = I;
    }
    A(P);
  }, U.prototype._flush = function(h) {
    var q = null;
    try {
      this.push(this.digest());
    } catch (A) {
      q = A;
    }
    h(q);
  }, U.prototype.update = function(h, q) {
    if (g(h, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(h) || (h = e.from(h, q));
    for (var A = this._block, P = 0; this._blockOffset + h.length - P >= this._blockSize; ) {
      for (var I = this._blockOffset; I < this._blockSize; )
        A[I++] = h[P++];
      this._update(), this._blockOffset = 0;
    }
    for (; P < h.length; )
      A[this._blockOffset++] = h[P++];
    for (var B = 0, H = h.length * 8; H > 0; ++B)
      this._length[B] += H, H = this._length[B] / 4294967296 | 0, H > 0 && (this._length[B] -= 4294967296 * H);
    return this;
  }, U.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, U.prototype.digest = function(h) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var q = this._digest();
    h !== void 0 && (q = q.toString(h)), this._block.fill(0), this._blockOffset = 0;
    for (var A = 0; A < 4; ++A)
      this._length[A] = 0;
    return q;
  }, U.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase$2 = U, hashBase$2;
}
var ripemd160$1, hasRequiredRipemd160$1;
function requireRipemd160$1() {
  if (hasRequiredRipemd160$1)
    return ripemd160$1;
  hasRequiredRipemd160$1 = 1;
  var e = requireBuffer$1().Buffer, o = requireInherits_browser$1(), S = requireHashBase$2(), g = new Array(16), U = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], h = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], q = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], A = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], P = [0, 1518500249, 1859775393, 2400959708, 2840853838], I = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function B() {
    S.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  o(B, S), B.prototype._update = function() {
    for (var te = g, se = 0; se < 16; ++se)
      te[se] = this._block.readInt32LE(se * 4);
    for (var le = this._a | 0, ce = this._b | 0, pe = this._c | 0, me = this._d | 0, Me = this._e | 0, Ee = this._a | 0, Re = this._b | 0, Ne = this._c | 0, ne = this._d | 0, Y = this._e | 0, M = 0; M < 80; M += 1) {
      var $, O;
      M < 16 ? ($ = V(le, ce, pe, me, Me, te[U[M]], P[0], q[M]), O = ie(Ee, Re, Ne, ne, Y, te[h[M]], I[0], A[M])) : M < 32 ? ($ = X(le, ce, pe, me, Me, te[U[M]], P[1], q[M]), O = ee(Ee, Re, Ne, ne, Y, te[h[M]], I[1], A[M])) : M < 48 ? ($ = Q(le, ce, pe, me, Me, te[U[M]], P[2], q[M]), O = Q(Ee, Re, Ne, ne, Y, te[h[M]], I[2], A[M])) : M < 64 ? ($ = ee(le, ce, pe, me, Me, te[U[M]], P[3], q[M]), O = X(Ee, Re, Ne, ne, Y, te[h[M]], I[3], A[M])) : ($ = ie(le, ce, pe, me, Me, te[U[M]], P[4], q[M]), O = V(Ee, Re, Ne, ne, Y, te[h[M]], I[4], A[M])), le = Me, Me = me, me = H(pe, 10), pe = ce, ce = $, Ee = Y, Y = ne, ne = H(Ne, 10), Ne = Re, Re = O;
    }
    var J = this._b + pe + ne | 0;
    this._b = this._c + me + Y | 0, this._c = this._d + Me + Ee | 0, this._d = this._e + le + Re | 0, this._e = this._a + ce + Ne | 0, this._a = J;
  }, B.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var te = e.alloc ? e.alloc(20) : new e(20);
    return te.writeInt32LE(this._a, 0), te.writeInt32LE(this._b, 4), te.writeInt32LE(this._c, 8), te.writeInt32LE(this._d, 12), te.writeInt32LE(this._e, 16), te;
  };
  function H(te, se) {
    return te << se | te >>> 32 - se;
  }
  function V(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se ^ le ^ ce) + me + Me | 0, Ee) + pe | 0;
  }
  function X(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se & le | ~se & ce) + me + Me | 0, Ee) + pe | 0;
  }
  function Q(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + ((se | ~le) ^ ce) + me + Me | 0, Ee) + pe | 0;
  }
  function ee(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se & ce | le & ~ce) + me + Me | 0, Ee) + pe | 0;
  }
  function ie(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se ^ (le | ~ce)) + me + Me | 0, Ee) + pe | 0;
  }
  return ripemd160$1 = B, ripemd160$1;
}
var sha_js$1 = { exports: {} }, hash$1$1, hasRequiredHash$1$1;
function requireHash$1$1() {
  if (hasRequiredHash$1$1)
    return hash$1$1;
  hasRequiredHash$1$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer;
  function o(S, g) {
    this._block = e.alloc(S), this._finalSize = g, this._blockSize = S, this._len = 0;
  }
  return o.prototype.update = function(S, g) {
    typeof S == "string" && (g = g || "utf8", S = e.from(S, g));
    for (var U = this._block, h = this._blockSize, q = S.length, A = this._len, P = 0; P < q; ) {
      for (var I = A % h, B = Math.min(q - P, h - I), H = 0; H < B; H++)
        U[I + H] = S[P + H];
      A += B, P += B, A % h === 0 && this._update(U);
    }
    return this._len += q, this;
  }, o.prototype.digest = function(S) {
    var g = this._len % this._blockSize;
    this._block[g] = 128, this._block.fill(0, g + 1), g >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var U = this._len * 8;
    if (U <= 4294967295)
      this._block.writeUInt32BE(U, this._blockSize - 4);
    else {
      var h = (U & 4294967295) >>> 0, q = (U - h) / 4294967296;
      this._block.writeUInt32BE(q, this._blockSize - 8), this._block.writeUInt32BE(h, this._blockSize - 4);
    }
    this._update(this._block);
    var A = this._hash();
    return S ? A.toString(S) : A;
  }, o.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1$1 = o, hash$1$1;
}
var sha$1$1, hasRequiredSha$1$1;
function requireSha$1$1() {
  if (hasRequiredSha$1$1)
    return sha$1$1;
  hasRequiredSha$1$1 = 1;
  var e = requireInherits_browser$1(), o = requireHash$1$1(), S = requireSafeBuffer$1$1().Buffer, g = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], U = new Array(80);
  function h() {
    this.init(), this._w = U, o.call(this, 64, 56);
  }
  e(h, o), h.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function q(I) {
    return I << 5 | I >>> 27;
  }
  function A(I) {
    return I << 30 | I >>> 2;
  }
  function P(I, B, H, V) {
    return I === 0 ? B & H | ~B & V : I === 2 ? B & H | B & V | H & V : B ^ H ^ V;
  }
  return h.prototype._update = function(I) {
    for (var B = this._w, H = this._a | 0, V = this._b | 0, X = this._c | 0, Q = this._d | 0, ee = this._e | 0, ie = 0; ie < 16; ++ie)
      B[ie] = I.readInt32BE(ie * 4);
    for (; ie < 80; ++ie)
      B[ie] = B[ie - 3] ^ B[ie - 8] ^ B[ie - 14] ^ B[ie - 16];
    for (var te = 0; te < 80; ++te) {
      var se = ~~(te / 20), le = q(H) + P(se, V, X, Q) + ee + B[te] + g[se] | 0;
      ee = Q, Q = X, X = A(V), V = H, H = le;
    }
    this._a = H + this._a | 0, this._b = V + this._b | 0, this._c = X + this._c | 0, this._d = Q + this._d | 0, this._e = ee + this._e | 0;
  }, h.prototype._hash = function() {
    var I = S.allocUnsafe(20);
    return I.writeInt32BE(this._a | 0, 0), I.writeInt32BE(this._b | 0, 4), I.writeInt32BE(this._c | 0, 8), I.writeInt32BE(this._d | 0, 12), I.writeInt32BE(this._e | 0, 16), I;
  }, sha$1$1 = h, sha$1$1;
}
var sha1$1, hasRequiredSha1$1;
function requireSha1$1() {
  if (hasRequiredSha1$1)
    return sha1$1;
  hasRequiredSha1$1 = 1;
  var e = requireInherits_browser$1(), o = requireHash$1$1(), S = requireSafeBuffer$1$1().Buffer, g = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], U = new Array(80);
  function h() {
    this.init(), this._w = U, o.call(this, 64, 56);
  }
  e(h, o), h.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function q(B) {
    return B << 1 | B >>> 31;
  }
  function A(B) {
    return B << 5 | B >>> 27;
  }
  function P(B) {
    return B << 30 | B >>> 2;
  }
  function I(B, H, V, X) {
    return B === 0 ? H & V | ~H & X : B === 2 ? H & V | H & X | V & X : H ^ V ^ X;
  }
  return h.prototype._update = function(B) {
    for (var H = this._w, V = this._a | 0, X = this._b | 0, Q = this._c | 0, ee = this._d | 0, ie = this._e | 0, te = 0; te < 16; ++te)
      H[te] = B.readInt32BE(te * 4);
    for (; te < 80; ++te)
      H[te] = q(H[te - 3] ^ H[te - 8] ^ H[te - 14] ^ H[te - 16]);
    for (var se = 0; se < 80; ++se) {
      var le = ~~(se / 20), ce = A(V) + I(le, X, Q, ee) + ie + H[se] + g[le] | 0;
      ie = ee, ee = Q, Q = P(X), X = V, V = ce;
    }
    this._a = V + this._a | 0, this._b = X + this._b | 0, this._c = Q + this._c | 0, this._d = ee + this._d | 0, this._e = ie + this._e | 0;
  }, h.prototype._hash = function() {
    var B = S.allocUnsafe(20);
    return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
  }, sha1$1 = h, sha1$1;
}
var sha256$1$1, hasRequiredSha256$1;
function requireSha256$1() {
  if (hasRequiredSha256$1)
    return sha256$1$1;
  hasRequiredSha256$1 = 1;
  var e = requireInherits_browser$1(), o = requireHash$1$1(), S = requireSafeBuffer$1$1().Buffer, g = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], U = new Array(64);
  function h() {
    this.init(), this._w = U, o.call(this, 64, 56);
  }
  e(h, o), h.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function q(V, X, Q) {
    return Q ^ V & (X ^ Q);
  }
  function A(V, X, Q) {
    return V & X | Q & (V | X);
  }
  function P(V) {
    return (V >>> 2 | V << 30) ^ (V >>> 13 | V << 19) ^ (V >>> 22 | V << 10);
  }
  function I(V) {
    return (V >>> 6 | V << 26) ^ (V >>> 11 | V << 21) ^ (V >>> 25 | V << 7);
  }
  function B(V) {
    return (V >>> 7 | V << 25) ^ (V >>> 18 | V << 14) ^ V >>> 3;
  }
  function H(V) {
    return (V >>> 17 | V << 15) ^ (V >>> 19 | V << 13) ^ V >>> 10;
  }
  return h.prototype._update = function(V) {
    for (var X = this._w, Q = this._a | 0, ee = this._b | 0, ie = this._c | 0, te = this._d | 0, se = this._e | 0, le = this._f | 0, ce = this._g | 0, pe = this._h | 0, me = 0; me < 16; ++me)
      X[me] = V.readInt32BE(me * 4);
    for (; me < 64; ++me)
      X[me] = H(X[me - 2]) + X[me - 7] + B(X[me - 15]) + X[me - 16] | 0;
    for (var Me = 0; Me < 64; ++Me) {
      var Ee = pe + I(se) + q(se, le, ce) + g[Me] + X[Me] | 0, Re = P(Q) + A(Q, ee, ie) | 0;
      pe = ce, ce = le, le = se, se = te + Ee | 0, te = ie, ie = ee, ee = Q, Q = Ee + Re | 0;
    }
    this._a = Q + this._a | 0, this._b = ee + this._b | 0, this._c = ie + this._c | 0, this._d = te + this._d | 0, this._e = se + this._e | 0, this._f = le + this._f | 0, this._g = ce + this._g | 0, this._h = pe + this._h | 0;
  }, h.prototype._hash = function() {
    var V = S.allocUnsafe(32);
    return V.writeInt32BE(this._a, 0), V.writeInt32BE(this._b, 4), V.writeInt32BE(this._c, 8), V.writeInt32BE(this._d, 12), V.writeInt32BE(this._e, 16), V.writeInt32BE(this._f, 20), V.writeInt32BE(this._g, 24), V.writeInt32BE(this._h, 28), V;
  }, sha256$1$1 = h, sha256$1$1;
}
var sha224$1$1, hasRequiredSha224$1;
function requireSha224$1() {
  if (hasRequiredSha224$1)
    return sha224$1$1;
  hasRequiredSha224$1 = 1;
  var e = requireInherits_browser$1(), o = requireSha256$1(), S = requireHash$1$1(), g = requireSafeBuffer$1$1().Buffer, U = new Array(64);
  function h() {
    this.init(), this._w = U, S.call(this, 64, 56);
  }
  return e(h, o), h.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, h.prototype._hash = function() {
    var q = g.allocUnsafe(28);
    return q.writeInt32BE(this._a, 0), q.writeInt32BE(this._b, 4), q.writeInt32BE(this._c, 8), q.writeInt32BE(this._d, 12), q.writeInt32BE(this._e, 16), q.writeInt32BE(this._f, 20), q.writeInt32BE(this._g, 24), q;
  }, sha224$1$1 = h, sha224$1$1;
}
var sha512$1$1, hasRequiredSha512$1;
function requireSha512$1() {
  if (hasRequiredSha512$1)
    return sha512$1$1;
  hasRequiredSha512$1 = 1;
  var e = requireInherits_browser$1(), o = requireHash$1$1(), S = requireSafeBuffer$1$1().Buffer, g = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], U = new Array(160);
  function h() {
    this.init(), this._w = U, o.call(this, 128, 112);
  }
  e(h, o), h.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function q(ee, ie, te) {
    return te ^ ee & (ie ^ te);
  }
  function A(ee, ie, te) {
    return ee & ie | te & (ee | ie);
  }
  function P(ee, ie) {
    return (ee >>> 28 | ie << 4) ^ (ie >>> 2 | ee << 30) ^ (ie >>> 7 | ee << 25);
  }
  function I(ee, ie) {
    return (ee >>> 14 | ie << 18) ^ (ee >>> 18 | ie << 14) ^ (ie >>> 9 | ee << 23);
  }
  function B(ee, ie) {
    return (ee >>> 1 | ie << 31) ^ (ee >>> 8 | ie << 24) ^ ee >>> 7;
  }
  function H(ee, ie) {
    return (ee >>> 1 | ie << 31) ^ (ee >>> 8 | ie << 24) ^ (ee >>> 7 | ie << 25);
  }
  function V(ee, ie) {
    return (ee >>> 19 | ie << 13) ^ (ie >>> 29 | ee << 3) ^ ee >>> 6;
  }
  function X(ee, ie) {
    return (ee >>> 19 | ie << 13) ^ (ie >>> 29 | ee << 3) ^ (ee >>> 6 | ie << 26);
  }
  function Q(ee, ie) {
    return ee >>> 0 < ie >>> 0 ? 1 : 0;
  }
  return h.prototype._update = function(ee) {
    for (var ie = this._w, te = this._ah | 0, se = this._bh | 0, le = this._ch | 0, ce = this._dh | 0, pe = this._eh | 0, me = this._fh | 0, Me = this._gh | 0, Ee = this._hh | 0, Re = this._al | 0, Ne = this._bl | 0, ne = this._cl | 0, Y = this._dl | 0, M = this._el | 0, $ = this._fl | 0, O = this._gl | 0, J = this._hl | 0, Z = 0; Z < 32; Z += 2)
      ie[Z] = ee.readInt32BE(Z * 4), ie[Z + 1] = ee.readInt32BE(Z * 4 + 4);
    for (; Z < 160; Z += 2) {
      var K = ie[Z - 30], z = ie[Z - 15 * 2 + 1], G = B(K, z), D = H(z, K);
      K = ie[Z - 2 * 2], z = ie[Z - 2 * 2 + 1];
      var F = V(K, z), ae = X(z, K), ge = ie[Z - 7 * 2], xe = ie[Z - 7 * 2 + 1], ye = ie[Z - 16 * 2], oe = ie[Z - 16 * 2 + 1], fe = D + xe | 0, $e = G + ge + Q(fe, D) | 0;
      fe = fe + ae | 0, $e = $e + F + Q(fe, ae) | 0, fe = fe + oe | 0, $e = $e + ye + Q(fe, oe) | 0, ie[Z] = $e, ie[Z + 1] = fe;
    }
    for (var Be = 0; Be < 160; Be += 2) {
      $e = ie[Be], fe = ie[Be + 1];
      var be = A(te, se, le), ve = A(Re, Ne, ne), qe = P(te, Re), De = P(Re, te), Ye = I(pe, M), he = I(M, pe), ue = g[Be], de = g[Be + 1], _e = q(pe, me, Me), Pe = q(M, $, O), He = J + he | 0, Ve = Ee + Ye + Q(He, J) | 0;
      He = He + Pe | 0, Ve = Ve + _e + Q(He, Pe) | 0, He = He + de | 0, Ve = Ve + ue + Q(He, de) | 0, He = He + fe | 0, Ve = Ve + $e + Q(He, fe) | 0;
      var nt = De + ve | 0, Ie = qe + be + Q(nt, De) | 0;
      Ee = Me, J = O, Me = me, O = $, me = pe, $ = M, M = Y + He | 0, pe = ce + Ve + Q(M, Y) | 0, ce = le, Y = ne, le = se, ne = Ne, se = te, Ne = Re, Re = He + nt | 0, te = Ve + Ie + Q(Re, He) | 0;
    }
    this._al = this._al + Re | 0, this._bl = this._bl + Ne | 0, this._cl = this._cl + ne | 0, this._dl = this._dl + Y | 0, this._el = this._el + M | 0, this._fl = this._fl + $ | 0, this._gl = this._gl + O | 0, this._hl = this._hl + J | 0, this._ah = this._ah + te + Q(this._al, Re) | 0, this._bh = this._bh + se + Q(this._bl, Ne) | 0, this._ch = this._ch + le + Q(this._cl, ne) | 0, this._dh = this._dh + ce + Q(this._dl, Y) | 0, this._eh = this._eh + pe + Q(this._el, M) | 0, this._fh = this._fh + me + Q(this._fl, $) | 0, this._gh = this._gh + Me + Q(this._gl, O) | 0, this._hh = this._hh + Ee + Q(this._hl, J) | 0;
  }, h.prototype._hash = function() {
    var ee = S.allocUnsafe(64);
    function ie(te, se, le) {
      ee.writeInt32BE(te, le), ee.writeInt32BE(se, le + 4);
    }
    return ie(this._ah, this._al, 0), ie(this._bh, this._bl, 8), ie(this._ch, this._cl, 16), ie(this._dh, this._dl, 24), ie(this._eh, this._el, 32), ie(this._fh, this._fl, 40), ie(this._gh, this._gl, 48), ie(this._hh, this._hl, 56), ee;
  }, sha512$1$1 = h, sha512$1$1;
}
var sha384$1$1, hasRequiredSha384$1;
function requireSha384$1() {
  if (hasRequiredSha384$1)
    return sha384$1$1;
  hasRequiredSha384$1 = 1;
  var e = requireInherits_browser$1(), o = requireSha512$1(), S = requireHash$1$1(), g = requireSafeBuffer$1$1().Buffer, U = new Array(160);
  function h() {
    this.init(), this._w = U, S.call(this, 128, 112);
  }
  return e(h, o), h.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, h.prototype._hash = function() {
    var q = g.allocUnsafe(48);
    function A(P, I, B) {
      q.writeInt32BE(P, B), q.writeInt32BE(I, B + 4);
    }
    return A(this._ah, this._al, 0), A(this._bh, this._bl, 8), A(this._ch, this._cl, 16), A(this._dh, this._dl, 24), A(this._eh, this._el, 32), A(this._fh, this._fl, 40), q;
  }, sha384$1$1 = h, sha384$1$1;
}
var hasRequiredSha_js$1;
function requireSha_js$1() {
  if (hasRequiredSha_js$1)
    return sha_js$1.exports;
  hasRequiredSha_js$1 = 1;
  var e = sha_js$1.exports = function(o) {
    o = o.toLowerCase();
    var S = e[o];
    if (!S)
      throw new Error(o + " is not supported (we accept pull requests)");
    return new S();
  };
  return e.sha = requireSha$1$1(), e.sha1 = requireSha1$1(), e.sha224 = requireSha224$1(), e.sha256 = requireSha256$1(), e.sha384 = requireSha384$1(), e.sha512 = requireSha512$1(), sha_js$1.exports;
}
var streamBrowserify$1, hasRequiredStreamBrowserify$1;
function requireStreamBrowserify$1() {
  if (hasRequiredStreamBrowserify$1)
    return streamBrowserify$1;
  hasRequiredStreamBrowserify$1 = 1, streamBrowserify$1 = S;
  var e = requireEvents().EventEmitter, o = requireInherits_browser$1();
  o(S, e), S.Readable = require_stream_readable$1$1(), S.Writable = require_stream_writable$1$1(), S.Duplex = require_stream_duplex$1$1(), S.Transform = require_stream_transform$1$1(), S.PassThrough = require_stream_passthrough$1$1(), S.finished = requireEndOfStream$1(), S.pipeline = requirePipeline$1(), S.Stream = S;
  function S() {
    e.call(this);
  }
  return S.prototype.pipe = function(g, U) {
    var h = this;
    function q(X) {
      g.writable && g.write(X) === !1 && h.pause && h.pause();
    }
    h.on("data", q);
    function A() {
      h.readable && h.resume && h.resume();
    }
    g.on("drain", A), !g._isStdio && (!U || U.end !== !1) && (h.on("end", I), h.on("close", B));
    var P = !1;
    function I() {
      P || (P = !0, g.end());
    }
    function B() {
      P || (P = !0, typeof g.destroy == "function" && g.destroy());
    }
    function H(X) {
      if (V(), e.listenerCount(this, "error") === 0)
        throw X;
    }
    h.on("error", H), g.on("error", H);
    function V() {
      h.removeListener("data", q), g.removeListener("drain", A), h.removeListener("end", I), h.removeListener("close", B), h.removeListener("error", H), g.removeListener("error", H), h.removeListener("end", V), h.removeListener("close", V), g.removeListener("close", V);
    }
    return h.on("end", V), h.on("close", V), g.on("close", V), g.emit("pipe", h), g;
  }, streamBrowserify$1;
}
var cipherBase$1, hasRequiredCipherBase$1;
function requireCipherBase$1() {
  if (hasRequiredCipherBase$1)
    return cipherBase$1;
  hasRequiredCipherBase$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireStreamBrowserify$1().Transform, S = requireString_decoder$1().StringDecoder, g = requireInherits_browser$1();
  function U(h) {
    o.call(this), this.hashMode = typeof h == "string", this.hashMode ? this[h] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return g(U, o), U.prototype.update = function(h, q, A) {
    typeof h == "string" && (h = e.from(h, q));
    var P = this._update(h);
    return this.hashMode ? this : (A && (P = this._toString(P, A)), P);
  }, U.prototype.setAutoPadding = function() {
  }, U.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, U.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, U.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, U.prototype._transform = function(h, q, A) {
    var P;
    try {
      this.hashMode ? this._update(h) : this.push(this._update(h));
    } catch (I) {
      P = I;
    } finally {
      A(P);
    }
  }, U.prototype._flush = function(h) {
    var q;
    try {
      this.push(this.__final());
    } catch (A) {
      q = A;
    }
    h(q);
  }, U.prototype._finalOrDigest = function(h) {
    var q = this.__final() || e.alloc(0);
    return h && (q = this._toString(q, h, !0)), q;
  }, U.prototype._toString = function(h, q, A) {
    if (this._decoder || (this._decoder = new S(q), this._encoding = q), this._encoding !== q)
      throw new Error("can't switch encodings");
    var P = this._decoder.write(h);
    return A && (P += this._decoder.end()), P;
  }, cipherBase$1 = U, cipherBase$1;
}
var browser$9$1, hasRequiredBrowser$9$1;
function requireBrowser$9$1() {
  if (hasRequiredBrowser$9$1)
    return browser$9$1;
  hasRequiredBrowser$9$1 = 1;
  var e = requireInherits_browser$1(), o = requireMd5_js$1(), S = requireRipemd160$1(), g = requireSha_js$1(), U = requireCipherBase$1();
  function h(q) {
    U.call(this, "digest"), this._hash = q;
  }
  return e(h, U), h.prototype._update = function(q) {
    this._hash.update(q);
  }, h.prototype._final = function() {
    return this._hash.digest();
  }, browser$9$1 = function(q) {
    return q = q.toLowerCase(), q === "md5" ? new o() : q === "rmd160" || q === "ripemd160" ? new S() : new h(g(q));
  }, browser$9$1;
}
var legacy$1, hasRequiredLegacy$1;
function requireLegacy$1() {
  if (hasRequiredLegacy$1)
    return legacy$1;
  hasRequiredLegacy$1 = 1;
  var e = requireInherits_browser$1(), o = requireSafeBuffer$1$1().Buffer, S = requireCipherBase$1(), g = o.alloc(128), U = 64;
  function h(q, A) {
    S.call(this, "digest"), typeof A == "string" && (A = o.from(A)), this._alg = q, this._key = A, A.length > U ? A = q(A) : A.length < U && (A = o.concat([A, g], U));
    for (var P = this._ipad = o.allocUnsafe(U), I = this._opad = o.allocUnsafe(U), B = 0; B < U; B++)
      P[B] = A[B] ^ 54, I[B] = A[B] ^ 92;
    this._hash = [P];
  }
  return e(h, S), h.prototype._update = function(q) {
    this._hash.push(q);
  }, h.prototype._final = function() {
    var q = this._alg(o.concat(this._hash));
    return this._alg(o.concat([this._opad, q]));
  }, legacy$1 = h, legacy$1;
}
var md5$1, hasRequiredMd5$1;
function requireMd5$1() {
  if (hasRequiredMd5$1)
    return md5$1;
  hasRequiredMd5$1 = 1;
  var e = requireMd5_js$1();
  return md5$1 = function(o) {
    return new e().update(o).digest();
  }, md5$1;
}
var browser$8$1, hasRequiredBrowser$8$1;
function requireBrowser$8$1() {
  if (hasRequiredBrowser$8$1)
    return browser$8$1;
  hasRequiredBrowser$8$1 = 1;
  var e = requireInherits_browser$1(), o = requireLegacy$1(), S = requireCipherBase$1(), g = requireSafeBuffer$1$1().Buffer, U = requireMd5$1(), h = requireRipemd160$1(), q = requireSha_js$1(), A = g.alloc(128);
  function P(I, B) {
    S.call(this, "digest"), typeof B == "string" && (B = g.from(B));
    var H = I === "sha512" || I === "sha384" ? 128 : 64;
    if (this._alg = I, this._key = B, B.length > H) {
      var V = I === "rmd160" ? new h() : q(I);
      B = V.update(B).digest();
    } else
      B.length < H && (B = g.concat([B, A], H));
    for (var X = this._ipad = g.allocUnsafe(H), Q = this._opad = g.allocUnsafe(H), ee = 0; ee < H; ee++)
      X[ee] = B[ee] ^ 54, Q[ee] = B[ee] ^ 92;
    this._hash = I === "rmd160" ? new h() : q(I), this._hash.update(X);
  }
  return e(P, S), P.prototype._update = function(I) {
    this._hash.update(I);
  }, P.prototype._final = function() {
    var I = this._hash.digest(), B = this._alg === "rmd160" ? new h() : q(this._alg);
    return B.update(this._opad).update(I).digest();
  }, browser$8$1 = function(I, B) {
    return I = I.toLowerCase(), I === "rmd160" || I === "ripemd160" ? new P("rmd160", B) : I === "md5" ? new o(U, B) : new P(I, B);
  }, browser$8$1;
}
const sha224WithRSAEncryption$1 = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption$1 = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption$1 = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption$1 = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$3 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224$2 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384$2 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$2 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA$1 = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA$1 = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption$1 = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6$1 = {
  sha224WithRSAEncryption: sha224WithRSAEncryption$1,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: sha256WithRSAEncryption$1,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: sha384WithRSAEncryption$1,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: sha512WithRSAEncryption$1,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$3,
  sha224: sha224$2,
  sha384: sha384$2,
  sha512: sha512$2,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: DSA$1,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: ripemd160WithRSA$1,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: md5WithRSAEncryption$1,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos$1, hasRequiredAlgos$1;
function requireAlgos$1() {
  return hasRequiredAlgos$1 || (hasRequiredAlgos$1 = 1, algos$1 = require$$6$1), algos$1;
}
var browser$7$1 = {}, precondition$1, hasRequiredPrecondition$1;
function requirePrecondition$1() {
  if (hasRequiredPrecondition$1)
    return precondition$1;
  hasRequiredPrecondition$1 = 1;
  var e = Math.pow(2, 30) - 1;
  return precondition$1 = function(o, S) {
    if (typeof o != "number")
      throw new TypeError("Iterations not a number");
    if (o < 0)
      throw new TypeError("Bad iterations");
    if (typeof S != "number")
      throw new TypeError("Key length not a number");
    if (S < 0 || S > e || S !== S)
      throw new TypeError("Bad key length");
  }, precondition$1;
}
var defaultEncoding_1$1, hasRequiredDefaultEncoding$1;
function requireDefaultEncoding$1() {
  if (hasRequiredDefaultEncoding$1)
    return defaultEncoding_1$1;
  hasRequiredDefaultEncoding$1 = 1;
  var e;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    e = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var o = parseInt(process$1.version.split(".")[0].slice(1), 10);
    e = o >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return defaultEncoding_1$1 = e, defaultEncoding_1$1;
}
var toBuffer$1, hasRequiredToBuffer$1;
function requireToBuffer$1() {
  if (hasRequiredToBuffer$1)
    return toBuffer$1;
  hasRequiredToBuffer$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer;
  return toBuffer$1 = function(o, S, g) {
    if (e.isBuffer(o))
      return o;
    if (typeof o == "string")
      return e.from(o, S);
    if (ArrayBuffer.isView(o))
      return e.from(o.buffer);
    throw new TypeError(g + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser$1, hasRequiredSyncBrowser$1;
function requireSyncBrowser$1() {
  if (hasRequiredSyncBrowser$1)
    return syncBrowser$1;
  hasRequiredSyncBrowser$1 = 1;
  var e = requireMd5$1(), o = requireRipemd160$1(), S = requireSha_js$1(), g = requireSafeBuffer$1$1().Buffer, U = requirePrecondition$1(), h = requireDefaultEncoding$1(), q = requireToBuffer$1(), A = g.alloc(128), P = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function I(V, X, Q) {
    var ee = B(V), ie = V === "sha512" || V === "sha384" ? 128 : 64;
    X.length > ie ? X = ee(X) : X.length < ie && (X = g.concat([X, A], ie));
    for (var te = g.allocUnsafe(ie + P[V]), se = g.allocUnsafe(ie + P[V]), le = 0; le < ie; le++)
      te[le] = X[le] ^ 54, se[le] = X[le] ^ 92;
    var ce = g.allocUnsafe(ie + Q + 4);
    te.copy(ce, 0, 0, ie), this.ipad1 = ce, this.ipad2 = te, this.opad = se, this.alg = V, this.blocksize = ie, this.hash = ee, this.size = P[V];
  }
  I.prototype.run = function(V, X) {
    V.copy(X, this.blocksize);
    var Q = this.hash(X);
    return Q.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function B(V) {
    function X(ee) {
      return S(V).update(ee).digest();
    }
    function Q(ee) {
      return new o().update(ee).digest();
    }
    return V === "rmd160" || V === "ripemd160" ? Q : V === "md5" ? e : X;
  }
  function H(V, X, Q, ee, ie) {
    U(Q, ee), V = q(V, h, "Password"), X = q(X, h, "Salt"), ie = ie || "sha1";
    var te = new I(ie, V, X.length), se = g.allocUnsafe(ee), le = g.allocUnsafe(X.length + 4);
    X.copy(le, 0, 0, X.length);
    for (var ce = 0, pe = P[ie], me = Math.ceil(ee / pe), Me = 1; Me <= me; Me++) {
      le.writeUInt32BE(Me, X.length);
      for (var Ee = te.run(le, te.ipad1), Re = Ee, Ne = 1; Ne < Q; Ne++) {
        Re = te.run(Re, te.ipad2);
        for (var ne = 0; ne < pe; ne++)
          Ee[ne] ^= Re[ne];
      }
      Ee.copy(se, ce), ce += pe;
    }
    return se;
  }
  return syncBrowser$1 = H, syncBrowser$1;
}
var async$1, hasRequiredAsync$1;
function requireAsync$1() {
  if (hasRequiredAsync$1)
    return async$1;
  hasRequiredAsync$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requirePrecondition$1(), S = requireDefaultEncoding$1(), g = requireSyncBrowser$1(), U = requireToBuffer$1(), h, q = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, A = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, P = [];
  function I(Q) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !q || !q.importKey || !q.deriveBits)
      return Promise.resolve(!1);
    if (P[Q] !== void 0)
      return P[Q];
    h = h || e.alloc(8);
    var ee = V(h, h, 10, 128, Q).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return P[Q] = ee, ee;
  }
  var B;
  function H() {
    return B || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? B = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? B = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? B = commonjsGlobal.setImmediate : B = commonjsGlobal.setTimeout, B);
  }
  function V(Q, ee, ie, te, se) {
    return q.importKey(
      "raw",
      Q,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(le) {
      return q.deriveBits({
        name: "PBKDF2",
        salt: ee,
        iterations: ie,
        hash: {
          name: se
        }
      }, le, te << 3);
    }).then(function(le) {
      return e.from(le);
    });
  }
  function X(Q, ee) {
    Q.then(function(ie) {
      H()(function() {
        ee(null, ie);
      });
    }, function(ie) {
      H()(function() {
        ee(ie);
      });
    });
  }
  return async$1 = function(Q, ee, ie, te, se, le) {
    typeof se == "function" && (le = se, se = void 0), se = se || "sha1";
    var ce = A[se.toLowerCase()];
    if (!ce || typeof commonjsGlobal.Promise != "function") {
      H()(function() {
        var pe;
        try {
          pe = g(Q, ee, ie, te, se);
        } catch (me) {
          return le(me);
        }
        le(null, pe);
      });
      return;
    }
    if (o(ie, te), Q = U(Q, S, "Password"), ee = U(ee, S, "Salt"), typeof le != "function")
      throw new Error("No callback provided to pbkdf2");
    X(I(ce).then(function(pe) {
      return pe ? V(Q, ee, ie, te, ce) : g(Q, ee, ie, te, se);
    }), le);
  }, async$1;
}
var hasRequiredBrowser$7$1;
function requireBrowser$7$1() {
  return hasRequiredBrowser$7$1 || (hasRequiredBrowser$7$1 = 1, browser$7$1.pbkdf2 = requireAsync$1(), browser$7$1.pbkdf2Sync = requireSyncBrowser$1()), browser$7$1;
}
var browser$6$1 = {}, des$1$1 = {}, utils$3$1 = {}, hasRequiredUtils$3$1;
function requireUtils$3$1() {
  if (hasRequiredUtils$3$1)
    return utils$3$1;
  hasRequiredUtils$3$1 = 1, utils$3$1.readUInt32BE = function(g, U) {
    var h = g[0 + U] << 24 | g[1 + U] << 16 | g[2 + U] << 8 | g[3 + U];
    return h >>> 0;
  }, utils$3$1.writeUInt32BE = function(g, U, h) {
    g[0 + h] = U >>> 24, g[1 + h] = U >>> 16 & 255, g[2 + h] = U >>> 8 & 255, g[3 + h] = U & 255;
  }, utils$3$1.ip = function(g, U, h, q) {
    for (var A = 0, P = 0, I = 6; I >= 0; I -= 2) {
      for (var B = 0; B <= 24; B += 8)
        A <<= 1, A |= U >>> B + I & 1;
      for (var B = 0; B <= 24; B += 8)
        A <<= 1, A |= g >>> B + I & 1;
    }
    for (var I = 6; I >= 0; I -= 2) {
      for (var B = 1; B <= 25; B += 8)
        P <<= 1, P |= U >>> B + I & 1;
      for (var B = 1; B <= 25; B += 8)
        P <<= 1, P |= g >>> B + I & 1;
    }
    h[q + 0] = A >>> 0, h[q + 1] = P >>> 0;
  }, utils$3$1.rip = function(g, U, h, q) {
    for (var A = 0, P = 0, I = 0; I < 4; I++)
      for (var B = 24; B >= 0; B -= 8)
        A <<= 1, A |= U >>> B + I & 1, A <<= 1, A |= g >>> B + I & 1;
    for (var I = 4; I < 8; I++)
      for (var B = 24; B >= 0; B -= 8)
        P <<= 1, P |= U >>> B + I & 1, P <<= 1, P |= g >>> B + I & 1;
    h[q + 0] = A >>> 0, h[q + 1] = P >>> 0;
  }, utils$3$1.pc1 = function(g, U, h, q) {
    for (var A = 0, P = 0, I = 7; I >= 5; I--) {
      for (var B = 0; B <= 24; B += 8)
        A <<= 1, A |= U >> B + I & 1;
      for (var B = 0; B <= 24; B += 8)
        A <<= 1, A |= g >> B + I & 1;
    }
    for (var B = 0; B <= 24; B += 8)
      A <<= 1, A |= U >> B + I & 1;
    for (var I = 1; I <= 3; I++) {
      for (var B = 0; B <= 24; B += 8)
        P <<= 1, P |= U >> B + I & 1;
      for (var B = 0; B <= 24; B += 8)
        P <<= 1, P |= g >> B + I & 1;
    }
    for (var B = 0; B <= 24; B += 8)
      P <<= 1, P |= g >> B + I & 1;
    h[q + 0] = A >>> 0, h[q + 1] = P >>> 0;
  }, utils$3$1.r28shl = function(g, U) {
    return g << U & 268435455 | g >>> 28 - U;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$3$1.pc2 = function(g, U, h, q) {
    for (var A = 0, P = 0, I = e.length >>> 1, B = 0; B < I; B++)
      A <<= 1, A |= g >>> e[B] & 1;
    for (var B = I; B < e.length; B++)
      P <<= 1, P |= U >>> e[B] & 1;
    h[q + 0] = A >>> 0, h[q + 1] = P >>> 0;
  }, utils$3$1.expand = function(g, U, h) {
    var q = 0, A = 0;
    q = (g & 1) << 5 | g >>> 27;
    for (var P = 23; P >= 15; P -= 4)
      q <<= 6, q |= g >>> P & 63;
    for (var P = 11; P >= 3; P -= 4)
      A |= g >>> P & 63, A <<= 6;
    A |= (g & 31) << 1 | g >>> 31, U[h + 0] = q >>> 0, U[h + 1] = A >>> 0;
  };
  var o = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$3$1.substitute = function(g, U) {
    for (var h = 0, q = 0; q < 4; q++) {
      var A = g >>> 18 - q * 6 & 63, P = o[q * 64 + A];
      h <<= 4, h |= P;
    }
    for (var q = 0; q < 4; q++) {
      var A = U >>> 18 - q * 6 & 63, P = o[4 * 64 + q * 64 + A];
      h <<= 4, h |= P;
    }
    return h >>> 0;
  };
  var S = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$3$1.permute = function(g) {
    for (var U = 0, h = 0; h < S.length; h++)
      U <<= 1, U |= g >>> S[h] & 1;
    return U >>> 0;
  }, utils$3$1.padSplit = function(g, U, h) {
    for (var q = g.toString(2); q.length < U; )
      q = "0" + q;
    for (var A = [], P = 0; P < U; P += h)
      A.push(q.slice(P, P + h));
    return A.join(" ");
  }, utils$3$1;
}
var minimalisticAssert$1, hasRequiredMinimalisticAssert$1;
function requireMinimalisticAssert$1() {
  if (hasRequiredMinimalisticAssert$1)
    return minimalisticAssert$1;
  hasRequiredMinimalisticAssert$1 = 1, minimalisticAssert$1 = e;
  function e(o, S) {
    if (!o)
      throw new Error(S || "Assertion failed");
  }
  return e.equal = function(o, S, g) {
    if (o != S)
      throw new Error(g || "Assertion failed: " + o + " != " + S);
  }, minimalisticAssert$1;
}
var cipher$1, hasRequiredCipher$1;
function requireCipher$1() {
  if (hasRequiredCipher$1)
    return cipher$1;
  hasRequiredCipher$1 = 1;
  var e = requireMinimalisticAssert$1();
  function o(S) {
    this.options = S, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = S.padding !== !1;
  }
  return cipher$1 = o, o.prototype._init = function() {
  }, o.prototype.update = function(S) {
    return S.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(S) : this._updateEncrypt(S);
  }, o.prototype._buffer = function(S, g) {
    for (var U = Math.min(this.buffer.length - this.bufferOff, S.length - g), h = 0; h < U; h++)
      this.buffer[this.bufferOff + h] = S[g + h];
    return this.bufferOff += U, U;
  }, o.prototype._flushBuffer = function(S, g) {
    return this._update(this.buffer, 0, S, g), this.bufferOff = 0, this.blockSize;
  }, o.prototype._updateEncrypt = function(S) {
    var g = 0, U = 0, h = (this.bufferOff + S.length) / this.blockSize | 0, q = new Array(h * this.blockSize);
    this.bufferOff !== 0 && (g += this._buffer(S, g), this.bufferOff === this.buffer.length && (U += this._flushBuffer(q, U)));
    for (var A = S.length - (S.length - g) % this.blockSize; g < A; g += this.blockSize)
      this._update(S, g, q, U), U += this.blockSize;
    for (; g < S.length; g++, this.bufferOff++)
      this.buffer[this.bufferOff] = S[g];
    return q;
  }, o.prototype._updateDecrypt = function(S) {
    for (var g = 0, U = 0, h = Math.ceil((this.bufferOff + S.length) / this.blockSize) - 1, q = new Array(h * this.blockSize); h > 0; h--)
      g += this._buffer(S, g), U += this._flushBuffer(q, U);
    return g += this._buffer(S, g), q;
  }, o.prototype.final = function(S) {
    var g;
    S && (g = this.update(S));
    var U;
    return this.type === "encrypt" ? U = this._finalEncrypt() : U = this._finalDecrypt(), g ? g.concat(U) : U;
  }, o.prototype._pad = function(S, g) {
    if (g === 0)
      return !1;
    for (; g < S.length; )
      S[g++] = 0;
    return !0;
  }, o.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var S = new Array(this.blockSize);
    return this._update(this.buffer, 0, S, 0), S;
  }, o.prototype._unpad = function(S) {
    return S;
  }, o.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var S = new Array(this.blockSize);
    return this._flushBuffer(S, 0), this._unpad(S);
  }, cipher$1;
}
var des$2, hasRequiredDes$1$1;
function requireDes$1$1() {
  if (hasRequiredDes$1$1)
    return des$2;
  hasRequiredDes$1$1 = 1;
  var e = requireMinimalisticAssert$1(), o = requireInherits_browser$1(), S = requireUtils$3$1(), g = requireCipher$1();
  function U() {
    this.tmp = new Array(2), this.keys = null;
  }
  function h(A) {
    g.call(this, A);
    var P = new U();
    this._desState = P, this.deriveKeys(P, A.key);
  }
  o(h, g), des$2 = h, h.create = function(A) {
    return new h(A);
  };
  var q = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return h.prototype.deriveKeys = function(A, P) {
    A.keys = new Array(16 * 2), e.equal(P.length, this.blockSize, "Invalid key length");
    var I = S.readUInt32BE(P, 0), B = S.readUInt32BE(P, 4);
    S.pc1(I, B, A.tmp, 0), I = A.tmp[0], B = A.tmp[1];
    for (var H = 0; H < A.keys.length; H += 2) {
      var V = q[H >>> 1];
      I = S.r28shl(I, V), B = S.r28shl(B, V), S.pc2(I, B, A.keys, H);
    }
  }, h.prototype._update = function(A, P, I, B) {
    var H = this._desState, V = S.readUInt32BE(A, P), X = S.readUInt32BE(A, P + 4);
    S.ip(V, X, H.tmp, 0), V = H.tmp[0], X = H.tmp[1], this.type === "encrypt" ? this._encrypt(H, V, X, H.tmp, 0) : this._decrypt(H, V, X, H.tmp, 0), V = H.tmp[0], X = H.tmp[1], S.writeUInt32BE(I, V, B), S.writeUInt32BE(I, X, B + 4);
  }, h.prototype._pad = function(A, P) {
    if (this.padding === !1)
      return !1;
    for (var I = A.length - P, B = P; B < A.length; B++)
      A[B] = I;
    return !0;
  }, h.prototype._unpad = function(A) {
    if (this.padding === !1)
      return A;
    for (var P = A[A.length - 1], I = A.length - P; I < A.length; I++)
      e.equal(A[I], P);
    return A.slice(0, A.length - P);
  }, h.prototype._encrypt = function(A, P, I, B, H) {
    for (var V = P, X = I, Q = 0; Q < A.keys.length; Q += 2) {
      var ee = A.keys[Q], ie = A.keys[Q + 1];
      S.expand(X, A.tmp, 0), ee ^= A.tmp[0], ie ^= A.tmp[1];
      var te = S.substitute(ee, ie), se = S.permute(te), le = X;
      X = (V ^ se) >>> 0, V = le;
    }
    S.rip(X, V, B, H);
  }, h.prototype._decrypt = function(A, P, I, B, H) {
    for (var V = I, X = P, Q = A.keys.length - 2; Q >= 0; Q -= 2) {
      var ee = A.keys[Q], ie = A.keys[Q + 1];
      S.expand(V, A.tmp, 0), ee ^= A.tmp[0], ie ^= A.tmp[1];
      var te = S.substitute(ee, ie), se = S.permute(te), le = V;
      V = (X ^ se) >>> 0, X = le;
    }
    S.rip(V, X, B, H);
  }, des$2;
}
var cbc$1$1 = {}, hasRequiredCbc$1$1;
function requireCbc$1$1() {
  if (hasRequiredCbc$1$1)
    return cbc$1$1;
  hasRequiredCbc$1$1 = 1;
  var e = requireMinimalisticAssert$1(), o = requireInherits_browser$1(), S = {};
  function g(h) {
    e.equal(h.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var q = 0; q < this.iv.length; q++)
      this.iv[q] = h[q];
  }
  function U(h) {
    function q(B) {
      h.call(this, B), this._cbcInit();
    }
    o(q, h);
    for (var A = Object.keys(S), P = 0; P < A.length; P++) {
      var I = A[P];
      q.prototype[I] = S[I];
    }
    return q.create = function(B) {
      return new q(B);
    }, q;
  }
  return cbc$1$1.instantiate = U, S._cbcInit = function() {
    var h = new g(this.options.iv);
    this._cbcState = h;
  }, S._update = function(h, q, A, P) {
    var I = this._cbcState, B = this.constructor.super_.prototype, H = I.iv;
    if (this.type === "encrypt") {
      for (var V = 0; V < this.blockSize; V++)
        H[V] ^= h[q + V];
      B._update.call(this, H, 0, A, P);
      for (var V = 0; V < this.blockSize; V++)
        H[V] = A[P + V];
    } else {
      B._update.call(this, h, q, A, P);
      for (var V = 0; V < this.blockSize; V++)
        A[P + V] ^= H[V];
      for (var V = 0; V < this.blockSize; V++)
        H[V] = h[q + V];
    }
  }, cbc$1$1;
}
var ede$1, hasRequiredEde$1;
function requireEde$1() {
  if (hasRequiredEde$1)
    return ede$1;
  hasRequiredEde$1 = 1;
  var e = requireMinimalisticAssert$1(), o = requireInherits_browser$1(), S = requireCipher$1(), g = requireDes$1$1();
  function U(q, A) {
    e.equal(A.length, 24, "Invalid key length");
    var P = A.slice(0, 8), I = A.slice(8, 16), B = A.slice(16, 24);
    q === "encrypt" ? this.ciphers = [
      g.create({ type: "encrypt", key: P }),
      g.create({ type: "decrypt", key: I }),
      g.create({ type: "encrypt", key: B })
    ] : this.ciphers = [
      g.create({ type: "decrypt", key: B }),
      g.create({ type: "encrypt", key: I }),
      g.create({ type: "decrypt", key: P })
    ];
  }
  function h(q) {
    S.call(this, q);
    var A = new U(this.type, this.options.key);
    this._edeState = A;
  }
  return o(h, S), ede$1 = h, h.create = function(q) {
    return new h(q);
  }, h.prototype._update = function(q, A, P, I) {
    var B = this._edeState;
    B.ciphers[0]._update(q, A, P, I), B.ciphers[1]._update(P, I, P, I), B.ciphers[2]._update(P, I, P, I);
  }, h.prototype._pad = g.prototype._pad, h.prototype._unpad = g.prototype._unpad, ede$1;
}
var hasRequiredDes$2;
function requireDes$2() {
  return hasRequiredDes$2 || (hasRequiredDes$2 = 1, des$1$1.utils = requireUtils$3$1(), des$1$1.Cipher = requireCipher$1(), des$1$1.DES = requireDes$1$1(), des$1$1.CBC = requireCbc$1$1(), des$1$1.EDE = requireEde$1()), des$1$1;
}
var browserifyDes$1, hasRequiredBrowserifyDes$1;
function requireBrowserifyDes$1() {
  if (hasRequiredBrowserifyDes$1)
    return browserifyDes$1;
  hasRequiredBrowserifyDes$1 = 1;
  var e = requireCipherBase$1(), o = requireDes$2(), S = requireInherits_browser$1(), g = requireSafeBuffer$1$1().Buffer, U = {
    "des-ede3-cbc": o.CBC.instantiate(o.EDE),
    "des-ede3": o.EDE,
    "des-ede-cbc": o.CBC.instantiate(o.EDE),
    "des-ede": o.EDE,
    "des-cbc": o.CBC.instantiate(o.DES),
    "des-ecb": o.DES
  };
  U.des = U["des-cbc"], U.des3 = U["des-ede3-cbc"], browserifyDes$1 = h, S(h, e);
  function h(q) {
    e.call(this);
    var A = q.mode.toLowerCase(), P = U[A], I;
    q.decrypt ? I = "decrypt" : I = "encrypt";
    var B = q.key;
    g.isBuffer(B) || (B = g.from(B)), (A === "des-ede" || A === "des-ede-cbc") && (B = g.concat([B, B.slice(0, 8)]));
    var H = q.iv;
    g.isBuffer(H) || (H = g.from(H)), this._des = P.create({
      key: B,
      iv: H,
      type: I
    });
  }
  return h.prototype._update = function(q) {
    return g.from(this._des.update(q));
  }, h.prototype._final = function() {
    return g.from(this._des.final());
  }, browserifyDes$1;
}
var browser$5$1 = {}, encrypter$1 = {}, ecb$1 = {}, hasRequiredEcb$1;
function requireEcb$1() {
  return hasRequiredEcb$1 || (hasRequiredEcb$1 = 1, ecb$1.encrypt = function(e, o) {
    return e._cipher.encryptBlock(o);
  }, ecb$1.decrypt = function(e, o) {
    return e._cipher.decryptBlock(o);
  }), ecb$1;
}
var cbc$2 = {}, bufferXor$1, hasRequiredBufferXor$1;
function requireBufferXor$1() {
  return hasRequiredBufferXor$1 || (hasRequiredBufferXor$1 = 1, bufferXor$1 = function(e, o) {
    for (var S = Math.min(e.length, o.length), g = new bufferExports.Buffer(S), U = 0; U < S; ++U)
      g[U] = e[U] ^ o[U];
    return g;
  }), bufferXor$1;
}
var hasRequiredCbc$2;
function requireCbc$2() {
  if (hasRequiredCbc$2)
    return cbc$2;
  hasRequiredCbc$2 = 1;
  var e = requireBufferXor$1();
  return cbc$2.encrypt = function(o, S) {
    var g = e(S, o._prev);
    return o._prev = o._cipher.encryptBlock(g), o._prev;
  }, cbc$2.decrypt = function(o, S) {
    var g = o._prev;
    o._prev = S;
    var U = o._cipher.decryptBlock(S);
    return e(U, g);
  }, cbc$2;
}
var cfb$1 = {}, hasRequiredCfb$1;
function requireCfb$1() {
  if (hasRequiredCfb$1)
    return cfb$1;
  hasRequiredCfb$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireBufferXor$1();
  function S(g, U, h) {
    var q = U.length, A = o(U, g._cache);
    return g._cache = g._cache.slice(q), g._prev = e.concat([g._prev, h ? U : A]), A;
  }
  return cfb$1.encrypt = function(g, U, h) {
    for (var q = e.allocUnsafe(0), A; U.length; )
      if (g._cache.length === 0 && (g._cache = g._cipher.encryptBlock(g._prev), g._prev = e.allocUnsafe(0)), g._cache.length <= U.length)
        A = g._cache.length, q = e.concat([q, S(g, U.slice(0, A), h)]), U = U.slice(A);
      else {
        q = e.concat([q, S(g, U, h)]);
        break;
      }
    return q;
  }, cfb$1;
}
var cfb8$1 = {}, hasRequiredCfb8$1;
function requireCfb8$1() {
  if (hasRequiredCfb8$1)
    return cfb8$1;
  hasRequiredCfb8$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer;
  function o(S, g, U) {
    var h = S._cipher.encryptBlock(S._prev), q = h[0] ^ g;
    return S._prev = e.concat([
      S._prev.slice(1),
      e.from([U ? g : q])
    ]), q;
  }
  return cfb8$1.encrypt = function(S, g, U) {
    for (var h = g.length, q = e.allocUnsafe(h), A = -1; ++A < h; )
      q[A] = o(S, g[A], U);
    return q;
  }, cfb8$1;
}
var cfb1$1 = {}, hasRequiredCfb1$1;
function requireCfb1$1() {
  if (hasRequiredCfb1$1)
    return cfb1$1;
  hasRequiredCfb1$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer;
  function o(g, U, h) {
    for (var q, A = -1, P = 8, I = 0, B, H; ++A < P; )
      q = g._cipher.encryptBlock(g._prev), B = U & 1 << 7 - A ? 128 : 0, H = q[0] ^ B, I += (H & 128) >> A % 8, g._prev = S(g._prev, h ? B : H);
    return I;
  }
  function S(g, U) {
    var h = g.length, q = -1, A = e.allocUnsafe(g.length);
    for (g = e.concat([g, e.from([U])]); ++q < h; )
      A[q] = g[q] << 1 | g[q + 1] >> 7;
    return A;
  }
  return cfb1$1.encrypt = function(g, U, h) {
    for (var q = U.length, A = e.allocUnsafe(q), P = -1; ++P < q; )
      A[P] = o(g, U[P], h);
    return A;
  }, cfb1$1;
}
var ofb$1 = {}, hasRequiredOfb$1;
function requireOfb$1() {
  if (hasRequiredOfb$1)
    return ofb$1;
  hasRequiredOfb$1 = 1;
  var e = requireBufferXor$1();
  function o(S) {
    return S._prev = S._cipher.encryptBlock(S._prev), S._prev;
  }
  return ofb$1.encrypt = function(S, g) {
    for (; S._cache.length < g.length; )
      S._cache = bufferExports.Buffer.concat([S._cache, o(S)]);
    var U = S._cache.slice(0, g.length);
    return S._cache = S._cache.slice(g.length), e(g, U);
  }, ofb$1;
}
var ctr$1 = {}, incr32_1$1, hasRequiredIncr32$1;
function requireIncr32$1() {
  if (hasRequiredIncr32$1)
    return incr32_1$1;
  hasRequiredIncr32$1 = 1;
  function e(o) {
    for (var S = o.length, g; S--; )
      if (g = o.readUInt8(S), g === 255)
        o.writeUInt8(0, S);
      else {
        g++, o.writeUInt8(g, S);
        break;
      }
  }
  return incr32_1$1 = e, incr32_1$1;
}
var hasRequiredCtr$1;
function requireCtr$1() {
  if (hasRequiredCtr$1)
    return ctr$1;
  hasRequiredCtr$1 = 1;
  var e = requireBufferXor$1(), o = requireSafeBuffer$1$1().Buffer, S = requireIncr32$1();
  function g(h) {
    var q = h._cipher.encryptBlockRaw(h._prev);
    return S(h._prev), q;
  }
  var U = 16;
  return ctr$1.encrypt = function(h, q) {
    var A = Math.ceil(q.length / U), P = h._cache.length;
    h._cache = o.concat([
      h._cache,
      o.allocUnsafe(A * U)
    ]);
    for (var I = 0; I < A; I++) {
      var B = g(h), H = P + I * U;
      h._cache.writeUInt32BE(B[0], H + 0), h._cache.writeUInt32BE(B[1], H + 4), h._cache.writeUInt32BE(B[2], H + 8), h._cache.writeUInt32BE(B[3], H + 12);
    }
    var V = h._cache.slice(0, q.length);
    return h._cache = h._cache.slice(q.length), e(q, V);
  }, ctr$1;
}
const aes128$1 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192$1 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256$1 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2$1 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: aes128$1,
  aes192: aes192$1,
  aes256: aes256$1,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1$1, hasRequiredModes$1$1;
function requireModes$1$1() {
  if (hasRequiredModes$1$1)
    return modes_1$1;
  hasRequiredModes$1$1 = 1;
  var e = {
    ECB: requireEcb$1(),
    CBC: requireCbc$2(),
    CFB: requireCfb$1(),
    CFB8: requireCfb8$1(),
    CFB1: requireCfb1$1(),
    OFB: requireOfb$1(),
    CTR: requireCtr$1(),
    GCM: requireCtr$1()
  }, o = require$$2$1;
  for (var S in o)
    o[S].module = e[o[S].mode];
  return modes_1$1 = o, modes_1$1;
}
var aes$1 = {}, hasRequiredAes$1;
function requireAes$1() {
  if (hasRequiredAes$1)
    return aes$1;
  hasRequiredAes$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer;
  function o(A) {
    e.isBuffer(A) || (A = e.from(A));
    for (var P = A.length / 4 | 0, I = new Array(P), B = 0; B < P; B++)
      I[B] = A.readUInt32BE(B * 4);
    return I;
  }
  function S(A) {
    for (var P = 0; P < A.length; A++)
      A[P] = 0;
  }
  function g(A, P, I, B, H) {
    for (var V = I[0], X = I[1], Q = I[2], ee = I[3], ie = A[0] ^ P[0], te = A[1] ^ P[1], se = A[2] ^ P[2], le = A[3] ^ P[3], ce, pe, me, Me, Ee = 4, Re = 1; Re < H; Re++)
      ce = V[ie >>> 24] ^ X[te >>> 16 & 255] ^ Q[se >>> 8 & 255] ^ ee[le & 255] ^ P[Ee++], pe = V[te >>> 24] ^ X[se >>> 16 & 255] ^ Q[le >>> 8 & 255] ^ ee[ie & 255] ^ P[Ee++], me = V[se >>> 24] ^ X[le >>> 16 & 255] ^ Q[ie >>> 8 & 255] ^ ee[te & 255] ^ P[Ee++], Me = V[le >>> 24] ^ X[ie >>> 16 & 255] ^ Q[te >>> 8 & 255] ^ ee[se & 255] ^ P[Ee++], ie = ce, te = pe, se = me, le = Me;
    return ce = (B[ie >>> 24] << 24 | B[te >>> 16 & 255] << 16 | B[se >>> 8 & 255] << 8 | B[le & 255]) ^ P[Ee++], pe = (B[te >>> 24] << 24 | B[se >>> 16 & 255] << 16 | B[le >>> 8 & 255] << 8 | B[ie & 255]) ^ P[Ee++], me = (B[se >>> 24] << 24 | B[le >>> 16 & 255] << 16 | B[ie >>> 8 & 255] << 8 | B[te & 255]) ^ P[Ee++], Me = (B[le >>> 24] << 24 | B[ie >>> 16 & 255] << 16 | B[te >>> 8 & 255] << 8 | B[se & 255]) ^ P[Ee++], ce = ce >>> 0, pe = pe >>> 0, me = me >>> 0, Me = Me >>> 0, [ce, pe, me, Me];
  }
  var U = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], h = function() {
    for (var A = new Array(256), P = 0; P < 256; P++)
      P < 128 ? A[P] = P << 1 : A[P] = P << 1 ^ 283;
    for (var I = [], B = [], H = [[], [], [], []], V = [[], [], [], []], X = 0, Q = 0, ee = 0; ee < 256; ++ee) {
      var ie = Q ^ Q << 1 ^ Q << 2 ^ Q << 3 ^ Q << 4;
      ie = ie >>> 8 ^ ie & 255 ^ 99, I[X] = ie, B[ie] = X;
      var te = A[X], se = A[te], le = A[se], ce = A[ie] * 257 ^ ie * 16843008;
      H[0][X] = ce << 24 | ce >>> 8, H[1][X] = ce << 16 | ce >>> 16, H[2][X] = ce << 8 | ce >>> 24, H[3][X] = ce, ce = le * 16843009 ^ se * 65537 ^ te * 257 ^ X * 16843008, V[0][ie] = ce << 24 | ce >>> 8, V[1][ie] = ce << 16 | ce >>> 16, V[2][ie] = ce << 8 | ce >>> 24, V[3][ie] = ce, X === 0 ? X = Q = 1 : (X = te ^ A[A[A[le ^ te]]], Q ^= A[A[Q]]);
    }
    return {
      SBOX: I,
      INV_SBOX: B,
      SUB_MIX: H,
      INV_SUB_MIX: V
    };
  }();
  function q(A) {
    this._key = o(A), this._reset();
  }
  return q.blockSize = 4 * 4, q.keySize = 256 / 8, q.prototype.blockSize = q.blockSize, q.prototype.keySize = q.keySize, q.prototype._reset = function() {
    for (var A = this._key, P = A.length, I = P + 6, B = (I + 1) * 4, H = [], V = 0; V < P; V++)
      H[V] = A[V];
    for (V = P; V < B; V++) {
      var X = H[V - 1];
      V % P === 0 ? (X = X << 8 | X >>> 24, X = h.SBOX[X >>> 24] << 24 | h.SBOX[X >>> 16 & 255] << 16 | h.SBOX[X >>> 8 & 255] << 8 | h.SBOX[X & 255], X ^= U[V / P | 0] << 24) : P > 6 && V % P === 4 && (X = h.SBOX[X >>> 24] << 24 | h.SBOX[X >>> 16 & 255] << 16 | h.SBOX[X >>> 8 & 255] << 8 | h.SBOX[X & 255]), H[V] = H[V - P] ^ X;
    }
    for (var Q = [], ee = 0; ee < B; ee++) {
      var ie = B - ee, te = H[ie - (ee % 4 ? 0 : 4)];
      ee < 4 || ie <= 4 ? Q[ee] = te : Q[ee] = h.INV_SUB_MIX[0][h.SBOX[te >>> 24]] ^ h.INV_SUB_MIX[1][h.SBOX[te >>> 16 & 255]] ^ h.INV_SUB_MIX[2][h.SBOX[te >>> 8 & 255]] ^ h.INV_SUB_MIX[3][h.SBOX[te & 255]];
    }
    this._nRounds = I, this._keySchedule = H, this._invKeySchedule = Q;
  }, q.prototype.encryptBlockRaw = function(A) {
    return A = o(A), g(A, this._keySchedule, h.SUB_MIX, h.SBOX, this._nRounds);
  }, q.prototype.encryptBlock = function(A) {
    var P = this.encryptBlockRaw(A), I = e.allocUnsafe(16);
    return I.writeUInt32BE(P[0], 0), I.writeUInt32BE(P[1], 4), I.writeUInt32BE(P[2], 8), I.writeUInt32BE(P[3], 12), I;
  }, q.prototype.decryptBlock = function(A) {
    A = o(A);
    var P = A[1];
    A[1] = A[3], A[3] = P;
    var I = g(A, this._invKeySchedule, h.INV_SUB_MIX, h.INV_SBOX, this._nRounds), B = e.allocUnsafe(16);
    return B.writeUInt32BE(I[0], 0), B.writeUInt32BE(I[3], 4), B.writeUInt32BE(I[2], 8), B.writeUInt32BE(I[1], 12), B;
  }, q.prototype.scrub = function() {
    S(this._keySchedule), S(this._invKeySchedule), S(this._key);
  }, aes$1.AES = q, aes$1;
}
var ghash$1, hasRequiredGhash$1;
function requireGhash$1() {
  if (hasRequiredGhash$1)
    return ghash$1;
  hasRequiredGhash$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = e.alloc(16, 0);
  function S(h) {
    return [
      h.readUInt32BE(0),
      h.readUInt32BE(4),
      h.readUInt32BE(8),
      h.readUInt32BE(12)
    ];
  }
  function g(h) {
    var q = e.allocUnsafe(16);
    return q.writeUInt32BE(h[0] >>> 0, 0), q.writeUInt32BE(h[1] >>> 0, 4), q.writeUInt32BE(h[2] >>> 0, 8), q.writeUInt32BE(h[3] >>> 0, 12), q;
  }
  function U(h) {
    this.h = h, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return U.prototype.ghash = function(h) {
    for (var q = -1; ++q < h.length; )
      this.state[q] ^= h[q];
    this._multiply();
  }, U.prototype._multiply = function() {
    for (var h = S(this.h), q = [0, 0, 0, 0], A, P, I, B = -1; ++B < 128; ) {
      for (P = (this.state[~~(B / 8)] & 1 << 7 - B % 8) !== 0, P && (q[0] ^= h[0], q[1] ^= h[1], q[2] ^= h[2], q[3] ^= h[3]), I = (h[3] & 1) !== 0, A = 3; A > 0; A--)
        h[A] = h[A] >>> 1 | (h[A - 1] & 1) << 31;
      h[0] = h[0] >>> 1, I && (h[0] = h[0] ^ 225 << 24);
    }
    this.state = g(q);
  }, U.prototype.update = function(h) {
    this.cache = e.concat([this.cache, h]);
    for (var q; this.cache.length >= 16; )
      q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(q);
  }, U.prototype.final = function(h, q) {
    return this.cache.length && this.ghash(e.concat([this.cache, o], 16)), this.ghash(g([0, h, 0, q])), this.state;
  }, ghash$1 = U, ghash$1;
}
var authCipher$1, hasRequiredAuthCipher$1;
function requireAuthCipher$1() {
  if (hasRequiredAuthCipher$1)
    return authCipher$1;
  hasRequiredAuthCipher$1 = 1;
  var e = requireAes$1(), o = requireSafeBuffer$1$1().Buffer, S = requireCipherBase$1(), g = requireInherits_browser$1(), U = requireGhash$1(), h = requireBufferXor$1(), q = requireIncr32$1();
  function A(B, H) {
    var V = 0;
    B.length !== H.length && V++;
    for (var X = Math.min(B.length, H.length), Q = 0; Q < X; ++Q)
      V += B[Q] ^ H[Q];
    return V;
  }
  function P(B, H, V) {
    if (H.length === 12)
      return B._finID = o.concat([H, o.from([0, 0, 0, 1])]), o.concat([H, o.from([0, 0, 0, 2])]);
    var X = new U(V), Q = H.length, ee = Q % 16;
    X.update(H), ee && (ee = 16 - ee, X.update(o.alloc(ee, 0))), X.update(o.alloc(8, 0));
    var ie = Q * 8, te = o.alloc(8);
    te.writeUIntBE(ie, 0, 8), X.update(te), B._finID = X.state;
    var se = o.from(B._finID);
    return q(se), se;
  }
  function I(B, H, V, X) {
    S.call(this);
    var Q = o.alloc(4, 0);
    this._cipher = new e.AES(H);
    var ee = this._cipher.encryptBlock(Q);
    this._ghash = new U(ee), V = P(this, V, ee), this._prev = o.from(V), this._cache = o.allocUnsafe(0), this._secCache = o.allocUnsafe(0), this._decrypt = X, this._alen = 0, this._len = 0, this._mode = B, this._authTag = null, this._called = !1;
  }
  return g(I, S), I.prototype._update = function(B) {
    if (!this._called && this._alen) {
      var H = 16 - this._alen % 16;
      H < 16 && (H = o.alloc(H, 0), this._ghash.update(H));
    }
    this._called = !0;
    var V = this._mode.encrypt(this, B);
    return this._decrypt ? this._ghash.update(B) : this._ghash.update(V), this._len += B.length, V;
  }, I.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var B = h(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && A(B, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = B, this._cipher.scrub();
  }, I.prototype.getAuthTag = function() {
    if (this._decrypt || !o.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, I.prototype.setAuthTag = function(B) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = B;
  }, I.prototype.setAAD = function(B) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(B), this._alen += B.length;
  }, authCipher$1 = I, authCipher$1;
}
var streamCipher$1, hasRequiredStreamCipher$1;
function requireStreamCipher$1() {
  if (hasRequiredStreamCipher$1)
    return streamCipher$1;
  hasRequiredStreamCipher$1 = 1;
  var e = requireAes$1(), o = requireSafeBuffer$1$1().Buffer, S = requireCipherBase$1(), g = requireInherits_browser$1();
  function U(h, q, A, P) {
    S.call(this), this._cipher = new e.AES(q), this._prev = o.from(A), this._cache = o.allocUnsafe(0), this._secCache = o.allocUnsafe(0), this._decrypt = P, this._mode = h;
  }
  return g(U, S), U.prototype._update = function(h) {
    return this._mode.encrypt(this, h, this._decrypt);
  }, U.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher$1 = U, streamCipher$1;
}
var evp_bytestokey$1, hasRequiredEvp_bytestokey$1;
function requireEvp_bytestokey$1() {
  if (hasRequiredEvp_bytestokey$1)
    return evp_bytestokey$1;
  hasRequiredEvp_bytestokey$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireMd5_js$1();
  function S(g, U, h, q) {
    if (e.isBuffer(g) || (g = e.from(g, "binary")), U && (e.isBuffer(U) || (U = e.from(U, "binary")), U.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var A = h / 8, P = e.alloc(A), I = e.alloc(q || 0), B = e.alloc(0); A > 0 || q > 0; ) {
      var H = new o();
      H.update(B), H.update(g), U && H.update(U), B = H.digest();
      var V = 0;
      if (A > 0) {
        var X = P.length - A;
        V = Math.min(A, B.length), B.copy(P, X, 0, V), A -= V;
      }
      if (V < B.length && q > 0) {
        var Q = I.length - q, ee = Math.min(q, B.length - V);
        B.copy(I, Q, V, V + ee), q -= ee;
      }
    }
    return B.fill(0), { key: P, iv: I };
  }
  return evp_bytestokey$1 = S, evp_bytestokey$1;
}
var hasRequiredEncrypter$1;
function requireEncrypter$1() {
  if (hasRequiredEncrypter$1)
    return encrypter$1;
  hasRequiredEncrypter$1 = 1;
  var e = requireModes$1$1(), o = requireAuthCipher$1(), S = requireSafeBuffer$1$1().Buffer, g = requireStreamCipher$1(), U = requireCipherBase$1(), h = requireAes$1(), q = requireEvp_bytestokey$1(), A = requireInherits_browser$1();
  function P(X, Q, ee) {
    U.call(this), this._cache = new B(), this._cipher = new h.AES(Q), this._prev = S.from(ee), this._mode = X, this._autopadding = !0;
  }
  A(P, U), P.prototype._update = function(X) {
    this._cache.add(X);
    for (var Q, ee, ie = []; Q = this._cache.get(); )
      ee = this._mode.encrypt(this, Q), ie.push(ee);
    return S.concat(ie);
  };
  var I = S.alloc(16, 16);
  P.prototype._final = function() {
    var X = this._cache.flush();
    if (this._autopadding)
      return X = this._mode.encrypt(this, X), this._cipher.scrub(), X;
    if (!X.equals(I))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, P.prototype.setAutoPadding = function(X) {
    return this._autopadding = !!X, this;
  };
  function B() {
    this.cache = S.allocUnsafe(0);
  }
  B.prototype.add = function(X) {
    this.cache = S.concat([this.cache, X]);
  }, B.prototype.get = function() {
    if (this.cache.length > 15) {
      var X = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), X;
    }
    return null;
  }, B.prototype.flush = function() {
    for (var X = 16 - this.cache.length, Q = S.allocUnsafe(X), ee = -1; ++ee < X; )
      Q.writeUInt8(X, ee);
    return S.concat([this.cache, Q]);
  };
  function H(X, Q, ee) {
    var ie = e[X.toLowerCase()];
    if (!ie)
      throw new TypeError("invalid suite type");
    if (typeof Q == "string" && (Q = S.from(Q)), Q.length !== ie.key / 8)
      throw new TypeError("invalid key length " + Q.length);
    if (typeof ee == "string" && (ee = S.from(ee)), ie.mode !== "GCM" && ee.length !== ie.iv)
      throw new TypeError("invalid iv length " + ee.length);
    return ie.type === "stream" ? new g(ie.module, Q, ee) : ie.type === "auth" ? new o(ie.module, Q, ee) : new P(ie.module, Q, ee);
  }
  function V(X, Q) {
    var ee = e[X.toLowerCase()];
    if (!ee)
      throw new TypeError("invalid suite type");
    var ie = q(Q, !1, ee.key, ee.iv);
    return H(X, ie.key, ie.iv);
  }
  return encrypter$1.createCipheriv = H, encrypter$1.createCipher = V, encrypter$1;
}
var decrypter$1 = {}, hasRequiredDecrypter$1;
function requireDecrypter$1() {
  if (hasRequiredDecrypter$1)
    return decrypter$1;
  hasRequiredDecrypter$1 = 1;
  var e = requireAuthCipher$1(), o = requireSafeBuffer$1$1().Buffer, S = requireModes$1$1(), g = requireStreamCipher$1(), U = requireCipherBase$1(), h = requireAes$1(), q = requireEvp_bytestokey$1(), A = requireInherits_browser$1();
  function P(X, Q, ee) {
    U.call(this), this._cache = new I(), this._last = void 0, this._cipher = new h.AES(Q), this._prev = o.from(ee), this._mode = X, this._autopadding = !0;
  }
  A(P, U), P.prototype._update = function(X) {
    this._cache.add(X);
    for (var Q, ee, ie = []; Q = this._cache.get(this._autopadding); )
      ee = this._mode.decrypt(this, Q), ie.push(ee);
    return o.concat(ie);
  }, P.prototype._final = function() {
    var X = this._cache.flush();
    if (this._autopadding)
      return B(this._mode.decrypt(this, X));
    if (X)
      throw new Error("data not multiple of block length");
  }, P.prototype.setAutoPadding = function(X) {
    return this._autopadding = !!X, this;
  };
  function I() {
    this.cache = o.allocUnsafe(0);
  }
  I.prototype.add = function(X) {
    this.cache = o.concat([this.cache, X]);
  }, I.prototype.get = function(X) {
    var Q;
    if (X) {
      if (this.cache.length > 16)
        return Q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Q;
    } else if (this.cache.length >= 16)
      return Q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Q;
    return null;
  }, I.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function B(X) {
    var Q = X[15];
    if (Q < 1 || Q > 16)
      throw new Error("unable to decrypt data");
    for (var ee = -1; ++ee < Q; )
      if (X[ee + (16 - Q)] !== Q)
        throw new Error("unable to decrypt data");
    if (Q !== 16)
      return X.slice(0, 16 - Q);
  }
  function H(X, Q, ee) {
    var ie = S[X.toLowerCase()];
    if (!ie)
      throw new TypeError("invalid suite type");
    if (typeof ee == "string" && (ee = o.from(ee)), ie.mode !== "GCM" && ee.length !== ie.iv)
      throw new TypeError("invalid iv length " + ee.length);
    if (typeof Q == "string" && (Q = o.from(Q)), Q.length !== ie.key / 8)
      throw new TypeError("invalid key length " + Q.length);
    return ie.type === "stream" ? new g(ie.module, Q, ee, !0) : ie.type === "auth" ? new e(ie.module, Q, ee, !0) : new P(ie.module, Q, ee);
  }
  function V(X, Q) {
    var ee = S[X.toLowerCase()];
    if (!ee)
      throw new TypeError("invalid suite type");
    var ie = q(Q, !1, ee.key, ee.iv);
    return H(X, ie.key, ie.iv);
  }
  return decrypter$1.createDecipher = V, decrypter$1.createDecipheriv = H, decrypter$1;
}
var hasRequiredBrowser$6$1;
function requireBrowser$6$1() {
  if (hasRequiredBrowser$6$1)
    return browser$5$1;
  hasRequiredBrowser$6$1 = 1;
  var e = requireEncrypter$1(), o = requireDecrypter$1(), S = require$$2$1;
  function g() {
    return Object.keys(S);
  }
  return browser$5$1.createCipher = browser$5$1.Cipher = e.createCipher, browser$5$1.createCipheriv = browser$5$1.Cipheriv = e.createCipheriv, browser$5$1.createDecipher = browser$5$1.Decipher = o.createDecipher, browser$5$1.createDecipheriv = browser$5$1.Decipheriv = o.createDecipheriv, browser$5$1.listCiphers = browser$5$1.getCiphers = g, browser$5$1;
}
var modes$1 = {}, hasRequiredModes$2;
function requireModes$2() {
  return hasRequiredModes$2 || (hasRequiredModes$2 = 1, function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes$1)), modes$1;
}
var hasRequiredBrowser$5$1;
function requireBrowser$5$1() {
  if (hasRequiredBrowser$5$1)
    return browser$6$1;
  hasRequiredBrowser$5$1 = 1;
  var e = requireBrowserifyDes$1(), o = requireBrowser$6$1(), S = requireModes$1$1(), g = requireModes$2(), U = requireEvp_bytestokey$1();
  function h(B, H) {
    B = B.toLowerCase();
    var V, X;
    if (S[B])
      V = S[B].key, X = S[B].iv;
    else if (g[B])
      V = g[B].key * 8, X = g[B].iv;
    else
      throw new TypeError("invalid suite type");
    var Q = U(H, !1, V, X);
    return A(B, Q.key, Q.iv);
  }
  function q(B, H) {
    B = B.toLowerCase();
    var V, X;
    if (S[B])
      V = S[B].key, X = S[B].iv;
    else if (g[B])
      V = g[B].key * 8, X = g[B].iv;
    else
      throw new TypeError("invalid suite type");
    var Q = U(H, !1, V, X);
    return P(B, Q.key, Q.iv);
  }
  function A(B, H, V) {
    if (B = B.toLowerCase(), S[B])
      return o.createCipheriv(B, H, V);
    if (g[B])
      return new e({ key: H, iv: V, mode: B });
    throw new TypeError("invalid suite type");
  }
  function P(B, H, V) {
    if (B = B.toLowerCase(), S[B])
      return o.createDecipheriv(B, H, V);
    if (g[B])
      return new e({ key: H, iv: V, mode: B, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function I() {
    return Object.keys(g).concat(o.getCiphers());
  }
  return browser$6$1.createCipher = browser$6$1.Cipher = h, browser$6$1.createCipheriv = browser$6$1.Cipheriv = A, browser$6$1.createDecipher = browser$6$1.Decipher = q, browser$6$1.createDecipheriv = browser$6$1.Decipheriv = P, browser$6$1.listCiphers = browser$6$1.getCiphers = I, browser$6$1;
}
var browser$4$1 = {}, bn$2$1 = { exports: {} }, hasRequiredBn$2;
function requireBn$2() {
  return hasRequiredBn$2 || (hasRequiredBn$2 = 1, function(e) {
    (function(o, S) {
      function g(ne, Y) {
        if (!ne)
          throw new Error(Y || "Assertion failed");
      }
      function U(ne, Y) {
        ne.super_ = Y;
        var M = function() {
        };
        M.prototype = Y.prototype, ne.prototype = new M(), ne.prototype.constructor = ne;
      }
      function h(ne, Y, M) {
        if (h.isBN(ne))
          return ne;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, ne !== null && ((Y === "le" || Y === "be") && (M = Y, Y = 10), this._init(ne || 0, Y || 10, M || "be"));
      }
      typeof o == "object" ? o.exports = h : S.BN = h, h.BN = h, h.wordSize = 26;
      var q;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? q = window.Buffer : q = requireBuffer$1().Buffer;
      } catch {
      }
      h.isBN = function(ne) {
        return ne instanceof h ? !0 : ne !== null && typeof ne == "object" && ne.constructor.wordSize === h.wordSize && Array.isArray(ne.words);
      }, h.max = function(ne, Y) {
        return ne.cmp(Y) > 0 ? ne : Y;
      }, h.min = function(ne, Y) {
        return ne.cmp(Y) < 0 ? ne : Y;
      }, h.prototype._init = function(ne, Y, M) {
        if (typeof ne == "number")
          return this._initNumber(ne, Y, M);
        if (typeof ne == "object")
          return this._initArray(ne, Y, M);
        Y === "hex" && (Y = 16), g(Y === (Y | 0) && Y >= 2 && Y <= 36), ne = ne.toString().replace(/\s+/g, "");
        var $ = 0;
        ne[0] === "-" && ($++, this.negative = 1), $ < ne.length && (Y === 16 ? this._parseHex(ne, $, M) : (this._parseBase(ne, Y, $), M === "le" && this._initArray(this.toArray(), Y, M)));
      }, h.prototype._initNumber = function(ne, Y, M) {
        ne < 0 && (this.negative = 1, ne = -ne), ne < 67108864 ? (this.words = [ne & 67108863], this.length = 1) : ne < 4503599627370496 ? (this.words = [
          ne & 67108863,
          ne / 67108864 & 67108863
        ], this.length = 2) : (g(ne < 9007199254740992), this.words = [
          ne & 67108863,
          ne / 67108864 & 67108863,
          1
        ], this.length = 3), M === "le" && this._initArray(this.toArray(), Y, M);
      }, h.prototype._initArray = function(ne, Y, M) {
        if (g(typeof ne.length == "number"), ne.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(ne.length / 3), this.words = new Array(this.length);
        for (var $ = 0; $ < this.length; $++)
          this.words[$] = 0;
        var O, J, Z = 0;
        if (M === "be")
          for ($ = ne.length - 1, O = 0; $ >= 0; $ -= 3)
            J = ne[$] | ne[$ - 1] << 8 | ne[$ - 2] << 16, this.words[O] |= J << Z & 67108863, this.words[O + 1] = J >>> 26 - Z & 67108863, Z += 24, Z >= 26 && (Z -= 26, O++);
        else if (M === "le")
          for ($ = 0, O = 0; $ < ne.length; $ += 3)
            J = ne[$] | ne[$ + 1] << 8 | ne[$ + 2] << 16, this.words[O] |= J << Z & 67108863, this.words[O + 1] = J >>> 26 - Z & 67108863, Z += 24, Z >= 26 && (Z -= 26, O++);
        return this.strip();
      };
      function A(ne, Y) {
        var M = ne.charCodeAt(Y);
        return M >= 65 && M <= 70 ? M - 55 : M >= 97 && M <= 102 ? M - 87 : M - 48 & 15;
      }
      function P(ne, Y, M) {
        var $ = A(ne, M);
        return M - 1 >= Y && ($ |= A(ne, M - 1) << 4), $;
      }
      h.prototype._parseHex = function(ne, Y, M) {
        this.length = Math.ceil((ne.length - Y) / 6), this.words = new Array(this.length);
        for (var $ = 0; $ < this.length; $++)
          this.words[$] = 0;
        var O = 0, J = 0, Z;
        if (M === "be")
          for ($ = ne.length - 1; $ >= Y; $ -= 2)
            Z = P(ne, Y, $) << O, this.words[J] |= Z & 67108863, O >= 18 ? (O -= 18, J += 1, this.words[J] |= Z >>> 26) : O += 8;
        else {
          var K = ne.length - Y;
          for ($ = K % 2 === 0 ? Y + 1 : Y; $ < ne.length; $ += 2)
            Z = P(ne, Y, $) << O, this.words[J] |= Z & 67108863, O >= 18 ? (O -= 18, J += 1, this.words[J] |= Z >>> 26) : O += 8;
        }
        this.strip();
      };
      function I(ne, Y, M, $) {
        for (var O = 0, J = Math.min(ne.length, M), Z = Y; Z < J; Z++) {
          var K = ne.charCodeAt(Z) - 48;
          O *= $, K >= 49 ? O += K - 49 + 10 : K >= 17 ? O += K - 17 + 10 : O += K;
        }
        return O;
      }
      h.prototype._parseBase = function(ne, Y, M) {
        this.words = [0], this.length = 1;
        for (var $ = 0, O = 1; O <= 67108863; O *= Y)
          $++;
        $--, O = O / Y | 0;
        for (var J = ne.length - M, Z = J % $, K = Math.min(J, J - Z) + M, z = 0, G = M; G < K; G += $)
          z = I(ne, G, G + $, Y), this.imuln(O), this.words[0] + z < 67108864 ? this.words[0] += z : this._iaddn(z);
        if (Z !== 0) {
          var D = 1;
          for (z = I(ne, G, ne.length, Y), G = 0; G < Z; G++)
            D *= Y;
          this.imuln(D), this.words[0] + z < 67108864 ? this.words[0] += z : this._iaddn(z);
        }
        this.strip();
      }, h.prototype.copy = function(ne) {
        ne.words = new Array(this.length);
        for (var Y = 0; Y < this.length; Y++)
          ne.words[Y] = this.words[Y];
        ne.length = this.length, ne.negative = this.negative, ne.red = this.red;
      }, h.prototype.clone = function() {
        var ne = new h(null);
        return this.copy(ne), ne;
      }, h.prototype._expand = function(ne) {
        for (; this.length < ne; )
          this.words[this.length++] = 0;
        return this;
      }, h.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, h.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, h.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var B = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], H = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], V = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      h.prototype.toString = function(ne, Y) {
        ne = ne || 10, Y = Y | 0 || 1;
        var M;
        if (ne === 16 || ne === "hex") {
          M = "";
          for (var $ = 0, O = 0, J = 0; J < this.length; J++) {
            var Z = this.words[J], K = ((Z << $ | O) & 16777215).toString(16);
            O = Z >>> 24 - $ & 16777215, O !== 0 || J !== this.length - 1 ? M = B[6 - K.length] + K + M : M = K + M, $ += 2, $ >= 26 && ($ -= 26, J--);
          }
          for (O !== 0 && (M = O.toString(16) + M); M.length % Y !== 0; )
            M = "0" + M;
          return this.negative !== 0 && (M = "-" + M), M;
        }
        if (ne === (ne | 0) && ne >= 2 && ne <= 36) {
          var z = H[ne], G = V[ne];
          M = "";
          var D = this.clone();
          for (D.negative = 0; !D.isZero(); ) {
            var F = D.modn(G).toString(ne);
            D = D.idivn(G), D.isZero() ? M = F + M : M = B[z - F.length] + F + M;
          }
          for (this.isZero() && (M = "0" + M); M.length % Y !== 0; )
            M = "0" + M;
          return this.negative !== 0 && (M = "-" + M), M;
        }
        g(!1, "Base should be between 2 and 36");
      }, h.prototype.toNumber = function() {
        var ne = this.words[0];
        return this.length === 2 ? ne += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ne += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && g(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ne : ne;
      }, h.prototype.toJSON = function() {
        return this.toString(16);
      }, h.prototype.toBuffer = function(ne, Y) {
        return g(typeof q < "u"), this.toArrayLike(q, ne, Y);
      }, h.prototype.toArray = function(ne, Y) {
        return this.toArrayLike(Array, ne, Y);
      }, h.prototype.toArrayLike = function(ne, Y, M) {
        var $ = this.byteLength(), O = M || Math.max(1, $);
        g($ <= O, "byte array longer than desired length"), g(O > 0, "Requested array length <= 0"), this.strip();
        var J = Y === "le", Z = new ne(O), K, z, G = this.clone();
        if (J) {
          for (z = 0; !G.isZero(); z++)
            K = G.andln(255), G.iushrn(8), Z[z] = K;
          for (; z < O; z++)
            Z[z] = 0;
        } else {
          for (z = 0; z < O - $; z++)
            Z[z] = 0;
          for (z = 0; !G.isZero(); z++)
            K = G.andln(255), G.iushrn(8), Z[O - z - 1] = K;
        }
        return Z;
      }, Math.clz32 ? h.prototype._countBits = function(ne) {
        return 32 - Math.clz32(ne);
      } : h.prototype._countBits = function(ne) {
        var Y = ne, M = 0;
        return Y >= 4096 && (M += 13, Y >>>= 13), Y >= 64 && (M += 7, Y >>>= 7), Y >= 8 && (M += 4, Y >>>= 4), Y >= 2 && (M += 2, Y >>>= 2), M + Y;
      }, h.prototype._zeroBits = function(ne) {
        if (ne === 0)
          return 26;
        var Y = ne, M = 0;
        return Y & 8191 || (M += 13, Y >>>= 13), Y & 127 || (M += 7, Y >>>= 7), Y & 15 || (M += 4, Y >>>= 4), Y & 3 || (M += 2, Y >>>= 2), Y & 1 || M++, M;
      }, h.prototype.bitLength = function() {
        var ne = this.words[this.length - 1], Y = this._countBits(ne);
        return (this.length - 1) * 26 + Y;
      };
      function X(ne) {
        for (var Y = new Array(ne.bitLength()), M = 0; M < Y.length; M++) {
          var $ = M / 26 | 0, O = M % 26;
          Y[M] = (ne.words[$] & 1 << O) >>> O;
        }
        return Y;
      }
      h.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var ne = 0, Y = 0; Y < this.length; Y++) {
          var M = this._zeroBits(this.words[Y]);
          if (ne += M, M !== 26)
            break;
        }
        return ne;
      }, h.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, h.prototype.toTwos = function(ne) {
        return this.negative !== 0 ? this.abs().inotn(ne).iaddn(1) : this.clone();
      }, h.prototype.fromTwos = function(ne) {
        return this.testn(ne - 1) ? this.notn(ne).iaddn(1).ineg() : this.clone();
      }, h.prototype.isNeg = function() {
        return this.negative !== 0;
      }, h.prototype.neg = function() {
        return this.clone().ineg();
      }, h.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, h.prototype.iuor = function(ne) {
        for (; this.length < ne.length; )
          this.words[this.length++] = 0;
        for (var Y = 0; Y < ne.length; Y++)
          this.words[Y] = this.words[Y] | ne.words[Y];
        return this.strip();
      }, h.prototype.ior = function(ne) {
        return g((this.negative | ne.negative) === 0), this.iuor(ne);
      }, h.prototype.or = function(ne) {
        return this.length > ne.length ? this.clone().ior(ne) : ne.clone().ior(this);
      }, h.prototype.uor = function(ne) {
        return this.length > ne.length ? this.clone().iuor(ne) : ne.clone().iuor(this);
      }, h.prototype.iuand = function(ne) {
        var Y;
        this.length > ne.length ? Y = ne : Y = this;
        for (var M = 0; M < Y.length; M++)
          this.words[M] = this.words[M] & ne.words[M];
        return this.length = Y.length, this.strip();
      }, h.prototype.iand = function(ne) {
        return g((this.negative | ne.negative) === 0), this.iuand(ne);
      }, h.prototype.and = function(ne) {
        return this.length > ne.length ? this.clone().iand(ne) : ne.clone().iand(this);
      }, h.prototype.uand = function(ne) {
        return this.length > ne.length ? this.clone().iuand(ne) : ne.clone().iuand(this);
      }, h.prototype.iuxor = function(ne) {
        var Y, M;
        this.length > ne.length ? (Y = this, M = ne) : (Y = ne, M = this);
        for (var $ = 0; $ < M.length; $++)
          this.words[$] = Y.words[$] ^ M.words[$];
        if (this !== Y)
          for (; $ < Y.length; $++)
            this.words[$] = Y.words[$];
        return this.length = Y.length, this.strip();
      }, h.prototype.ixor = function(ne) {
        return g((this.negative | ne.negative) === 0), this.iuxor(ne);
      }, h.prototype.xor = function(ne) {
        return this.length > ne.length ? this.clone().ixor(ne) : ne.clone().ixor(this);
      }, h.prototype.uxor = function(ne) {
        return this.length > ne.length ? this.clone().iuxor(ne) : ne.clone().iuxor(this);
      }, h.prototype.inotn = function(ne) {
        g(typeof ne == "number" && ne >= 0);
        var Y = Math.ceil(ne / 26) | 0, M = ne % 26;
        this._expand(Y), M > 0 && Y--;
        for (var $ = 0; $ < Y; $++)
          this.words[$] = ~this.words[$] & 67108863;
        return M > 0 && (this.words[$] = ~this.words[$] & 67108863 >> 26 - M), this.strip();
      }, h.prototype.notn = function(ne) {
        return this.clone().inotn(ne);
      }, h.prototype.setn = function(ne, Y) {
        g(typeof ne == "number" && ne >= 0);
        var M = ne / 26 | 0, $ = ne % 26;
        return this._expand(M + 1), Y ? this.words[M] = this.words[M] | 1 << $ : this.words[M] = this.words[M] & ~(1 << $), this.strip();
      }, h.prototype.iadd = function(ne) {
        var Y;
        if (this.negative !== 0 && ne.negative === 0)
          return this.negative = 0, Y = this.isub(ne), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && ne.negative !== 0)
          return ne.negative = 0, Y = this.isub(ne), ne.negative = 1, Y._normSign();
        var M, $;
        this.length > ne.length ? (M = this, $ = ne) : (M = ne, $ = this);
        for (var O = 0, J = 0; J < $.length; J++)
          Y = (M.words[J] | 0) + ($.words[J] | 0) + O, this.words[J] = Y & 67108863, O = Y >>> 26;
        for (; O !== 0 && J < M.length; J++)
          Y = (M.words[J] | 0) + O, this.words[J] = Y & 67108863, O = Y >>> 26;
        if (this.length = M.length, O !== 0)
          this.words[this.length] = O, this.length++;
        else if (M !== this)
          for (; J < M.length; J++)
            this.words[J] = M.words[J];
        return this;
      }, h.prototype.add = function(ne) {
        var Y;
        return ne.negative !== 0 && this.negative === 0 ? (ne.negative = 0, Y = this.sub(ne), ne.negative ^= 1, Y) : ne.negative === 0 && this.negative !== 0 ? (this.negative = 0, Y = ne.sub(this), this.negative = 1, Y) : this.length > ne.length ? this.clone().iadd(ne) : ne.clone().iadd(this);
      }, h.prototype.isub = function(ne) {
        if (ne.negative !== 0) {
          ne.negative = 0;
          var Y = this.iadd(ne);
          return ne.negative = 1, Y._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(ne), this.negative = 1, this._normSign();
        var M = this.cmp(ne);
        if (M === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var $, O;
        M > 0 ? ($ = this, O = ne) : ($ = ne, O = this);
        for (var J = 0, Z = 0; Z < O.length; Z++)
          Y = ($.words[Z] | 0) - (O.words[Z] | 0) + J, J = Y >> 26, this.words[Z] = Y & 67108863;
        for (; J !== 0 && Z < $.length; Z++)
          Y = ($.words[Z] | 0) + J, J = Y >> 26, this.words[Z] = Y & 67108863;
        if (J === 0 && Z < $.length && $ !== this)
          for (; Z < $.length; Z++)
            this.words[Z] = $.words[Z];
        return this.length = Math.max(this.length, Z), $ !== this && (this.negative = 1), this.strip();
      }, h.prototype.sub = function(ne) {
        return this.clone().isub(ne);
      };
      function Q(ne, Y, M) {
        M.negative = Y.negative ^ ne.negative;
        var $ = ne.length + Y.length | 0;
        M.length = $, $ = $ - 1 | 0;
        var O = ne.words[0] | 0, J = Y.words[0] | 0, Z = O * J, K = Z & 67108863, z = Z / 67108864 | 0;
        M.words[0] = K;
        for (var G = 1; G < $; G++) {
          for (var D = z >>> 26, F = z & 67108863, ae = Math.min(G, Y.length - 1), ge = Math.max(0, G - ne.length + 1); ge <= ae; ge++) {
            var xe = G - ge | 0;
            O = ne.words[xe] | 0, J = Y.words[ge] | 0, Z = O * J + F, D += Z / 67108864 | 0, F = Z & 67108863;
          }
          M.words[G] = F | 0, z = D | 0;
        }
        return z !== 0 ? M.words[G] = z | 0 : M.length--, M.strip();
      }
      var ee = function(ne, Y, M) {
        var $ = ne.words, O = Y.words, J = M.words, Z = 0, K, z, G, D = $[0] | 0, F = D & 8191, ae = D >>> 13, ge = $[1] | 0, xe = ge & 8191, ye = ge >>> 13, oe = $[2] | 0, fe = oe & 8191, $e = oe >>> 13, Be = $[3] | 0, be = Be & 8191, ve = Be >>> 13, qe = $[4] | 0, De = qe & 8191, Ye = qe >>> 13, he = $[5] | 0, ue = he & 8191, de = he >>> 13, _e = $[6] | 0, Pe = _e & 8191, He = _e >>> 13, Ve = $[7] | 0, nt = Ve & 8191, Ie = Ve >>> 13, Fe = $[8] | 0, je = Fe & 8191, Ke = Fe >>> 13, ot = $[9] | 0, ut = ot & 8191, pt = ot >>> 13, ke = O[0] | 0, Xe = ke & 8191, at = ke >>> 13, ht = O[1] | 0, We = ht & 8191, tt = ht >>> 13, Te = O[2] | 0, rt = Te & 8191, mt = Te >>> 13, Se = O[3] | 0, et = Se & 8191, Ze = Se >>> 13, Le = O[4] | 0, ze = Le & 8191, Qe = Le >>> 13, _t = O[5] | 0, ft = _t & 8191, dt = _t >>> 13, Mt = O[6] | 0, St = Mt & 8191, $t = Mt >>> 13, At = O[7] | 0, Ae = At & 8191, Ce = At >>> 13, Oe = O[8] | 0, we = Oe & 8191, Ue = Oe >>> 13, Je = O[9] | 0, Ge = Je & 8191, st = Je >>> 13;
        M.negative = ne.negative ^ Y.negative, M.length = 19, K = Math.imul(F, Xe), z = Math.imul(F, at), z = z + Math.imul(ae, Xe) | 0, G = Math.imul(ae, at);
        var ct = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, K = Math.imul(xe, Xe), z = Math.imul(xe, at), z = z + Math.imul(ye, Xe) | 0, G = Math.imul(ye, at), K = K + Math.imul(F, We) | 0, z = z + Math.imul(F, tt) | 0, z = z + Math.imul(ae, We) | 0, G = G + Math.imul(ae, tt) | 0;
        var bt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, K = Math.imul(fe, Xe), z = Math.imul(fe, at), z = z + Math.imul($e, Xe) | 0, G = Math.imul($e, at), K = K + Math.imul(xe, We) | 0, z = z + Math.imul(xe, tt) | 0, z = z + Math.imul(ye, We) | 0, G = G + Math.imul(ye, tt) | 0, K = K + Math.imul(F, rt) | 0, z = z + Math.imul(F, mt) | 0, z = z + Math.imul(ae, rt) | 0, G = G + Math.imul(ae, mt) | 0;
        var wt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, K = Math.imul(be, Xe), z = Math.imul(be, at), z = z + Math.imul(ve, Xe) | 0, G = Math.imul(ve, at), K = K + Math.imul(fe, We) | 0, z = z + Math.imul(fe, tt) | 0, z = z + Math.imul($e, We) | 0, G = G + Math.imul($e, tt) | 0, K = K + Math.imul(xe, rt) | 0, z = z + Math.imul(xe, mt) | 0, z = z + Math.imul(ye, rt) | 0, G = G + Math.imul(ye, mt) | 0, K = K + Math.imul(F, et) | 0, z = z + Math.imul(F, Ze) | 0, z = z + Math.imul(ae, et) | 0, G = G + Math.imul(ae, Ze) | 0;
        var zt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, K = Math.imul(De, Xe), z = Math.imul(De, at), z = z + Math.imul(Ye, Xe) | 0, G = Math.imul(Ye, at), K = K + Math.imul(be, We) | 0, z = z + Math.imul(be, tt) | 0, z = z + Math.imul(ve, We) | 0, G = G + Math.imul(ve, tt) | 0, K = K + Math.imul(fe, rt) | 0, z = z + Math.imul(fe, mt) | 0, z = z + Math.imul($e, rt) | 0, G = G + Math.imul($e, mt) | 0, K = K + Math.imul(xe, et) | 0, z = z + Math.imul(xe, Ze) | 0, z = z + Math.imul(ye, et) | 0, G = G + Math.imul(ye, Ze) | 0, K = K + Math.imul(F, ze) | 0, z = z + Math.imul(F, Qe) | 0, z = z + Math.imul(ae, ze) | 0, G = G + Math.imul(ae, Qe) | 0;
        var Tt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, K = Math.imul(ue, Xe), z = Math.imul(ue, at), z = z + Math.imul(de, Xe) | 0, G = Math.imul(de, at), K = K + Math.imul(De, We) | 0, z = z + Math.imul(De, tt) | 0, z = z + Math.imul(Ye, We) | 0, G = G + Math.imul(Ye, tt) | 0, K = K + Math.imul(be, rt) | 0, z = z + Math.imul(be, mt) | 0, z = z + Math.imul(ve, rt) | 0, G = G + Math.imul(ve, mt) | 0, K = K + Math.imul(fe, et) | 0, z = z + Math.imul(fe, Ze) | 0, z = z + Math.imul($e, et) | 0, G = G + Math.imul($e, Ze) | 0, K = K + Math.imul(xe, ze) | 0, z = z + Math.imul(xe, Qe) | 0, z = z + Math.imul(ye, ze) | 0, G = G + Math.imul(ye, Qe) | 0, K = K + Math.imul(F, ft) | 0, z = z + Math.imul(F, dt) | 0, z = z + Math.imul(ae, ft) | 0, G = G + Math.imul(ae, dt) | 0;
        var Lt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, K = Math.imul(Pe, Xe), z = Math.imul(Pe, at), z = z + Math.imul(He, Xe) | 0, G = Math.imul(He, at), K = K + Math.imul(ue, We) | 0, z = z + Math.imul(ue, tt) | 0, z = z + Math.imul(de, We) | 0, G = G + Math.imul(de, tt) | 0, K = K + Math.imul(De, rt) | 0, z = z + Math.imul(De, mt) | 0, z = z + Math.imul(Ye, rt) | 0, G = G + Math.imul(Ye, mt) | 0, K = K + Math.imul(be, et) | 0, z = z + Math.imul(be, Ze) | 0, z = z + Math.imul(ve, et) | 0, G = G + Math.imul(ve, Ze) | 0, K = K + Math.imul(fe, ze) | 0, z = z + Math.imul(fe, Qe) | 0, z = z + Math.imul($e, ze) | 0, G = G + Math.imul($e, Qe) | 0, K = K + Math.imul(xe, ft) | 0, z = z + Math.imul(xe, dt) | 0, z = z + Math.imul(ye, ft) | 0, G = G + Math.imul(ye, dt) | 0, K = K + Math.imul(F, St) | 0, z = z + Math.imul(F, $t) | 0, z = z + Math.imul(ae, St) | 0, G = G + Math.imul(ae, $t) | 0;
        var jt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, K = Math.imul(nt, Xe), z = Math.imul(nt, at), z = z + Math.imul(Ie, Xe) | 0, G = Math.imul(Ie, at), K = K + Math.imul(Pe, We) | 0, z = z + Math.imul(Pe, tt) | 0, z = z + Math.imul(He, We) | 0, G = G + Math.imul(He, tt) | 0, K = K + Math.imul(ue, rt) | 0, z = z + Math.imul(ue, mt) | 0, z = z + Math.imul(de, rt) | 0, G = G + Math.imul(de, mt) | 0, K = K + Math.imul(De, et) | 0, z = z + Math.imul(De, Ze) | 0, z = z + Math.imul(Ye, et) | 0, G = G + Math.imul(Ye, Ze) | 0, K = K + Math.imul(be, ze) | 0, z = z + Math.imul(be, Qe) | 0, z = z + Math.imul(ve, ze) | 0, G = G + Math.imul(ve, Qe) | 0, K = K + Math.imul(fe, ft) | 0, z = z + Math.imul(fe, dt) | 0, z = z + Math.imul($e, ft) | 0, G = G + Math.imul($e, dt) | 0, K = K + Math.imul(xe, St) | 0, z = z + Math.imul(xe, $t) | 0, z = z + Math.imul(ye, St) | 0, G = G + Math.imul(ye, $t) | 0, K = K + Math.imul(F, Ae) | 0, z = z + Math.imul(F, Ce) | 0, z = z + Math.imul(ae, Ae) | 0, G = G + Math.imul(ae, Ce) | 0;
        var Ht = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, K = Math.imul(je, Xe), z = Math.imul(je, at), z = z + Math.imul(Ke, Xe) | 0, G = Math.imul(Ke, at), K = K + Math.imul(nt, We) | 0, z = z + Math.imul(nt, tt) | 0, z = z + Math.imul(Ie, We) | 0, G = G + Math.imul(Ie, tt) | 0, K = K + Math.imul(Pe, rt) | 0, z = z + Math.imul(Pe, mt) | 0, z = z + Math.imul(He, rt) | 0, G = G + Math.imul(He, mt) | 0, K = K + Math.imul(ue, et) | 0, z = z + Math.imul(ue, Ze) | 0, z = z + Math.imul(de, et) | 0, G = G + Math.imul(de, Ze) | 0, K = K + Math.imul(De, ze) | 0, z = z + Math.imul(De, Qe) | 0, z = z + Math.imul(Ye, ze) | 0, G = G + Math.imul(Ye, Qe) | 0, K = K + Math.imul(be, ft) | 0, z = z + Math.imul(be, dt) | 0, z = z + Math.imul(ve, ft) | 0, G = G + Math.imul(ve, dt) | 0, K = K + Math.imul(fe, St) | 0, z = z + Math.imul(fe, $t) | 0, z = z + Math.imul($e, St) | 0, G = G + Math.imul($e, $t) | 0, K = K + Math.imul(xe, Ae) | 0, z = z + Math.imul(xe, Ce) | 0, z = z + Math.imul(ye, Ae) | 0, G = G + Math.imul(ye, Ce) | 0, K = K + Math.imul(F, we) | 0, z = z + Math.imul(F, Ue) | 0, z = z + Math.imul(ae, we) | 0, G = G + Math.imul(ae, Ue) | 0;
        var Ft = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, K = Math.imul(ut, Xe), z = Math.imul(ut, at), z = z + Math.imul(pt, Xe) | 0, G = Math.imul(pt, at), K = K + Math.imul(je, We) | 0, z = z + Math.imul(je, tt) | 0, z = z + Math.imul(Ke, We) | 0, G = G + Math.imul(Ke, tt) | 0, K = K + Math.imul(nt, rt) | 0, z = z + Math.imul(nt, mt) | 0, z = z + Math.imul(Ie, rt) | 0, G = G + Math.imul(Ie, mt) | 0, K = K + Math.imul(Pe, et) | 0, z = z + Math.imul(Pe, Ze) | 0, z = z + Math.imul(He, et) | 0, G = G + Math.imul(He, Ze) | 0, K = K + Math.imul(ue, ze) | 0, z = z + Math.imul(ue, Qe) | 0, z = z + Math.imul(de, ze) | 0, G = G + Math.imul(de, Qe) | 0, K = K + Math.imul(De, ft) | 0, z = z + Math.imul(De, dt) | 0, z = z + Math.imul(Ye, ft) | 0, G = G + Math.imul(Ye, dt) | 0, K = K + Math.imul(be, St) | 0, z = z + Math.imul(be, $t) | 0, z = z + Math.imul(ve, St) | 0, G = G + Math.imul(ve, $t) | 0, K = K + Math.imul(fe, Ae) | 0, z = z + Math.imul(fe, Ce) | 0, z = z + Math.imul($e, Ae) | 0, G = G + Math.imul($e, Ce) | 0, K = K + Math.imul(xe, we) | 0, z = z + Math.imul(xe, Ue) | 0, z = z + Math.imul(ye, we) | 0, G = G + Math.imul(ye, Ue) | 0, K = K + Math.imul(F, Ge) | 0, z = z + Math.imul(F, st) | 0, z = z + Math.imul(ae, Ge) | 0, G = G + Math.imul(ae, st) | 0;
        var Nt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, K = Math.imul(ut, We), z = Math.imul(ut, tt), z = z + Math.imul(pt, We) | 0, G = Math.imul(pt, tt), K = K + Math.imul(je, rt) | 0, z = z + Math.imul(je, mt) | 0, z = z + Math.imul(Ke, rt) | 0, G = G + Math.imul(Ke, mt) | 0, K = K + Math.imul(nt, et) | 0, z = z + Math.imul(nt, Ze) | 0, z = z + Math.imul(Ie, et) | 0, G = G + Math.imul(Ie, Ze) | 0, K = K + Math.imul(Pe, ze) | 0, z = z + Math.imul(Pe, Qe) | 0, z = z + Math.imul(He, ze) | 0, G = G + Math.imul(He, Qe) | 0, K = K + Math.imul(ue, ft) | 0, z = z + Math.imul(ue, dt) | 0, z = z + Math.imul(de, ft) | 0, G = G + Math.imul(de, dt) | 0, K = K + Math.imul(De, St) | 0, z = z + Math.imul(De, $t) | 0, z = z + Math.imul(Ye, St) | 0, G = G + Math.imul(Ye, $t) | 0, K = K + Math.imul(be, Ae) | 0, z = z + Math.imul(be, Ce) | 0, z = z + Math.imul(ve, Ae) | 0, G = G + Math.imul(ve, Ce) | 0, K = K + Math.imul(fe, we) | 0, z = z + Math.imul(fe, Ue) | 0, z = z + Math.imul($e, we) | 0, G = G + Math.imul($e, Ue) | 0, K = K + Math.imul(xe, Ge) | 0, z = z + Math.imul(xe, st) | 0, z = z + Math.imul(ye, Ge) | 0, G = G + Math.imul(ye, st) | 0;
        var Dt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, K = Math.imul(ut, rt), z = Math.imul(ut, mt), z = z + Math.imul(pt, rt) | 0, G = Math.imul(pt, mt), K = K + Math.imul(je, et) | 0, z = z + Math.imul(je, Ze) | 0, z = z + Math.imul(Ke, et) | 0, G = G + Math.imul(Ke, Ze) | 0, K = K + Math.imul(nt, ze) | 0, z = z + Math.imul(nt, Qe) | 0, z = z + Math.imul(Ie, ze) | 0, G = G + Math.imul(Ie, Qe) | 0, K = K + Math.imul(Pe, ft) | 0, z = z + Math.imul(Pe, dt) | 0, z = z + Math.imul(He, ft) | 0, G = G + Math.imul(He, dt) | 0, K = K + Math.imul(ue, St) | 0, z = z + Math.imul(ue, $t) | 0, z = z + Math.imul(de, St) | 0, G = G + Math.imul(de, $t) | 0, K = K + Math.imul(De, Ae) | 0, z = z + Math.imul(De, Ce) | 0, z = z + Math.imul(Ye, Ae) | 0, G = G + Math.imul(Ye, Ce) | 0, K = K + Math.imul(be, we) | 0, z = z + Math.imul(be, Ue) | 0, z = z + Math.imul(ve, we) | 0, G = G + Math.imul(ve, Ue) | 0, K = K + Math.imul(fe, Ge) | 0, z = z + Math.imul(fe, st) | 0, z = z + Math.imul($e, Ge) | 0, G = G + Math.imul($e, st) | 0;
        var Ut = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, K = Math.imul(ut, et), z = Math.imul(ut, Ze), z = z + Math.imul(pt, et) | 0, G = Math.imul(pt, Ze), K = K + Math.imul(je, ze) | 0, z = z + Math.imul(je, Qe) | 0, z = z + Math.imul(Ke, ze) | 0, G = G + Math.imul(Ke, Qe) | 0, K = K + Math.imul(nt, ft) | 0, z = z + Math.imul(nt, dt) | 0, z = z + Math.imul(Ie, ft) | 0, G = G + Math.imul(Ie, dt) | 0, K = K + Math.imul(Pe, St) | 0, z = z + Math.imul(Pe, $t) | 0, z = z + Math.imul(He, St) | 0, G = G + Math.imul(He, $t) | 0, K = K + Math.imul(ue, Ae) | 0, z = z + Math.imul(ue, Ce) | 0, z = z + Math.imul(de, Ae) | 0, G = G + Math.imul(de, Ce) | 0, K = K + Math.imul(De, we) | 0, z = z + Math.imul(De, Ue) | 0, z = z + Math.imul(Ye, we) | 0, G = G + Math.imul(Ye, Ue) | 0, K = K + Math.imul(be, Ge) | 0, z = z + Math.imul(be, st) | 0, z = z + Math.imul(ve, Ge) | 0, G = G + Math.imul(ve, st) | 0;
        var kt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, K = Math.imul(ut, ze), z = Math.imul(ut, Qe), z = z + Math.imul(pt, ze) | 0, G = Math.imul(pt, Qe), K = K + Math.imul(je, ft) | 0, z = z + Math.imul(je, dt) | 0, z = z + Math.imul(Ke, ft) | 0, G = G + Math.imul(Ke, dt) | 0, K = K + Math.imul(nt, St) | 0, z = z + Math.imul(nt, $t) | 0, z = z + Math.imul(Ie, St) | 0, G = G + Math.imul(Ie, $t) | 0, K = K + Math.imul(Pe, Ae) | 0, z = z + Math.imul(Pe, Ce) | 0, z = z + Math.imul(He, Ae) | 0, G = G + Math.imul(He, Ce) | 0, K = K + Math.imul(ue, we) | 0, z = z + Math.imul(ue, Ue) | 0, z = z + Math.imul(de, we) | 0, G = G + Math.imul(de, Ue) | 0, K = K + Math.imul(De, Ge) | 0, z = z + Math.imul(De, st) | 0, z = z + Math.imul(Ye, Ge) | 0, G = G + Math.imul(Ye, st) | 0;
        var Ot = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, K = Math.imul(ut, ft), z = Math.imul(ut, dt), z = z + Math.imul(pt, ft) | 0, G = Math.imul(pt, dt), K = K + Math.imul(je, St) | 0, z = z + Math.imul(je, $t) | 0, z = z + Math.imul(Ke, St) | 0, G = G + Math.imul(Ke, $t) | 0, K = K + Math.imul(nt, Ae) | 0, z = z + Math.imul(nt, Ce) | 0, z = z + Math.imul(Ie, Ae) | 0, G = G + Math.imul(Ie, Ce) | 0, K = K + Math.imul(Pe, we) | 0, z = z + Math.imul(Pe, Ue) | 0, z = z + Math.imul(He, we) | 0, G = G + Math.imul(He, Ue) | 0, K = K + Math.imul(ue, Ge) | 0, z = z + Math.imul(ue, st) | 0, z = z + Math.imul(de, Ge) | 0, G = G + Math.imul(de, st) | 0;
        var It = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, K = Math.imul(ut, St), z = Math.imul(ut, $t), z = z + Math.imul(pt, St) | 0, G = Math.imul(pt, $t), K = K + Math.imul(je, Ae) | 0, z = z + Math.imul(je, Ce) | 0, z = z + Math.imul(Ke, Ae) | 0, G = G + Math.imul(Ke, Ce) | 0, K = K + Math.imul(nt, we) | 0, z = z + Math.imul(nt, Ue) | 0, z = z + Math.imul(Ie, we) | 0, G = G + Math.imul(Ie, Ue) | 0, K = K + Math.imul(Pe, Ge) | 0, z = z + Math.imul(Pe, st) | 0, z = z + Math.imul(He, Ge) | 0, G = G + Math.imul(He, st) | 0;
        var Pt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, K = Math.imul(ut, Ae), z = Math.imul(ut, Ce), z = z + Math.imul(pt, Ae) | 0, G = Math.imul(pt, Ce), K = K + Math.imul(je, we) | 0, z = z + Math.imul(je, Ue) | 0, z = z + Math.imul(Ke, we) | 0, G = G + Math.imul(Ke, Ue) | 0, K = K + Math.imul(nt, Ge) | 0, z = z + Math.imul(nt, st) | 0, z = z + Math.imul(Ie, Ge) | 0, G = G + Math.imul(Ie, st) | 0;
        var Ct = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, K = Math.imul(ut, we), z = Math.imul(ut, Ue), z = z + Math.imul(pt, we) | 0, G = Math.imul(pt, Ue), K = K + Math.imul(je, Ge) | 0, z = z + Math.imul(je, st) | 0, z = z + Math.imul(Ke, Ge) | 0, G = G + Math.imul(Ke, st) | 0;
        var Bt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        Z = (G + (z >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, K = Math.imul(ut, Ge), z = Math.imul(ut, st), z = z + Math.imul(pt, Ge) | 0, G = Math.imul(pt, st);
        var vt = (Z + K | 0) + ((z & 8191) << 13) | 0;
        return Z = (G + (z >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, J[0] = ct, J[1] = bt, J[2] = wt, J[3] = zt, J[4] = Tt, J[5] = Lt, J[6] = jt, J[7] = Ht, J[8] = Ft, J[9] = Nt, J[10] = Dt, J[11] = Ut, J[12] = kt, J[13] = Ot, J[14] = It, J[15] = Pt, J[16] = Ct, J[17] = Bt, J[18] = vt, Z !== 0 && (J[19] = Z, M.length++), M;
      };
      Math.imul || (ee = Q);
      function ie(ne, Y, M) {
        M.negative = Y.negative ^ ne.negative, M.length = ne.length + Y.length;
        for (var $ = 0, O = 0, J = 0; J < M.length - 1; J++) {
          var Z = O;
          O = 0;
          for (var K = $ & 67108863, z = Math.min(J, Y.length - 1), G = Math.max(0, J - ne.length + 1); G <= z; G++) {
            var D = J - G, F = ne.words[D] | 0, ae = Y.words[G] | 0, ge = F * ae, xe = ge & 67108863;
            Z = Z + (ge / 67108864 | 0) | 0, xe = xe + K | 0, K = xe & 67108863, Z = Z + (xe >>> 26) | 0, O += Z >>> 26, Z &= 67108863;
          }
          M.words[J] = K, $ = Z, Z = O;
        }
        return $ !== 0 ? M.words[J] = $ : M.length--, M.strip();
      }
      function te(ne, Y, M) {
        var $ = new se();
        return $.mulp(ne, Y, M);
      }
      h.prototype.mulTo = function(ne, Y) {
        var M, $ = this.length + ne.length;
        return this.length === 10 && ne.length === 10 ? M = ee(this, ne, Y) : $ < 63 ? M = Q(this, ne, Y) : $ < 1024 ? M = ie(this, ne, Y) : M = te(this, ne, Y), M;
      };
      function se(ne, Y) {
        this.x = ne, this.y = Y;
      }
      se.prototype.makeRBT = function(ne) {
        for (var Y = new Array(ne), M = h.prototype._countBits(ne) - 1, $ = 0; $ < ne; $++)
          Y[$] = this.revBin($, M, ne);
        return Y;
      }, se.prototype.revBin = function(ne, Y, M) {
        if (ne === 0 || ne === M - 1)
          return ne;
        for (var $ = 0, O = 0; O < Y; O++)
          $ |= (ne & 1) << Y - O - 1, ne >>= 1;
        return $;
      }, se.prototype.permute = function(ne, Y, M, $, O, J) {
        for (var Z = 0; Z < J; Z++)
          $[Z] = Y[ne[Z]], O[Z] = M[ne[Z]];
      }, se.prototype.transform = function(ne, Y, M, $, O, J) {
        this.permute(J, ne, Y, M, $, O);
        for (var Z = 1; Z < O; Z <<= 1)
          for (var K = Z << 1, z = Math.cos(2 * Math.PI / K), G = Math.sin(2 * Math.PI / K), D = 0; D < O; D += K)
            for (var F = z, ae = G, ge = 0; ge < Z; ge++) {
              var xe = M[D + ge], ye = $[D + ge], oe = M[D + ge + Z], fe = $[D + ge + Z], $e = F * oe - ae * fe;
              fe = F * fe + ae * oe, oe = $e, M[D + ge] = xe + oe, $[D + ge] = ye + fe, M[D + ge + Z] = xe - oe, $[D + ge + Z] = ye - fe, ge !== K && ($e = z * F - G * ae, ae = z * ae + G * F, F = $e);
            }
      }, se.prototype.guessLen13b = function(ne, Y) {
        var M = Math.max(Y, ne) | 1, $ = M & 1, O = 0;
        for (M = M / 2 | 0; M; M = M >>> 1)
          O++;
        return 1 << O + 1 + $;
      }, se.prototype.conjugate = function(ne, Y, M) {
        if (!(M <= 1))
          for (var $ = 0; $ < M / 2; $++) {
            var O = ne[$];
            ne[$] = ne[M - $ - 1], ne[M - $ - 1] = O, O = Y[$], Y[$] = -Y[M - $ - 1], Y[M - $ - 1] = -O;
          }
      }, se.prototype.normalize13b = function(ne, Y) {
        for (var M = 0, $ = 0; $ < Y / 2; $++) {
          var O = Math.round(ne[2 * $ + 1] / Y) * 8192 + Math.round(ne[2 * $] / Y) + M;
          ne[$] = O & 67108863, O < 67108864 ? M = 0 : M = O / 67108864 | 0;
        }
        return ne;
      }, se.prototype.convert13b = function(ne, Y, M, $) {
        for (var O = 0, J = 0; J < Y; J++)
          O = O + (ne[J] | 0), M[2 * J] = O & 8191, O = O >>> 13, M[2 * J + 1] = O & 8191, O = O >>> 13;
        for (J = 2 * Y; J < $; ++J)
          M[J] = 0;
        g(O === 0), g((O & -8192) === 0);
      }, se.prototype.stub = function(ne) {
        for (var Y = new Array(ne), M = 0; M < ne; M++)
          Y[M] = 0;
        return Y;
      }, se.prototype.mulp = function(ne, Y, M) {
        var $ = 2 * this.guessLen13b(ne.length, Y.length), O = this.makeRBT($), J = this.stub($), Z = new Array($), K = new Array($), z = new Array($), G = new Array($), D = new Array($), F = new Array($), ae = M.words;
        ae.length = $, this.convert13b(ne.words, ne.length, Z, $), this.convert13b(Y.words, Y.length, G, $), this.transform(Z, J, K, z, $, O), this.transform(G, J, D, F, $, O);
        for (var ge = 0; ge < $; ge++) {
          var xe = K[ge] * D[ge] - z[ge] * F[ge];
          z[ge] = K[ge] * F[ge] + z[ge] * D[ge], K[ge] = xe;
        }
        return this.conjugate(K, z, $), this.transform(K, z, ae, J, $, O), this.conjugate(ae, J, $), this.normalize13b(ae, $), M.negative = ne.negative ^ Y.negative, M.length = ne.length + Y.length, M.strip();
      }, h.prototype.mul = function(ne) {
        var Y = new h(null);
        return Y.words = new Array(this.length + ne.length), this.mulTo(ne, Y);
      }, h.prototype.mulf = function(ne) {
        var Y = new h(null);
        return Y.words = new Array(this.length + ne.length), te(this, ne, Y);
      }, h.prototype.imul = function(ne) {
        return this.clone().mulTo(ne, this);
      }, h.prototype.imuln = function(ne) {
        g(typeof ne == "number"), g(ne < 67108864);
        for (var Y = 0, M = 0; M < this.length; M++) {
          var $ = (this.words[M] | 0) * ne, O = ($ & 67108863) + (Y & 67108863);
          Y >>= 26, Y += $ / 67108864 | 0, Y += O >>> 26, this.words[M] = O & 67108863;
        }
        return Y !== 0 && (this.words[M] = Y, this.length++), this;
      }, h.prototype.muln = function(ne) {
        return this.clone().imuln(ne);
      }, h.prototype.sqr = function() {
        return this.mul(this);
      }, h.prototype.isqr = function() {
        return this.imul(this.clone());
      }, h.prototype.pow = function(ne) {
        var Y = X(ne);
        if (Y.length === 0)
          return new h(1);
        for (var M = this, $ = 0; $ < Y.length && Y[$] === 0; $++, M = M.sqr())
          ;
        if (++$ < Y.length)
          for (var O = M.sqr(); $ < Y.length; $++, O = O.sqr())
            Y[$] !== 0 && (M = M.mul(O));
        return M;
      }, h.prototype.iushln = function(ne) {
        g(typeof ne == "number" && ne >= 0);
        var Y = ne % 26, M = (ne - Y) / 26, $ = 67108863 >>> 26 - Y << 26 - Y, O;
        if (Y !== 0) {
          var J = 0;
          for (O = 0; O < this.length; O++) {
            var Z = this.words[O] & $, K = (this.words[O] | 0) - Z << Y;
            this.words[O] = K | J, J = Z >>> 26 - Y;
          }
          J && (this.words[O] = J, this.length++);
        }
        if (M !== 0) {
          for (O = this.length - 1; O >= 0; O--)
            this.words[O + M] = this.words[O];
          for (O = 0; O < M; O++)
            this.words[O] = 0;
          this.length += M;
        }
        return this.strip();
      }, h.prototype.ishln = function(ne) {
        return g(this.negative === 0), this.iushln(ne);
      }, h.prototype.iushrn = function(ne, Y, M) {
        g(typeof ne == "number" && ne >= 0);
        var $;
        Y ? $ = (Y - Y % 26) / 26 : $ = 0;
        var O = ne % 26, J = Math.min((ne - O) / 26, this.length), Z = 67108863 ^ 67108863 >>> O << O, K = M;
        if ($ -= J, $ = Math.max(0, $), K) {
          for (var z = 0; z < J; z++)
            K.words[z] = this.words[z];
          K.length = J;
        }
        if (J !== 0)
          if (this.length > J)
            for (this.length -= J, z = 0; z < this.length; z++)
              this.words[z] = this.words[z + J];
          else
            this.words[0] = 0, this.length = 1;
        var G = 0;
        for (z = this.length - 1; z >= 0 && (G !== 0 || z >= $); z--) {
          var D = this.words[z] | 0;
          this.words[z] = G << 26 - O | D >>> O, G = D & Z;
        }
        return K && G !== 0 && (K.words[K.length++] = G), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, h.prototype.ishrn = function(ne, Y, M) {
        return g(this.negative === 0), this.iushrn(ne, Y, M);
      }, h.prototype.shln = function(ne) {
        return this.clone().ishln(ne);
      }, h.prototype.ushln = function(ne) {
        return this.clone().iushln(ne);
      }, h.prototype.shrn = function(ne) {
        return this.clone().ishrn(ne);
      }, h.prototype.ushrn = function(ne) {
        return this.clone().iushrn(ne);
      }, h.prototype.testn = function(ne) {
        g(typeof ne == "number" && ne >= 0);
        var Y = ne % 26, M = (ne - Y) / 26, $ = 1 << Y;
        if (this.length <= M)
          return !1;
        var O = this.words[M];
        return !!(O & $);
      }, h.prototype.imaskn = function(ne) {
        g(typeof ne == "number" && ne >= 0);
        var Y = ne % 26, M = (ne - Y) / 26;
        if (g(this.negative === 0, "imaskn works only with positive numbers"), this.length <= M)
          return this;
        if (Y !== 0 && M++, this.length = Math.min(M, this.length), Y !== 0) {
          var $ = 67108863 ^ 67108863 >>> Y << Y;
          this.words[this.length - 1] &= $;
        }
        return this.strip();
      }, h.prototype.maskn = function(ne) {
        return this.clone().imaskn(ne);
      }, h.prototype.iaddn = function(ne) {
        return g(typeof ne == "number"), g(ne < 67108864), ne < 0 ? this.isubn(-ne) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < ne ? (this.words[0] = ne - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ne), this.negative = 1, this) : this._iaddn(ne);
      }, h.prototype._iaddn = function(ne) {
        this.words[0] += ne;
        for (var Y = 0; Y < this.length && this.words[Y] >= 67108864; Y++)
          this.words[Y] -= 67108864, Y === this.length - 1 ? this.words[Y + 1] = 1 : this.words[Y + 1]++;
        return this.length = Math.max(this.length, Y + 1), this;
      }, h.prototype.isubn = function(ne) {
        if (g(typeof ne == "number"), g(ne < 67108864), ne < 0)
          return this.iaddn(-ne);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(ne), this.negative = 1, this;
        if (this.words[0] -= ne, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Y = 0; Y < this.length && this.words[Y] < 0; Y++)
            this.words[Y] += 67108864, this.words[Y + 1] -= 1;
        return this.strip();
      }, h.prototype.addn = function(ne) {
        return this.clone().iaddn(ne);
      }, h.prototype.subn = function(ne) {
        return this.clone().isubn(ne);
      }, h.prototype.iabs = function() {
        return this.negative = 0, this;
      }, h.prototype.abs = function() {
        return this.clone().iabs();
      }, h.prototype._ishlnsubmul = function(ne, Y, M) {
        var $ = ne.length + M, O;
        this._expand($);
        var J, Z = 0;
        for (O = 0; O < ne.length; O++) {
          J = (this.words[O + M] | 0) + Z;
          var K = (ne.words[O] | 0) * Y;
          J -= K & 67108863, Z = (J >> 26) - (K / 67108864 | 0), this.words[O + M] = J & 67108863;
        }
        for (; O < this.length - M; O++)
          J = (this.words[O + M] | 0) + Z, Z = J >> 26, this.words[O + M] = J & 67108863;
        if (Z === 0)
          return this.strip();
        for (g(Z === -1), Z = 0, O = 0; O < this.length; O++)
          J = -(this.words[O] | 0) + Z, Z = J >> 26, this.words[O] = J & 67108863;
        return this.negative = 1, this.strip();
      }, h.prototype._wordDiv = function(ne, Y) {
        var M = this.length - ne.length, $ = this.clone(), O = ne, J = O.words[O.length - 1] | 0, Z = this._countBits(J);
        M = 26 - Z, M !== 0 && (O = O.ushln(M), $.iushln(M), J = O.words[O.length - 1] | 0);
        var K = $.length - O.length, z;
        if (Y !== "mod") {
          z = new h(null), z.length = K + 1, z.words = new Array(z.length);
          for (var G = 0; G < z.length; G++)
            z.words[G] = 0;
        }
        var D = $.clone()._ishlnsubmul(O, 1, K);
        D.negative === 0 && ($ = D, z && (z.words[K] = 1));
        for (var F = K - 1; F >= 0; F--) {
          var ae = ($.words[O.length + F] | 0) * 67108864 + ($.words[O.length + F - 1] | 0);
          for (ae = Math.min(ae / J | 0, 67108863), $._ishlnsubmul(O, ae, F); $.negative !== 0; )
            ae--, $.negative = 0, $._ishlnsubmul(O, 1, F), $.isZero() || ($.negative ^= 1);
          z && (z.words[F] = ae);
        }
        return z && z.strip(), $.strip(), Y !== "div" && M !== 0 && $.iushrn(M), {
          div: z || null,
          mod: $
        };
      }, h.prototype.divmod = function(ne, Y, M) {
        if (g(!ne.isZero()), this.isZero())
          return {
            div: new h(0),
            mod: new h(0)
          };
        var $, O, J;
        return this.negative !== 0 && ne.negative === 0 ? (J = this.neg().divmod(ne, Y), Y !== "mod" && ($ = J.div.neg()), Y !== "div" && (O = J.mod.neg(), M && O.negative !== 0 && O.iadd(ne)), {
          div: $,
          mod: O
        }) : this.negative === 0 && ne.negative !== 0 ? (J = this.divmod(ne.neg(), Y), Y !== "mod" && ($ = J.div.neg()), {
          div: $,
          mod: J.mod
        }) : this.negative & ne.negative ? (J = this.neg().divmod(ne.neg(), Y), Y !== "div" && (O = J.mod.neg(), M && O.negative !== 0 && O.isub(ne)), {
          div: J.div,
          mod: O
        }) : ne.length > this.length || this.cmp(ne) < 0 ? {
          div: new h(0),
          mod: this
        } : ne.length === 1 ? Y === "div" ? {
          div: this.divn(ne.words[0]),
          mod: null
        } : Y === "mod" ? {
          div: null,
          mod: new h(this.modn(ne.words[0]))
        } : {
          div: this.divn(ne.words[0]),
          mod: new h(this.modn(ne.words[0]))
        } : this._wordDiv(ne, Y);
      }, h.prototype.div = function(ne) {
        return this.divmod(ne, "div", !1).div;
      }, h.prototype.mod = function(ne) {
        return this.divmod(ne, "mod", !1).mod;
      }, h.prototype.umod = function(ne) {
        return this.divmod(ne, "mod", !0).mod;
      }, h.prototype.divRound = function(ne) {
        var Y = this.divmod(ne);
        if (Y.mod.isZero())
          return Y.div;
        var M = Y.div.negative !== 0 ? Y.mod.isub(ne) : Y.mod, $ = ne.ushrn(1), O = ne.andln(1), J = M.cmp($);
        return J < 0 || O === 1 && J === 0 ? Y.div : Y.div.negative !== 0 ? Y.div.isubn(1) : Y.div.iaddn(1);
      }, h.prototype.modn = function(ne) {
        g(ne <= 67108863);
        for (var Y = (1 << 26) % ne, M = 0, $ = this.length - 1; $ >= 0; $--)
          M = (Y * M + (this.words[$] | 0)) % ne;
        return M;
      }, h.prototype.idivn = function(ne) {
        g(ne <= 67108863);
        for (var Y = 0, M = this.length - 1; M >= 0; M--) {
          var $ = (this.words[M] | 0) + Y * 67108864;
          this.words[M] = $ / ne | 0, Y = $ % ne;
        }
        return this.strip();
      }, h.prototype.divn = function(ne) {
        return this.clone().idivn(ne);
      }, h.prototype.egcd = function(ne) {
        g(ne.negative === 0), g(!ne.isZero());
        var Y = this, M = ne.clone();
        Y.negative !== 0 ? Y = Y.umod(ne) : Y = Y.clone();
        for (var $ = new h(1), O = new h(0), J = new h(0), Z = new h(1), K = 0; Y.isEven() && M.isEven(); )
          Y.iushrn(1), M.iushrn(1), ++K;
        for (var z = M.clone(), G = Y.clone(); !Y.isZero(); ) {
          for (var D = 0, F = 1; !(Y.words[0] & F) && D < 26; ++D, F <<= 1)
            ;
          if (D > 0)
            for (Y.iushrn(D); D-- > 0; )
              ($.isOdd() || O.isOdd()) && ($.iadd(z), O.isub(G)), $.iushrn(1), O.iushrn(1);
          for (var ae = 0, ge = 1; !(M.words[0] & ge) && ae < 26; ++ae, ge <<= 1)
            ;
          if (ae > 0)
            for (M.iushrn(ae); ae-- > 0; )
              (J.isOdd() || Z.isOdd()) && (J.iadd(z), Z.isub(G)), J.iushrn(1), Z.iushrn(1);
          Y.cmp(M) >= 0 ? (Y.isub(M), $.isub(J), O.isub(Z)) : (M.isub(Y), J.isub($), Z.isub(O));
        }
        return {
          a: J,
          b: Z,
          gcd: M.iushln(K)
        };
      }, h.prototype._invmp = function(ne) {
        g(ne.negative === 0), g(!ne.isZero());
        var Y = this, M = ne.clone();
        Y.negative !== 0 ? Y = Y.umod(ne) : Y = Y.clone();
        for (var $ = new h(1), O = new h(0), J = M.clone(); Y.cmpn(1) > 0 && M.cmpn(1) > 0; ) {
          for (var Z = 0, K = 1; !(Y.words[0] & K) && Z < 26; ++Z, K <<= 1)
            ;
          if (Z > 0)
            for (Y.iushrn(Z); Z-- > 0; )
              $.isOdd() && $.iadd(J), $.iushrn(1);
          for (var z = 0, G = 1; !(M.words[0] & G) && z < 26; ++z, G <<= 1)
            ;
          if (z > 0)
            for (M.iushrn(z); z-- > 0; )
              O.isOdd() && O.iadd(J), O.iushrn(1);
          Y.cmp(M) >= 0 ? (Y.isub(M), $.isub(O)) : (M.isub(Y), O.isub($));
        }
        var D;
        return Y.cmpn(1) === 0 ? D = $ : D = O, D.cmpn(0) < 0 && D.iadd(ne), D;
      }, h.prototype.gcd = function(ne) {
        if (this.isZero())
          return ne.abs();
        if (ne.isZero())
          return this.abs();
        var Y = this.clone(), M = ne.clone();
        Y.negative = 0, M.negative = 0;
        for (var $ = 0; Y.isEven() && M.isEven(); $++)
          Y.iushrn(1), M.iushrn(1);
        do {
          for (; Y.isEven(); )
            Y.iushrn(1);
          for (; M.isEven(); )
            M.iushrn(1);
          var O = Y.cmp(M);
          if (O < 0) {
            var J = Y;
            Y = M, M = J;
          } else if (O === 0 || M.cmpn(1) === 0)
            break;
          Y.isub(M);
        } while (!0);
        return M.iushln($);
      }, h.prototype.invm = function(ne) {
        return this.egcd(ne).a.umod(ne);
      }, h.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, h.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, h.prototype.andln = function(ne) {
        return this.words[0] & ne;
      }, h.prototype.bincn = function(ne) {
        g(typeof ne == "number");
        var Y = ne % 26, M = (ne - Y) / 26, $ = 1 << Y;
        if (this.length <= M)
          return this._expand(M + 1), this.words[M] |= $, this;
        for (var O = $, J = M; O !== 0 && J < this.length; J++) {
          var Z = this.words[J] | 0;
          Z += O, O = Z >>> 26, Z &= 67108863, this.words[J] = Z;
        }
        return O !== 0 && (this.words[J] = O, this.length++), this;
      }, h.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, h.prototype.cmpn = function(ne) {
        var Y = ne < 0;
        if (this.negative !== 0 && !Y)
          return -1;
        if (this.negative === 0 && Y)
          return 1;
        this.strip();
        var M;
        if (this.length > 1)
          M = 1;
        else {
          Y && (ne = -ne), g(ne <= 67108863, "Number is too big");
          var $ = this.words[0] | 0;
          M = $ === ne ? 0 : $ < ne ? -1 : 1;
        }
        return this.negative !== 0 ? -M | 0 : M;
      }, h.prototype.cmp = function(ne) {
        if (this.negative !== 0 && ne.negative === 0)
          return -1;
        if (this.negative === 0 && ne.negative !== 0)
          return 1;
        var Y = this.ucmp(ne);
        return this.negative !== 0 ? -Y | 0 : Y;
      }, h.prototype.ucmp = function(ne) {
        if (this.length > ne.length)
          return 1;
        if (this.length < ne.length)
          return -1;
        for (var Y = 0, M = this.length - 1; M >= 0; M--) {
          var $ = this.words[M] | 0, O = ne.words[M] | 0;
          if ($ !== O) {
            $ < O ? Y = -1 : $ > O && (Y = 1);
            break;
          }
        }
        return Y;
      }, h.prototype.gtn = function(ne) {
        return this.cmpn(ne) === 1;
      }, h.prototype.gt = function(ne) {
        return this.cmp(ne) === 1;
      }, h.prototype.gten = function(ne) {
        return this.cmpn(ne) >= 0;
      }, h.prototype.gte = function(ne) {
        return this.cmp(ne) >= 0;
      }, h.prototype.ltn = function(ne) {
        return this.cmpn(ne) === -1;
      }, h.prototype.lt = function(ne) {
        return this.cmp(ne) === -1;
      }, h.prototype.lten = function(ne) {
        return this.cmpn(ne) <= 0;
      }, h.prototype.lte = function(ne) {
        return this.cmp(ne) <= 0;
      }, h.prototype.eqn = function(ne) {
        return this.cmpn(ne) === 0;
      }, h.prototype.eq = function(ne) {
        return this.cmp(ne) === 0;
      }, h.red = function(ne) {
        return new Re(ne);
      }, h.prototype.toRed = function(ne) {
        return g(!this.red, "Already a number in reduction context"), g(this.negative === 0, "red works only with positives"), ne.convertTo(this)._forceRed(ne);
      }, h.prototype.fromRed = function() {
        return g(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, h.prototype._forceRed = function(ne) {
        return this.red = ne, this;
      }, h.prototype.forceRed = function(ne) {
        return g(!this.red, "Already a number in reduction context"), this._forceRed(ne);
      }, h.prototype.redAdd = function(ne) {
        return g(this.red, "redAdd works only with red numbers"), this.red.add(this, ne);
      }, h.prototype.redIAdd = function(ne) {
        return g(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ne);
      }, h.prototype.redSub = function(ne) {
        return g(this.red, "redSub works only with red numbers"), this.red.sub(this, ne);
      }, h.prototype.redISub = function(ne) {
        return g(this.red, "redISub works only with red numbers"), this.red.isub(this, ne);
      }, h.prototype.redShl = function(ne) {
        return g(this.red, "redShl works only with red numbers"), this.red.shl(this, ne);
      }, h.prototype.redMul = function(ne) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, ne), this.red.mul(this, ne);
      }, h.prototype.redIMul = function(ne) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, ne), this.red.imul(this, ne);
      }, h.prototype.redSqr = function() {
        return g(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, h.prototype.redISqr = function() {
        return g(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, h.prototype.redSqrt = function() {
        return g(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, h.prototype.redInvm = function() {
        return g(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, h.prototype.redNeg = function() {
        return g(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, h.prototype.redPow = function(ne) {
        return g(this.red && !ne.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ne);
      };
      var le = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function ce(ne, Y) {
        this.name = ne, this.p = new h(Y, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ce.prototype._tmp = function() {
        var ne = new h(null);
        return ne.words = new Array(Math.ceil(this.n / 13)), ne;
      }, ce.prototype.ireduce = function(ne) {
        var Y = ne, M;
        do
          this.split(Y, this.tmp), Y = this.imulK(Y), Y = Y.iadd(this.tmp), M = Y.bitLength();
        while (M > this.n);
        var $ = M < this.n ? -1 : Y.ucmp(this.p);
        return $ === 0 ? (Y.words[0] = 0, Y.length = 1) : $ > 0 ? Y.isub(this.p) : Y.strip !== void 0 ? Y.strip() : Y._strip(), Y;
      }, ce.prototype.split = function(ne, Y) {
        ne.iushrn(this.n, 0, Y);
      }, ce.prototype.imulK = function(ne) {
        return ne.imul(this.k);
      };
      function pe() {
        ce.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      U(pe, ce), pe.prototype.split = function(ne, Y) {
        for (var M = 4194303, $ = Math.min(ne.length, 9), O = 0; O < $; O++)
          Y.words[O] = ne.words[O];
        if (Y.length = $, ne.length <= 9) {
          ne.words[0] = 0, ne.length = 1;
          return;
        }
        var J = ne.words[9];
        for (Y.words[Y.length++] = J & M, O = 10; O < ne.length; O++) {
          var Z = ne.words[O] | 0;
          ne.words[O - 10] = (Z & M) << 4 | J >>> 22, J = Z;
        }
        J >>>= 22, ne.words[O - 10] = J, J === 0 && ne.length > 10 ? ne.length -= 10 : ne.length -= 9;
      }, pe.prototype.imulK = function(ne) {
        ne.words[ne.length] = 0, ne.words[ne.length + 1] = 0, ne.length += 2;
        for (var Y = 0, M = 0; M < ne.length; M++) {
          var $ = ne.words[M] | 0;
          Y += $ * 977, ne.words[M] = Y & 67108863, Y = $ * 64 + (Y / 67108864 | 0);
        }
        return ne.words[ne.length - 1] === 0 && (ne.length--, ne.words[ne.length - 1] === 0 && ne.length--), ne;
      };
      function me() {
        ce.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      U(me, ce);
      function Me() {
        ce.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      U(Me, ce);
      function Ee() {
        ce.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      U(Ee, ce), Ee.prototype.imulK = function(ne) {
        for (var Y = 0, M = 0; M < ne.length; M++) {
          var $ = (ne.words[M] | 0) * 19 + Y, O = $ & 67108863;
          $ >>>= 26, ne.words[M] = O, Y = $;
        }
        return Y !== 0 && (ne.words[ne.length++] = Y), ne;
      }, h._prime = function(ne) {
        if (le[ne])
          return le[ne];
        var Y;
        if (ne === "k256")
          Y = new pe();
        else if (ne === "p224")
          Y = new me();
        else if (ne === "p192")
          Y = new Me();
        else if (ne === "p25519")
          Y = new Ee();
        else
          throw new Error("Unknown prime " + ne);
        return le[ne] = Y, Y;
      };
      function Re(ne) {
        if (typeof ne == "string") {
          var Y = h._prime(ne);
          this.m = Y.p, this.prime = Y;
        } else
          g(ne.gtn(1), "modulus must be greater than 1"), this.m = ne, this.prime = null;
      }
      Re.prototype._verify1 = function(ne) {
        g(ne.negative === 0, "red works only with positives"), g(ne.red, "red works only with red numbers");
      }, Re.prototype._verify2 = function(ne, Y) {
        g((ne.negative | Y.negative) === 0, "red works only with positives"), g(
          ne.red && ne.red === Y.red,
          "red works only with red numbers"
        );
      }, Re.prototype.imod = function(ne) {
        return this.prime ? this.prime.ireduce(ne)._forceRed(this) : ne.umod(this.m)._forceRed(this);
      }, Re.prototype.neg = function(ne) {
        return ne.isZero() ? ne.clone() : this.m.sub(ne)._forceRed(this);
      }, Re.prototype.add = function(ne, Y) {
        this._verify2(ne, Y);
        var M = ne.add(Y);
        return M.cmp(this.m) >= 0 && M.isub(this.m), M._forceRed(this);
      }, Re.prototype.iadd = function(ne, Y) {
        this._verify2(ne, Y);
        var M = ne.iadd(Y);
        return M.cmp(this.m) >= 0 && M.isub(this.m), M;
      }, Re.prototype.sub = function(ne, Y) {
        this._verify2(ne, Y);
        var M = ne.sub(Y);
        return M.cmpn(0) < 0 && M.iadd(this.m), M._forceRed(this);
      }, Re.prototype.isub = function(ne, Y) {
        this._verify2(ne, Y);
        var M = ne.isub(Y);
        return M.cmpn(0) < 0 && M.iadd(this.m), M;
      }, Re.prototype.shl = function(ne, Y) {
        return this._verify1(ne), this.imod(ne.ushln(Y));
      }, Re.prototype.imul = function(ne, Y) {
        return this._verify2(ne, Y), this.imod(ne.imul(Y));
      }, Re.prototype.mul = function(ne, Y) {
        return this._verify2(ne, Y), this.imod(ne.mul(Y));
      }, Re.prototype.isqr = function(ne) {
        return this.imul(ne, ne.clone());
      }, Re.prototype.sqr = function(ne) {
        return this.mul(ne, ne);
      }, Re.prototype.sqrt = function(ne) {
        if (ne.isZero())
          return ne.clone();
        var Y = this.m.andln(3);
        if (g(Y % 2 === 1), Y === 3) {
          var M = this.m.add(new h(1)).iushrn(2);
          return this.pow(ne, M);
        }
        for (var $ = this.m.subn(1), O = 0; !$.isZero() && $.andln(1) === 0; )
          O++, $.iushrn(1);
        g(!$.isZero());
        var J = new h(1).toRed(this), Z = J.redNeg(), K = this.m.subn(1).iushrn(1), z = this.m.bitLength();
        for (z = new h(2 * z * z).toRed(this); this.pow(z, K).cmp(Z) !== 0; )
          z.redIAdd(Z);
        for (var G = this.pow(z, $), D = this.pow(ne, $.addn(1).iushrn(1)), F = this.pow(ne, $), ae = O; F.cmp(J) !== 0; ) {
          for (var ge = F, xe = 0; ge.cmp(J) !== 0; xe++)
            ge = ge.redSqr();
          g(xe < ae);
          var ye = this.pow(G, new h(1).iushln(ae - xe - 1));
          D = D.redMul(ye), G = ye.redSqr(), F = F.redMul(G), ae = xe;
        }
        return D;
      }, Re.prototype.invm = function(ne) {
        var Y = ne._invmp(this.m);
        return Y.negative !== 0 ? (Y.negative = 0, this.imod(Y).redNeg()) : this.imod(Y);
      }, Re.prototype.pow = function(ne, Y) {
        if (Y.isZero())
          return new h(1).toRed(this);
        if (Y.cmpn(1) === 0)
          return ne.clone();
        var M = 4, $ = new Array(1 << M);
        $[0] = new h(1).toRed(this), $[1] = ne;
        for (var O = 2; O < $.length; O++)
          $[O] = this.mul($[O - 1], ne);
        var J = $[0], Z = 0, K = 0, z = Y.bitLength() % 26;
        for (z === 0 && (z = 26), O = Y.length - 1; O >= 0; O--) {
          for (var G = Y.words[O], D = z - 1; D >= 0; D--) {
            var F = G >> D & 1;
            if (J !== $[0] && (J = this.sqr(J)), F === 0 && Z === 0) {
              K = 0;
              continue;
            }
            Z <<= 1, Z |= F, K++, !(K !== M && (O !== 0 || D !== 0)) && (J = this.mul(J, $[Z]), K = 0, Z = 0);
          }
          z = 26;
        }
        return J;
      }, Re.prototype.convertTo = function(ne) {
        var Y = ne.umod(this.m);
        return Y === ne ? Y.clone() : Y;
      }, Re.prototype.convertFrom = function(ne) {
        var Y = ne.clone();
        return Y.red = null, Y;
      }, h.mont = function(ne) {
        return new Ne(ne);
      };
      function Ne(ne) {
        Re.call(this, ne), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      U(Ne, Re), Ne.prototype.convertTo = function(ne) {
        return this.imod(ne.ushln(this.shift));
      }, Ne.prototype.convertFrom = function(ne) {
        var Y = this.imod(ne.mul(this.rinv));
        return Y.red = null, Y;
      }, Ne.prototype.imul = function(ne, Y) {
        if (ne.isZero() || Y.isZero())
          return ne.words[0] = 0, ne.length = 1, ne;
        var M = ne.imul(Y), $ = M.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = M.isub($).iushrn(this.shift), J = O;
        return O.cmp(this.m) >= 0 ? J = O.isub(this.m) : O.cmpn(0) < 0 && (J = O.iadd(this.m)), J._forceRed(this);
      }, Ne.prototype.mul = function(ne, Y) {
        if (ne.isZero() || Y.isZero())
          return new h(0)._forceRed(this);
        var M = ne.mul(Y), $ = M.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = M.isub($).iushrn(this.shift), J = O;
        return O.cmp(this.m) >= 0 ? J = O.isub(this.m) : O.cmpn(0) < 0 && (J = O.iadd(this.m)), J._forceRed(this);
      }, Ne.prototype.invm = function(ne) {
        var Y = this.imod(ne._invmp(this.m).mul(this.r2));
        return Y._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$2$1)), bn$2$1.exports;
}
var brorand$1 = { exports: {} }, hasRequiredBrorand$1;
function requireBrorand$1() {
  if (hasRequiredBrorand$1)
    return brorand$1.exports;
  hasRequiredBrorand$1 = 1;
  var e;
  brorand$1.exports = function(g) {
    return e || (e = new o(null)), e.generate(g);
  };
  function o(g) {
    this.rand = g;
  }
  if (brorand$1.exports.Rand = o, o.prototype.generate = function(g) {
    return this._rand(g);
  }, o.prototype._rand = function(g) {
    if (this.rand.getBytes)
      return this.rand.getBytes(g);
    for (var U = new Uint8Array(g), h = 0; h < U.length; h++)
      U[h] = this.rand.getByte();
    return U;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? o.prototype._rand = function(g) {
      var U = new Uint8Array(g);
      return self.crypto.getRandomValues(U), U;
    } : self.msCrypto && self.msCrypto.getRandomValues ? o.prototype._rand = function(g) {
      var U = new Uint8Array(g);
      return self.msCrypto.getRandomValues(U), U;
    } : typeof window == "object" && (o.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var S = requireCryptoBrowserify$1();
      if (typeof S.randomBytes != "function")
        throw new Error("Not supported");
      o.prototype._rand = function(g) {
        return S.randomBytes(g);
      };
    } catch {
    }
  return brorand$1.exports;
}
var mr$1, hasRequiredMr$1;
function requireMr$1() {
  if (hasRequiredMr$1)
    return mr$1;
  hasRequiredMr$1 = 1;
  var e = requireBn$2(), o = requireBrorand$1();
  function S(g) {
    this.rand = g || new o.Rand();
  }
  return mr$1 = S, S.create = function(g) {
    return new S(g);
  }, S.prototype._randbelow = function(g) {
    var U = g.bitLength(), h = Math.ceil(U / 8);
    do
      var q = new e(this.rand.generate(h));
    while (q.cmp(g) >= 0);
    return q;
  }, S.prototype._randrange = function(g, U) {
    var h = U.sub(g);
    return g.add(this._randbelow(h));
  }, S.prototype.test = function(g, U, h) {
    var q = g.bitLength(), A = e.mont(g), P = new e(1).toRed(A);
    U || (U = Math.max(1, q / 48 | 0));
    for (var I = g.subn(1), B = 0; !I.testn(B); B++)
      ;
    for (var H = g.shrn(B), V = I.toRed(A), X = !0; U > 0; U--) {
      var Q = this._randrange(new e(2), I);
      h && h(Q);
      var ee = Q.toRed(A).redPow(H);
      if (!(ee.cmp(P) === 0 || ee.cmp(V) === 0)) {
        for (var ie = 1; ie < B; ie++) {
          if (ee = ee.redSqr(), ee.cmp(P) === 0)
            return !1;
          if (ee.cmp(V) === 0)
            break;
        }
        if (ie === B)
          return !1;
      }
    }
    return X;
  }, S.prototype.getDivisor = function(g, U) {
    var h = g.bitLength(), q = e.mont(g), A = new e(1).toRed(q);
    U || (U = Math.max(1, h / 48 | 0));
    for (var P = g.subn(1), I = 0; !P.testn(I); I++)
      ;
    for (var B = g.shrn(I), H = P.toRed(q); U > 0; U--) {
      var V = this._randrange(new e(2), P), X = g.gcd(V);
      if (X.cmpn(1) !== 0)
        return X;
      var Q = V.toRed(q).redPow(B);
      if (!(Q.cmp(A) === 0 || Q.cmp(H) === 0)) {
        for (var ee = 1; ee < I; ee++) {
          if (Q = Q.redSqr(), Q.cmp(A) === 0)
            return Q.fromRed().subn(1).gcd(g);
          if (Q.cmp(H) === 0)
            break;
        }
        if (ee === I)
          return Q = Q.redSqr(), Q.fromRed().subn(1).gcd(g);
      }
    }
    return !1;
  }, mr$1;
}
var generatePrime$1, hasRequiredGeneratePrime$1;
function requireGeneratePrime$1() {
  if (hasRequiredGeneratePrime$1)
    return generatePrime$1;
  hasRequiredGeneratePrime$1 = 1;
  var e = requireBrowser$b$1();
  generatePrime$1 = ie, ie.simpleSieve = Q, ie.fermatTest = ee;
  var o = requireBn$2(), S = new o(24), g = requireMr$1(), U = new g(), h = new o(1), q = new o(2), A = new o(5);
  new o(16), new o(8);
  var P = new o(10), I = new o(3);
  new o(7);
  var B = new o(11), H = new o(4);
  new o(12);
  var V = null;
  function X() {
    if (V !== null)
      return V;
    var te = 1048576, se = [];
    se[0] = 2;
    for (var le = 1, ce = 3; ce < te; ce += 2) {
      for (var pe = Math.ceil(Math.sqrt(ce)), me = 0; me < le && se[me] <= pe && ce % se[me] !== 0; me++)
        ;
      le !== me && se[me] <= pe || (se[le++] = ce);
    }
    return V = se, se;
  }
  function Q(te) {
    for (var se = X(), le = 0; le < se.length; le++)
      if (te.modn(se[le]) === 0)
        return te.cmpn(se[le]) === 0;
    return !0;
  }
  function ee(te) {
    var se = o.mont(te);
    return q.toRed(se).redPow(te.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ie(te, se) {
    if (te < 16)
      return se === 2 || se === 5 ? new o([140, 123]) : new o([140, 39]);
    se = new o(se);
    for (var le, ce; ; ) {
      for (le = new o(e(Math.ceil(te / 8))); le.bitLength() > te; )
        le.ishrn(1);
      if (le.isEven() && le.iadd(h), le.testn(1) || le.iadd(q), se.cmp(q)) {
        if (!se.cmp(A))
          for (; le.mod(P).cmp(I); )
            le.iadd(H);
      } else
        for (; le.mod(S).cmp(B); )
          le.iadd(H);
      if (ce = le.shrn(1), Q(ce) && Q(le) && ee(ce) && ee(le) && U.test(ce) && U.test(le))
        return le;
    }
  }
  return generatePrime$1;
}
const modp1$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18$1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1$1 = {
  modp1: modp1$1,
  modp2: modp2$1,
  modp5: modp5$1,
  modp14: modp14$1,
  modp15: modp15$1,
  modp16: modp16$1,
  modp17: modp17$1,
  modp18: modp18$1
};
var dh$1, hasRequiredDh$1;
function requireDh$1() {
  if (hasRequiredDh$1)
    return dh$1;
  hasRequiredDh$1 = 1;
  var e = requireBn$2(), o = requireMr$1(), S = new o(), g = new e(24), U = new e(11), h = new e(10), q = new e(3), A = new e(7), P = requireGeneratePrime$1(), I = requireBrowser$b$1();
  dh$1 = Q;
  function B(ie, te) {
    return te = te || "utf8", bufferExports.Buffer.isBuffer(ie) || (ie = new bufferExports.Buffer(ie, te)), this._pub = new e(ie), this;
  }
  function H(ie, te) {
    return te = te || "utf8", bufferExports.Buffer.isBuffer(ie) || (ie = new bufferExports.Buffer(ie, te)), this._priv = new e(ie), this;
  }
  var V = {};
  function X(ie, te) {
    var se = te.toString("hex"), le = [se, ie.toString(16)].join("_");
    if (le in V)
      return V[le];
    var ce = 0;
    if (ie.isEven() || !P.simpleSieve || !P.fermatTest(ie) || !S.test(ie))
      return ce += 1, se === "02" || se === "05" ? ce += 8 : ce += 4, V[le] = ce, ce;
    S.test(ie.shrn(1)) || (ce += 2);
    var pe;
    switch (se) {
      case "02":
        ie.mod(g).cmp(U) && (ce += 8);
        break;
      case "05":
        pe = ie.mod(h), pe.cmp(q) && pe.cmp(A) && (ce += 8);
        break;
      default:
        ce += 4;
    }
    return V[le] = ce, ce;
  }
  function Q(ie, te, se) {
    this.setGenerator(te), this.__prime = new e(ie), this._prime = e.mont(this.__prime), this._primeLen = ie.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, se ? (this.setPublicKey = B, this.setPrivateKey = H) : this._primeCode = 8;
  }
  Object.defineProperty(Q.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = X(this.__prime, this.__gen)), this._primeCode;
    }
  }), Q.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(I(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, Q.prototype.computeSecret = function(ie) {
    ie = new e(ie), ie = ie.toRed(this._prime);
    var te = ie.redPow(this._priv).fromRed(), se = new bufferExports.Buffer(te.toArray()), le = this.getPrime();
    if (se.length < le.length) {
      var ce = new bufferExports.Buffer(le.length - se.length);
      ce.fill(0), se = bufferExports.Buffer.concat([ce, se]);
    }
    return se;
  }, Q.prototype.getPublicKey = function(ie) {
    return ee(this._pub, ie);
  }, Q.prototype.getPrivateKey = function(ie) {
    return ee(this._priv, ie);
  }, Q.prototype.getPrime = function(ie) {
    return ee(this.__prime, ie);
  }, Q.prototype.getGenerator = function(ie) {
    return ee(this._gen, ie);
  }, Q.prototype.setGenerator = function(ie, te) {
    return te = te || "utf8", bufferExports.Buffer.isBuffer(ie) || (ie = new bufferExports.Buffer(ie, te)), this.__gen = ie, this._gen = new e(ie), this;
  };
  function ee(ie, te) {
    var se = new bufferExports.Buffer(ie.toArray());
    return te ? se.toString(te) : se;
  }
  return dh$1;
}
var hasRequiredBrowser$4$1;
function requireBrowser$4$1() {
  if (hasRequiredBrowser$4$1)
    return browser$4$1;
  hasRequiredBrowser$4$1 = 1;
  var e = requireGeneratePrime$1(), o = require$$1$1$1, S = requireDh$1();
  function g(q) {
    var A = new bufferExports.Buffer(o[q].prime, "hex"), P = new bufferExports.Buffer(o[q].gen, "hex");
    return new S(A, P);
  }
  var U = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function h(q, A, P, I) {
    return bufferExports.Buffer.isBuffer(A) || U[A] === void 0 ? h(q, "binary", A, P) : (A = A || "binary", I = I || "binary", P = P || new bufferExports.Buffer([2]), bufferExports.Buffer.isBuffer(P) || (P = new bufferExports.Buffer(P, I)), typeof q == "number" ? new S(e(q, P), P, !0) : (bufferExports.Buffer.isBuffer(q) || (q = new bufferExports.Buffer(q, A)), new S(q, P, !0)));
  }
  return browser$4$1.DiffieHellmanGroup = browser$4$1.createDiffieHellmanGroup = browser$4$1.getDiffieHellman = g, browser$4$1.createDiffieHellman = browser$4$1.DiffieHellman = h, browser$4$1;
}
var readableBrowser$2 = { exports: {} }, processNextickArgs$1 = { exports: {} }, hasRequiredProcessNextickArgs$1;
function requireProcessNextickArgs$1() {
  if (hasRequiredProcessNextickArgs$1)
    return processNextickArgs$1.exports;
  hasRequiredProcessNextickArgs$1 = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs$1.exports = { nextTick: e } : processNextickArgs$1.exports = process$1;
  function e(o, S, g, U) {
    if (typeof o != "function")
      throw new TypeError('"callback" argument must be a function');
    var h = arguments.length, q, A;
    switch (h) {
      case 0:
      case 1:
        return process$1.nextTick(o);
      case 2:
        return process$1.nextTick(function() {
          o.call(null, S);
        });
      case 3:
        return process$1.nextTick(function() {
          o.call(null, S, g);
        });
      case 4:
        return process$1.nextTick(function() {
          o.call(null, S, g, U);
        });
      default:
        for (q = new Array(h - 1), A = 0; A < q.length; )
          q[A++] = arguments[A];
        return process$1.nextTick(function() {
          o.apply(null, q);
        });
    }
  }
  return processNextickArgs$1.exports;
}
var isarray$2, hasRequiredIsarray$1;
function requireIsarray$1() {
  if (hasRequiredIsarray$1)
    return isarray$2;
  hasRequiredIsarray$1 = 1;
  var e = {}.toString;
  return isarray$2 = Array.isArray || function(o) {
    return e.call(o) == "[object Array]";
  }, isarray$2;
}
var streamBrowser$2, hasRequiredStreamBrowser$2;
function requireStreamBrowser$2() {
  return hasRequiredStreamBrowser$2 || (hasRequiredStreamBrowser$2 = 1, streamBrowser$2 = requireEvents().EventEmitter), streamBrowser$2;
}
var safeBuffer$2 = { exports: {} }, hasRequiredSafeBuffer$2;
function requireSafeBuffer$2() {
  return hasRequiredSafeBuffer$2 || (hasRequiredSafeBuffer$2 = 1, function(e, o) {
    var S = requireBuffer$1(), g = S.Buffer;
    function U(q, A) {
      for (var P in q)
        A[P] = q[P];
    }
    g.from && g.alloc && g.allocUnsafe && g.allocUnsafeSlow ? e.exports = S : (U(S, o), o.Buffer = h);
    function h(q, A, P) {
      return g(q, A, P);
    }
    U(g, h), h.from = function(q, A, P) {
      if (typeof q == "number")
        throw new TypeError("Argument must not be a number");
      return g(q, A, P);
    }, h.alloc = function(q, A, P) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      var I = g(q);
      return A !== void 0 ? typeof P == "string" ? I.fill(A, P) : I.fill(A) : I.fill(0), I;
    }, h.allocUnsafe = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return g(q);
    }, h.allocUnsafeSlow = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return S.SlowBuffer(q);
    };
  }(safeBuffer$2, safeBuffer$2.exports)), safeBuffer$2.exports;
}
var util$2 = {}, hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2)
    return util$2;
  hasRequiredUtil$2 = 1;
  function e(ee) {
    return Array.isArray ? Array.isArray(ee) : Q(ee) === "[object Array]";
  }
  util$2.isArray = e;
  function o(ee) {
    return typeof ee == "boolean";
  }
  util$2.isBoolean = o;
  function S(ee) {
    return ee === null;
  }
  util$2.isNull = S;
  function g(ee) {
    return ee == null;
  }
  util$2.isNullOrUndefined = g;
  function U(ee) {
    return typeof ee == "number";
  }
  util$2.isNumber = U;
  function h(ee) {
    return typeof ee == "string";
  }
  util$2.isString = h;
  function q(ee) {
    return typeof ee == "symbol";
  }
  util$2.isSymbol = q;
  function A(ee) {
    return ee === void 0;
  }
  util$2.isUndefined = A;
  function P(ee) {
    return Q(ee) === "[object RegExp]";
  }
  util$2.isRegExp = P;
  function I(ee) {
    return typeof ee == "object" && ee !== null;
  }
  util$2.isObject = I;
  function B(ee) {
    return Q(ee) === "[object Date]";
  }
  util$2.isDate = B;
  function H(ee) {
    return Q(ee) === "[object Error]" || ee instanceof Error;
  }
  util$2.isError = H;
  function V(ee) {
    return typeof ee == "function";
  }
  util$2.isFunction = V;
  function X(ee) {
    return ee === null || typeof ee == "boolean" || typeof ee == "number" || typeof ee == "string" || typeof ee == "symbol" || // ES6 symbol
    typeof ee > "u";
  }
  util$2.isPrimitive = X, util$2.isBuffer = requireBuffer$1().Buffer.isBuffer;
  function Q(ee) {
    return Object.prototype.toString.call(ee);
  }
  return util$2;
}
var BufferList$1 = { exports: {} }, hasRequiredBufferList$1;
function requireBufferList$1() {
  return hasRequiredBufferList$1 || (hasRequiredBufferList$1 = 1, function(e) {
    function o(h, q) {
      if (!(h instanceof q))
        throw new TypeError("Cannot call a class as a function");
    }
    var S = requireSafeBuffer$2().Buffer, g = requireUtil$1$1();
    function U(h, q, A) {
      h.copy(q, A);
    }
    e.exports = function() {
      function h() {
        o(this, h), this.head = null, this.tail = null, this.length = 0;
      }
      return h.prototype.push = function(q) {
        var A = { data: q, next: null };
        this.length > 0 ? this.tail.next = A : this.head = A, this.tail = A, ++this.length;
      }, h.prototype.unshift = function(q) {
        var A = { data: q, next: this.head };
        this.length === 0 && (this.tail = A), this.head = A, ++this.length;
      }, h.prototype.shift = function() {
        if (this.length !== 0) {
          var q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, q;
        }
      }, h.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, h.prototype.join = function(q) {
        if (this.length === 0)
          return "";
        for (var A = this.head, P = "" + A.data; A = A.next; )
          P += q + A.data;
        return P;
      }, h.prototype.concat = function(q) {
        if (this.length === 0)
          return S.alloc(0);
        for (var A = S.allocUnsafe(q >>> 0), P = this.head, I = 0; P; )
          U(P.data, A, I), I += P.data.length, P = P.next;
        return A;
      }, h;
    }(), g && g.inspect && g.inspect.custom && (e.exports.prototype[g.inspect.custom] = function() {
      var h = g.inspect({ length: this.length });
      return this.constructor.name + " " + h;
    });
  }(BufferList$1)), BufferList$1.exports;
}
var destroy_1$2, hasRequiredDestroy$2;
function requireDestroy$2() {
  if (hasRequiredDestroy$2)
    return destroy_1$2;
  hasRequiredDestroy$2 = 1;
  var e = requireProcessNextickArgs$1();
  function o(U, h) {
    var q = this, A = this._readableState && this._readableState.destroyed, P = this._writableState && this._writableState.destroyed;
    return A || P ? (h ? h(U) : U && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(g, this, U)) : e.nextTick(g, this, U)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(U || null, function(I) {
      !h && I ? q._writableState ? q._writableState.errorEmitted || (q._writableState.errorEmitted = !0, e.nextTick(g, q, I)) : e.nextTick(g, q, I) : h && h(I);
    }), this);
  }
  function S() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function g(U, h) {
    U.emit("error", h);
  }
  return destroy_1$2 = {
    destroy: o,
    undestroy: S
  }, destroy_1$2;
}
var _stream_writable$2, hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2)
    return _stream_writable$2;
  hasRequired_stream_writable$2 = 1;
  var e = requireProcessNextickArgs$1();
  _stream_writable$2 = ee;
  function o(Z) {
    var K = this;
    this.next = null, this.entry = null, this.finish = function() {
      J(K, Z);
    };
  }
  var S = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, g;
  ee.WritableState = X;
  var U = Object.create(requireUtil$2());
  U.inherits = requireInherits_browser$1();
  var h = {
    deprecate: requireBrowser$a$1()
  }, q = requireStreamBrowser$2(), A = requireSafeBuffer$2().Buffer, P = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function I(Z) {
    return A.from(Z);
  }
  function B(Z) {
    return A.isBuffer(Z) || Z instanceof P;
  }
  var H = requireDestroy$2();
  U.inherits(ee, q);
  function V() {
  }
  function X(Z, K) {
    g = g || require_stream_duplex$2(), Z = Z || {};
    var z = K instanceof g;
    this.objectMode = !!Z.objectMode, z && (this.objectMode = this.objectMode || !!Z.writableObjectMode);
    var G = Z.highWaterMark, D = Z.writableHighWaterMark, F = this.objectMode ? 16 : 16 * 1024;
    G || G === 0 ? this.highWaterMark = G : z && (D || D === 0) ? this.highWaterMark = D : this.highWaterMark = F, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ae = Z.decodeStrings === !1;
    this.decodeStrings = !ae, this.defaultEncoding = Z.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ge) {
      Me(K, ge);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new o(this);
  }
  X.prototype.getBuffer = function() {
    for (var Z = this.bufferedRequest, K = []; Z; )
      K.push(Z), Z = Z.next;
    return K;
  }, function() {
    try {
      Object.defineProperty(X.prototype, "buffer", {
        get: h.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Q = Function.prototype[Symbol.hasInstance], Object.defineProperty(ee, Symbol.hasInstance, {
    value: function(Z) {
      return Q.call(this, Z) ? !0 : this !== ee ? !1 : Z && Z._writableState instanceof X;
    }
  })) : Q = function(Z) {
    return Z instanceof this;
  };
  function ee(Z) {
    if (g = g || require_stream_duplex$2(), !Q.call(ee, this) && !(this instanceof g))
      return new ee(Z);
    this._writableState = new X(Z, this), this.writable = !0, Z && (typeof Z.write == "function" && (this._write = Z.write), typeof Z.writev == "function" && (this._writev = Z.writev), typeof Z.destroy == "function" && (this._destroy = Z.destroy), typeof Z.final == "function" && (this._final = Z.final)), q.call(this);
  }
  ee.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function ie(Z, K) {
    var z = new Error("write after end");
    Z.emit("error", z), e.nextTick(K, z);
  }
  function te(Z, K, z, G) {
    var D = !0, F = !1;
    return z === null ? F = new TypeError("May not write null values to stream") : typeof z != "string" && z !== void 0 && !K.objectMode && (F = new TypeError("Invalid non-string/buffer chunk")), F && (Z.emit("error", F), e.nextTick(G, F), D = !1), D;
  }
  ee.prototype.write = function(Z, K, z) {
    var G = this._writableState, D = !1, F = !G.objectMode && B(Z);
    return F && !A.isBuffer(Z) && (Z = I(Z)), typeof K == "function" && (z = K, K = null), F ? K = "buffer" : K || (K = G.defaultEncoding), typeof z != "function" && (z = V), G.ended ? ie(this, z) : (F || te(this, G, Z, z)) && (G.pendingcb++, D = le(this, G, F, Z, K, z)), D;
  }, ee.prototype.cork = function() {
    var Z = this._writableState;
    Z.corked++;
  }, ee.prototype.uncork = function() {
    var Z = this._writableState;
    Z.corked && (Z.corked--, !Z.writing && !Z.corked && !Z.bufferProcessing && Z.bufferedRequest && Ne(this, Z));
  }, ee.prototype.setDefaultEncoding = function(Z) {
    if (typeof Z == "string" && (Z = Z.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Z + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + Z);
    return this._writableState.defaultEncoding = Z, this;
  };
  function se(Z, K, z) {
    return !Z.objectMode && Z.decodeStrings !== !1 && typeof K == "string" && (K = A.from(K, z)), K;
  }
  Object.defineProperty(ee.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function le(Z, K, z, G, D, F) {
    if (!z) {
      var ae = se(K, G, D);
      G !== ae && (z = !0, D = "buffer", G = ae);
    }
    var ge = K.objectMode ? 1 : G.length;
    K.length += ge;
    var xe = K.length < K.highWaterMark;
    if (xe || (K.needDrain = !0), K.writing || K.corked) {
      var ye = K.lastBufferedRequest;
      K.lastBufferedRequest = {
        chunk: G,
        encoding: D,
        isBuf: z,
        callback: F,
        next: null
      }, ye ? ye.next = K.lastBufferedRequest : K.bufferedRequest = K.lastBufferedRequest, K.bufferedRequestCount += 1;
    } else
      ce(Z, K, !1, ge, G, D, F);
    return xe;
  }
  function ce(Z, K, z, G, D, F, ae) {
    K.writelen = G, K.writecb = ae, K.writing = !0, K.sync = !0, z ? Z._writev(D, K.onwrite) : Z._write(D, F, K.onwrite), K.sync = !1;
  }
  function pe(Z, K, z, G, D) {
    --K.pendingcb, z ? (e.nextTick(D, G), e.nextTick($, Z, K), Z._writableState.errorEmitted = !0, Z.emit("error", G)) : (D(G), Z._writableState.errorEmitted = !0, Z.emit("error", G), $(Z, K));
  }
  function me(Z) {
    Z.writing = !1, Z.writecb = null, Z.length -= Z.writelen, Z.writelen = 0;
  }
  function Me(Z, K) {
    var z = Z._writableState, G = z.sync, D = z.writecb;
    if (me(z), K)
      pe(Z, z, G, K, D);
    else {
      var F = ne(z);
      !F && !z.corked && !z.bufferProcessing && z.bufferedRequest && Ne(Z, z), G ? S(Ee, Z, z, F, D) : Ee(Z, z, F, D);
    }
  }
  function Ee(Z, K, z, G) {
    z || Re(Z, K), K.pendingcb--, G(), $(Z, K);
  }
  function Re(Z, K) {
    K.length === 0 && K.needDrain && (K.needDrain = !1, Z.emit("drain"));
  }
  function Ne(Z, K) {
    K.bufferProcessing = !0;
    var z = K.bufferedRequest;
    if (Z._writev && z && z.next) {
      var G = K.bufferedRequestCount, D = new Array(G), F = K.corkedRequestsFree;
      F.entry = z;
      for (var ae = 0, ge = !0; z; )
        D[ae] = z, z.isBuf || (ge = !1), z = z.next, ae += 1;
      D.allBuffers = ge, ce(Z, K, !0, K.length, D, "", F.finish), K.pendingcb++, K.lastBufferedRequest = null, F.next ? (K.corkedRequestsFree = F.next, F.next = null) : K.corkedRequestsFree = new o(K), K.bufferedRequestCount = 0;
    } else {
      for (; z; ) {
        var xe = z.chunk, ye = z.encoding, oe = z.callback, fe = K.objectMode ? 1 : xe.length;
        if (ce(Z, K, !1, fe, xe, ye, oe), z = z.next, K.bufferedRequestCount--, K.writing)
          break;
      }
      z === null && (K.lastBufferedRequest = null);
    }
    K.bufferedRequest = z, K.bufferProcessing = !1;
  }
  ee.prototype._write = function(Z, K, z) {
    z(new Error("_write() is not implemented"));
  }, ee.prototype._writev = null, ee.prototype.end = function(Z, K, z) {
    var G = this._writableState;
    typeof Z == "function" ? (z = Z, Z = null, K = null) : typeof K == "function" && (z = K, K = null), Z != null && this.write(Z, K), G.corked && (G.corked = 1, this.uncork()), G.ending || O(this, G, z);
  };
  function ne(Z) {
    return Z.ending && Z.length === 0 && Z.bufferedRequest === null && !Z.finished && !Z.writing;
  }
  function Y(Z, K) {
    Z._final(function(z) {
      K.pendingcb--, z && Z.emit("error", z), K.prefinished = !0, Z.emit("prefinish"), $(Z, K);
    });
  }
  function M(Z, K) {
    !K.prefinished && !K.finalCalled && (typeof Z._final == "function" ? (K.pendingcb++, K.finalCalled = !0, e.nextTick(Y, Z, K)) : (K.prefinished = !0, Z.emit("prefinish")));
  }
  function $(Z, K) {
    var z = ne(K);
    return z && (M(Z, K), K.pendingcb === 0 && (K.finished = !0, Z.emit("finish"))), z;
  }
  function O(Z, K, z) {
    K.ending = !0, $(Z, K), z && (K.finished ? e.nextTick(z) : Z.once("finish", z)), K.ended = !0, Z.writable = !1;
  }
  function J(Z, K, z) {
    var G = Z.entry;
    for (Z.entry = null; G; ) {
      var D = G.callback;
      K.pendingcb--, D(z), G = G.next;
    }
    K.corkedRequestsFree.next = Z;
  }
  return Object.defineProperty(ee.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Z) {
      this._writableState && (this._writableState.destroyed = Z);
    }
  }), ee.prototype.destroy = H.destroy, ee.prototype._undestroy = H.undestroy, ee.prototype._destroy = function(Z, K) {
    this.end(), K(Z);
  }, _stream_writable$2;
}
var _stream_duplex$2, hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2)
    return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var e = requireProcessNextickArgs$1(), o = Object.keys || function(H) {
    var V = [];
    for (var X in H)
      V.push(X);
    return V;
  };
  _stream_duplex$2 = P;
  var S = Object.create(requireUtil$2());
  S.inherits = requireInherits_browser$1();
  var g = require_stream_readable$2(), U = require_stream_writable$2();
  S.inherits(P, g);
  for (var h = o(U.prototype), q = 0; q < h.length; q++) {
    var A = h[q];
    P.prototype[A] || (P.prototype[A] = U.prototype[A]);
  }
  function P(H) {
    if (!(this instanceof P))
      return new P(H);
    g.call(this, H), U.call(this, H), H && H.readable === !1 && (this.readable = !1), H && H.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, H && H.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", I);
  }
  Object.defineProperty(P.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function I() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(B, this);
  }
  function B(H) {
    H.end();
  }
  return Object.defineProperty(P.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(H) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = H, this._writableState.destroyed = H);
    }
  }), P.prototype._destroy = function(H, V) {
    this.push(null), this.end(), e.nextTick(V, H);
  }, _stream_duplex$2;
}
var _stream_readable$2, hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2)
    return _stream_readable$2;
  hasRequired_stream_readable$2 = 1;
  var e = requireProcessNextickArgs$1();
  _stream_readable$2 = se;
  var o = requireIsarray$1(), S;
  se.ReadableState = te, requireEvents().EventEmitter;
  var g = function(oe, fe) {
    return oe.listeners(fe).length;
  }, U = requireStreamBrowser$2(), h = requireSafeBuffer$2().Buffer, q = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function A(oe) {
    return h.from(oe);
  }
  function P(oe) {
    return h.isBuffer(oe) || oe instanceof q;
  }
  var I = Object.create(requireUtil$2());
  I.inherits = requireInherits_browser$1();
  var B = requireUtil$1$1(), H = void 0;
  B && B.debuglog ? H = B.debuglog("stream") : H = function() {
  };
  var V = requireBufferList$1(), X = requireDestroy$2(), Q;
  I.inherits(se, U);
  var ee = ["error", "close", "destroy", "pause", "resume"];
  function ie(oe, fe, $e) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(fe, $e);
    !oe._events || !oe._events[fe] ? oe.on(fe, $e) : o(oe._events[fe]) ? oe._events[fe].unshift($e) : oe._events[fe] = [$e, oe._events[fe]];
  }
  function te(oe, fe) {
    S = S || require_stream_duplex$2(), oe = oe || {};
    var $e = fe instanceof S;
    this.objectMode = !!oe.objectMode, $e && (this.objectMode = this.objectMode || !!oe.readableObjectMode);
    var Be = oe.highWaterMark, be = oe.readableHighWaterMark, ve = this.objectMode ? 16 : 16 * 1024;
    Be || Be === 0 ? this.highWaterMark = Be : $e && (be || be === 0) ? this.highWaterMark = be : this.highWaterMark = ve, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new V(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (Q || (Q = requireString_decoder$1().StringDecoder), this.decoder = new Q(oe.encoding), this.encoding = oe.encoding);
  }
  function se(oe) {
    if (S = S || require_stream_duplex$2(), !(this instanceof se))
      return new se(oe);
    this._readableState = new te(oe, this), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), U.call(this);
  }
  Object.defineProperty(se.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(oe) {
      this._readableState && (this._readableState.destroyed = oe);
    }
  }), se.prototype.destroy = X.destroy, se.prototype._undestroy = X.undestroy, se.prototype._destroy = function(oe, fe) {
    this.push(null), fe(oe);
  }, se.prototype.push = function(oe, fe) {
    var $e = this._readableState, Be;
    return $e.objectMode ? Be = !0 : typeof oe == "string" && (fe = fe || $e.defaultEncoding, fe !== $e.encoding && (oe = h.from(oe, fe), fe = ""), Be = !0), le(this, oe, fe, !1, Be);
  }, se.prototype.unshift = function(oe) {
    return le(this, oe, null, !0, !1);
  };
  function le(oe, fe, $e, Be, be) {
    var ve = oe._readableState;
    if (fe === null)
      ve.reading = !1, Ne(oe, ve);
    else {
      var qe;
      be || (qe = pe(ve, fe)), qe ? oe.emit("error", qe) : ve.objectMode || fe && fe.length > 0 ? (typeof fe != "string" && !ve.objectMode && Object.getPrototypeOf(fe) !== h.prototype && (fe = A(fe)), Be ? ve.endEmitted ? oe.emit("error", new Error("stream.unshift() after end event")) : ce(oe, ve, fe, !0) : ve.ended ? oe.emit("error", new Error("stream.push() after EOF")) : (ve.reading = !1, ve.decoder && !$e ? (fe = ve.decoder.write(fe), ve.objectMode || fe.length !== 0 ? ce(oe, ve, fe, !1) : M(oe, ve)) : ce(oe, ve, fe, !1))) : Be || (ve.reading = !1);
    }
    return me(ve);
  }
  function ce(oe, fe, $e, Be) {
    fe.flowing && fe.length === 0 && !fe.sync ? (oe.emit("data", $e), oe.read(0)) : (fe.length += fe.objectMode ? 1 : $e.length, Be ? fe.buffer.unshift($e) : fe.buffer.push($e), fe.needReadable && ne(oe)), M(oe, fe);
  }
  function pe(oe, fe) {
    var $e;
    return !P(fe) && typeof fe != "string" && fe !== void 0 && !oe.objectMode && ($e = new TypeError("Invalid non-string/buffer chunk")), $e;
  }
  function me(oe) {
    return !oe.ended && (oe.needReadable || oe.length < oe.highWaterMark || oe.length === 0);
  }
  se.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, se.prototype.setEncoding = function(oe) {
    return Q || (Q = requireString_decoder$1().StringDecoder), this._readableState.decoder = new Q(oe), this._readableState.encoding = oe, this;
  };
  var Me = 8388608;
  function Ee(oe) {
    return oe >= Me ? oe = Me : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function Re(oe, fe) {
    return oe <= 0 || fe.length === 0 && fe.ended ? 0 : fe.objectMode ? 1 : oe !== oe ? fe.flowing && fe.length ? fe.buffer.head.data.length : fe.length : (oe > fe.highWaterMark && (fe.highWaterMark = Ee(oe)), oe <= fe.length ? oe : fe.ended ? fe.length : (fe.needReadable = !0, 0));
  }
  se.prototype.read = function(oe) {
    H("read", oe), oe = parseInt(oe, 10);
    var fe = this._readableState, $e = oe;
    if (oe !== 0 && (fe.emittedReadable = !1), oe === 0 && fe.needReadable && (fe.length >= fe.highWaterMark || fe.ended))
      return H("read: emitReadable", fe.length, fe.ended), fe.length === 0 && fe.ended ? ge(this) : ne(this), null;
    if (oe = Re(oe, fe), oe === 0 && fe.ended)
      return fe.length === 0 && ge(this), null;
    var Be = fe.needReadable;
    H("need readable", Be), (fe.length === 0 || fe.length - oe < fe.highWaterMark) && (Be = !0, H("length less than watermark", Be)), fe.ended || fe.reading ? (Be = !1, H("reading or ended", Be)) : Be && (H("do read"), fe.reading = !0, fe.sync = !0, fe.length === 0 && (fe.needReadable = !0), this._read(fe.highWaterMark), fe.sync = !1, fe.reading || (oe = Re($e, fe)));
    var be;
    return oe > 0 ? be = G(oe, fe) : be = null, be === null ? (fe.needReadable = !0, oe = 0) : fe.length -= oe, fe.length === 0 && (fe.ended || (fe.needReadable = !0), $e !== oe && fe.ended && ge(this)), be !== null && this.emit("data", be), be;
  };
  function Ne(oe, fe) {
    if (!fe.ended) {
      if (fe.decoder) {
        var $e = fe.decoder.end();
        $e && $e.length && (fe.buffer.push($e), fe.length += fe.objectMode ? 1 : $e.length);
      }
      fe.ended = !0, ne(oe);
    }
  }
  function ne(oe) {
    var fe = oe._readableState;
    fe.needReadable = !1, fe.emittedReadable || (H("emitReadable", fe.flowing), fe.emittedReadable = !0, fe.sync ? e.nextTick(Y, oe) : Y(oe));
  }
  function Y(oe) {
    H("emit readable"), oe.emit("readable"), z(oe);
  }
  function M(oe, fe) {
    fe.readingMore || (fe.readingMore = !0, e.nextTick($, oe, fe));
  }
  function $(oe, fe) {
    for (var $e = fe.length; !fe.reading && !fe.flowing && !fe.ended && fe.length < fe.highWaterMark && (H("maybeReadMore read 0"), oe.read(0), $e !== fe.length); )
      $e = fe.length;
    fe.readingMore = !1;
  }
  se.prototype._read = function(oe) {
    this.emit("error", new Error("_read() is not implemented"));
  }, se.prototype.pipe = function(oe, fe) {
    var $e = this, Be = this._readableState;
    switch (Be.pipesCount) {
      case 0:
        Be.pipes = oe;
        break;
      case 1:
        Be.pipes = [Be.pipes, oe];
        break;
      default:
        Be.pipes.push(oe);
        break;
    }
    Be.pipesCount += 1, H("pipe count=%d opts=%j", Be.pipesCount, fe);
    var be = (!fe || fe.end !== !1) && oe !== process$1.stdout && oe !== process$1.stderr, ve = be ? De : nt;
    Be.endEmitted ? e.nextTick(ve) : $e.once("end", ve), oe.on("unpipe", qe);
    function qe(Ie, Fe) {
      H("onunpipe"), Ie === $e && Fe && Fe.hasUnpiped === !1 && (Fe.hasUnpiped = !0, ue());
    }
    function De() {
      H("onend"), oe.end();
    }
    var Ye = O($e);
    oe.on("drain", Ye);
    var he = !1;
    function ue() {
      H("cleanup"), oe.removeListener("close", He), oe.removeListener("finish", Ve), oe.removeListener("drain", Ye), oe.removeListener("error", Pe), oe.removeListener("unpipe", qe), $e.removeListener("end", De), $e.removeListener("end", nt), $e.removeListener("data", _e), he = !0, Be.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && Ye();
    }
    var de = !1;
    $e.on("data", _e);
    function _e(Ie) {
      H("ondata"), de = !1;
      var Fe = oe.write(Ie);
      Fe === !1 && !de && ((Be.pipesCount === 1 && Be.pipes === oe || Be.pipesCount > 1 && ye(Be.pipes, oe) !== -1) && !he && (H("false write response, pause", Be.awaitDrain), Be.awaitDrain++, de = !0), $e.pause());
    }
    function Pe(Ie) {
      H("onerror", Ie), nt(), oe.removeListener("error", Pe), g(oe, "error") === 0 && oe.emit("error", Ie);
    }
    ie(oe, "error", Pe);
    function He() {
      oe.removeListener("finish", Ve), nt();
    }
    oe.once("close", He);
    function Ve() {
      H("onfinish"), oe.removeListener("close", He), nt();
    }
    oe.once("finish", Ve);
    function nt() {
      H("unpipe"), $e.unpipe(oe);
    }
    return oe.emit("pipe", $e), Be.flowing || (H("pipe resume"), $e.resume()), oe;
  };
  function O(oe) {
    return function() {
      var fe = oe._readableState;
      H("pipeOnDrain", fe.awaitDrain), fe.awaitDrain && fe.awaitDrain--, fe.awaitDrain === 0 && g(oe, "data") && (fe.flowing = !0, z(oe));
    };
  }
  se.prototype.unpipe = function(oe) {
    var fe = this._readableState, $e = { hasUnpiped: !1 };
    if (fe.pipesCount === 0)
      return this;
    if (fe.pipesCount === 1)
      return oe && oe !== fe.pipes ? this : (oe || (oe = fe.pipes), fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1, oe && oe.emit("unpipe", this, $e), this);
    if (!oe) {
      var Be = fe.pipes, be = fe.pipesCount;
      fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1;
      for (var ve = 0; ve < be; ve++)
        Be[ve].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var qe = ye(fe.pipes, oe);
    return qe === -1 ? this : (fe.pipes.splice(qe, 1), fe.pipesCount -= 1, fe.pipesCount === 1 && (fe.pipes = fe.pipes[0]), oe.emit("unpipe", this, $e), this);
  }, se.prototype.on = function(oe, fe) {
    var $e = U.prototype.on.call(this, oe, fe);
    if (oe === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (oe === "readable") {
      var Be = this._readableState;
      !Be.endEmitted && !Be.readableListening && (Be.readableListening = Be.needReadable = !0, Be.emittedReadable = !1, Be.reading ? Be.length && ne(this) : e.nextTick(J, this));
    }
    return $e;
  }, se.prototype.addListener = se.prototype.on;
  function J(oe) {
    H("readable nexttick read 0"), oe.read(0);
  }
  se.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (H("resume"), oe.flowing = !0, Z(this, oe)), this;
  };
  function Z(oe, fe) {
    fe.resumeScheduled || (fe.resumeScheduled = !0, e.nextTick(K, oe, fe));
  }
  function K(oe, fe) {
    fe.reading || (H("resume read 0"), oe.read(0)), fe.resumeScheduled = !1, fe.awaitDrain = 0, oe.emit("resume"), z(oe), fe.flowing && !fe.reading && oe.read(0);
  }
  se.prototype.pause = function() {
    return H("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (H("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function z(oe) {
    var fe = oe._readableState;
    for (H("flow", fe.flowing); fe.flowing && oe.read() !== null; )
      ;
  }
  se.prototype.wrap = function(oe) {
    var fe = this, $e = this._readableState, Be = !1;
    oe.on("end", function() {
      if (H("wrapped end"), $e.decoder && !$e.ended) {
        var qe = $e.decoder.end();
        qe && qe.length && fe.push(qe);
      }
      fe.push(null);
    }), oe.on("data", function(qe) {
      if (H("wrapped data"), $e.decoder && (qe = $e.decoder.write(qe)), !($e.objectMode && qe == null) && !(!$e.objectMode && (!qe || !qe.length))) {
        var De = fe.push(qe);
        De || (Be = !0, oe.pause());
      }
    });
    for (var be in oe)
      this[be] === void 0 && typeof oe[be] == "function" && (this[be] = /* @__PURE__ */ function(qe) {
        return function() {
          return oe[qe].apply(oe, arguments);
        };
      }(be));
    for (var ve = 0; ve < ee.length; ve++)
      oe.on(ee[ve], this.emit.bind(this, ee[ve]));
    return this._read = function(qe) {
      H("wrapped _read", qe), Be && (Be = !1, oe.resume());
    }, this;
  }, Object.defineProperty(se.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), se._fromList = G;
  function G(oe, fe) {
    if (fe.length === 0)
      return null;
    var $e;
    return fe.objectMode ? $e = fe.buffer.shift() : !oe || oe >= fe.length ? (fe.decoder ? $e = fe.buffer.join("") : fe.buffer.length === 1 ? $e = fe.buffer.head.data : $e = fe.buffer.concat(fe.length), fe.buffer.clear()) : $e = D(oe, fe.buffer, fe.decoder), $e;
  }
  function D(oe, fe, $e) {
    var Be;
    return oe < fe.head.data.length ? (Be = fe.head.data.slice(0, oe), fe.head.data = fe.head.data.slice(oe)) : oe === fe.head.data.length ? Be = fe.shift() : Be = $e ? F(oe, fe) : ae(oe, fe), Be;
  }
  function F(oe, fe) {
    var $e = fe.head, Be = 1, be = $e.data;
    for (oe -= be.length; $e = $e.next; ) {
      var ve = $e.data, qe = oe > ve.length ? ve.length : oe;
      if (qe === ve.length ? be += ve : be += ve.slice(0, oe), oe -= qe, oe === 0) {
        qe === ve.length ? (++Be, $e.next ? fe.head = $e.next : fe.head = fe.tail = null) : (fe.head = $e, $e.data = ve.slice(qe));
        break;
      }
      ++Be;
    }
    return fe.length -= Be, be;
  }
  function ae(oe, fe) {
    var $e = h.allocUnsafe(oe), Be = fe.head, be = 1;
    for (Be.data.copy($e), oe -= Be.data.length; Be = Be.next; ) {
      var ve = Be.data, qe = oe > ve.length ? ve.length : oe;
      if (ve.copy($e, $e.length - oe, 0, qe), oe -= qe, oe === 0) {
        qe === ve.length ? (++be, Be.next ? fe.head = Be.next : fe.head = fe.tail = null) : (fe.head = Be, Be.data = ve.slice(qe));
        break;
      }
      ++be;
    }
    return fe.length -= be, $e;
  }
  function ge(oe) {
    var fe = oe._readableState;
    if (fe.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    fe.endEmitted || (fe.ended = !0, e.nextTick(xe, fe, oe));
  }
  function xe(oe, fe) {
    !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, fe.readable = !1, fe.emit("end"));
  }
  function ye(oe, fe) {
    for (var $e = 0, Be = oe.length; $e < Be; $e++)
      if (oe[$e] === fe)
        return $e;
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2, hasRequired_stream_transform$2;
function require_stream_transform$2() {
  if (hasRequired_stream_transform$2)
    return _stream_transform$2;
  hasRequired_stream_transform$2 = 1, _stream_transform$2 = g;
  var e = require_stream_duplex$2(), o = Object.create(requireUtil$2());
  o.inherits = requireInherits_browser$1(), o.inherits(g, e);
  function S(q, A) {
    var P = this._transformState;
    P.transforming = !1;
    var I = P.writecb;
    if (!I)
      return this.emit("error", new Error("write callback called multiple times"));
    P.writechunk = null, P.writecb = null, A != null && this.push(A), I(q);
    var B = this._readableState;
    B.reading = !1, (B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark);
  }
  function g(q) {
    if (!(this instanceof g))
      return new g(q);
    e.call(this, q), this._transformState = {
      afterTransform: S.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, q && (typeof q.transform == "function" && (this._transform = q.transform), typeof q.flush == "function" && (this._flush = q.flush)), this.on("prefinish", U);
  }
  function U() {
    var q = this;
    typeof this._flush == "function" ? this._flush(function(A, P) {
      h(q, A, P);
    }) : h(this, null, null);
  }
  g.prototype.push = function(q, A) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, q, A);
  }, g.prototype._transform = function(q, A, P) {
    throw new Error("_transform() is not implemented");
  }, g.prototype._write = function(q, A, P) {
    var I = this._transformState;
    if (I.writecb = P, I.writechunk = q, I.writeencoding = A, !I.transforming) {
      var B = this._readableState;
      (I.needTransform || B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark);
    }
  }, g.prototype._read = function(q) {
    var A = this._transformState;
    A.writechunk !== null && A.writecb && !A.transforming ? (A.transforming = !0, this._transform(A.writechunk, A.writeencoding, A.afterTransform)) : A.needTransform = !0;
  }, g.prototype._destroy = function(q, A) {
    var P = this;
    e.prototype._destroy.call(this, q, function(I) {
      A(I), P.emit("close");
    });
  };
  function h(q, A, P) {
    if (A)
      return q.emit("error", A);
    if (P != null && q.push(P), q._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (q._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return q.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2, hasRequired_stream_passthrough$2;
function require_stream_passthrough$2() {
  if (hasRequired_stream_passthrough$2)
    return _stream_passthrough$2;
  hasRequired_stream_passthrough$2 = 1, _stream_passthrough$2 = S;
  var e = require_stream_transform$2(), o = Object.create(requireUtil$2());
  o.inherits = requireInherits_browser$1(), o.inherits(S, e);
  function S(g) {
    if (!(this instanceof S))
      return new S(g);
    e.call(this, g);
  }
  return S.prototype._transform = function(g, U, h) {
    h(null, g);
  }, _stream_passthrough$2;
}
var hasRequiredReadableBrowser$2;
function requireReadableBrowser$2() {
  return hasRequiredReadableBrowser$2 || (hasRequiredReadableBrowser$2 = 1, function(e, o) {
    o = e.exports = require_stream_readable$2(), o.Stream = o, o.Readable = o, o.Writable = require_stream_writable$2(), o.Duplex = require_stream_duplex$2(), o.Transform = require_stream_transform$2(), o.PassThrough = require_stream_passthrough$2();
  }(readableBrowser$2, readableBrowser$2.exports)), readableBrowser$2.exports;
}
var sign$2 = { exports: {} }, bn$1$1 = { exports: {} }, hasRequiredBn$1$1;
function requireBn$1$1() {
  return hasRequiredBn$1$1 || (hasRequiredBn$1$1 = 1, function(e) {
    (function(o, S) {
      function g(M, $) {
        if (!M)
          throw new Error($ || "Assertion failed");
      }
      function U(M, $) {
        M.super_ = $;
        var O = function() {
        };
        O.prototype = $.prototype, M.prototype = new O(), M.prototype.constructor = M;
      }
      function h(M, $, O) {
        if (h.isBN(M))
          return M;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && (($ === "le" || $ === "be") && (O = $, $ = 10), this._init(M || 0, $ || 10, O || "be"));
      }
      typeof o == "object" ? o.exports = h : S.BN = h, h.BN = h, h.wordSize = 26;
      var q;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? q = window.Buffer : q = requireBuffer$1().Buffer;
      } catch {
      }
      h.isBN = function(M) {
        return M instanceof h ? !0 : M !== null && typeof M == "object" && M.constructor.wordSize === h.wordSize && Array.isArray(M.words);
      }, h.max = function(M, $) {
        return M.cmp($) > 0 ? M : $;
      }, h.min = function(M, $) {
        return M.cmp($) < 0 ? M : $;
      }, h.prototype._init = function(M, $, O) {
        if (typeof M == "number")
          return this._initNumber(M, $, O);
        if (typeof M == "object")
          return this._initArray(M, $, O);
        $ === "hex" && ($ = 16), g($ === ($ | 0) && $ >= 2 && $ <= 36), M = M.toString().replace(/\s+/g, "");
        var J = 0;
        M[0] === "-" && (J++, this.negative = 1), J < M.length && ($ === 16 ? this._parseHex(M, J, O) : (this._parseBase(M, $, J), O === "le" && this._initArray(this.toArray(), $, O)));
      }, h.prototype._initNumber = function(M, $, O) {
        M < 0 && (this.negative = 1, M = -M), M < 67108864 ? (this.words = [M & 67108863], this.length = 1) : M < 4503599627370496 ? (this.words = [
          M & 67108863,
          M / 67108864 & 67108863
        ], this.length = 2) : (g(M < 9007199254740992), this.words = [
          M & 67108863,
          M / 67108864 & 67108863,
          1
        ], this.length = 3), O === "le" && this._initArray(this.toArray(), $, O);
      }, h.prototype._initArray = function(M, $, O) {
        if (g(typeof M.length == "number"), M.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(M.length / 3), this.words = new Array(this.length);
        for (var J = 0; J < this.length; J++)
          this.words[J] = 0;
        var Z, K, z = 0;
        if (O === "be")
          for (J = M.length - 1, Z = 0; J >= 0; J -= 3)
            K = M[J] | M[J - 1] << 8 | M[J - 2] << 16, this.words[Z] |= K << z & 67108863, this.words[Z + 1] = K >>> 26 - z & 67108863, z += 24, z >= 26 && (z -= 26, Z++);
        else if (O === "le")
          for (J = 0, Z = 0; J < M.length; J += 3)
            K = M[J] | M[J + 1] << 8 | M[J + 2] << 16, this.words[Z] |= K << z & 67108863, this.words[Z + 1] = K >>> 26 - z & 67108863, z += 24, z >= 26 && (z -= 26, Z++);
        return this._strip();
      };
      function A(M, $) {
        var O = M.charCodeAt($);
        if (O >= 48 && O <= 57)
          return O - 48;
        if (O >= 65 && O <= 70)
          return O - 55;
        if (O >= 97 && O <= 102)
          return O - 87;
        g(!1, "Invalid character in " + M);
      }
      function P(M, $, O) {
        var J = A(M, O);
        return O - 1 >= $ && (J |= A(M, O - 1) << 4), J;
      }
      h.prototype._parseHex = function(M, $, O) {
        this.length = Math.ceil((M.length - $) / 6), this.words = new Array(this.length);
        for (var J = 0; J < this.length; J++)
          this.words[J] = 0;
        var Z = 0, K = 0, z;
        if (O === "be")
          for (J = M.length - 1; J >= $; J -= 2)
            z = P(M, $, J) << Z, this.words[K] |= z & 67108863, Z >= 18 ? (Z -= 18, K += 1, this.words[K] |= z >>> 26) : Z += 8;
        else {
          var G = M.length - $;
          for (J = G % 2 === 0 ? $ + 1 : $; J < M.length; J += 2)
            z = P(M, $, J) << Z, this.words[K] |= z & 67108863, Z >= 18 ? (Z -= 18, K += 1, this.words[K] |= z >>> 26) : Z += 8;
        }
        this._strip();
      };
      function I(M, $, O, J) {
        for (var Z = 0, K = 0, z = Math.min(M.length, O), G = $; G < z; G++) {
          var D = M.charCodeAt(G) - 48;
          Z *= J, D >= 49 ? K = D - 49 + 10 : D >= 17 ? K = D - 17 + 10 : K = D, g(D >= 0 && K < J, "Invalid character"), Z += K;
        }
        return Z;
      }
      h.prototype._parseBase = function(M, $, O) {
        this.words = [0], this.length = 1;
        for (var J = 0, Z = 1; Z <= 67108863; Z *= $)
          J++;
        J--, Z = Z / $ | 0;
        for (var K = M.length - O, z = K % J, G = Math.min(K, K - z) + O, D = 0, F = O; F < G; F += J)
          D = I(M, F, F + J, $), this.imuln(Z), this.words[0] + D < 67108864 ? this.words[0] += D : this._iaddn(D);
        if (z !== 0) {
          var ae = 1;
          for (D = I(M, F, M.length, $), F = 0; F < z; F++)
            ae *= $;
          this.imuln(ae), this.words[0] + D < 67108864 ? this.words[0] += D : this._iaddn(D);
        }
        this._strip();
      }, h.prototype.copy = function(M) {
        M.words = new Array(this.length);
        for (var $ = 0; $ < this.length; $++)
          M.words[$] = this.words[$];
        M.length = this.length, M.negative = this.negative, M.red = this.red;
      };
      function B(M, $) {
        M.words = $.words, M.length = $.length, M.negative = $.negative, M.red = $.red;
      }
      if (h.prototype._move = function(M) {
        B(M, this);
      }, h.prototype.clone = function() {
        var M = new h(null);
        return this.copy(M), M;
      }, h.prototype._expand = function(M) {
        for (; this.length < M; )
          this.words[this.length++] = 0;
        return this;
      }, h.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, h.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          h.prototype[Symbol.for("nodejs.util.inspect.custom")] = H;
        } catch {
          h.prototype.inspect = H;
        }
      else
        h.prototype.inspect = H;
      function H() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var V = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], X = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Q = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      h.prototype.toString = function(M, $) {
        M = M || 10, $ = $ | 0 || 1;
        var O;
        if (M === 16 || M === "hex") {
          O = "";
          for (var J = 0, Z = 0, K = 0; K < this.length; K++) {
            var z = this.words[K], G = ((z << J | Z) & 16777215).toString(16);
            Z = z >>> 24 - J & 16777215, J += 2, J >= 26 && (J -= 26, K--), Z !== 0 || K !== this.length - 1 ? O = V[6 - G.length] + G + O : O = G + O;
          }
          for (Z !== 0 && (O = Z.toString(16) + O); O.length % $ !== 0; )
            O = "0" + O;
          return this.negative !== 0 && (O = "-" + O), O;
        }
        if (M === (M | 0) && M >= 2 && M <= 36) {
          var D = X[M], F = Q[M];
          O = "";
          var ae = this.clone();
          for (ae.negative = 0; !ae.isZero(); ) {
            var ge = ae.modrn(F).toString(M);
            ae = ae.idivn(F), ae.isZero() ? O = ge + O : O = V[D - ge.length] + ge + O;
          }
          for (this.isZero() && (O = "0" + O); O.length % $ !== 0; )
            O = "0" + O;
          return this.negative !== 0 && (O = "-" + O), O;
        }
        g(!1, "Base should be between 2 and 36");
      }, h.prototype.toNumber = function() {
        var M = this.words[0];
        return this.length === 2 ? M += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? M += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && g(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -M : M;
      }, h.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, q && (h.prototype.toBuffer = function(M, $) {
        return this.toArrayLike(q, M, $);
      }), h.prototype.toArray = function(M, $) {
        return this.toArrayLike(Array, M, $);
      };
      var ee = function(M, $) {
        return M.allocUnsafe ? M.allocUnsafe($) : new M($);
      };
      h.prototype.toArrayLike = function(M, $, O) {
        this._strip();
        var J = this.byteLength(), Z = O || Math.max(1, J);
        g(J <= Z, "byte array longer than desired length"), g(Z > 0, "Requested array length <= 0");
        var K = ee(M, Z), z = $ === "le" ? "LE" : "BE";
        return this["_toArrayLike" + z](K, J), K;
      }, h.prototype._toArrayLikeLE = function(M, $) {
        for (var O = 0, J = 0, Z = 0, K = 0; Z < this.length; Z++) {
          var z = this.words[Z] << K | J;
          M[O++] = z & 255, O < M.length && (M[O++] = z >> 8 & 255), O < M.length && (M[O++] = z >> 16 & 255), K === 6 ? (O < M.length && (M[O++] = z >> 24 & 255), J = 0, K = 0) : (J = z >>> 24, K += 2);
        }
        if (O < M.length)
          for (M[O++] = J; O < M.length; )
            M[O++] = 0;
      }, h.prototype._toArrayLikeBE = function(M, $) {
        for (var O = M.length - 1, J = 0, Z = 0, K = 0; Z < this.length; Z++) {
          var z = this.words[Z] << K | J;
          M[O--] = z & 255, O >= 0 && (M[O--] = z >> 8 & 255), O >= 0 && (M[O--] = z >> 16 & 255), K === 6 ? (O >= 0 && (M[O--] = z >> 24 & 255), J = 0, K = 0) : (J = z >>> 24, K += 2);
        }
        if (O >= 0)
          for (M[O--] = J; O >= 0; )
            M[O--] = 0;
      }, Math.clz32 ? h.prototype._countBits = function(M) {
        return 32 - Math.clz32(M);
      } : h.prototype._countBits = function(M) {
        var $ = M, O = 0;
        return $ >= 4096 && (O += 13, $ >>>= 13), $ >= 64 && (O += 7, $ >>>= 7), $ >= 8 && (O += 4, $ >>>= 4), $ >= 2 && (O += 2, $ >>>= 2), O + $;
      }, h.prototype._zeroBits = function(M) {
        if (M === 0)
          return 26;
        var $ = M, O = 0;
        return $ & 8191 || (O += 13, $ >>>= 13), $ & 127 || (O += 7, $ >>>= 7), $ & 15 || (O += 4, $ >>>= 4), $ & 3 || (O += 2, $ >>>= 2), $ & 1 || O++, O;
      }, h.prototype.bitLength = function() {
        var M = this.words[this.length - 1], $ = this._countBits(M);
        return (this.length - 1) * 26 + $;
      };
      function ie(M) {
        for (var $ = new Array(M.bitLength()), O = 0; O < $.length; O++) {
          var J = O / 26 | 0, Z = O % 26;
          $[O] = M.words[J] >>> Z & 1;
        }
        return $;
      }
      h.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var M = 0, $ = 0; $ < this.length; $++) {
          var O = this._zeroBits(this.words[$]);
          if (M += O, O !== 26)
            break;
        }
        return M;
      }, h.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, h.prototype.toTwos = function(M) {
        return this.negative !== 0 ? this.abs().inotn(M).iaddn(1) : this.clone();
      }, h.prototype.fromTwos = function(M) {
        return this.testn(M - 1) ? this.notn(M).iaddn(1).ineg() : this.clone();
      }, h.prototype.isNeg = function() {
        return this.negative !== 0;
      }, h.prototype.neg = function() {
        return this.clone().ineg();
      }, h.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, h.prototype.iuor = function(M) {
        for (; this.length < M.length; )
          this.words[this.length++] = 0;
        for (var $ = 0; $ < M.length; $++)
          this.words[$] = this.words[$] | M.words[$];
        return this._strip();
      }, h.prototype.ior = function(M) {
        return g((this.negative | M.negative) === 0), this.iuor(M);
      }, h.prototype.or = function(M) {
        return this.length > M.length ? this.clone().ior(M) : M.clone().ior(this);
      }, h.prototype.uor = function(M) {
        return this.length > M.length ? this.clone().iuor(M) : M.clone().iuor(this);
      }, h.prototype.iuand = function(M) {
        var $;
        this.length > M.length ? $ = M : $ = this;
        for (var O = 0; O < $.length; O++)
          this.words[O] = this.words[O] & M.words[O];
        return this.length = $.length, this._strip();
      }, h.prototype.iand = function(M) {
        return g((this.negative | M.negative) === 0), this.iuand(M);
      }, h.prototype.and = function(M) {
        return this.length > M.length ? this.clone().iand(M) : M.clone().iand(this);
      }, h.prototype.uand = function(M) {
        return this.length > M.length ? this.clone().iuand(M) : M.clone().iuand(this);
      }, h.prototype.iuxor = function(M) {
        var $, O;
        this.length > M.length ? ($ = this, O = M) : ($ = M, O = this);
        for (var J = 0; J < O.length; J++)
          this.words[J] = $.words[J] ^ O.words[J];
        if (this !== $)
          for (; J < $.length; J++)
            this.words[J] = $.words[J];
        return this.length = $.length, this._strip();
      }, h.prototype.ixor = function(M) {
        return g((this.negative | M.negative) === 0), this.iuxor(M);
      }, h.prototype.xor = function(M) {
        return this.length > M.length ? this.clone().ixor(M) : M.clone().ixor(this);
      }, h.prototype.uxor = function(M) {
        return this.length > M.length ? this.clone().iuxor(M) : M.clone().iuxor(this);
      }, h.prototype.inotn = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = Math.ceil(M / 26) | 0, O = M % 26;
        this._expand($), O > 0 && $--;
        for (var J = 0; J < $; J++)
          this.words[J] = ~this.words[J] & 67108863;
        return O > 0 && (this.words[J] = ~this.words[J] & 67108863 >> 26 - O), this._strip();
      }, h.prototype.notn = function(M) {
        return this.clone().inotn(M);
      }, h.prototype.setn = function(M, $) {
        g(typeof M == "number" && M >= 0);
        var O = M / 26 | 0, J = M % 26;
        return this._expand(O + 1), $ ? this.words[O] = this.words[O] | 1 << J : this.words[O] = this.words[O] & ~(1 << J), this._strip();
      }, h.prototype.iadd = function(M) {
        var $;
        if (this.negative !== 0 && M.negative === 0)
          return this.negative = 0, $ = this.isub(M), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && M.negative !== 0)
          return M.negative = 0, $ = this.isub(M), M.negative = 1, $._normSign();
        var O, J;
        this.length > M.length ? (O = this, J = M) : (O = M, J = this);
        for (var Z = 0, K = 0; K < J.length; K++)
          $ = (O.words[K] | 0) + (J.words[K] | 0) + Z, this.words[K] = $ & 67108863, Z = $ >>> 26;
        for (; Z !== 0 && K < O.length; K++)
          $ = (O.words[K] | 0) + Z, this.words[K] = $ & 67108863, Z = $ >>> 26;
        if (this.length = O.length, Z !== 0)
          this.words[this.length] = Z, this.length++;
        else if (O !== this)
          for (; K < O.length; K++)
            this.words[K] = O.words[K];
        return this;
      }, h.prototype.add = function(M) {
        var $;
        return M.negative !== 0 && this.negative === 0 ? (M.negative = 0, $ = this.sub(M), M.negative ^= 1, $) : M.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = M.sub(this), this.negative = 1, $) : this.length > M.length ? this.clone().iadd(M) : M.clone().iadd(this);
      }, h.prototype.isub = function(M) {
        if (M.negative !== 0) {
          M.negative = 0;
          var $ = this.iadd(M);
          return M.negative = 1, $._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(M), this.negative = 1, this._normSign();
        var O = this.cmp(M);
        if (O === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var J, Z;
        O > 0 ? (J = this, Z = M) : (J = M, Z = this);
        for (var K = 0, z = 0; z < Z.length; z++)
          $ = (J.words[z] | 0) - (Z.words[z] | 0) + K, K = $ >> 26, this.words[z] = $ & 67108863;
        for (; K !== 0 && z < J.length; z++)
          $ = (J.words[z] | 0) + K, K = $ >> 26, this.words[z] = $ & 67108863;
        if (K === 0 && z < J.length && J !== this)
          for (; z < J.length; z++)
            this.words[z] = J.words[z];
        return this.length = Math.max(this.length, z), J !== this && (this.negative = 1), this._strip();
      }, h.prototype.sub = function(M) {
        return this.clone().isub(M);
      };
      function te(M, $, O) {
        O.negative = $.negative ^ M.negative;
        var J = M.length + $.length | 0;
        O.length = J, J = J - 1 | 0;
        var Z = M.words[0] | 0, K = $.words[0] | 0, z = Z * K, G = z & 67108863, D = z / 67108864 | 0;
        O.words[0] = G;
        for (var F = 1; F < J; F++) {
          for (var ae = D >>> 26, ge = D & 67108863, xe = Math.min(F, $.length - 1), ye = Math.max(0, F - M.length + 1); ye <= xe; ye++) {
            var oe = F - ye | 0;
            Z = M.words[oe] | 0, K = $.words[ye] | 0, z = Z * K + ge, ae += z / 67108864 | 0, ge = z & 67108863;
          }
          O.words[F] = ge | 0, D = ae | 0;
        }
        return D !== 0 ? O.words[F] = D | 0 : O.length--, O._strip();
      }
      var se = function(M, $, O) {
        var J = M.words, Z = $.words, K = O.words, z = 0, G, D, F, ae = J[0] | 0, ge = ae & 8191, xe = ae >>> 13, ye = J[1] | 0, oe = ye & 8191, fe = ye >>> 13, $e = J[2] | 0, Be = $e & 8191, be = $e >>> 13, ve = J[3] | 0, qe = ve & 8191, De = ve >>> 13, Ye = J[4] | 0, he = Ye & 8191, ue = Ye >>> 13, de = J[5] | 0, _e = de & 8191, Pe = de >>> 13, He = J[6] | 0, Ve = He & 8191, nt = He >>> 13, Ie = J[7] | 0, Fe = Ie & 8191, je = Ie >>> 13, Ke = J[8] | 0, ot = Ke & 8191, ut = Ke >>> 13, pt = J[9] | 0, ke = pt & 8191, Xe = pt >>> 13, at = Z[0] | 0, ht = at & 8191, We = at >>> 13, tt = Z[1] | 0, Te = tt & 8191, rt = tt >>> 13, mt = Z[2] | 0, Se = mt & 8191, et = mt >>> 13, Ze = Z[3] | 0, Le = Ze & 8191, ze = Ze >>> 13, Qe = Z[4] | 0, _t = Qe & 8191, ft = Qe >>> 13, dt = Z[5] | 0, Mt = dt & 8191, St = dt >>> 13, $t = Z[6] | 0, At = $t & 8191, Ae = $t >>> 13, Ce = Z[7] | 0, Oe = Ce & 8191, we = Ce >>> 13, Ue = Z[8] | 0, Je = Ue & 8191, Ge = Ue >>> 13, st = Z[9] | 0, ct = st & 8191, bt = st >>> 13;
        O.negative = M.negative ^ $.negative, O.length = 19, G = Math.imul(ge, ht), D = Math.imul(ge, We), D = D + Math.imul(xe, ht) | 0, F = Math.imul(xe, We);
        var wt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, G = Math.imul(oe, ht), D = Math.imul(oe, We), D = D + Math.imul(fe, ht) | 0, F = Math.imul(fe, We), G = G + Math.imul(ge, Te) | 0, D = D + Math.imul(ge, rt) | 0, D = D + Math.imul(xe, Te) | 0, F = F + Math.imul(xe, rt) | 0;
        var zt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, G = Math.imul(Be, ht), D = Math.imul(Be, We), D = D + Math.imul(be, ht) | 0, F = Math.imul(be, We), G = G + Math.imul(oe, Te) | 0, D = D + Math.imul(oe, rt) | 0, D = D + Math.imul(fe, Te) | 0, F = F + Math.imul(fe, rt) | 0, G = G + Math.imul(ge, Se) | 0, D = D + Math.imul(ge, et) | 0, D = D + Math.imul(xe, Se) | 0, F = F + Math.imul(xe, et) | 0;
        var Tt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, G = Math.imul(qe, ht), D = Math.imul(qe, We), D = D + Math.imul(De, ht) | 0, F = Math.imul(De, We), G = G + Math.imul(Be, Te) | 0, D = D + Math.imul(Be, rt) | 0, D = D + Math.imul(be, Te) | 0, F = F + Math.imul(be, rt) | 0, G = G + Math.imul(oe, Se) | 0, D = D + Math.imul(oe, et) | 0, D = D + Math.imul(fe, Se) | 0, F = F + Math.imul(fe, et) | 0, G = G + Math.imul(ge, Le) | 0, D = D + Math.imul(ge, ze) | 0, D = D + Math.imul(xe, Le) | 0, F = F + Math.imul(xe, ze) | 0;
        var Lt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(he, ht), D = Math.imul(he, We), D = D + Math.imul(ue, ht) | 0, F = Math.imul(ue, We), G = G + Math.imul(qe, Te) | 0, D = D + Math.imul(qe, rt) | 0, D = D + Math.imul(De, Te) | 0, F = F + Math.imul(De, rt) | 0, G = G + Math.imul(Be, Se) | 0, D = D + Math.imul(Be, et) | 0, D = D + Math.imul(be, Se) | 0, F = F + Math.imul(be, et) | 0, G = G + Math.imul(oe, Le) | 0, D = D + Math.imul(oe, ze) | 0, D = D + Math.imul(fe, Le) | 0, F = F + Math.imul(fe, ze) | 0, G = G + Math.imul(ge, _t) | 0, D = D + Math.imul(ge, ft) | 0, D = D + Math.imul(xe, _t) | 0, F = F + Math.imul(xe, ft) | 0;
        var jt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(_e, ht), D = Math.imul(_e, We), D = D + Math.imul(Pe, ht) | 0, F = Math.imul(Pe, We), G = G + Math.imul(he, Te) | 0, D = D + Math.imul(he, rt) | 0, D = D + Math.imul(ue, Te) | 0, F = F + Math.imul(ue, rt) | 0, G = G + Math.imul(qe, Se) | 0, D = D + Math.imul(qe, et) | 0, D = D + Math.imul(De, Se) | 0, F = F + Math.imul(De, et) | 0, G = G + Math.imul(Be, Le) | 0, D = D + Math.imul(Be, ze) | 0, D = D + Math.imul(be, Le) | 0, F = F + Math.imul(be, ze) | 0, G = G + Math.imul(oe, _t) | 0, D = D + Math.imul(oe, ft) | 0, D = D + Math.imul(fe, _t) | 0, F = F + Math.imul(fe, ft) | 0, G = G + Math.imul(ge, Mt) | 0, D = D + Math.imul(ge, St) | 0, D = D + Math.imul(xe, Mt) | 0, F = F + Math.imul(xe, St) | 0;
        var Ht = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(Ve, ht), D = Math.imul(Ve, We), D = D + Math.imul(nt, ht) | 0, F = Math.imul(nt, We), G = G + Math.imul(_e, Te) | 0, D = D + Math.imul(_e, rt) | 0, D = D + Math.imul(Pe, Te) | 0, F = F + Math.imul(Pe, rt) | 0, G = G + Math.imul(he, Se) | 0, D = D + Math.imul(he, et) | 0, D = D + Math.imul(ue, Se) | 0, F = F + Math.imul(ue, et) | 0, G = G + Math.imul(qe, Le) | 0, D = D + Math.imul(qe, ze) | 0, D = D + Math.imul(De, Le) | 0, F = F + Math.imul(De, ze) | 0, G = G + Math.imul(Be, _t) | 0, D = D + Math.imul(Be, ft) | 0, D = D + Math.imul(be, _t) | 0, F = F + Math.imul(be, ft) | 0, G = G + Math.imul(oe, Mt) | 0, D = D + Math.imul(oe, St) | 0, D = D + Math.imul(fe, Mt) | 0, F = F + Math.imul(fe, St) | 0, G = G + Math.imul(ge, At) | 0, D = D + Math.imul(ge, Ae) | 0, D = D + Math.imul(xe, At) | 0, F = F + Math.imul(xe, Ae) | 0;
        var Ft = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(Fe, ht), D = Math.imul(Fe, We), D = D + Math.imul(je, ht) | 0, F = Math.imul(je, We), G = G + Math.imul(Ve, Te) | 0, D = D + Math.imul(Ve, rt) | 0, D = D + Math.imul(nt, Te) | 0, F = F + Math.imul(nt, rt) | 0, G = G + Math.imul(_e, Se) | 0, D = D + Math.imul(_e, et) | 0, D = D + Math.imul(Pe, Se) | 0, F = F + Math.imul(Pe, et) | 0, G = G + Math.imul(he, Le) | 0, D = D + Math.imul(he, ze) | 0, D = D + Math.imul(ue, Le) | 0, F = F + Math.imul(ue, ze) | 0, G = G + Math.imul(qe, _t) | 0, D = D + Math.imul(qe, ft) | 0, D = D + Math.imul(De, _t) | 0, F = F + Math.imul(De, ft) | 0, G = G + Math.imul(Be, Mt) | 0, D = D + Math.imul(Be, St) | 0, D = D + Math.imul(be, Mt) | 0, F = F + Math.imul(be, St) | 0, G = G + Math.imul(oe, At) | 0, D = D + Math.imul(oe, Ae) | 0, D = D + Math.imul(fe, At) | 0, F = F + Math.imul(fe, Ae) | 0, G = G + Math.imul(ge, Oe) | 0, D = D + Math.imul(ge, we) | 0, D = D + Math.imul(xe, Oe) | 0, F = F + Math.imul(xe, we) | 0;
        var Nt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ot, ht), D = Math.imul(ot, We), D = D + Math.imul(ut, ht) | 0, F = Math.imul(ut, We), G = G + Math.imul(Fe, Te) | 0, D = D + Math.imul(Fe, rt) | 0, D = D + Math.imul(je, Te) | 0, F = F + Math.imul(je, rt) | 0, G = G + Math.imul(Ve, Se) | 0, D = D + Math.imul(Ve, et) | 0, D = D + Math.imul(nt, Se) | 0, F = F + Math.imul(nt, et) | 0, G = G + Math.imul(_e, Le) | 0, D = D + Math.imul(_e, ze) | 0, D = D + Math.imul(Pe, Le) | 0, F = F + Math.imul(Pe, ze) | 0, G = G + Math.imul(he, _t) | 0, D = D + Math.imul(he, ft) | 0, D = D + Math.imul(ue, _t) | 0, F = F + Math.imul(ue, ft) | 0, G = G + Math.imul(qe, Mt) | 0, D = D + Math.imul(qe, St) | 0, D = D + Math.imul(De, Mt) | 0, F = F + Math.imul(De, St) | 0, G = G + Math.imul(Be, At) | 0, D = D + Math.imul(Be, Ae) | 0, D = D + Math.imul(be, At) | 0, F = F + Math.imul(be, Ae) | 0, G = G + Math.imul(oe, Oe) | 0, D = D + Math.imul(oe, we) | 0, D = D + Math.imul(fe, Oe) | 0, F = F + Math.imul(fe, we) | 0, G = G + Math.imul(ge, Je) | 0, D = D + Math.imul(ge, Ge) | 0, D = D + Math.imul(xe, Je) | 0, F = F + Math.imul(xe, Ge) | 0;
        var Dt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, G = Math.imul(ke, ht), D = Math.imul(ke, We), D = D + Math.imul(Xe, ht) | 0, F = Math.imul(Xe, We), G = G + Math.imul(ot, Te) | 0, D = D + Math.imul(ot, rt) | 0, D = D + Math.imul(ut, Te) | 0, F = F + Math.imul(ut, rt) | 0, G = G + Math.imul(Fe, Se) | 0, D = D + Math.imul(Fe, et) | 0, D = D + Math.imul(je, Se) | 0, F = F + Math.imul(je, et) | 0, G = G + Math.imul(Ve, Le) | 0, D = D + Math.imul(Ve, ze) | 0, D = D + Math.imul(nt, Le) | 0, F = F + Math.imul(nt, ze) | 0, G = G + Math.imul(_e, _t) | 0, D = D + Math.imul(_e, ft) | 0, D = D + Math.imul(Pe, _t) | 0, F = F + Math.imul(Pe, ft) | 0, G = G + Math.imul(he, Mt) | 0, D = D + Math.imul(he, St) | 0, D = D + Math.imul(ue, Mt) | 0, F = F + Math.imul(ue, St) | 0, G = G + Math.imul(qe, At) | 0, D = D + Math.imul(qe, Ae) | 0, D = D + Math.imul(De, At) | 0, F = F + Math.imul(De, Ae) | 0, G = G + Math.imul(Be, Oe) | 0, D = D + Math.imul(Be, we) | 0, D = D + Math.imul(be, Oe) | 0, F = F + Math.imul(be, we) | 0, G = G + Math.imul(oe, Je) | 0, D = D + Math.imul(oe, Ge) | 0, D = D + Math.imul(fe, Je) | 0, F = F + Math.imul(fe, Ge) | 0, G = G + Math.imul(ge, ct) | 0, D = D + Math.imul(ge, bt) | 0, D = D + Math.imul(xe, ct) | 0, F = F + Math.imul(xe, bt) | 0;
        var Ut = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, G = Math.imul(ke, Te), D = Math.imul(ke, rt), D = D + Math.imul(Xe, Te) | 0, F = Math.imul(Xe, rt), G = G + Math.imul(ot, Se) | 0, D = D + Math.imul(ot, et) | 0, D = D + Math.imul(ut, Se) | 0, F = F + Math.imul(ut, et) | 0, G = G + Math.imul(Fe, Le) | 0, D = D + Math.imul(Fe, ze) | 0, D = D + Math.imul(je, Le) | 0, F = F + Math.imul(je, ze) | 0, G = G + Math.imul(Ve, _t) | 0, D = D + Math.imul(Ve, ft) | 0, D = D + Math.imul(nt, _t) | 0, F = F + Math.imul(nt, ft) | 0, G = G + Math.imul(_e, Mt) | 0, D = D + Math.imul(_e, St) | 0, D = D + Math.imul(Pe, Mt) | 0, F = F + Math.imul(Pe, St) | 0, G = G + Math.imul(he, At) | 0, D = D + Math.imul(he, Ae) | 0, D = D + Math.imul(ue, At) | 0, F = F + Math.imul(ue, Ae) | 0, G = G + Math.imul(qe, Oe) | 0, D = D + Math.imul(qe, we) | 0, D = D + Math.imul(De, Oe) | 0, F = F + Math.imul(De, we) | 0, G = G + Math.imul(Be, Je) | 0, D = D + Math.imul(Be, Ge) | 0, D = D + Math.imul(be, Je) | 0, F = F + Math.imul(be, Ge) | 0, G = G + Math.imul(oe, ct) | 0, D = D + Math.imul(oe, bt) | 0, D = D + Math.imul(fe, ct) | 0, F = F + Math.imul(fe, bt) | 0;
        var kt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, G = Math.imul(ke, Se), D = Math.imul(ke, et), D = D + Math.imul(Xe, Se) | 0, F = Math.imul(Xe, et), G = G + Math.imul(ot, Le) | 0, D = D + Math.imul(ot, ze) | 0, D = D + Math.imul(ut, Le) | 0, F = F + Math.imul(ut, ze) | 0, G = G + Math.imul(Fe, _t) | 0, D = D + Math.imul(Fe, ft) | 0, D = D + Math.imul(je, _t) | 0, F = F + Math.imul(je, ft) | 0, G = G + Math.imul(Ve, Mt) | 0, D = D + Math.imul(Ve, St) | 0, D = D + Math.imul(nt, Mt) | 0, F = F + Math.imul(nt, St) | 0, G = G + Math.imul(_e, At) | 0, D = D + Math.imul(_e, Ae) | 0, D = D + Math.imul(Pe, At) | 0, F = F + Math.imul(Pe, Ae) | 0, G = G + Math.imul(he, Oe) | 0, D = D + Math.imul(he, we) | 0, D = D + Math.imul(ue, Oe) | 0, F = F + Math.imul(ue, we) | 0, G = G + Math.imul(qe, Je) | 0, D = D + Math.imul(qe, Ge) | 0, D = D + Math.imul(De, Je) | 0, F = F + Math.imul(De, Ge) | 0, G = G + Math.imul(Be, ct) | 0, D = D + Math.imul(Be, bt) | 0, D = D + Math.imul(be, ct) | 0, F = F + Math.imul(be, bt) | 0;
        var Ot = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, G = Math.imul(ke, Le), D = Math.imul(ke, ze), D = D + Math.imul(Xe, Le) | 0, F = Math.imul(Xe, ze), G = G + Math.imul(ot, _t) | 0, D = D + Math.imul(ot, ft) | 0, D = D + Math.imul(ut, _t) | 0, F = F + Math.imul(ut, ft) | 0, G = G + Math.imul(Fe, Mt) | 0, D = D + Math.imul(Fe, St) | 0, D = D + Math.imul(je, Mt) | 0, F = F + Math.imul(je, St) | 0, G = G + Math.imul(Ve, At) | 0, D = D + Math.imul(Ve, Ae) | 0, D = D + Math.imul(nt, At) | 0, F = F + Math.imul(nt, Ae) | 0, G = G + Math.imul(_e, Oe) | 0, D = D + Math.imul(_e, we) | 0, D = D + Math.imul(Pe, Oe) | 0, F = F + Math.imul(Pe, we) | 0, G = G + Math.imul(he, Je) | 0, D = D + Math.imul(he, Ge) | 0, D = D + Math.imul(ue, Je) | 0, F = F + Math.imul(ue, Ge) | 0, G = G + Math.imul(qe, ct) | 0, D = D + Math.imul(qe, bt) | 0, D = D + Math.imul(De, ct) | 0, F = F + Math.imul(De, bt) | 0;
        var It = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(ke, _t), D = Math.imul(ke, ft), D = D + Math.imul(Xe, _t) | 0, F = Math.imul(Xe, ft), G = G + Math.imul(ot, Mt) | 0, D = D + Math.imul(ot, St) | 0, D = D + Math.imul(ut, Mt) | 0, F = F + Math.imul(ut, St) | 0, G = G + Math.imul(Fe, At) | 0, D = D + Math.imul(Fe, Ae) | 0, D = D + Math.imul(je, At) | 0, F = F + Math.imul(je, Ae) | 0, G = G + Math.imul(Ve, Oe) | 0, D = D + Math.imul(Ve, we) | 0, D = D + Math.imul(nt, Oe) | 0, F = F + Math.imul(nt, we) | 0, G = G + Math.imul(_e, Je) | 0, D = D + Math.imul(_e, Ge) | 0, D = D + Math.imul(Pe, Je) | 0, F = F + Math.imul(Pe, Ge) | 0, G = G + Math.imul(he, ct) | 0, D = D + Math.imul(he, bt) | 0, D = D + Math.imul(ue, ct) | 0, F = F + Math.imul(ue, bt) | 0;
        var Pt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, G = Math.imul(ke, Mt), D = Math.imul(ke, St), D = D + Math.imul(Xe, Mt) | 0, F = Math.imul(Xe, St), G = G + Math.imul(ot, At) | 0, D = D + Math.imul(ot, Ae) | 0, D = D + Math.imul(ut, At) | 0, F = F + Math.imul(ut, Ae) | 0, G = G + Math.imul(Fe, Oe) | 0, D = D + Math.imul(Fe, we) | 0, D = D + Math.imul(je, Oe) | 0, F = F + Math.imul(je, we) | 0, G = G + Math.imul(Ve, Je) | 0, D = D + Math.imul(Ve, Ge) | 0, D = D + Math.imul(nt, Je) | 0, F = F + Math.imul(nt, Ge) | 0, G = G + Math.imul(_e, ct) | 0, D = D + Math.imul(_e, bt) | 0, D = D + Math.imul(Pe, ct) | 0, F = F + Math.imul(Pe, bt) | 0;
        var Ct = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, G = Math.imul(ke, At), D = Math.imul(ke, Ae), D = D + Math.imul(Xe, At) | 0, F = Math.imul(Xe, Ae), G = G + Math.imul(ot, Oe) | 0, D = D + Math.imul(ot, we) | 0, D = D + Math.imul(ut, Oe) | 0, F = F + Math.imul(ut, we) | 0, G = G + Math.imul(Fe, Je) | 0, D = D + Math.imul(Fe, Ge) | 0, D = D + Math.imul(je, Je) | 0, F = F + Math.imul(je, Ge) | 0, G = G + Math.imul(Ve, ct) | 0, D = D + Math.imul(Ve, bt) | 0, D = D + Math.imul(nt, ct) | 0, F = F + Math.imul(nt, bt) | 0;
        var Bt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, G = Math.imul(ke, Oe), D = Math.imul(ke, we), D = D + Math.imul(Xe, Oe) | 0, F = Math.imul(Xe, we), G = G + Math.imul(ot, Je) | 0, D = D + Math.imul(ot, Ge) | 0, D = D + Math.imul(ut, Je) | 0, F = F + Math.imul(ut, Ge) | 0, G = G + Math.imul(Fe, ct) | 0, D = D + Math.imul(Fe, bt) | 0, D = D + Math.imul(je, ct) | 0, F = F + Math.imul(je, bt) | 0;
        var vt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, G = Math.imul(ke, Je), D = Math.imul(ke, Ge), D = D + Math.imul(Xe, Je) | 0, F = Math.imul(Xe, Ge), G = G + Math.imul(ot, ct) | 0, D = D + Math.imul(ot, bt) | 0, D = D + Math.imul(ut, ct) | 0, F = F + Math.imul(ut, bt) | 0;
        var yt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, G = Math.imul(ke, ct), D = Math.imul(ke, bt), D = D + Math.imul(Xe, ct) | 0, F = Math.imul(Xe, bt);
        var xt = (z + G | 0) + ((D & 8191) << 13) | 0;
        return z = (F + (D >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, K[0] = wt, K[1] = zt, K[2] = Tt, K[3] = Lt, K[4] = jt, K[5] = Ht, K[6] = Ft, K[7] = Nt, K[8] = Dt, K[9] = Ut, K[10] = kt, K[11] = Ot, K[12] = It, K[13] = Pt, K[14] = Ct, K[15] = Bt, K[16] = vt, K[17] = yt, K[18] = xt, z !== 0 && (K[19] = z, O.length++), O;
      };
      Math.imul || (se = te);
      function le(M, $, O) {
        O.negative = $.negative ^ M.negative, O.length = M.length + $.length;
        for (var J = 0, Z = 0, K = 0; K < O.length - 1; K++) {
          var z = Z;
          Z = 0;
          for (var G = J & 67108863, D = Math.min(K, $.length - 1), F = Math.max(0, K - M.length + 1); F <= D; F++) {
            var ae = K - F, ge = M.words[ae] | 0, xe = $.words[F] | 0, ye = ge * xe, oe = ye & 67108863;
            z = z + (ye / 67108864 | 0) | 0, oe = oe + G | 0, G = oe & 67108863, z = z + (oe >>> 26) | 0, Z += z >>> 26, z &= 67108863;
          }
          O.words[K] = G, J = z, z = Z;
        }
        return J !== 0 ? O.words[K] = J : O.length--, O._strip();
      }
      function ce(M, $, O) {
        return le(M, $, O);
      }
      h.prototype.mulTo = function(M, $) {
        var O, J = this.length + M.length;
        return this.length === 10 && M.length === 10 ? O = se(this, M, $) : J < 63 ? O = te(this, M, $) : J < 1024 ? O = le(this, M, $) : O = ce(this, M, $), O;
      }, h.prototype.mul = function(M) {
        var $ = new h(null);
        return $.words = new Array(this.length + M.length), this.mulTo(M, $);
      }, h.prototype.mulf = function(M) {
        var $ = new h(null);
        return $.words = new Array(this.length + M.length), ce(this, M, $);
      }, h.prototype.imul = function(M) {
        return this.clone().mulTo(M, this);
      }, h.prototype.imuln = function(M) {
        var $ = M < 0;
        $ && (M = -M), g(typeof M == "number"), g(M < 67108864);
        for (var O = 0, J = 0; J < this.length; J++) {
          var Z = (this.words[J] | 0) * M, K = (Z & 67108863) + (O & 67108863);
          O >>= 26, O += Z / 67108864 | 0, O += K >>> 26, this.words[J] = K & 67108863;
        }
        return O !== 0 && (this.words[J] = O, this.length++), $ ? this.ineg() : this;
      }, h.prototype.muln = function(M) {
        return this.clone().imuln(M);
      }, h.prototype.sqr = function() {
        return this.mul(this);
      }, h.prototype.isqr = function() {
        return this.imul(this.clone());
      }, h.prototype.pow = function(M) {
        var $ = ie(M);
        if ($.length === 0)
          return new h(1);
        for (var O = this, J = 0; J < $.length && $[J] === 0; J++, O = O.sqr())
          ;
        if (++J < $.length)
          for (var Z = O.sqr(); J < $.length; J++, Z = Z.sqr())
            $[J] !== 0 && (O = O.mul(Z));
        return O;
      }, h.prototype.iushln = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = M % 26, O = (M - $) / 26, J = 67108863 >>> 26 - $ << 26 - $, Z;
        if ($ !== 0) {
          var K = 0;
          for (Z = 0; Z < this.length; Z++) {
            var z = this.words[Z] & J, G = (this.words[Z] | 0) - z << $;
            this.words[Z] = G | K, K = z >>> 26 - $;
          }
          K && (this.words[Z] = K, this.length++);
        }
        if (O !== 0) {
          for (Z = this.length - 1; Z >= 0; Z--)
            this.words[Z + O] = this.words[Z];
          for (Z = 0; Z < O; Z++)
            this.words[Z] = 0;
          this.length += O;
        }
        return this._strip();
      }, h.prototype.ishln = function(M) {
        return g(this.negative === 0), this.iushln(M);
      }, h.prototype.iushrn = function(M, $, O) {
        g(typeof M == "number" && M >= 0);
        var J;
        $ ? J = ($ - $ % 26) / 26 : J = 0;
        var Z = M % 26, K = Math.min((M - Z) / 26, this.length), z = 67108863 ^ 67108863 >>> Z << Z, G = O;
        if (J -= K, J = Math.max(0, J), G) {
          for (var D = 0; D < K; D++)
            G.words[D] = this.words[D];
          G.length = K;
        }
        if (K !== 0)
          if (this.length > K)
            for (this.length -= K, D = 0; D < this.length; D++)
              this.words[D] = this.words[D + K];
          else
            this.words[0] = 0, this.length = 1;
        var F = 0;
        for (D = this.length - 1; D >= 0 && (F !== 0 || D >= J); D--) {
          var ae = this.words[D] | 0;
          this.words[D] = F << 26 - Z | ae >>> Z, F = ae & z;
        }
        return G && F !== 0 && (G.words[G.length++] = F), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, h.prototype.ishrn = function(M, $, O) {
        return g(this.negative === 0), this.iushrn(M, $, O);
      }, h.prototype.shln = function(M) {
        return this.clone().ishln(M);
      }, h.prototype.ushln = function(M) {
        return this.clone().iushln(M);
      }, h.prototype.shrn = function(M) {
        return this.clone().ishrn(M);
      }, h.prototype.ushrn = function(M) {
        return this.clone().iushrn(M);
      }, h.prototype.testn = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = M % 26, O = (M - $) / 26, J = 1 << $;
        if (this.length <= O)
          return !1;
        var Z = this.words[O];
        return !!(Z & J);
      }, h.prototype.imaskn = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = M % 26, O = (M - $) / 26;
        if (g(this.negative === 0, "imaskn works only with positive numbers"), this.length <= O)
          return this;
        if ($ !== 0 && O++, this.length = Math.min(O, this.length), $ !== 0) {
          var J = 67108863 ^ 67108863 >>> $ << $;
          this.words[this.length - 1] &= J;
        }
        return this._strip();
      }, h.prototype.maskn = function(M) {
        return this.clone().imaskn(M);
      }, h.prototype.iaddn = function(M) {
        return g(typeof M == "number"), g(M < 67108864), M < 0 ? this.isubn(-M) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= M ? (this.words[0] = M - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(M), this.negative = 1, this) : this._iaddn(M);
      }, h.prototype._iaddn = function(M) {
        this.words[0] += M;
        for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
          this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
        return this.length = Math.max(this.length, $ + 1), this;
      }, h.prototype.isubn = function(M) {
        if (g(typeof M == "number"), g(M < 67108864), M < 0)
          return this.iaddn(-M);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(M), this.negative = 1, this;
        if (this.words[0] -= M, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
            this.words[$] += 67108864, this.words[$ + 1] -= 1;
        return this._strip();
      }, h.prototype.addn = function(M) {
        return this.clone().iaddn(M);
      }, h.prototype.subn = function(M) {
        return this.clone().isubn(M);
      }, h.prototype.iabs = function() {
        return this.negative = 0, this;
      }, h.prototype.abs = function() {
        return this.clone().iabs();
      }, h.prototype._ishlnsubmul = function(M, $, O) {
        var J = M.length + O, Z;
        this._expand(J);
        var K, z = 0;
        for (Z = 0; Z < M.length; Z++) {
          K = (this.words[Z + O] | 0) + z;
          var G = (M.words[Z] | 0) * $;
          K -= G & 67108863, z = (K >> 26) - (G / 67108864 | 0), this.words[Z + O] = K & 67108863;
        }
        for (; Z < this.length - O; Z++)
          K = (this.words[Z + O] | 0) + z, z = K >> 26, this.words[Z + O] = K & 67108863;
        if (z === 0)
          return this._strip();
        for (g(z === -1), z = 0, Z = 0; Z < this.length; Z++)
          K = -(this.words[Z] | 0) + z, z = K >> 26, this.words[Z] = K & 67108863;
        return this.negative = 1, this._strip();
      }, h.prototype._wordDiv = function(M, $) {
        var O = this.length - M.length, J = this.clone(), Z = M, K = Z.words[Z.length - 1] | 0, z = this._countBits(K);
        O = 26 - z, O !== 0 && (Z = Z.ushln(O), J.iushln(O), K = Z.words[Z.length - 1] | 0);
        var G = J.length - Z.length, D;
        if ($ !== "mod") {
          D = new h(null), D.length = G + 1, D.words = new Array(D.length);
          for (var F = 0; F < D.length; F++)
            D.words[F] = 0;
        }
        var ae = J.clone()._ishlnsubmul(Z, 1, G);
        ae.negative === 0 && (J = ae, D && (D.words[G] = 1));
        for (var ge = G - 1; ge >= 0; ge--) {
          var xe = (J.words[Z.length + ge] | 0) * 67108864 + (J.words[Z.length + ge - 1] | 0);
          for (xe = Math.min(xe / K | 0, 67108863), J._ishlnsubmul(Z, xe, ge); J.negative !== 0; )
            xe--, J.negative = 0, J._ishlnsubmul(Z, 1, ge), J.isZero() || (J.negative ^= 1);
          D && (D.words[ge] = xe);
        }
        return D && D._strip(), J._strip(), $ !== "div" && O !== 0 && J.iushrn(O), {
          div: D || null,
          mod: J
        };
      }, h.prototype.divmod = function(M, $, O) {
        if (g(!M.isZero()), this.isZero())
          return {
            div: new h(0),
            mod: new h(0)
          };
        var J, Z, K;
        return this.negative !== 0 && M.negative === 0 ? (K = this.neg().divmod(M, $), $ !== "mod" && (J = K.div.neg()), $ !== "div" && (Z = K.mod.neg(), O && Z.negative !== 0 && Z.iadd(M)), {
          div: J,
          mod: Z
        }) : this.negative === 0 && M.negative !== 0 ? (K = this.divmod(M.neg(), $), $ !== "mod" && (J = K.div.neg()), {
          div: J,
          mod: K.mod
        }) : this.negative & M.negative ? (K = this.neg().divmod(M.neg(), $), $ !== "div" && (Z = K.mod.neg(), O && Z.negative !== 0 && Z.isub(M)), {
          div: K.div,
          mod: Z
        }) : M.length > this.length || this.cmp(M) < 0 ? {
          div: new h(0),
          mod: this
        } : M.length === 1 ? $ === "div" ? {
          div: this.divn(M.words[0]),
          mod: null
        } : $ === "mod" ? {
          div: null,
          mod: new h(this.modrn(M.words[0]))
        } : {
          div: this.divn(M.words[0]),
          mod: new h(this.modrn(M.words[0]))
        } : this._wordDiv(M, $);
      }, h.prototype.div = function(M) {
        return this.divmod(M, "div", !1).div;
      }, h.prototype.mod = function(M) {
        return this.divmod(M, "mod", !1).mod;
      }, h.prototype.umod = function(M) {
        return this.divmod(M, "mod", !0).mod;
      }, h.prototype.divRound = function(M) {
        var $ = this.divmod(M);
        if ($.mod.isZero())
          return $.div;
        var O = $.div.negative !== 0 ? $.mod.isub(M) : $.mod, J = M.ushrn(1), Z = M.andln(1), K = O.cmp(J);
        return K < 0 || Z === 1 && K === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
      }, h.prototype.modrn = function(M) {
        var $ = M < 0;
        $ && (M = -M), g(M <= 67108863);
        for (var O = (1 << 26) % M, J = 0, Z = this.length - 1; Z >= 0; Z--)
          J = (O * J + (this.words[Z] | 0)) % M;
        return $ ? -J : J;
      }, h.prototype.modn = function(M) {
        return this.modrn(M);
      }, h.prototype.idivn = function(M) {
        var $ = M < 0;
        $ && (M = -M), g(M <= 67108863);
        for (var O = 0, J = this.length - 1; J >= 0; J--) {
          var Z = (this.words[J] | 0) + O * 67108864;
          this.words[J] = Z / M | 0, O = Z % M;
        }
        return this._strip(), $ ? this.ineg() : this;
      }, h.prototype.divn = function(M) {
        return this.clone().idivn(M);
      }, h.prototype.egcd = function(M) {
        g(M.negative === 0), g(!M.isZero());
        var $ = this, O = M.clone();
        $.negative !== 0 ? $ = $.umod(M) : $ = $.clone();
        for (var J = new h(1), Z = new h(0), K = new h(0), z = new h(1), G = 0; $.isEven() && O.isEven(); )
          $.iushrn(1), O.iushrn(1), ++G;
        for (var D = O.clone(), F = $.clone(); !$.isZero(); ) {
          for (var ae = 0, ge = 1; !($.words[0] & ge) && ae < 26; ++ae, ge <<= 1)
            ;
          if (ae > 0)
            for ($.iushrn(ae); ae-- > 0; )
              (J.isOdd() || Z.isOdd()) && (J.iadd(D), Z.isub(F)), J.iushrn(1), Z.iushrn(1);
          for (var xe = 0, ye = 1; !(O.words[0] & ye) && xe < 26; ++xe, ye <<= 1)
            ;
          if (xe > 0)
            for (O.iushrn(xe); xe-- > 0; )
              (K.isOdd() || z.isOdd()) && (K.iadd(D), z.isub(F)), K.iushrn(1), z.iushrn(1);
          $.cmp(O) >= 0 ? ($.isub(O), J.isub(K), Z.isub(z)) : (O.isub($), K.isub(J), z.isub(Z));
        }
        return {
          a: K,
          b: z,
          gcd: O.iushln(G)
        };
      }, h.prototype._invmp = function(M) {
        g(M.negative === 0), g(!M.isZero());
        var $ = this, O = M.clone();
        $.negative !== 0 ? $ = $.umod(M) : $ = $.clone();
        for (var J = new h(1), Z = new h(0), K = O.clone(); $.cmpn(1) > 0 && O.cmpn(1) > 0; ) {
          for (var z = 0, G = 1; !($.words[0] & G) && z < 26; ++z, G <<= 1)
            ;
          if (z > 0)
            for ($.iushrn(z); z-- > 0; )
              J.isOdd() && J.iadd(K), J.iushrn(1);
          for (var D = 0, F = 1; !(O.words[0] & F) && D < 26; ++D, F <<= 1)
            ;
          if (D > 0)
            for (O.iushrn(D); D-- > 0; )
              Z.isOdd() && Z.iadd(K), Z.iushrn(1);
          $.cmp(O) >= 0 ? ($.isub(O), J.isub(Z)) : (O.isub($), Z.isub(J));
        }
        var ae;
        return $.cmpn(1) === 0 ? ae = J : ae = Z, ae.cmpn(0) < 0 && ae.iadd(M), ae;
      }, h.prototype.gcd = function(M) {
        if (this.isZero())
          return M.abs();
        if (M.isZero())
          return this.abs();
        var $ = this.clone(), O = M.clone();
        $.negative = 0, O.negative = 0;
        for (var J = 0; $.isEven() && O.isEven(); J++)
          $.iushrn(1), O.iushrn(1);
        do {
          for (; $.isEven(); )
            $.iushrn(1);
          for (; O.isEven(); )
            O.iushrn(1);
          var Z = $.cmp(O);
          if (Z < 0) {
            var K = $;
            $ = O, O = K;
          } else if (Z === 0 || O.cmpn(1) === 0)
            break;
          $.isub(O);
        } while (!0);
        return O.iushln(J);
      }, h.prototype.invm = function(M) {
        return this.egcd(M).a.umod(M);
      }, h.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, h.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, h.prototype.andln = function(M) {
        return this.words[0] & M;
      }, h.prototype.bincn = function(M) {
        g(typeof M == "number");
        var $ = M % 26, O = (M - $) / 26, J = 1 << $;
        if (this.length <= O)
          return this._expand(O + 1), this.words[O] |= J, this;
        for (var Z = J, K = O; Z !== 0 && K < this.length; K++) {
          var z = this.words[K] | 0;
          z += Z, Z = z >>> 26, z &= 67108863, this.words[K] = z;
        }
        return Z !== 0 && (this.words[K] = Z, this.length++), this;
      }, h.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, h.prototype.cmpn = function(M) {
        var $ = M < 0;
        if (this.negative !== 0 && !$)
          return -1;
        if (this.negative === 0 && $)
          return 1;
        this._strip();
        var O;
        if (this.length > 1)
          O = 1;
        else {
          $ && (M = -M), g(M <= 67108863, "Number is too big");
          var J = this.words[0] | 0;
          O = J === M ? 0 : J < M ? -1 : 1;
        }
        return this.negative !== 0 ? -O | 0 : O;
      }, h.prototype.cmp = function(M) {
        if (this.negative !== 0 && M.negative === 0)
          return -1;
        if (this.negative === 0 && M.negative !== 0)
          return 1;
        var $ = this.ucmp(M);
        return this.negative !== 0 ? -$ | 0 : $;
      }, h.prototype.ucmp = function(M) {
        if (this.length > M.length)
          return 1;
        if (this.length < M.length)
          return -1;
        for (var $ = 0, O = this.length - 1; O >= 0; O--) {
          var J = this.words[O] | 0, Z = M.words[O] | 0;
          if (J !== Z) {
            J < Z ? $ = -1 : J > Z && ($ = 1);
            break;
          }
        }
        return $;
      }, h.prototype.gtn = function(M) {
        return this.cmpn(M) === 1;
      }, h.prototype.gt = function(M) {
        return this.cmp(M) === 1;
      }, h.prototype.gten = function(M) {
        return this.cmpn(M) >= 0;
      }, h.prototype.gte = function(M) {
        return this.cmp(M) >= 0;
      }, h.prototype.ltn = function(M) {
        return this.cmpn(M) === -1;
      }, h.prototype.lt = function(M) {
        return this.cmp(M) === -1;
      }, h.prototype.lten = function(M) {
        return this.cmpn(M) <= 0;
      }, h.prototype.lte = function(M) {
        return this.cmp(M) <= 0;
      }, h.prototype.eqn = function(M) {
        return this.cmpn(M) === 0;
      }, h.prototype.eq = function(M) {
        return this.cmp(M) === 0;
      }, h.red = function(M) {
        return new ne(M);
      }, h.prototype.toRed = function(M) {
        return g(!this.red, "Already a number in reduction context"), g(this.negative === 0, "red works only with positives"), M.convertTo(this)._forceRed(M);
      }, h.prototype.fromRed = function() {
        return g(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, h.prototype._forceRed = function(M) {
        return this.red = M, this;
      }, h.prototype.forceRed = function(M) {
        return g(!this.red, "Already a number in reduction context"), this._forceRed(M);
      }, h.prototype.redAdd = function(M) {
        return g(this.red, "redAdd works only with red numbers"), this.red.add(this, M);
      }, h.prototype.redIAdd = function(M) {
        return g(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, M);
      }, h.prototype.redSub = function(M) {
        return g(this.red, "redSub works only with red numbers"), this.red.sub(this, M);
      }, h.prototype.redISub = function(M) {
        return g(this.red, "redISub works only with red numbers"), this.red.isub(this, M);
      }, h.prototype.redShl = function(M) {
        return g(this.red, "redShl works only with red numbers"), this.red.shl(this, M);
      }, h.prototype.redMul = function(M) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, M), this.red.mul(this, M);
      }, h.prototype.redIMul = function(M) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, M), this.red.imul(this, M);
      }, h.prototype.redSqr = function() {
        return g(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, h.prototype.redISqr = function() {
        return g(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, h.prototype.redSqrt = function() {
        return g(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, h.prototype.redInvm = function() {
        return g(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, h.prototype.redNeg = function() {
        return g(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, h.prototype.redPow = function(M) {
        return g(this.red && !M.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, M);
      };
      var pe = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function me(M, $) {
        this.name = M, this.p = new h($, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var M = new h(null);
        return M.words = new Array(Math.ceil(this.n / 13)), M;
      }, me.prototype.ireduce = function(M) {
        var $ = M, O;
        do
          this.split($, this.tmp), $ = this.imulK($), $ = $.iadd(this.tmp), O = $.bitLength();
        while (O > this.n);
        var J = O < this.n ? -1 : $.ucmp(this.p);
        return J === 0 ? ($.words[0] = 0, $.length = 1) : J > 0 ? $.isub(this.p) : $.strip !== void 0 ? $.strip() : $._strip(), $;
      }, me.prototype.split = function(M, $) {
        M.iushrn(this.n, 0, $);
      }, me.prototype.imulK = function(M) {
        return M.imul(this.k);
      };
      function Me() {
        me.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      U(Me, me), Me.prototype.split = function(M, $) {
        for (var O = 4194303, J = Math.min(M.length, 9), Z = 0; Z < J; Z++)
          $.words[Z] = M.words[Z];
        if ($.length = J, M.length <= 9) {
          M.words[0] = 0, M.length = 1;
          return;
        }
        var K = M.words[9];
        for ($.words[$.length++] = K & O, Z = 10; Z < M.length; Z++) {
          var z = M.words[Z] | 0;
          M.words[Z - 10] = (z & O) << 4 | K >>> 22, K = z;
        }
        K >>>= 22, M.words[Z - 10] = K, K === 0 && M.length > 10 ? M.length -= 10 : M.length -= 9;
      }, Me.prototype.imulK = function(M) {
        M.words[M.length] = 0, M.words[M.length + 1] = 0, M.length += 2;
        for (var $ = 0, O = 0; O < M.length; O++) {
          var J = M.words[O] | 0;
          $ += J * 977, M.words[O] = $ & 67108863, $ = J * 64 + ($ / 67108864 | 0);
        }
        return M.words[M.length - 1] === 0 && (M.length--, M.words[M.length - 1] === 0 && M.length--), M;
      };
      function Ee() {
        me.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      U(Ee, me);
      function Re() {
        me.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      U(Re, me);
      function Ne() {
        me.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      U(Ne, me), Ne.prototype.imulK = function(M) {
        for (var $ = 0, O = 0; O < M.length; O++) {
          var J = (M.words[O] | 0) * 19 + $, Z = J & 67108863;
          J >>>= 26, M.words[O] = Z, $ = J;
        }
        return $ !== 0 && (M.words[M.length++] = $), M;
      }, h._prime = function(M) {
        if (pe[M])
          return pe[M];
        var $;
        if (M === "k256")
          $ = new Me();
        else if (M === "p224")
          $ = new Ee();
        else if (M === "p192")
          $ = new Re();
        else if (M === "p25519")
          $ = new Ne();
        else
          throw new Error("Unknown prime " + M);
        return pe[M] = $, $;
      };
      function ne(M) {
        if (typeof M == "string") {
          var $ = h._prime(M);
          this.m = $.p, this.prime = $;
        } else
          g(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
      }
      ne.prototype._verify1 = function(M) {
        g(M.negative === 0, "red works only with positives"), g(M.red, "red works only with red numbers");
      }, ne.prototype._verify2 = function(M, $) {
        g((M.negative | $.negative) === 0, "red works only with positives"), g(
          M.red && M.red === $.red,
          "red works only with red numbers"
        );
      }, ne.prototype.imod = function(M) {
        return this.prime ? this.prime.ireduce(M)._forceRed(this) : (B(M, M.umod(this.m)._forceRed(this)), M);
      }, ne.prototype.neg = function(M) {
        return M.isZero() ? M.clone() : this.m.sub(M)._forceRed(this);
      }, ne.prototype.add = function(M, $) {
        this._verify2(M, $);
        var O = M.add($);
        return O.cmp(this.m) >= 0 && O.isub(this.m), O._forceRed(this);
      }, ne.prototype.iadd = function(M, $) {
        this._verify2(M, $);
        var O = M.iadd($);
        return O.cmp(this.m) >= 0 && O.isub(this.m), O;
      }, ne.prototype.sub = function(M, $) {
        this._verify2(M, $);
        var O = M.sub($);
        return O.cmpn(0) < 0 && O.iadd(this.m), O._forceRed(this);
      }, ne.prototype.isub = function(M, $) {
        this._verify2(M, $);
        var O = M.isub($);
        return O.cmpn(0) < 0 && O.iadd(this.m), O;
      }, ne.prototype.shl = function(M, $) {
        return this._verify1(M), this.imod(M.ushln($));
      }, ne.prototype.imul = function(M, $) {
        return this._verify2(M, $), this.imod(M.imul($));
      }, ne.prototype.mul = function(M, $) {
        return this._verify2(M, $), this.imod(M.mul($));
      }, ne.prototype.isqr = function(M) {
        return this.imul(M, M.clone());
      }, ne.prototype.sqr = function(M) {
        return this.mul(M, M);
      }, ne.prototype.sqrt = function(M) {
        if (M.isZero())
          return M.clone();
        var $ = this.m.andln(3);
        if (g($ % 2 === 1), $ === 3) {
          var O = this.m.add(new h(1)).iushrn(2);
          return this.pow(M, O);
        }
        for (var J = this.m.subn(1), Z = 0; !J.isZero() && J.andln(1) === 0; )
          Z++, J.iushrn(1);
        g(!J.isZero());
        var K = new h(1).toRed(this), z = K.redNeg(), G = this.m.subn(1).iushrn(1), D = this.m.bitLength();
        for (D = new h(2 * D * D).toRed(this); this.pow(D, G).cmp(z) !== 0; )
          D.redIAdd(z);
        for (var F = this.pow(D, J), ae = this.pow(M, J.addn(1).iushrn(1)), ge = this.pow(M, J), xe = Z; ge.cmp(K) !== 0; ) {
          for (var ye = ge, oe = 0; ye.cmp(K) !== 0; oe++)
            ye = ye.redSqr();
          g(oe < xe);
          var fe = this.pow(F, new h(1).iushln(xe - oe - 1));
          ae = ae.redMul(fe), F = fe.redSqr(), ge = ge.redMul(F), xe = oe;
        }
        return ae;
      }, ne.prototype.invm = function(M) {
        var $ = M._invmp(this.m);
        return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
      }, ne.prototype.pow = function(M, $) {
        if ($.isZero())
          return new h(1).toRed(this);
        if ($.cmpn(1) === 0)
          return M.clone();
        var O = 4, J = new Array(1 << O);
        J[0] = new h(1).toRed(this), J[1] = M;
        for (var Z = 2; Z < J.length; Z++)
          J[Z] = this.mul(J[Z - 1], M);
        var K = J[0], z = 0, G = 0, D = $.bitLength() % 26;
        for (D === 0 && (D = 26), Z = $.length - 1; Z >= 0; Z--) {
          for (var F = $.words[Z], ae = D - 1; ae >= 0; ae--) {
            var ge = F >> ae & 1;
            if (K !== J[0] && (K = this.sqr(K)), ge === 0 && z === 0) {
              G = 0;
              continue;
            }
            z <<= 1, z |= ge, G++, !(G !== O && (Z !== 0 || ae !== 0)) && (K = this.mul(K, J[z]), G = 0, z = 0);
          }
          D = 26;
        }
        return K;
      }, ne.prototype.convertTo = function(M) {
        var $ = M.umod(this.m);
        return $ === M ? $.clone() : $;
      }, ne.prototype.convertFrom = function(M) {
        var $ = M.clone();
        return $.red = null, $;
      }, h.mont = function(M) {
        return new Y(M);
      };
      function Y(M) {
        ne.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      U(Y, ne), Y.prototype.convertTo = function(M) {
        return this.imod(M.ushln(this.shift));
      }, Y.prototype.convertFrom = function(M) {
        var $ = this.imod(M.mul(this.rinv));
        return $.red = null, $;
      }, Y.prototype.imul = function(M, $) {
        if (M.isZero() || $.isZero())
          return M.words[0] = 0, M.length = 1, M;
        var O = M.imul($), J = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Z = O.isub(J).iushrn(this.shift), K = Z;
        return Z.cmp(this.m) >= 0 ? K = Z.isub(this.m) : Z.cmpn(0) < 0 && (K = Z.iadd(this.m)), K._forceRed(this);
      }, Y.prototype.mul = function(M, $) {
        if (M.isZero() || $.isZero())
          return new h(0)._forceRed(this);
        var O = M.mul($), J = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Z = O.isub(J).iushrn(this.shift), K = Z;
        return Z.cmp(this.m) >= 0 ? K = Z.isub(this.m) : Z.cmpn(0) < 0 && (K = Z.iadd(this.m)), K._forceRed(this);
      }, Y.prototype.invm = function(M) {
        var $ = this.imod(M._invmp(this.m).mul(this.r2));
        return $._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$1$1)), bn$1$1.exports;
}
var browserifyRsa$1, hasRequiredBrowserifyRsa$1;
function requireBrowserifyRsa$1() {
  if (hasRequiredBrowserifyRsa$1)
    return browserifyRsa$1;
  hasRequiredBrowserifyRsa$1 = 1;
  var e = requireBn$1$1(), o = requireBrowser$b$1();
  function S(h) {
    var q = g(h), A = q.toRed(e.mont(h.modulus)).redPow(new e(h.publicExponent)).fromRed();
    return { blinder: A, unblinder: q.invm(h.modulus) };
  }
  function g(h) {
    var q = h.modulus.byteLength(), A;
    do
      A = new e(o(q));
    while (A.cmp(h.modulus) >= 0 || !A.umod(h.prime1) || !A.umod(h.prime2));
    return A;
  }
  function U(h, q) {
    var A = S(q), P = q.modulus.byteLength(), I = new e(h).mul(A.blinder).umod(q.modulus), B = I.toRed(e.mont(q.prime1)), H = I.toRed(e.mont(q.prime2)), V = q.coefficient, X = q.prime1, Q = q.prime2, ee = B.redPow(q.exponent1).fromRed(), ie = H.redPow(q.exponent2).fromRed(), te = ee.isub(ie).imul(V).umod(X).imul(Q);
    return ie.iadd(te).imul(A.unblinder).umod(q.modulus).toArrayLike(bufferExports.Buffer, "be", P);
  }
  return U.getr = g, browserifyRsa$1 = U, browserifyRsa$1;
}
var elliptic$1 = {};
const name$2 = "elliptic", version$2 = "6.5.5", description$2 = "EC cryptography", main$2 = "lib/elliptic.js", files$2 = [
  "lib"
], scripts$2 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository$1 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords$2 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author$2 = "Fedor Indutny <fedor@indutny.com>", license$2 = "MIT", bugs$1 = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage$2 = "https://github.com/indutny/elliptic", devDependencies$2 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies$2 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$1 = {
  name: name$2,
  version: version$2,
  description: description$2,
  main: main$2,
  files: files$2,
  scripts: scripts$2,
  repository: repository$1,
  keywords: keywords$2,
  author: author$2,
  license: license$2,
  bugs: bugs$1,
  homepage: homepage$2,
  devDependencies: devDependencies$2,
  dependencies: dependencies$2
};
var utils$2$1 = {}, utils$1$1 = {}, hasRequiredUtils$2$1;
function requireUtils$2$1() {
  return hasRequiredUtils$2$1 || (hasRequiredUtils$2$1 = 1, function(e) {
    var o = e;
    function S(h, q) {
      if (Array.isArray(h))
        return h.slice();
      if (!h)
        return [];
      var A = [];
      if (typeof h != "string") {
        for (var P = 0; P < h.length; P++)
          A[P] = h[P] | 0;
        return A;
      }
      if (q === "hex") {
        h = h.replace(/[^a-z0-9]+/ig, ""), h.length % 2 !== 0 && (h = "0" + h);
        for (var P = 0; P < h.length; P += 2)
          A.push(parseInt(h[P] + h[P + 1], 16));
      } else
        for (var P = 0; P < h.length; P++) {
          var I = h.charCodeAt(P), B = I >> 8, H = I & 255;
          B ? A.push(B, H) : A.push(H);
        }
      return A;
    }
    o.toArray = S;
    function g(h) {
      return h.length === 1 ? "0" + h : h;
    }
    o.zero2 = g;
    function U(h) {
      for (var q = "", A = 0; A < h.length; A++)
        q += g(h[A].toString(16));
      return q;
    }
    o.toHex = U, o.encode = function(h, q) {
      return q === "hex" ? U(h) : h;
    };
  }(utils$1$1)), utils$1$1;
}
var hasRequiredUtils$1$1;
function requireUtils$1$1() {
  return hasRequiredUtils$1$1 || (hasRequiredUtils$1$1 = 1, function(e) {
    var o = e, S = requireBn$2(), g = requireMinimalisticAssert$1(), U = requireUtils$2$1();
    o.assert = g, o.toArray = U.toArray, o.zero2 = U.zero2, o.toHex = U.toHex, o.encode = U.encode;
    function h(B, H, V) {
      var X = new Array(Math.max(B.bitLength(), V) + 1), Q;
      for (Q = 0; Q < X.length; Q += 1)
        X[Q] = 0;
      var ee = 1 << H + 1, ie = B.clone();
      for (Q = 0; Q < X.length; Q++) {
        var te, se = ie.andln(ee - 1);
        ie.isOdd() ? (se > (ee >> 1) - 1 ? te = (ee >> 1) - se : te = se, ie.isubn(te)) : te = 0, X[Q] = te, ie.iushrn(1);
      }
      return X;
    }
    o.getNAF = h;
    function q(B, H) {
      var V = [
        [],
        []
      ];
      B = B.clone(), H = H.clone();
      for (var X = 0, Q = 0, ee; B.cmpn(-X) > 0 || H.cmpn(-Q) > 0; ) {
        var ie = B.andln(3) + X & 3, te = H.andln(3) + Q & 3;
        ie === 3 && (ie = -1), te === 3 && (te = -1);
        var se;
        ie & 1 ? (ee = B.andln(7) + X & 7, (ee === 3 || ee === 5) && te === 2 ? se = -ie : se = ie) : se = 0, V[0].push(se);
        var le;
        te & 1 ? (ee = H.andln(7) + Q & 7, (ee === 3 || ee === 5) && ie === 2 ? le = -te : le = te) : le = 0, V[1].push(le), 2 * X === se + 1 && (X = 1 - X), 2 * Q === le + 1 && (Q = 1 - Q), B.iushrn(1), H.iushrn(1);
      }
      return V;
    }
    o.getJSF = q;
    function A(B, H, V) {
      var X = "_" + H;
      B.prototype[H] = function() {
        return this[X] !== void 0 ? this[X] : this[X] = V.call(this);
      };
    }
    o.cachedProperty = A;
    function P(B) {
      return typeof B == "string" ? o.toArray(B, "hex") : B;
    }
    o.parseBytes = P;
    function I(B) {
      return new S(B, "hex", "le");
    }
    o.intFromLE = I;
  }(utils$2$1)), utils$2$1;
}
var curve$2 = {}, base$1$1, hasRequiredBase$1$1;
function requireBase$1$1() {
  if (hasRequiredBase$1$1)
    return base$1$1;
  hasRequiredBase$1$1 = 1;
  var e = requireBn$2(), o = requireUtils$1$1(), S = o.getNAF, g = o.getJSF, U = o.assert;
  function h(A, P) {
    this.type = A, this.p = new e(P.p, 16), this.red = P.prime ? e.red(P.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = P.n && new e(P.n, 16), this.g = P.g && this.pointFromJSON(P.g, P.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var I = this.n && this.p.div(this.n);
    !I || I.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$1$1 = h, h.prototype.point = function() {
    throw new Error("Not implemented");
  }, h.prototype.validate = function() {
    throw new Error("Not implemented");
  }, h.prototype._fixedNafMul = function(A, P) {
    U(A.precomputed);
    var I = A._getDoubles(), B = S(P, 1, this._bitLength), H = (1 << I.step + 1) - (I.step % 2 === 0 ? 2 : 1);
    H /= 3;
    var V = [], X, Q;
    for (X = 0; X < B.length; X += I.step) {
      Q = 0;
      for (var ee = X + I.step - 1; ee >= X; ee--)
        Q = (Q << 1) + B[ee];
      V.push(Q);
    }
    for (var ie = this.jpoint(null, null, null), te = this.jpoint(null, null, null), se = H; se > 0; se--) {
      for (X = 0; X < V.length; X++)
        Q = V[X], Q === se ? te = te.mixedAdd(I.points[X]) : Q === -se && (te = te.mixedAdd(I.points[X].neg()));
      ie = ie.add(te);
    }
    return ie.toP();
  }, h.prototype._wnafMul = function(A, P) {
    var I = 4, B = A._getNAFPoints(I);
    I = B.wnd;
    for (var H = B.points, V = S(P, I, this._bitLength), X = this.jpoint(null, null, null), Q = V.length - 1; Q >= 0; Q--) {
      for (var ee = 0; Q >= 0 && V[Q] === 0; Q--)
        ee++;
      if (Q >= 0 && ee++, X = X.dblp(ee), Q < 0)
        break;
      var ie = V[Q];
      U(ie !== 0), A.type === "affine" ? ie > 0 ? X = X.mixedAdd(H[ie - 1 >> 1]) : X = X.mixedAdd(H[-ie - 1 >> 1].neg()) : ie > 0 ? X = X.add(H[ie - 1 >> 1]) : X = X.add(H[-ie - 1 >> 1].neg());
    }
    return A.type === "affine" ? X.toP() : X;
  }, h.prototype._wnafMulAdd = function(A, P, I, B, H) {
    var V = this._wnafT1, X = this._wnafT2, Q = this._wnafT3, ee = 0, ie, te, se;
    for (ie = 0; ie < B; ie++) {
      se = P[ie];
      var le = se._getNAFPoints(A);
      V[ie] = le.wnd, X[ie] = le.points;
    }
    for (ie = B - 1; ie >= 1; ie -= 2) {
      var ce = ie - 1, pe = ie;
      if (V[ce] !== 1 || V[pe] !== 1) {
        Q[ce] = S(I[ce], V[ce], this._bitLength), Q[pe] = S(I[pe], V[pe], this._bitLength), ee = Math.max(Q[ce].length, ee), ee = Math.max(Q[pe].length, ee);
        continue;
      }
      var me = [
        P[ce],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        P[pe]
        /* 7 */
      ];
      P[ce].y.cmp(P[pe].y) === 0 ? (me[1] = P[ce].add(P[pe]), me[2] = P[ce].toJ().mixedAdd(P[pe].neg())) : P[ce].y.cmp(P[pe].y.redNeg()) === 0 ? (me[1] = P[ce].toJ().mixedAdd(P[pe]), me[2] = P[ce].add(P[pe].neg())) : (me[1] = P[ce].toJ().mixedAdd(P[pe]), me[2] = P[ce].toJ().mixedAdd(P[pe].neg()));
      var Me = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Ee = g(I[ce], I[pe]);
      for (ee = Math.max(Ee[0].length, ee), Q[ce] = new Array(ee), Q[pe] = new Array(ee), te = 0; te < ee; te++) {
        var Re = Ee[0][te] | 0, Ne = Ee[1][te] | 0;
        Q[ce][te] = Me[(Re + 1) * 3 + (Ne + 1)], Q[pe][te] = 0, X[ce] = me;
      }
    }
    var ne = this.jpoint(null, null, null), Y = this._wnafT4;
    for (ie = ee; ie >= 0; ie--) {
      for (var M = 0; ie >= 0; ) {
        var $ = !0;
        for (te = 0; te < B; te++)
          Y[te] = Q[te][ie] | 0, Y[te] !== 0 && ($ = !1);
        if (!$)
          break;
        M++, ie--;
      }
      if (ie >= 0 && M++, ne = ne.dblp(M), ie < 0)
        break;
      for (te = 0; te < B; te++) {
        var O = Y[te];
        O !== 0 && (O > 0 ? se = X[te][O - 1 >> 1] : O < 0 && (se = X[te][-O - 1 >> 1].neg()), se.type === "affine" ? ne = ne.mixedAdd(se) : ne = ne.add(se));
      }
    }
    for (ie = 0; ie < B; ie++)
      X[ie] = null;
    return H ? ne : ne.toP();
  };
  function q(A, P) {
    this.curve = A, this.type = P, this.precomputed = null;
  }
  return h.BasePoint = q, q.prototype.eq = function() {
    throw new Error("Not implemented");
  }, q.prototype.validate = function() {
    return this.curve.validate(this);
  }, h.prototype.decodePoint = function(A, P) {
    A = o.toArray(A, P);
    var I = this.p.byteLength();
    if ((A[0] === 4 || A[0] === 6 || A[0] === 7) && A.length - 1 === 2 * I) {
      A[0] === 6 ? U(A[A.length - 1] % 2 === 0) : A[0] === 7 && U(A[A.length - 1] % 2 === 1);
      var B = this.point(
        A.slice(1, 1 + I),
        A.slice(1 + I, 1 + 2 * I)
      );
      return B;
    } else if ((A[0] === 2 || A[0] === 3) && A.length - 1 === I)
      return this.pointFromX(A.slice(1, 1 + I), A[0] === 3);
    throw new Error("Unknown point format");
  }, q.prototype.encodeCompressed = function(A) {
    return this.encode(A, !0);
  }, q.prototype._encode = function(A) {
    var P = this.curve.p.byteLength(), I = this.getX().toArray("be", P);
    return A ? [this.getY().isEven() ? 2 : 3].concat(I) : [4].concat(I, this.getY().toArray("be", P));
  }, q.prototype.encode = function(A, P) {
    return o.encode(this._encode(P), A);
  }, q.prototype.precompute = function(A) {
    if (this.precomputed)
      return this;
    var P = {
      doubles: null,
      naf: null,
      beta: null
    };
    return P.naf = this._getNAFPoints(8), P.doubles = this._getDoubles(4, A), P.beta = this._getBeta(), this.precomputed = P, this;
  }, q.prototype._hasDoubles = function(A) {
    if (!this.precomputed)
      return !1;
    var P = this.precomputed.doubles;
    return P ? P.points.length >= Math.ceil((A.bitLength() + 1) / P.step) : !1;
  }, q.prototype._getDoubles = function(A, P) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var I = [this], B = this, H = 0; H < P; H += A) {
      for (var V = 0; V < A; V++)
        B = B.dbl();
      I.push(B);
    }
    return {
      step: A,
      points: I
    };
  }, q.prototype._getNAFPoints = function(A) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var P = [this], I = (1 << A) - 1, B = I === 1 ? null : this.dbl(), H = 1; H < I; H++)
      P[H] = P[H - 1].add(B);
    return {
      wnd: A,
      points: P
    };
  }, q.prototype._getBeta = function() {
    return null;
  }, q.prototype.dblp = function(A) {
    for (var P = this, I = 0; I < A; I++)
      P = P.dbl();
    return P;
  }, base$1$1;
}
var short$1, hasRequiredShort$1;
function requireShort$1() {
  if (hasRequiredShort$1)
    return short$1;
  hasRequiredShort$1 = 1;
  var e = requireUtils$1$1(), o = requireBn$2(), S = requireInherits_browser$1(), g = requireBase$1$1(), U = e.assert;
  function h(P) {
    g.call(this, "short", P), this.a = new o(P.a, 16).toRed(this.red), this.b = new o(P.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(P), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  S(h, g), short$1 = h, h.prototype._getEndomorphism = function(P) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var I, B;
      if (P.beta)
        I = new o(P.beta, 16).toRed(this.red);
      else {
        var H = this._getEndoRoots(this.p);
        I = H[0].cmp(H[1]) < 0 ? H[0] : H[1], I = I.toRed(this.red);
      }
      if (P.lambda)
        B = new o(P.lambda, 16);
      else {
        var V = this._getEndoRoots(this.n);
        this.g.mul(V[0]).x.cmp(this.g.x.redMul(I)) === 0 ? B = V[0] : (B = V[1], U(this.g.mul(B).x.cmp(this.g.x.redMul(I)) === 0));
      }
      var X;
      return P.basis ? X = P.basis.map(function(Q) {
        return {
          a: new o(Q.a, 16),
          b: new o(Q.b, 16)
        };
      }) : X = this._getEndoBasis(B), {
        beta: I,
        lambda: B,
        basis: X
      };
    }
  }, h.prototype._getEndoRoots = function(P) {
    var I = P === this.p ? this.red : o.mont(P), B = new o(2).toRed(I).redInvm(), H = B.redNeg(), V = new o(3).toRed(I).redNeg().redSqrt().redMul(B), X = H.redAdd(V).fromRed(), Q = H.redSub(V).fromRed();
    return [X, Q];
  }, h.prototype._getEndoBasis = function(P) {
    for (var I = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), B = P, H = this.n.clone(), V = new o(1), X = new o(0), Q = new o(0), ee = new o(1), ie, te, se, le, ce, pe, me, Me = 0, Ee, Re; B.cmpn(0) !== 0; ) {
      var Ne = H.div(B);
      Ee = H.sub(Ne.mul(B)), Re = Q.sub(Ne.mul(V));
      var ne = ee.sub(Ne.mul(X));
      if (!se && Ee.cmp(I) < 0)
        ie = me.neg(), te = V, se = Ee.neg(), le = Re;
      else if (se && ++Me === 2)
        break;
      me = Ee, H = B, B = Ee, Q = V, V = Re, ee = X, X = ne;
    }
    ce = Ee.neg(), pe = Re;
    var Y = se.sqr().add(le.sqr()), M = ce.sqr().add(pe.sqr());
    return M.cmp(Y) >= 0 && (ce = ie, pe = te), se.negative && (se = se.neg(), le = le.neg()), ce.negative && (ce = ce.neg(), pe = pe.neg()), [
      { a: se, b: le },
      { a: ce, b: pe }
    ];
  }, h.prototype._endoSplit = function(P) {
    var I = this.endo.basis, B = I[0], H = I[1], V = H.b.mul(P).divRound(this.n), X = B.b.neg().mul(P).divRound(this.n), Q = V.mul(B.a), ee = X.mul(H.a), ie = V.mul(B.b), te = X.mul(H.b), se = P.sub(Q).sub(ee), le = ie.add(te).neg();
    return { k1: se, k2: le };
  }, h.prototype.pointFromX = function(P, I) {
    P = new o(P, 16), P.red || (P = P.toRed(this.red));
    var B = P.redSqr().redMul(P).redIAdd(P.redMul(this.a)).redIAdd(this.b), H = B.redSqrt();
    if (H.redSqr().redSub(B).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var V = H.fromRed().isOdd();
    return (I && !V || !I && V) && (H = H.redNeg()), this.point(P, H);
  }, h.prototype.validate = function(P) {
    if (P.inf)
      return !0;
    var I = P.x, B = P.y, H = this.a.redMul(I), V = I.redSqr().redMul(I).redIAdd(H).redIAdd(this.b);
    return B.redSqr().redISub(V).cmpn(0) === 0;
  }, h.prototype._endoWnafMulAdd = function(P, I, B) {
    for (var H = this._endoWnafT1, V = this._endoWnafT2, X = 0; X < P.length; X++) {
      var Q = this._endoSplit(I[X]), ee = P[X], ie = ee._getBeta();
      Q.k1.negative && (Q.k1.ineg(), ee = ee.neg(!0)), Q.k2.negative && (Q.k2.ineg(), ie = ie.neg(!0)), H[X * 2] = ee, H[X * 2 + 1] = ie, V[X * 2] = Q.k1, V[X * 2 + 1] = Q.k2;
    }
    for (var te = this._wnafMulAdd(1, H, V, X * 2, B), se = 0; se < X * 2; se++)
      H[se] = null, V[se] = null;
    return te;
  };
  function q(P, I, B, H) {
    g.BasePoint.call(this, P, "affine"), I === null && B === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new o(I, 16), this.y = new o(B, 16), H && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  S(q, g.BasePoint), h.prototype.point = function(P, I, B) {
    return new q(this, P, I, B);
  }, h.prototype.pointFromJSON = function(P, I) {
    return q.fromJSON(this, P, I);
  }, q.prototype._getBeta = function() {
    if (this.curve.endo) {
      var P = this.precomputed;
      if (P && P.beta)
        return P.beta;
      var I = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (P) {
        var B = this.curve, H = function(V) {
          return B.point(V.x.redMul(B.endo.beta), V.y);
        };
        P.beta = I, I.precomputed = {
          beta: null,
          naf: P.naf && {
            wnd: P.naf.wnd,
            points: P.naf.points.map(H)
          },
          doubles: P.doubles && {
            step: P.doubles.step,
            points: P.doubles.points.map(H)
          }
        };
      }
      return I;
    }
  }, q.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, q.fromJSON = function(P, I, B) {
    typeof I == "string" && (I = JSON.parse(I));
    var H = P.point(I[0], I[1], B);
    if (!I[2])
      return H;
    function V(Q) {
      return P.point(Q[0], Q[1], B);
    }
    var X = I[2];
    return H.precomputed = {
      beta: null,
      doubles: X.doubles && {
        step: X.doubles.step,
        points: [H].concat(X.doubles.points.map(V))
      },
      naf: X.naf && {
        wnd: X.naf.wnd,
        points: [H].concat(X.naf.points.map(V))
      }
    }, H;
  }, q.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, q.prototype.isInfinity = function() {
    return this.inf;
  }, q.prototype.add = function(P) {
    if (this.inf)
      return P;
    if (P.inf)
      return this;
    if (this.eq(P))
      return this.dbl();
    if (this.neg().eq(P))
      return this.curve.point(null, null);
    if (this.x.cmp(P.x) === 0)
      return this.curve.point(null, null);
    var I = this.y.redSub(P.y);
    I.cmpn(0) !== 0 && (I = I.redMul(this.x.redSub(P.x).redInvm()));
    var B = I.redSqr().redISub(this.x).redISub(P.x), H = I.redMul(this.x.redSub(B)).redISub(this.y);
    return this.curve.point(B, H);
  }, q.prototype.dbl = function() {
    if (this.inf)
      return this;
    var P = this.y.redAdd(this.y);
    if (P.cmpn(0) === 0)
      return this.curve.point(null, null);
    var I = this.curve.a, B = this.x.redSqr(), H = P.redInvm(), V = B.redAdd(B).redIAdd(B).redIAdd(I).redMul(H), X = V.redSqr().redISub(this.x.redAdd(this.x)), Q = V.redMul(this.x.redSub(X)).redISub(this.y);
    return this.curve.point(X, Q);
  }, q.prototype.getX = function() {
    return this.x.fromRed();
  }, q.prototype.getY = function() {
    return this.y.fromRed();
  }, q.prototype.mul = function(P) {
    return P = new o(P, 16), this.isInfinity() ? this : this._hasDoubles(P) ? this.curve._fixedNafMul(this, P) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [P]) : this.curve._wnafMul(this, P);
  }, q.prototype.mulAdd = function(P, I, B) {
    var H = [this, I], V = [P, B];
    return this.curve.endo ? this.curve._endoWnafMulAdd(H, V) : this.curve._wnafMulAdd(1, H, V, 2);
  }, q.prototype.jmulAdd = function(P, I, B) {
    var H = [this, I], V = [P, B];
    return this.curve.endo ? this.curve._endoWnafMulAdd(H, V, !0) : this.curve._wnafMulAdd(1, H, V, 2, !0);
  }, q.prototype.eq = function(P) {
    return this === P || this.inf === P.inf && (this.inf || this.x.cmp(P.x) === 0 && this.y.cmp(P.y) === 0);
  }, q.prototype.neg = function(P) {
    if (this.inf)
      return this;
    var I = this.curve.point(this.x, this.y.redNeg());
    if (P && this.precomputed) {
      var B = this.precomputed, H = function(V) {
        return V.neg();
      };
      I.precomputed = {
        naf: B.naf && {
          wnd: B.naf.wnd,
          points: B.naf.points.map(H)
        },
        doubles: B.doubles && {
          step: B.doubles.step,
          points: B.doubles.points.map(H)
        }
      };
    }
    return I;
  }, q.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var P = this.curve.jpoint(this.x, this.y, this.curve.one);
    return P;
  };
  function A(P, I, B, H) {
    g.BasePoint.call(this, P, "jacobian"), I === null && B === null && H === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new o(0)) : (this.x = new o(I, 16), this.y = new o(B, 16), this.z = new o(H, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return S(A, g.BasePoint), h.prototype.jpoint = function(P, I, B) {
    return new A(this, P, I, B);
  }, A.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var P = this.z.redInvm(), I = P.redSqr(), B = this.x.redMul(I), H = this.y.redMul(I).redMul(P);
    return this.curve.point(B, H);
  }, A.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, A.prototype.add = function(P) {
    if (this.isInfinity())
      return P;
    if (P.isInfinity())
      return this;
    var I = P.z.redSqr(), B = this.z.redSqr(), H = this.x.redMul(I), V = P.x.redMul(B), X = this.y.redMul(I.redMul(P.z)), Q = P.y.redMul(B.redMul(this.z)), ee = H.redSub(V), ie = X.redSub(Q);
    if (ee.cmpn(0) === 0)
      return ie.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var te = ee.redSqr(), se = te.redMul(ee), le = H.redMul(te), ce = ie.redSqr().redIAdd(se).redISub(le).redISub(le), pe = ie.redMul(le.redISub(ce)).redISub(X.redMul(se)), me = this.z.redMul(P.z).redMul(ee);
    return this.curve.jpoint(ce, pe, me);
  }, A.prototype.mixedAdd = function(P) {
    if (this.isInfinity())
      return P.toJ();
    if (P.isInfinity())
      return this;
    var I = this.z.redSqr(), B = this.x, H = P.x.redMul(I), V = this.y, X = P.y.redMul(I).redMul(this.z), Q = B.redSub(H), ee = V.redSub(X);
    if (Q.cmpn(0) === 0)
      return ee.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var ie = Q.redSqr(), te = ie.redMul(Q), se = B.redMul(ie), le = ee.redSqr().redIAdd(te).redISub(se).redISub(se), ce = ee.redMul(se.redISub(le)).redISub(V.redMul(te)), pe = this.z.redMul(Q);
    return this.curve.jpoint(le, ce, pe);
  }, A.prototype.dblp = function(P) {
    if (P === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!P)
      return this.dbl();
    var I;
    if (this.curve.zeroA || this.curve.threeA) {
      var B = this;
      for (I = 0; I < P; I++)
        B = B.dbl();
      return B;
    }
    var H = this.curve.a, V = this.curve.tinv, X = this.x, Q = this.y, ee = this.z, ie = ee.redSqr().redSqr(), te = Q.redAdd(Q);
    for (I = 0; I < P; I++) {
      var se = X.redSqr(), le = te.redSqr(), ce = le.redSqr(), pe = se.redAdd(se).redIAdd(se).redIAdd(H.redMul(ie)), me = X.redMul(le), Me = pe.redSqr().redISub(me.redAdd(me)), Ee = me.redISub(Me), Re = pe.redMul(Ee);
      Re = Re.redIAdd(Re).redISub(ce);
      var Ne = te.redMul(ee);
      I + 1 < P && (ie = ie.redMul(ce)), X = Me, ee = Ne, te = Re;
    }
    return this.curve.jpoint(X, te.redMul(V), ee);
  }, A.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, A.prototype._zeroDbl = function() {
    var P, I, B;
    if (this.zOne) {
      var H = this.x.redSqr(), V = this.y.redSqr(), X = V.redSqr(), Q = this.x.redAdd(V).redSqr().redISub(H).redISub(X);
      Q = Q.redIAdd(Q);
      var ee = H.redAdd(H).redIAdd(H), ie = ee.redSqr().redISub(Q).redISub(Q), te = X.redIAdd(X);
      te = te.redIAdd(te), te = te.redIAdd(te), P = ie, I = ee.redMul(Q.redISub(ie)).redISub(te), B = this.y.redAdd(this.y);
    } else {
      var se = this.x.redSqr(), le = this.y.redSqr(), ce = le.redSqr(), pe = this.x.redAdd(le).redSqr().redISub(se).redISub(ce);
      pe = pe.redIAdd(pe);
      var me = se.redAdd(se).redIAdd(se), Me = me.redSqr(), Ee = ce.redIAdd(ce);
      Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee), P = Me.redISub(pe).redISub(pe), I = me.redMul(pe.redISub(P)).redISub(Ee), B = this.y.redMul(this.z), B = B.redIAdd(B);
    }
    return this.curve.jpoint(P, I, B);
  }, A.prototype._threeDbl = function() {
    var P, I, B;
    if (this.zOne) {
      var H = this.x.redSqr(), V = this.y.redSqr(), X = V.redSqr(), Q = this.x.redAdd(V).redSqr().redISub(H).redISub(X);
      Q = Q.redIAdd(Q);
      var ee = H.redAdd(H).redIAdd(H).redIAdd(this.curve.a), ie = ee.redSqr().redISub(Q).redISub(Q);
      P = ie;
      var te = X.redIAdd(X);
      te = te.redIAdd(te), te = te.redIAdd(te), I = ee.redMul(Q.redISub(ie)).redISub(te), B = this.y.redAdd(this.y);
    } else {
      var se = this.z.redSqr(), le = this.y.redSqr(), ce = this.x.redMul(le), pe = this.x.redSub(se).redMul(this.x.redAdd(se));
      pe = pe.redAdd(pe).redIAdd(pe);
      var me = ce.redIAdd(ce);
      me = me.redIAdd(me);
      var Me = me.redAdd(me);
      P = pe.redSqr().redISub(Me), B = this.y.redAdd(this.z).redSqr().redISub(le).redISub(se);
      var Ee = le.redSqr();
      Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee), I = pe.redMul(me.redISub(P)).redISub(Ee);
    }
    return this.curve.jpoint(P, I, B);
  }, A.prototype._dbl = function() {
    var P = this.curve.a, I = this.x, B = this.y, H = this.z, V = H.redSqr().redSqr(), X = I.redSqr(), Q = B.redSqr(), ee = X.redAdd(X).redIAdd(X).redIAdd(P.redMul(V)), ie = I.redAdd(I);
    ie = ie.redIAdd(ie);
    var te = ie.redMul(Q), se = ee.redSqr().redISub(te.redAdd(te)), le = te.redISub(se), ce = Q.redSqr();
    ce = ce.redIAdd(ce), ce = ce.redIAdd(ce), ce = ce.redIAdd(ce);
    var pe = ee.redMul(le).redISub(ce), me = B.redAdd(B).redMul(H);
    return this.curve.jpoint(se, pe, me);
  }, A.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var P = this.x.redSqr(), I = this.y.redSqr(), B = this.z.redSqr(), H = I.redSqr(), V = P.redAdd(P).redIAdd(P), X = V.redSqr(), Q = this.x.redAdd(I).redSqr().redISub(P).redISub(H);
    Q = Q.redIAdd(Q), Q = Q.redAdd(Q).redIAdd(Q), Q = Q.redISub(X);
    var ee = Q.redSqr(), ie = H.redIAdd(H);
    ie = ie.redIAdd(ie), ie = ie.redIAdd(ie), ie = ie.redIAdd(ie);
    var te = V.redIAdd(Q).redSqr().redISub(X).redISub(ee).redISub(ie), se = I.redMul(te);
    se = se.redIAdd(se), se = se.redIAdd(se);
    var le = this.x.redMul(ee).redISub(se);
    le = le.redIAdd(le), le = le.redIAdd(le);
    var ce = this.y.redMul(te.redMul(ie.redISub(te)).redISub(Q.redMul(ee)));
    ce = ce.redIAdd(ce), ce = ce.redIAdd(ce), ce = ce.redIAdd(ce);
    var pe = this.z.redAdd(Q).redSqr().redISub(B).redISub(ee);
    return this.curve.jpoint(le, ce, pe);
  }, A.prototype.mul = function(P, I) {
    return P = new o(P, I), this.curve._wnafMul(this, P);
  }, A.prototype.eq = function(P) {
    if (P.type === "affine")
      return this.eq(P.toJ());
    if (this === P)
      return !0;
    var I = this.z.redSqr(), B = P.z.redSqr();
    if (this.x.redMul(B).redISub(P.x.redMul(I)).cmpn(0) !== 0)
      return !1;
    var H = I.redMul(this.z), V = B.redMul(P.z);
    return this.y.redMul(V).redISub(P.y.redMul(H)).cmpn(0) === 0;
  }, A.prototype.eqXToP = function(P) {
    var I = this.z.redSqr(), B = P.toRed(this.curve.red).redMul(I);
    if (this.x.cmp(B) === 0)
      return !0;
    for (var H = P.clone(), V = this.curve.redN.redMul(I); ; ) {
      if (H.iadd(this.curve.n), H.cmp(this.curve.p) >= 0)
        return !1;
      if (B.redIAdd(V), this.x.cmp(B) === 0)
        return !0;
    }
  }, A.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, A.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short$1;
}
var mont$1, hasRequiredMont$1;
function requireMont$1() {
  if (hasRequiredMont$1)
    return mont$1;
  hasRequiredMont$1 = 1;
  var e = requireBn$2(), o = requireInherits_browser$1(), S = requireBase$1$1(), g = requireUtils$1$1();
  function U(q) {
    S.call(this, "mont", q), this.a = new e(q.a, 16).toRed(this.red), this.b = new e(q.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  o(U, S), mont$1 = U, U.prototype.validate = function(q) {
    var A = q.normalize().x, P = A.redSqr(), I = P.redMul(A).redAdd(P.redMul(this.a)).redAdd(A), B = I.redSqrt();
    return B.redSqr().cmp(I) === 0;
  };
  function h(q, A, P) {
    S.BasePoint.call(this, q, "projective"), A === null && P === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(A, 16), this.z = new e(P, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return o(h, S.BasePoint), U.prototype.decodePoint = function(q, A) {
    return this.point(g.toArray(q, A), 1);
  }, U.prototype.point = function(q, A) {
    return new h(this, q, A);
  }, U.prototype.pointFromJSON = function(q) {
    return h.fromJSON(this, q);
  }, h.prototype.precompute = function() {
  }, h.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, h.fromJSON = function(q, A) {
    return new h(q, A[0], A[1] || q.one);
  }, h.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, h.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, h.prototype.dbl = function() {
    var q = this.x.redAdd(this.z), A = q.redSqr(), P = this.x.redSub(this.z), I = P.redSqr(), B = A.redSub(I), H = A.redMul(I), V = B.redMul(I.redAdd(this.curve.a24.redMul(B)));
    return this.curve.point(H, V);
  }, h.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, h.prototype.diffAdd = function(q, A) {
    var P = this.x.redAdd(this.z), I = this.x.redSub(this.z), B = q.x.redAdd(q.z), H = q.x.redSub(q.z), V = H.redMul(P), X = B.redMul(I), Q = A.z.redMul(V.redAdd(X).redSqr()), ee = A.x.redMul(V.redISub(X).redSqr());
    return this.curve.point(Q, ee);
  }, h.prototype.mul = function(q) {
    for (var A = q.clone(), P = this, I = this.curve.point(null, null), B = this, H = []; A.cmpn(0) !== 0; A.iushrn(1))
      H.push(A.andln(1));
    for (var V = H.length - 1; V >= 0; V--)
      H[V] === 0 ? (P = P.diffAdd(I, B), I = I.dbl()) : (I = P.diffAdd(I, B), P = P.dbl());
    return I;
  }, h.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, h.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, h.prototype.eq = function(q) {
    return this.getX().cmp(q.getX()) === 0;
  }, h.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, h.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont$1;
}
var edwards$1, hasRequiredEdwards$1;
function requireEdwards$1() {
  if (hasRequiredEdwards$1)
    return edwards$1;
  hasRequiredEdwards$1 = 1;
  var e = requireUtils$1$1(), o = requireBn$2(), S = requireInherits_browser$1(), g = requireBase$1$1(), U = e.assert;
  function h(A) {
    this.twisted = (A.a | 0) !== 1, this.mOneA = this.twisted && (A.a | 0) === -1, this.extended = this.mOneA, g.call(this, "edwards", A), this.a = new o(A.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new o(A.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new o(A.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), U(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (A.c | 0) === 1;
  }
  S(h, g), edwards$1 = h, h.prototype._mulA = function(A) {
    return this.mOneA ? A.redNeg() : this.a.redMul(A);
  }, h.prototype._mulC = function(A) {
    return this.oneC ? A : this.c.redMul(A);
  }, h.prototype.jpoint = function(A, P, I, B) {
    return this.point(A, P, I, B);
  }, h.prototype.pointFromX = function(A, P) {
    A = new o(A, 16), A.red || (A = A.toRed(this.red));
    var I = A.redSqr(), B = this.c2.redSub(this.a.redMul(I)), H = this.one.redSub(this.c2.redMul(this.d).redMul(I)), V = B.redMul(H.redInvm()), X = V.redSqrt();
    if (X.redSqr().redSub(V).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Q = X.fromRed().isOdd();
    return (P && !Q || !P && Q) && (X = X.redNeg()), this.point(A, X);
  }, h.prototype.pointFromY = function(A, P) {
    A = new o(A, 16), A.red || (A = A.toRed(this.red));
    var I = A.redSqr(), B = I.redSub(this.c2), H = I.redMul(this.d).redMul(this.c2).redSub(this.a), V = B.redMul(H.redInvm());
    if (V.cmp(this.zero) === 0) {
      if (P)
        throw new Error("invalid point");
      return this.point(this.zero, A);
    }
    var X = V.redSqrt();
    if (X.redSqr().redSub(V).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return X.fromRed().isOdd() !== P && (X = X.redNeg()), this.point(X, A);
  }, h.prototype.validate = function(A) {
    if (A.isInfinity())
      return !0;
    A.normalize();
    var P = A.x.redSqr(), I = A.y.redSqr(), B = P.redMul(this.a).redAdd(I), H = this.c2.redMul(this.one.redAdd(this.d.redMul(P).redMul(I)));
    return B.cmp(H) === 0;
  };
  function q(A, P, I, B, H) {
    g.BasePoint.call(this, A, "projective"), P === null && I === null && B === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new o(P, 16), this.y = new o(I, 16), this.z = B ? new o(B, 16) : this.curve.one, this.t = H && new o(H, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return S(q, g.BasePoint), h.prototype.pointFromJSON = function(A) {
    return q.fromJSON(this, A);
  }, h.prototype.point = function(A, P, I, B) {
    return new q(this, A, P, I, B);
  }, q.fromJSON = function(A, P) {
    return new q(A, P[0], P[1], P[2]);
  }, q.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, q.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, q.prototype._extDbl = function() {
    var A = this.x.redSqr(), P = this.y.redSqr(), I = this.z.redSqr();
    I = I.redIAdd(I);
    var B = this.curve._mulA(A), H = this.x.redAdd(this.y).redSqr().redISub(A).redISub(P), V = B.redAdd(P), X = V.redSub(I), Q = B.redSub(P), ee = H.redMul(X), ie = V.redMul(Q), te = H.redMul(Q), se = X.redMul(V);
    return this.curve.point(ee, ie, se, te);
  }, q.prototype._projDbl = function() {
    var A = this.x.redAdd(this.y).redSqr(), P = this.x.redSqr(), I = this.y.redSqr(), B, H, V, X, Q, ee;
    if (this.curve.twisted) {
      X = this.curve._mulA(P);
      var ie = X.redAdd(I);
      this.zOne ? (B = A.redSub(P).redSub(I).redMul(ie.redSub(this.curve.two)), H = ie.redMul(X.redSub(I)), V = ie.redSqr().redSub(ie).redSub(ie)) : (Q = this.z.redSqr(), ee = ie.redSub(Q).redISub(Q), B = A.redSub(P).redISub(I).redMul(ee), H = ie.redMul(X.redSub(I)), V = ie.redMul(ee));
    } else
      X = P.redAdd(I), Q = this.curve._mulC(this.z).redSqr(), ee = X.redSub(Q).redSub(Q), B = this.curve._mulC(A.redISub(X)).redMul(ee), H = this.curve._mulC(X).redMul(P.redISub(I)), V = X.redMul(ee);
    return this.curve.point(B, H, V);
  }, q.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, q.prototype._extAdd = function(A) {
    var P = this.y.redSub(this.x).redMul(A.y.redSub(A.x)), I = this.y.redAdd(this.x).redMul(A.y.redAdd(A.x)), B = this.t.redMul(this.curve.dd).redMul(A.t), H = this.z.redMul(A.z.redAdd(A.z)), V = I.redSub(P), X = H.redSub(B), Q = H.redAdd(B), ee = I.redAdd(P), ie = V.redMul(X), te = Q.redMul(ee), se = V.redMul(ee), le = X.redMul(Q);
    return this.curve.point(ie, te, le, se);
  }, q.prototype._projAdd = function(A) {
    var P = this.z.redMul(A.z), I = P.redSqr(), B = this.x.redMul(A.x), H = this.y.redMul(A.y), V = this.curve.d.redMul(B).redMul(H), X = I.redSub(V), Q = I.redAdd(V), ee = this.x.redAdd(this.y).redMul(A.x.redAdd(A.y)).redISub(B).redISub(H), ie = P.redMul(X).redMul(ee), te, se;
    return this.curve.twisted ? (te = P.redMul(Q).redMul(H.redSub(this.curve._mulA(B))), se = X.redMul(Q)) : (te = P.redMul(Q).redMul(H.redSub(B)), se = this.curve._mulC(X).redMul(Q)), this.curve.point(ie, te, se);
  }, q.prototype.add = function(A) {
    return this.isInfinity() ? A : A.isInfinity() ? this : this.curve.extended ? this._extAdd(A) : this._projAdd(A);
  }, q.prototype.mul = function(A) {
    return this._hasDoubles(A) ? this.curve._fixedNafMul(this, A) : this.curve._wnafMul(this, A);
  }, q.prototype.mulAdd = function(A, P, I) {
    return this.curve._wnafMulAdd(1, [this, P], [A, I], 2, !1);
  }, q.prototype.jmulAdd = function(A, P, I) {
    return this.curve._wnafMulAdd(1, [this, P], [A, I], 2, !0);
  }, q.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var A = this.z.redInvm();
    return this.x = this.x.redMul(A), this.y = this.y.redMul(A), this.t && (this.t = this.t.redMul(A)), this.z = this.curve.one, this.zOne = !0, this;
  }, q.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, q.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, q.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, q.prototype.eq = function(A) {
    return this === A || this.getX().cmp(A.getX()) === 0 && this.getY().cmp(A.getY()) === 0;
  }, q.prototype.eqXToP = function(A) {
    var P = A.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(P) === 0)
      return !0;
    for (var I = A.clone(), B = this.curve.redN.redMul(this.z); ; ) {
      if (I.iadd(this.curve.n), I.cmp(this.curve.p) >= 0)
        return !1;
      if (P.redIAdd(B), this.x.cmp(P) === 0)
        return !0;
    }
  }, q.prototype.toP = q.prototype.normalize, q.prototype.mixedAdd = q.prototype.add, edwards$1;
}
var hasRequiredCurve$1;
function requireCurve$1() {
  return hasRequiredCurve$1 || (hasRequiredCurve$1 = 1, function(e) {
    var o = e;
    o.base = requireBase$1$1(), o.short = requireShort$1(), o.mont = requireMont$1(), o.edwards = requireEdwards$1();
  }(curve$2)), curve$2;
}
var curves$1 = {}, hash$3 = {}, utils$9 = {}, hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4)
    return utils$9;
  hasRequiredUtils$4 = 1;
  var e = requireMinimalisticAssert$1(), o = requireInherits_browser$1();
  utils$9.inherits = o;
  function S(Y, M) {
    return (Y.charCodeAt(M) & 64512) !== 55296 || M < 0 || M + 1 >= Y.length ? !1 : (Y.charCodeAt(M + 1) & 64512) === 56320;
  }
  function g(Y, M) {
    if (Array.isArray(Y))
      return Y.slice();
    if (!Y)
      return [];
    var $ = [];
    if (typeof Y == "string")
      if (M) {
        if (M === "hex")
          for (Y = Y.replace(/[^a-z0-9]+/ig, ""), Y.length % 2 !== 0 && (Y = "0" + Y), J = 0; J < Y.length; J += 2)
            $.push(parseInt(Y[J] + Y[J + 1], 16));
      } else
        for (var O = 0, J = 0; J < Y.length; J++) {
          var Z = Y.charCodeAt(J);
          Z < 128 ? $[O++] = Z : Z < 2048 ? ($[O++] = Z >> 6 | 192, $[O++] = Z & 63 | 128) : S(Y, J) ? (Z = 65536 + ((Z & 1023) << 10) + (Y.charCodeAt(++J) & 1023), $[O++] = Z >> 18 | 240, $[O++] = Z >> 12 & 63 | 128, $[O++] = Z >> 6 & 63 | 128, $[O++] = Z & 63 | 128) : ($[O++] = Z >> 12 | 224, $[O++] = Z >> 6 & 63 | 128, $[O++] = Z & 63 | 128);
        }
    else
      for (J = 0; J < Y.length; J++)
        $[J] = Y[J] | 0;
    return $;
  }
  utils$9.toArray = g;
  function U(Y) {
    for (var M = "", $ = 0; $ < Y.length; $++)
      M += A(Y[$].toString(16));
    return M;
  }
  utils$9.toHex = U;
  function h(Y) {
    var M = Y >>> 24 | Y >>> 8 & 65280 | Y << 8 & 16711680 | (Y & 255) << 24;
    return M >>> 0;
  }
  utils$9.htonl = h;
  function q(Y, M) {
    for (var $ = "", O = 0; O < Y.length; O++) {
      var J = Y[O];
      M === "little" && (J = h(J)), $ += P(J.toString(16));
    }
    return $;
  }
  utils$9.toHex32 = q;
  function A(Y) {
    return Y.length === 1 ? "0" + Y : Y;
  }
  utils$9.zero2 = A;
  function P(Y) {
    return Y.length === 7 ? "0" + Y : Y.length === 6 ? "00" + Y : Y.length === 5 ? "000" + Y : Y.length === 4 ? "0000" + Y : Y.length === 3 ? "00000" + Y : Y.length === 2 ? "000000" + Y : Y.length === 1 ? "0000000" + Y : Y;
  }
  utils$9.zero8 = P;
  function I(Y, M, $, O) {
    var J = $ - M;
    e(J % 4 === 0);
    for (var Z = new Array(J / 4), K = 0, z = M; K < Z.length; K++, z += 4) {
      var G;
      O === "big" ? G = Y[z] << 24 | Y[z + 1] << 16 | Y[z + 2] << 8 | Y[z + 3] : G = Y[z + 3] << 24 | Y[z + 2] << 16 | Y[z + 1] << 8 | Y[z], Z[K] = G >>> 0;
    }
    return Z;
  }
  utils$9.join32 = I;
  function B(Y, M) {
    for (var $ = new Array(Y.length * 4), O = 0, J = 0; O < Y.length; O++, J += 4) {
      var Z = Y[O];
      M === "big" ? ($[J] = Z >>> 24, $[J + 1] = Z >>> 16 & 255, $[J + 2] = Z >>> 8 & 255, $[J + 3] = Z & 255) : ($[J + 3] = Z >>> 24, $[J + 2] = Z >>> 16 & 255, $[J + 1] = Z >>> 8 & 255, $[J] = Z & 255);
    }
    return $;
  }
  utils$9.split32 = B;
  function H(Y, M) {
    return Y >>> M | Y << 32 - M;
  }
  utils$9.rotr32 = H;
  function V(Y, M) {
    return Y << M | Y >>> 32 - M;
  }
  utils$9.rotl32 = V;
  function X(Y, M) {
    return Y + M >>> 0;
  }
  utils$9.sum32 = X;
  function Q(Y, M, $) {
    return Y + M + $ >>> 0;
  }
  utils$9.sum32_3 = Q;
  function ee(Y, M, $, O) {
    return Y + M + $ + O >>> 0;
  }
  utils$9.sum32_4 = ee;
  function ie(Y, M, $, O, J) {
    return Y + M + $ + O + J >>> 0;
  }
  utils$9.sum32_5 = ie;
  function te(Y, M, $, O) {
    var J = Y[M], Z = Y[M + 1], K = O + Z >>> 0, z = (K < O ? 1 : 0) + $ + J;
    Y[M] = z >>> 0, Y[M + 1] = K;
  }
  utils$9.sum64 = te;
  function se(Y, M, $, O) {
    var J = M + O >>> 0, Z = (J < M ? 1 : 0) + Y + $;
    return Z >>> 0;
  }
  utils$9.sum64_hi = se;
  function le(Y, M, $, O) {
    var J = M + O;
    return J >>> 0;
  }
  utils$9.sum64_lo = le;
  function ce(Y, M, $, O, J, Z, K, z) {
    var G = 0, D = M;
    D = D + O >>> 0, G += D < M ? 1 : 0, D = D + Z >>> 0, G += D < Z ? 1 : 0, D = D + z >>> 0, G += D < z ? 1 : 0;
    var F = Y + $ + J + K + G;
    return F >>> 0;
  }
  utils$9.sum64_4_hi = ce;
  function pe(Y, M, $, O, J, Z, K, z) {
    var G = M + O + Z + z;
    return G >>> 0;
  }
  utils$9.sum64_4_lo = pe;
  function me(Y, M, $, O, J, Z, K, z, G, D) {
    var F = 0, ae = M;
    ae = ae + O >>> 0, F += ae < M ? 1 : 0, ae = ae + Z >>> 0, F += ae < Z ? 1 : 0, ae = ae + z >>> 0, F += ae < z ? 1 : 0, ae = ae + D >>> 0, F += ae < D ? 1 : 0;
    var ge = Y + $ + J + K + G + F;
    return ge >>> 0;
  }
  utils$9.sum64_5_hi = me;
  function Me(Y, M, $, O, J, Z, K, z, G, D) {
    var F = M + O + Z + z + D;
    return F >>> 0;
  }
  utils$9.sum64_5_lo = Me;
  function Ee(Y, M, $) {
    var O = M << 32 - $ | Y >>> $;
    return O >>> 0;
  }
  utils$9.rotr64_hi = Ee;
  function Re(Y, M, $) {
    var O = Y << 32 - $ | M >>> $;
    return O >>> 0;
  }
  utils$9.rotr64_lo = Re;
  function Ne(Y, M, $) {
    return Y >>> $;
  }
  utils$9.shr64_hi = Ne;
  function ne(Y, M, $) {
    var O = Y << 32 - $ | M >>> $;
    return O >>> 0;
  }
  return utils$9.shr64_lo = ne, utils$9;
}
var common$1$1 = {}, hasRequiredCommon$1$1;
function requireCommon$1$1() {
  if (hasRequiredCommon$1$1)
    return common$1$1;
  hasRequiredCommon$1$1 = 1;
  var e = requireUtils$4(), o = requireMinimalisticAssert$1();
  function S() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1$1.BlockHash = S, S.prototype.update = function(g, U) {
    if (g = e.toArray(g, U), this.pending ? this.pending = this.pending.concat(g) : this.pending = g, this.pendingTotal += g.length, this.pending.length >= this._delta8) {
      g = this.pending;
      var h = g.length % this._delta8;
      this.pending = g.slice(g.length - h, g.length), this.pending.length === 0 && (this.pending = null), g = e.join32(g, 0, g.length - h, this.endian);
      for (var q = 0; q < g.length; q += this._delta32)
        this._update(g, q, q + this._delta32);
    }
    return this;
  }, S.prototype.digest = function(g) {
    return this.update(this._pad()), o(this.pending === null), this._digest(g);
  }, S.prototype._pad = function() {
    var g = this.pendingTotal, U = this._delta8, h = U - (g + this.padLength) % U, q = new Array(h + this.padLength);
    q[0] = 128;
    for (var A = 1; A < h; A++)
      q[A] = 0;
    if (g <<= 3, this.endian === "big") {
      for (var P = 8; P < this.padLength; P++)
        q[A++] = 0;
      q[A++] = 0, q[A++] = 0, q[A++] = 0, q[A++] = 0, q[A++] = g >>> 24 & 255, q[A++] = g >>> 16 & 255, q[A++] = g >>> 8 & 255, q[A++] = g & 255;
    } else
      for (q[A++] = g & 255, q[A++] = g >>> 8 & 255, q[A++] = g >>> 16 & 255, q[A++] = g >>> 24 & 255, q[A++] = 0, q[A++] = 0, q[A++] = 0, q[A++] = 0, P = 8; P < this.padLength; P++)
        q[A++] = 0;
    return q;
  }, common$1$1;
}
var sha$2 = {}, common$4 = {}, hasRequiredCommon$3;
function requireCommon$3() {
  if (hasRequiredCommon$3)
    return common$4;
  hasRequiredCommon$3 = 1;
  var e = requireUtils$4(), o = e.rotr32;
  function S(B, H, V, X) {
    if (B === 0)
      return g(H, V, X);
    if (B === 1 || B === 3)
      return h(H, V, X);
    if (B === 2)
      return U(H, V, X);
  }
  common$4.ft_1 = S;
  function g(B, H, V) {
    return B & H ^ ~B & V;
  }
  common$4.ch32 = g;
  function U(B, H, V) {
    return B & H ^ B & V ^ H & V;
  }
  common$4.maj32 = U;
  function h(B, H, V) {
    return B ^ H ^ V;
  }
  common$4.p32 = h;
  function q(B) {
    return o(B, 2) ^ o(B, 13) ^ o(B, 22);
  }
  common$4.s0_256 = q;
  function A(B) {
    return o(B, 6) ^ o(B, 11) ^ o(B, 25);
  }
  common$4.s1_256 = A;
  function P(B) {
    return o(B, 7) ^ o(B, 18) ^ B >>> 3;
  }
  common$4.g0_256 = P;
  function I(B) {
    return o(B, 17) ^ o(B, 19) ^ B >>> 10;
  }
  return common$4.g1_256 = I, common$4;
}
var _1$1, hasRequired_1$1;
function require_1$1() {
  if (hasRequired_1$1)
    return _1$1;
  hasRequired_1$1 = 1;
  var e = requireUtils$4(), o = requireCommon$1$1(), S = requireCommon$3(), g = e.rotl32, U = e.sum32, h = e.sum32_5, q = S.ft_1, A = o.BlockHash, P = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function I() {
    if (!(this instanceof I))
      return new I();
    A.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(I, A), _1$1 = I, I.blockSize = 512, I.outSize = 160, I.hmacStrength = 80, I.padLength = 64, I.prototype._update = function(B, H) {
    for (var V = this.W, X = 0; X < 16; X++)
      V[X] = B[H + X];
    for (; X < V.length; X++)
      V[X] = g(V[X - 3] ^ V[X - 8] ^ V[X - 14] ^ V[X - 16], 1);
    var Q = this.h[0], ee = this.h[1], ie = this.h[2], te = this.h[3], se = this.h[4];
    for (X = 0; X < V.length; X++) {
      var le = ~~(X / 20), ce = h(g(Q, 5), q(le, ee, ie, te), se, V[X], P[le]);
      se = te, te = ie, ie = g(ee, 30), ee = Q, Q = ce;
    }
    this.h[0] = U(this.h[0], Q), this.h[1] = U(this.h[1], ee), this.h[2] = U(this.h[2], ie), this.h[3] = U(this.h[3], te), this.h[4] = U(this.h[4], se);
  }, I.prototype._digest = function(B) {
    return B === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _1$1;
}
var _256$1, hasRequired_256$1;
function require_256$1() {
  if (hasRequired_256$1)
    return _256$1;
  hasRequired_256$1 = 1;
  var e = requireUtils$4(), o = requireCommon$1$1(), S = requireCommon$3(), g = requireMinimalisticAssert$1(), U = e.sum32, h = e.sum32_4, q = e.sum32_5, A = S.ch32, P = S.maj32, I = S.s0_256, B = S.s1_256, H = S.g0_256, V = S.g1_256, X = o.BlockHash, Q = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ee() {
    if (!(this instanceof ee))
      return new ee();
    X.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = Q, this.W = new Array(64);
  }
  return e.inherits(ee, X), _256$1 = ee, ee.blockSize = 512, ee.outSize = 256, ee.hmacStrength = 192, ee.padLength = 64, ee.prototype._update = function(ie, te) {
    for (var se = this.W, le = 0; le < 16; le++)
      se[le] = ie[te + le];
    for (; le < se.length; le++)
      se[le] = h(V(se[le - 2]), se[le - 7], H(se[le - 15]), se[le - 16]);
    var ce = this.h[0], pe = this.h[1], me = this.h[2], Me = this.h[3], Ee = this.h[4], Re = this.h[5], Ne = this.h[6], ne = this.h[7];
    for (g(this.k.length === se.length), le = 0; le < se.length; le++) {
      var Y = q(ne, B(Ee), A(Ee, Re, Ne), this.k[le], se[le]), M = U(I(ce), P(ce, pe, me));
      ne = Ne, Ne = Re, Re = Ee, Ee = U(Me, Y), Me = me, me = pe, pe = ce, ce = U(Y, M);
    }
    this.h[0] = U(this.h[0], ce), this.h[1] = U(this.h[1], pe), this.h[2] = U(this.h[2], me), this.h[3] = U(this.h[3], Me), this.h[4] = U(this.h[4], Ee), this.h[5] = U(this.h[5], Re), this.h[6] = U(this.h[6], Ne), this.h[7] = U(this.h[7], ne);
  }, ee.prototype._digest = function(ie) {
    return ie === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _256$1;
}
var _224$1, hasRequired_224$1;
function require_224$1() {
  if (hasRequired_224$1)
    return _224$1;
  hasRequired_224$1 = 1;
  var e = requireUtils$4(), o = require_256$1();
  function S() {
    if (!(this instanceof S))
      return new S();
    o.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(S, o), _224$1 = S, S.blockSize = 512, S.outSize = 224, S.hmacStrength = 192, S.padLength = 64, S.prototype._digest = function(g) {
    return g === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, _224$1;
}
var _512$1, hasRequired_512$1;
function require_512$1() {
  if (hasRequired_512$1)
    return _512$1;
  hasRequired_512$1 = 1;
  var e = requireUtils$4(), o = requireCommon$1$1(), S = requireMinimalisticAssert$1(), g = e.rotr64_hi, U = e.rotr64_lo, h = e.shr64_hi, q = e.shr64_lo, A = e.sum64, P = e.sum64_hi, I = e.sum64_lo, B = e.sum64_4_hi, H = e.sum64_4_lo, V = e.sum64_5_hi, X = e.sum64_5_lo, Q = o.BlockHash, ee = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function ie() {
    if (!(this instanceof ie))
      return new ie();
    Q.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = ee, this.W = new Array(160);
  }
  e.inherits(ie, Q), _512$1 = ie, ie.blockSize = 1024, ie.outSize = 512, ie.hmacStrength = 192, ie.padLength = 128, ie.prototype._prepareBlock = function(M, $) {
    for (var O = this.W, J = 0; J < 32; J++)
      O[J] = M[$ + J];
    for (; J < O.length; J += 2) {
      var Z = ne(O[J - 4], O[J - 3]), K = Y(O[J - 4], O[J - 3]), z = O[J - 14], G = O[J - 13], D = Re(O[J - 30], O[J - 29]), F = Ne(O[J - 30], O[J - 29]), ae = O[J - 32], ge = O[J - 31];
      O[J] = B(
        Z,
        K,
        z,
        G,
        D,
        F,
        ae,
        ge
      ), O[J + 1] = H(
        Z,
        K,
        z,
        G,
        D,
        F,
        ae,
        ge
      );
    }
  }, ie.prototype._update = function(M, $) {
    this._prepareBlock(M, $);
    var O = this.W, J = this.h[0], Z = this.h[1], K = this.h[2], z = this.h[3], G = this.h[4], D = this.h[5], F = this.h[6], ae = this.h[7], ge = this.h[8], xe = this.h[9], ye = this.h[10], oe = this.h[11], fe = this.h[12], $e = this.h[13], Be = this.h[14], be = this.h[15];
    S(this.k.length === O.length);
    for (var ve = 0; ve < O.length; ve += 2) {
      var qe = Be, De = be, Ye = Me(ge, xe), he = Ee(ge, xe), ue = te(ge, xe, ye, oe, fe), de = se(ge, xe, ye, oe, fe, $e), _e = this.k[ve], Pe = this.k[ve + 1], He = O[ve], Ve = O[ve + 1], nt = V(
        qe,
        De,
        Ye,
        he,
        ue,
        de,
        _e,
        Pe,
        He,
        Ve
      ), Ie = X(
        qe,
        De,
        Ye,
        he,
        ue,
        de,
        _e,
        Pe,
        He,
        Ve
      );
      qe = pe(J, Z), De = me(J, Z), Ye = le(J, Z, K, z, G), he = ce(J, Z, K, z, G, D);
      var Fe = P(qe, De, Ye, he), je = I(qe, De, Ye, he);
      Be = fe, be = $e, fe = ye, $e = oe, ye = ge, oe = xe, ge = P(F, ae, nt, Ie), xe = I(ae, ae, nt, Ie), F = G, ae = D, G = K, D = z, K = J, z = Z, J = P(nt, Ie, Fe, je), Z = I(nt, Ie, Fe, je);
    }
    A(this.h, 0, J, Z), A(this.h, 2, K, z), A(this.h, 4, G, D), A(this.h, 6, F, ae), A(this.h, 8, ge, xe), A(this.h, 10, ye, oe), A(this.h, 12, fe, $e), A(this.h, 14, Be, be);
  }, ie.prototype._digest = function(M) {
    return M === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function te(M, $, O, J, Z) {
    var K = M & O ^ ~M & Z;
    return K < 0 && (K += 4294967296), K;
  }
  function se(M, $, O, J, Z, K) {
    var z = $ & J ^ ~$ & K;
    return z < 0 && (z += 4294967296), z;
  }
  function le(M, $, O, J, Z) {
    var K = M & O ^ M & Z ^ O & Z;
    return K < 0 && (K += 4294967296), K;
  }
  function ce(M, $, O, J, Z, K) {
    var z = $ & J ^ $ & K ^ J & K;
    return z < 0 && (z += 4294967296), z;
  }
  function pe(M, $) {
    var O = g(M, $, 28), J = g($, M, 2), Z = g($, M, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function me(M, $) {
    var O = U(M, $, 28), J = U($, M, 2), Z = U($, M, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Me(M, $) {
    var O = g(M, $, 14), J = g(M, $, 18), Z = g($, M, 9), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Ee(M, $) {
    var O = U(M, $, 14), J = U(M, $, 18), Z = U($, M, 9), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Re(M, $) {
    var O = g(M, $, 1), J = g(M, $, 8), Z = h(M, $, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Ne(M, $) {
    var O = U(M, $, 1), J = U(M, $, 8), Z = q(M, $, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function ne(M, $) {
    var O = g(M, $, 19), J = g($, M, 29), Z = h(M, $, 6), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Y(M, $) {
    var O = U(M, $, 19), J = U($, M, 29), Z = q(M, $, 6), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  return _512$1;
}
var _384$1, hasRequired_384$1;
function require_384$1() {
  if (hasRequired_384$1)
    return _384$1;
  hasRequired_384$1 = 1;
  var e = requireUtils$4(), o = require_512$1();
  function S() {
    if (!(this instanceof S))
      return new S();
    o.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(S, o), _384$1 = S, S.blockSize = 1024, S.outSize = 384, S.hmacStrength = 192, S.padLength = 128, S.prototype._digest = function(g) {
    return g === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, _384$1;
}
var hasRequiredSha$2;
function requireSha$2() {
  return hasRequiredSha$2 || (hasRequiredSha$2 = 1, sha$2.sha1 = require_1$1(), sha$2.sha224 = require_224$1(), sha$2.sha256 = require_256$1(), sha$2.sha384 = require_384$1(), sha$2.sha512 = require_512$1()), sha$2;
}
var ripemd$1 = {}, hasRequiredRipemd$1;
function requireRipemd$1() {
  if (hasRequiredRipemd$1)
    return ripemd$1;
  hasRequiredRipemd$1 = 1;
  var e = requireUtils$4(), o = requireCommon$1$1(), S = e.rotl32, g = e.sum32, U = e.sum32_3, h = e.sum32_4, q = o.BlockHash;
  function A() {
    if (!(this instanceof A))
      return new A();
    q.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(A, q), ripemd$1.ripemd160 = A, A.blockSize = 512, A.outSize = 160, A.hmacStrength = 192, A.padLength = 64, A.prototype._update = function(ee, ie) {
    for (var te = this.h[0], se = this.h[1], le = this.h[2], ce = this.h[3], pe = this.h[4], me = te, Me = se, Ee = le, Re = ce, Ne = pe, ne = 0; ne < 80; ne++) {
      var Y = g(
        S(
          h(te, P(ne, se, le, ce), ee[H[ne] + ie], I(ne)),
          X[ne]
        ),
        pe
      );
      te = pe, pe = ce, ce = S(le, 10), le = se, se = Y, Y = g(
        S(
          h(me, P(79 - ne, Me, Ee, Re), ee[V[ne] + ie], B(ne)),
          Q[ne]
        ),
        Ne
      ), me = Ne, Ne = Re, Re = S(Ee, 10), Ee = Me, Me = Y;
    }
    Y = U(this.h[1], le, Re), this.h[1] = U(this.h[2], ce, Ne), this.h[2] = U(this.h[3], pe, me), this.h[3] = U(this.h[4], te, Me), this.h[4] = U(this.h[0], se, Ee), this.h[0] = Y;
  }, A.prototype._digest = function(ee) {
    return ee === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function P(ee, ie, te, se) {
    return ee <= 15 ? ie ^ te ^ se : ee <= 31 ? ie & te | ~ie & se : ee <= 47 ? (ie | ~te) ^ se : ee <= 63 ? ie & se | te & ~se : ie ^ (te | ~se);
  }
  function I(ee) {
    return ee <= 15 ? 0 : ee <= 31 ? 1518500249 : ee <= 47 ? 1859775393 : ee <= 63 ? 2400959708 : 2840853838;
  }
  function B(ee) {
    return ee <= 15 ? 1352829926 : ee <= 31 ? 1548603684 : ee <= 47 ? 1836072691 : ee <= 63 ? 2053994217 : 0;
  }
  var H = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], V = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], X = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], Q = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd$1;
}
var hmac$2, hasRequiredHmac$1;
function requireHmac$1() {
  if (hasRequiredHmac$1)
    return hmac$2;
  hasRequiredHmac$1 = 1;
  var e = requireUtils$4(), o = requireMinimalisticAssert$1();
  function S(g, U, h) {
    if (!(this instanceof S))
      return new S(g, U, h);
    this.Hash = g, this.blockSize = g.blockSize / 8, this.outSize = g.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(U, h));
  }
  return hmac$2 = S, S.prototype._init = function(g) {
    g.length > this.blockSize && (g = new this.Hash().update(g).digest()), o(g.length <= this.blockSize);
    for (var U = g.length; U < this.blockSize; U++)
      g.push(0);
    for (U = 0; U < g.length; U++)
      g[U] ^= 54;
    for (this.inner = new this.Hash().update(g), U = 0; U < g.length; U++)
      g[U] ^= 106;
    this.outer = new this.Hash().update(g);
  }, S.prototype.update = function(g, U) {
    return this.inner.update(g, U), this;
  }, S.prototype.digest = function(g) {
    return this.outer.update(this.inner.digest()), this.outer.digest(g);
  }, hmac$2;
}
var hasRequiredHash$2;
function requireHash$2() {
  return hasRequiredHash$2 || (hasRequiredHash$2 = 1, function(e) {
    var o = e;
    o.utils = requireUtils$4(), o.common = requireCommon$1$1(), o.sha = requireSha$2(), o.ripemd = requireRipemd$1(), o.hmac = requireHmac$1(), o.sha1 = o.sha.sha1, o.sha256 = o.sha.sha256, o.sha224 = o.sha.sha224, o.sha384 = o.sha.sha384, o.sha512 = o.sha.sha512, o.ripemd160 = o.ripemd.ripemd160;
  }(hash$3)), hash$3;
}
var secp256k1$3, hasRequiredSecp256k1$1;
function requireSecp256k1$1() {
  return hasRequiredSecp256k1$1 || (hasRequiredSecp256k1$1 = 1, secp256k1$3 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1$3;
}
var hasRequiredCurves$1;
function requireCurves$1() {
  return hasRequiredCurves$1 || (hasRequiredCurves$1 = 1, function(e) {
    var o = e, S = requireHash$2(), g = requireCurve$1(), U = requireUtils$1$1(), h = U.assert;
    function q(I) {
      I.type === "short" ? this.curve = new g.short(I) : I.type === "edwards" ? this.curve = new g.edwards(I) : this.curve = new g.mont(I), this.g = this.curve.g, this.n = this.curve.n, this.hash = I.hash, h(this.g.validate(), "Invalid curve"), h(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    o.PresetCurve = q;
    function A(I, B) {
      Object.defineProperty(o, I, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var H = new q(B);
          return Object.defineProperty(o, I, {
            configurable: !0,
            enumerable: !0,
            value: H
          }), H;
        }
      });
    }
    A("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: S.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), A("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: S.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), A("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: S.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), A("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: S.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), A("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: S.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), A("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: S.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), A("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: S.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var P;
    try {
      P = requireSecp256k1$1();
    } catch {
      P = void 0;
    }
    A("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: S.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        P
      ]
    });
  }(curves$1)), curves$1;
}
var hmacDrbg$1, hasRequiredHmacDrbg$1;
function requireHmacDrbg$1() {
  if (hasRequiredHmacDrbg$1)
    return hmacDrbg$1;
  hasRequiredHmacDrbg$1 = 1;
  var e = requireHash$2(), o = requireUtils$2$1(), S = requireMinimalisticAssert$1();
  function g(U) {
    if (!(this instanceof g))
      return new g(U);
    this.hash = U.hash, this.predResist = !!U.predResist, this.outLen = this.hash.outSize, this.minEntropy = U.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var h = o.toArray(U.entropy, U.entropyEnc || "hex"), q = o.toArray(U.nonce, U.nonceEnc || "hex"), A = o.toArray(U.pers, U.persEnc || "hex");
    S(
      h.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(h, q, A);
  }
  return hmacDrbg$1 = g, g.prototype._init = function(U, h, q) {
    var A = U.concat(h).concat(q);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var P = 0; P < this.V.length; P++)
      this.K[P] = 0, this.V[P] = 1;
    this._update(A), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, g.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, g.prototype._update = function(U) {
    var h = this._hmac().update(this.V).update([0]);
    U && (h = h.update(U)), this.K = h.digest(), this.V = this._hmac().update(this.V).digest(), U && (this.K = this._hmac().update(this.V).update([1]).update(U).digest(), this.V = this._hmac().update(this.V).digest());
  }, g.prototype.reseed = function(U, h, q, A) {
    typeof h != "string" && (A = q, q = h, h = null), U = o.toArray(U, h), q = o.toArray(q, A), S(
      U.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(U.concat(q || [])), this._reseed = 1;
  }, g.prototype.generate = function(U, h, q, A) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof h != "string" && (A = q, q = h, h = null), q && (q = o.toArray(q, A || "hex"), this._update(q));
    for (var P = []; P.length < U; )
      this.V = this._hmac().update(this.V).digest(), P = P.concat(this.V);
    var I = P.slice(0, U);
    return this._update(q), this._reseed++, o.encode(I, h);
  }, hmacDrbg$1;
}
var key$1$1, hasRequiredKey$1$1;
function requireKey$1$1() {
  if (hasRequiredKey$1$1)
    return key$1$1;
  hasRequiredKey$1$1 = 1;
  var e = requireBn$2(), o = requireUtils$1$1(), S = o.assert;
  function g(U, h) {
    this.ec = U, this.priv = null, this.pub = null, h.priv && this._importPrivate(h.priv, h.privEnc), h.pub && this._importPublic(h.pub, h.pubEnc);
  }
  return key$1$1 = g, g.fromPublic = function(U, h, q) {
    return h instanceof g ? h : new g(U, {
      pub: h,
      pubEnc: q
    });
  }, g.fromPrivate = function(U, h, q) {
    return h instanceof g ? h : new g(U, {
      priv: h,
      privEnc: q
    });
  }, g.prototype.validate = function() {
    var U = this.getPublic();
    return U.isInfinity() ? { result: !1, reason: "Invalid public key" } : U.validate() ? U.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, g.prototype.getPublic = function(U, h) {
    return typeof U == "string" && (h = U, U = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), h ? this.pub.encode(h, U) : this.pub;
  }, g.prototype.getPrivate = function(U) {
    return U === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, g.prototype._importPrivate = function(U, h) {
    this.priv = new e(U, h || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, g.prototype._importPublic = function(U, h) {
    if (U.x || U.y) {
      this.ec.curve.type === "mont" ? S(U.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && S(U.x && U.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(U.x, U.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(U, h);
  }, g.prototype.derive = function(U) {
    return U.validate() || S(U.validate(), "public point not validated"), U.mul(this.priv).getX();
  }, g.prototype.sign = function(U, h, q) {
    return this.ec.sign(U, this, h, q);
  }, g.prototype.verify = function(U, h) {
    return this.ec.verify(U, h, this);
  }, g.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1$1;
}
var signature$1$1, hasRequiredSignature$1$1;
function requireSignature$1$1() {
  if (hasRequiredSignature$1$1)
    return signature$1$1;
  hasRequiredSignature$1$1 = 1;
  var e = requireBn$2(), o = requireUtils$1$1(), S = o.assert;
  function g(P, I) {
    if (P instanceof g)
      return P;
    this._importDER(P, I) || (S(P.r && P.s, "Signature without r or s"), this.r = new e(P.r, 16), this.s = new e(P.s, 16), P.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = P.recoveryParam);
  }
  signature$1$1 = g;
  function U() {
    this.place = 0;
  }
  function h(P, I) {
    var B = P[I.place++];
    if (!(B & 128))
      return B;
    var H = B & 15;
    if (H === 0 || H > 4)
      return !1;
    for (var V = 0, X = 0, Q = I.place; X < H; X++, Q++)
      V <<= 8, V |= P[Q], V >>>= 0;
    return V <= 127 ? !1 : (I.place = Q, V);
  }
  function q(P) {
    for (var I = 0, B = P.length - 1; !P[I] && !(P[I + 1] & 128) && I < B; )
      I++;
    return I === 0 ? P : P.slice(I);
  }
  g.prototype._importDER = function(P, I) {
    P = o.toArray(P, I);
    var B = new U();
    if (P[B.place++] !== 48)
      return !1;
    var H = h(P, B);
    if (H === !1 || H + B.place !== P.length || P[B.place++] !== 2)
      return !1;
    var V = h(P, B);
    if (V === !1)
      return !1;
    var X = P.slice(B.place, V + B.place);
    if (B.place += V, P[B.place++] !== 2)
      return !1;
    var Q = h(P, B);
    if (Q === !1 || P.length !== Q + B.place)
      return !1;
    var ee = P.slice(B.place, Q + B.place);
    if (X[0] === 0)
      if (X[1] & 128)
        X = X.slice(1);
      else
        return !1;
    if (ee[0] === 0)
      if (ee[1] & 128)
        ee = ee.slice(1);
      else
        return !1;
    return this.r = new e(X), this.s = new e(ee), this.recoveryParam = null, !0;
  };
  function A(P, I) {
    if (I < 128) {
      P.push(I);
      return;
    }
    var B = 1 + (Math.log(I) / Math.LN2 >>> 3);
    for (P.push(B | 128); --B; )
      P.push(I >>> (B << 3) & 255);
    P.push(I);
  }
  return g.prototype.toDER = function(P) {
    var I = this.r.toArray(), B = this.s.toArray();
    for (I[0] & 128 && (I = [0].concat(I)), B[0] & 128 && (B = [0].concat(B)), I = q(I), B = q(B); !B[0] && !(B[1] & 128); )
      B = B.slice(1);
    var H = [2];
    A(H, I.length), H = H.concat(I), H.push(2), A(H, B.length);
    var V = H.concat(B), X = [48];
    return A(X, V.length), X = X.concat(V), o.encode(X, P);
  }, signature$1$1;
}
var ec$1, hasRequiredEc$1;
function requireEc$1() {
  if (hasRequiredEc$1)
    return ec$1;
  hasRequiredEc$1 = 1;
  var e = requireBn$2(), o = requireHmacDrbg$1(), S = requireUtils$1$1(), g = requireCurves$1(), U = requireBrorand$1(), h = S.assert, q = requireKey$1$1(), A = requireSignature$1$1();
  function P(I) {
    if (!(this instanceof P))
      return new P(I);
    typeof I == "string" && (h(
      Object.prototype.hasOwnProperty.call(g, I),
      "Unknown curve " + I
    ), I = g[I]), I instanceof g.PresetCurve && (I = { curve: I }), this.curve = I.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = I.curve.g, this.g.precompute(I.curve.n.bitLength() + 1), this.hash = I.hash || I.curve.hash;
  }
  return ec$1 = P, P.prototype.keyPair = function(I) {
    return new q(this, I);
  }, P.prototype.keyFromPrivate = function(I, B) {
    return q.fromPrivate(this, I, B);
  }, P.prototype.keyFromPublic = function(I, B) {
    return q.fromPublic(this, I, B);
  }, P.prototype.genKeyPair = function(I) {
    I || (I = {});
    for (var B = new o({
      hash: this.hash,
      pers: I.pers,
      persEnc: I.persEnc || "utf8",
      entropy: I.entropy || U(this.hash.hmacStrength),
      entropyEnc: I.entropy && I.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), H = this.n.byteLength(), V = this.n.sub(new e(2)); ; ) {
      var X = new e(B.generate(H));
      if (!(X.cmp(V) > 0))
        return X.iaddn(1), this.keyFromPrivate(X);
    }
  }, P.prototype._truncateToN = function(I, B) {
    var H = I.byteLength() * 8 - this.n.bitLength();
    return H > 0 && (I = I.ushrn(H)), !B && I.cmp(this.n) >= 0 ? I.sub(this.n) : I;
  }, P.prototype.sign = function(I, B, H, V) {
    typeof H == "object" && (V = H, H = null), V || (V = {}), B = this.keyFromPrivate(B, H), I = this._truncateToN(new e(I, 16));
    for (var X = this.n.byteLength(), Q = B.getPrivate().toArray("be", X), ee = I.toArray("be", X), ie = new o({
      hash: this.hash,
      entropy: Q,
      nonce: ee,
      pers: V.pers,
      persEnc: V.persEnc || "utf8"
    }), te = this.n.sub(new e(1)), se = 0; ; se++) {
      var le = V.k ? V.k(se) : new e(ie.generate(this.n.byteLength()));
      if (le = this._truncateToN(le, !0), !(le.cmpn(1) <= 0 || le.cmp(te) >= 0)) {
        var ce = this.g.mul(le);
        if (!ce.isInfinity()) {
          var pe = ce.getX(), me = pe.umod(this.n);
          if (me.cmpn(0) !== 0) {
            var Me = le.invm(this.n).mul(me.mul(B.getPrivate()).iadd(I));
            if (Me = Me.umod(this.n), Me.cmpn(0) !== 0) {
              var Ee = (ce.getY().isOdd() ? 1 : 0) | (pe.cmp(me) !== 0 ? 2 : 0);
              return V.canonical && Me.cmp(this.nh) > 0 && (Me = this.n.sub(Me), Ee ^= 1), new A({ r: me, s: Me, recoveryParam: Ee });
            }
          }
        }
      }
    }
  }, P.prototype.verify = function(I, B, H, V) {
    I = this._truncateToN(new e(I, 16)), H = this.keyFromPublic(H, V), B = new A(B, "hex");
    var X = B.r, Q = B.s;
    if (X.cmpn(1) < 0 || X.cmp(this.n) >= 0 || Q.cmpn(1) < 0 || Q.cmp(this.n) >= 0)
      return !1;
    var ee = Q.invm(this.n), ie = ee.mul(I).umod(this.n), te = ee.mul(X).umod(this.n), se;
    return this.curve._maxwellTrick ? (se = this.g.jmulAdd(ie, H.getPublic(), te), se.isInfinity() ? !1 : se.eqXToP(X)) : (se = this.g.mulAdd(ie, H.getPublic(), te), se.isInfinity() ? !1 : se.getX().umod(this.n).cmp(X) === 0);
  }, P.prototype.recoverPubKey = function(I, B, H, V) {
    h((3 & H) === H, "The recovery param is more than two bits"), B = new A(B, V);
    var X = this.n, Q = new e(I), ee = B.r, ie = B.s, te = H & 1, se = H >> 1;
    if (ee.cmp(this.curve.p.umod(this.curve.n)) >= 0 && se)
      throw new Error("Unable to find sencond key candinate");
    se ? ee = this.curve.pointFromX(ee.add(this.curve.n), te) : ee = this.curve.pointFromX(ee, te);
    var le = B.r.invm(X), ce = X.sub(Q).mul(le).umod(X), pe = ie.mul(le).umod(X);
    return this.g.mulAdd(ce, ee, pe);
  }, P.prototype.getKeyRecoveryParam = function(I, B, H, V) {
    if (B = new A(B, V), B.recoveryParam !== null)
      return B.recoveryParam;
    for (var X = 0; X < 4; X++) {
      var Q;
      try {
        Q = this.recoverPubKey(I, B, X);
      } catch {
        continue;
      }
      if (Q.eq(H))
        return X;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec$1;
}
var key$2, hasRequiredKey$2;
function requireKey$2() {
  if (hasRequiredKey$2)
    return key$2;
  hasRequiredKey$2 = 1;
  var e = requireUtils$1$1(), o = e.assert, S = e.parseBytes, g = e.cachedProperty;
  function U(h, q) {
    this.eddsa = h, this._secret = S(q.secret), h.isPoint(q.pub) ? this._pub = q.pub : this._pubBytes = S(q.pub);
  }
  return U.fromPublic = function(h, q) {
    return q instanceof U ? q : new U(h, { pub: q });
  }, U.fromSecret = function(h, q) {
    return q instanceof U ? q : new U(h, { secret: q });
  }, U.prototype.secret = function() {
    return this._secret;
  }, g(U, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), g(U, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), g(U, "privBytes", function() {
    var h = this.eddsa, q = this.hash(), A = h.encodingLength - 1, P = q.slice(0, h.encodingLength);
    return P[0] &= 248, P[A] &= 127, P[A] |= 64, P;
  }), g(U, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), g(U, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), g(U, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), U.prototype.sign = function(h) {
    return o(this._secret, "KeyPair can only verify"), this.eddsa.sign(h, this);
  }, U.prototype.verify = function(h, q) {
    return this.eddsa.verify(h, q, this);
  }, U.prototype.getSecret = function(h) {
    return o(this._secret, "KeyPair is public only"), e.encode(this.secret(), h);
  }, U.prototype.getPublic = function(h) {
    return e.encode(this.pubBytes(), h);
  }, key$2 = U, key$2;
}
var signature$3, hasRequiredSignature$2;
function requireSignature$2() {
  if (hasRequiredSignature$2)
    return signature$3;
  hasRequiredSignature$2 = 1;
  var e = requireBn$2(), o = requireUtils$1$1(), S = o.assert, g = o.cachedProperty, U = o.parseBytes;
  function h(q, A) {
    this.eddsa = q, typeof A != "object" && (A = U(A)), Array.isArray(A) && (A = {
      R: A.slice(0, q.encodingLength),
      S: A.slice(q.encodingLength)
    }), S(A.R && A.S, "Signature without R or S"), q.isPoint(A.R) && (this._R = A.R), A.S instanceof e && (this._S = A.S), this._Rencoded = Array.isArray(A.R) ? A.R : A.Rencoded, this._Sencoded = Array.isArray(A.S) ? A.S : A.Sencoded;
  }
  return g(h, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), g(h, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), g(h, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), g(h, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), h.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, h.prototype.toHex = function() {
    return o.encode(this.toBytes(), "hex").toUpperCase();
  }, signature$3 = h, signature$3;
}
var eddsa$1, hasRequiredEddsa$1;
function requireEddsa$1() {
  if (hasRequiredEddsa$1)
    return eddsa$1;
  hasRequiredEddsa$1 = 1;
  var e = requireHash$2(), o = requireCurves$1(), S = requireUtils$1$1(), g = S.assert, U = S.parseBytes, h = requireKey$2(), q = requireSignature$2();
  function A(P) {
    if (g(P === "ed25519", "only tested with ed25519 so far"), !(this instanceof A))
      return new A(P);
    P = o[P].curve, this.curve = P, this.g = P.g, this.g.precompute(P.n.bitLength() + 1), this.pointClass = P.point().constructor, this.encodingLength = Math.ceil(P.n.bitLength() / 8), this.hash = e.sha512;
  }
  return eddsa$1 = A, A.prototype.sign = function(P, I) {
    P = U(P);
    var B = this.keyFromSecret(I), H = this.hashInt(B.messagePrefix(), P), V = this.g.mul(H), X = this.encodePoint(V), Q = this.hashInt(X, B.pubBytes(), P).mul(B.priv()), ee = H.add(Q).umod(this.curve.n);
    return this.makeSignature({ R: V, S: ee, Rencoded: X });
  }, A.prototype.verify = function(P, I, B) {
    P = U(P), I = this.makeSignature(I);
    var H = this.keyFromPublic(B), V = this.hashInt(I.Rencoded(), H.pubBytes(), P), X = this.g.mul(I.S()), Q = I.R().add(H.pub().mul(V));
    return Q.eq(X);
  }, A.prototype.hashInt = function() {
    for (var P = this.hash(), I = 0; I < arguments.length; I++)
      P.update(arguments[I]);
    return S.intFromLE(P.digest()).umod(this.curve.n);
  }, A.prototype.keyFromPublic = function(P) {
    return h.fromPublic(this, P);
  }, A.prototype.keyFromSecret = function(P) {
    return h.fromSecret(this, P);
  }, A.prototype.makeSignature = function(P) {
    return P instanceof q ? P : new q(this, P);
  }, A.prototype.encodePoint = function(P) {
    var I = P.getY().toArray("le", this.encodingLength);
    return I[this.encodingLength - 1] |= P.getX().isOdd() ? 128 : 0, I;
  }, A.prototype.decodePoint = function(P) {
    P = S.parseBytes(P);
    var I = P.length - 1, B = P.slice(0, I).concat(P[I] & -129), H = (P[I] & 128) !== 0, V = S.intFromLE(B);
    return this.curve.pointFromY(V, H);
  }, A.prototype.encodeInt = function(P) {
    return P.toArray("le", this.encodingLength);
  }, A.prototype.decodeInt = function(P) {
    return S.intFromLE(P);
  }, A.prototype.isPoint = function(P) {
    return P instanceof this.pointClass;
  }, eddsa$1;
}
var hasRequiredElliptic$1;
function requireElliptic$1() {
  return hasRequiredElliptic$1 || (hasRequiredElliptic$1 = 1, function(e) {
    var o = e;
    o.version = require$$0$1.version, o.utils = requireUtils$1$1(), o.rand = requireBrorand$1(), o.curve = requireCurve$1(), o.curves = requireCurves$1(), o.ec = requireEc$1(), o.eddsa = requireEddsa$1();
  }(elliptic$1)), elliptic$1;
}
var bn$3 = { exports: {} }, hasRequiredBn$3;
function requireBn$3() {
  return hasRequiredBn$3 || (hasRequiredBn$3 = 1, function(e) {
    (function(o, S) {
      function g(M, $) {
        if (!M)
          throw new Error($ || "Assertion failed");
      }
      function U(M, $) {
        M.super_ = $;
        var O = function() {
        };
        O.prototype = $.prototype, M.prototype = new O(), M.prototype.constructor = M;
      }
      function h(M, $, O) {
        if (h.isBN(M))
          return M;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && (($ === "le" || $ === "be") && (O = $, $ = 10), this._init(M || 0, $ || 10, O || "be"));
      }
      typeof o == "object" ? o.exports = h : S.BN = h, h.BN = h, h.wordSize = 26;
      var q;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? q = window.Buffer : q = requireBuffer$1().Buffer;
      } catch {
      }
      h.isBN = function(M) {
        return M instanceof h ? !0 : M !== null && typeof M == "object" && M.constructor.wordSize === h.wordSize && Array.isArray(M.words);
      }, h.max = function(M, $) {
        return M.cmp($) > 0 ? M : $;
      }, h.min = function(M, $) {
        return M.cmp($) < 0 ? M : $;
      }, h.prototype._init = function(M, $, O) {
        if (typeof M == "number")
          return this._initNumber(M, $, O);
        if (typeof M == "object")
          return this._initArray(M, $, O);
        $ === "hex" && ($ = 16), g($ === ($ | 0) && $ >= 2 && $ <= 36), M = M.toString().replace(/\s+/g, "");
        var J = 0;
        M[0] === "-" && (J++, this.negative = 1), J < M.length && ($ === 16 ? this._parseHex(M, J, O) : (this._parseBase(M, $, J), O === "le" && this._initArray(this.toArray(), $, O)));
      }, h.prototype._initNumber = function(M, $, O) {
        M < 0 && (this.negative = 1, M = -M), M < 67108864 ? (this.words = [M & 67108863], this.length = 1) : M < 4503599627370496 ? (this.words = [
          M & 67108863,
          M / 67108864 & 67108863
        ], this.length = 2) : (g(M < 9007199254740992), this.words = [
          M & 67108863,
          M / 67108864 & 67108863,
          1
        ], this.length = 3), O === "le" && this._initArray(this.toArray(), $, O);
      }, h.prototype._initArray = function(M, $, O) {
        if (g(typeof M.length == "number"), M.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(M.length / 3), this.words = new Array(this.length);
        for (var J = 0; J < this.length; J++)
          this.words[J] = 0;
        var Z, K, z = 0;
        if (O === "be")
          for (J = M.length - 1, Z = 0; J >= 0; J -= 3)
            K = M[J] | M[J - 1] << 8 | M[J - 2] << 16, this.words[Z] |= K << z & 67108863, this.words[Z + 1] = K >>> 26 - z & 67108863, z += 24, z >= 26 && (z -= 26, Z++);
        else if (O === "le")
          for (J = 0, Z = 0; J < M.length; J += 3)
            K = M[J] | M[J + 1] << 8 | M[J + 2] << 16, this.words[Z] |= K << z & 67108863, this.words[Z + 1] = K >>> 26 - z & 67108863, z += 24, z >= 26 && (z -= 26, Z++);
        return this._strip();
      };
      function A(M, $) {
        var O = M.charCodeAt($);
        if (O >= 48 && O <= 57)
          return O - 48;
        if (O >= 65 && O <= 70)
          return O - 55;
        if (O >= 97 && O <= 102)
          return O - 87;
        g(!1, "Invalid character in " + M);
      }
      function P(M, $, O) {
        var J = A(M, O);
        return O - 1 >= $ && (J |= A(M, O - 1) << 4), J;
      }
      h.prototype._parseHex = function(M, $, O) {
        this.length = Math.ceil((M.length - $) / 6), this.words = new Array(this.length);
        for (var J = 0; J < this.length; J++)
          this.words[J] = 0;
        var Z = 0, K = 0, z;
        if (O === "be")
          for (J = M.length - 1; J >= $; J -= 2)
            z = P(M, $, J) << Z, this.words[K] |= z & 67108863, Z >= 18 ? (Z -= 18, K += 1, this.words[K] |= z >>> 26) : Z += 8;
        else {
          var G = M.length - $;
          for (J = G % 2 === 0 ? $ + 1 : $; J < M.length; J += 2)
            z = P(M, $, J) << Z, this.words[K] |= z & 67108863, Z >= 18 ? (Z -= 18, K += 1, this.words[K] |= z >>> 26) : Z += 8;
        }
        this._strip();
      };
      function I(M, $, O, J) {
        for (var Z = 0, K = 0, z = Math.min(M.length, O), G = $; G < z; G++) {
          var D = M.charCodeAt(G) - 48;
          Z *= J, D >= 49 ? K = D - 49 + 10 : D >= 17 ? K = D - 17 + 10 : K = D, g(D >= 0 && K < J, "Invalid character"), Z += K;
        }
        return Z;
      }
      h.prototype._parseBase = function(M, $, O) {
        this.words = [0], this.length = 1;
        for (var J = 0, Z = 1; Z <= 67108863; Z *= $)
          J++;
        J--, Z = Z / $ | 0;
        for (var K = M.length - O, z = K % J, G = Math.min(K, K - z) + O, D = 0, F = O; F < G; F += J)
          D = I(M, F, F + J, $), this.imuln(Z), this.words[0] + D < 67108864 ? this.words[0] += D : this._iaddn(D);
        if (z !== 0) {
          var ae = 1;
          for (D = I(M, F, M.length, $), F = 0; F < z; F++)
            ae *= $;
          this.imuln(ae), this.words[0] + D < 67108864 ? this.words[0] += D : this._iaddn(D);
        }
        this._strip();
      }, h.prototype.copy = function(M) {
        M.words = new Array(this.length);
        for (var $ = 0; $ < this.length; $++)
          M.words[$] = this.words[$];
        M.length = this.length, M.negative = this.negative, M.red = this.red;
      };
      function B(M, $) {
        M.words = $.words, M.length = $.length, M.negative = $.negative, M.red = $.red;
      }
      if (h.prototype._move = function(M) {
        B(M, this);
      }, h.prototype.clone = function() {
        var M = new h(null);
        return this.copy(M), M;
      }, h.prototype._expand = function(M) {
        for (; this.length < M; )
          this.words[this.length++] = 0;
        return this;
      }, h.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, h.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          h.prototype[Symbol.for("nodejs.util.inspect.custom")] = H;
        } catch {
          h.prototype.inspect = H;
        }
      else
        h.prototype.inspect = H;
      function H() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var V = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], X = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Q = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      h.prototype.toString = function(M, $) {
        M = M || 10, $ = $ | 0 || 1;
        var O;
        if (M === 16 || M === "hex") {
          O = "";
          for (var J = 0, Z = 0, K = 0; K < this.length; K++) {
            var z = this.words[K], G = ((z << J | Z) & 16777215).toString(16);
            Z = z >>> 24 - J & 16777215, J += 2, J >= 26 && (J -= 26, K--), Z !== 0 || K !== this.length - 1 ? O = V[6 - G.length] + G + O : O = G + O;
          }
          for (Z !== 0 && (O = Z.toString(16) + O); O.length % $ !== 0; )
            O = "0" + O;
          return this.negative !== 0 && (O = "-" + O), O;
        }
        if (M === (M | 0) && M >= 2 && M <= 36) {
          var D = X[M], F = Q[M];
          O = "";
          var ae = this.clone();
          for (ae.negative = 0; !ae.isZero(); ) {
            var ge = ae.modrn(F).toString(M);
            ae = ae.idivn(F), ae.isZero() ? O = ge + O : O = V[D - ge.length] + ge + O;
          }
          for (this.isZero() && (O = "0" + O); O.length % $ !== 0; )
            O = "0" + O;
          return this.negative !== 0 && (O = "-" + O), O;
        }
        g(!1, "Base should be between 2 and 36");
      }, h.prototype.toNumber = function() {
        var M = this.words[0];
        return this.length === 2 ? M += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? M += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && g(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -M : M;
      }, h.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, q && (h.prototype.toBuffer = function(M, $) {
        return this.toArrayLike(q, M, $);
      }), h.prototype.toArray = function(M, $) {
        return this.toArrayLike(Array, M, $);
      };
      var ee = function(M, $) {
        return M.allocUnsafe ? M.allocUnsafe($) : new M($);
      };
      h.prototype.toArrayLike = function(M, $, O) {
        this._strip();
        var J = this.byteLength(), Z = O || Math.max(1, J);
        g(J <= Z, "byte array longer than desired length"), g(Z > 0, "Requested array length <= 0");
        var K = ee(M, Z), z = $ === "le" ? "LE" : "BE";
        return this["_toArrayLike" + z](K, J), K;
      }, h.prototype._toArrayLikeLE = function(M, $) {
        for (var O = 0, J = 0, Z = 0, K = 0; Z < this.length; Z++) {
          var z = this.words[Z] << K | J;
          M[O++] = z & 255, O < M.length && (M[O++] = z >> 8 & 255), O < M.length && (M[O++] = z >> 16 & 255), K === 6 ? (O < M.length && (M[O++] = z >> 24 & 255), J = 0, K = 0) : (J = z >>> 24, K += 2);
        }
        if (O < M.length)
          for (M[O++] = J; O < M.length; )
            M[O++] = 0;
      }, h.prototype._toArrayLikeBE = function(M, $) {
        for (var O = M.length - 1, J = 0, Z = 0, K = 0; Z < this.length; Z++) {
          var z = this.words[Z] << K | J;
          M[O--] = z & 255, O >= 0 && (M[O--] = z >> 8 & 255), O >= 0 && (M[O--] = z >> 16 & 255), K === 6 ? (O >= 0 && (M[O--] = z >> 24 & 255), J = 0, K = 0) : (J = z >>> 24, K += 2);
        }
        if (O >= 0)
          for (M[O--] = J; O >= 0; )
            M[O--] = 0;
      }, Math.clz32 ? h.prototype._countBits = function(M) {
        return 32 - Math.clz32(M);
      } : h.prototype._countBits = function(M) {
        var $ = M, O = 0;
        return $ >= 4096 && (O += 13, $ >>>= 13), $ >= 64 && (O += 7, $ >>>= 7), $ >= 8 && (O += 4, $ >>>= 4), $ >= 2 && (O += 2, $ >>>= 2), O + $;
      }, h.prototype._zeroBits = function(M) {
        if (M === 0)
          return 26;
        var $ = M, O = 0;
        return $ & 8191 || (O += 13, $ >>>= 13), $ & 127 || (O += 7, $ >>>= 7), $ & 15 || (O += 4, $ >>>= 4), $ & 3 || (O += 2, $ >>>= 2), $ & 1 || O++, O;
      }, h.prototype.bitLength = function() {
        var M = this.words[this.length - 1], $ = this._countBits(M);
        return (this.length - 1) * 26 + $;
      };
      function ie(M) {
        for (var $ = new Array(M.bitLength()), O = 0; O < $.length; O++) {
          var J = O / 26 | 0, Z = O % 26;
          $[O] = M.words[J] >>> Z & 1;
        }
        return $;
      }
      h.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var M = 0, $ = 0; $ < this.length; $++) {
          var O = this._zeroBits(this.words[$]);
          if (M += O, O !== 26)
            break;
        }
        return M;
      }, h.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, h.prototype.toTwos = function(M) {
        return this.negative !== 0 ? this.abs().inotn(M).iaddn(1) : this.clone();
      }, h.prototype.fromTwos = function(M) {
        return this.testn(M - 1) ? this.notn(M).iaddn(1).ineg() : this.clone();
      }, h.prototype.isNeg = function() {
        return this.negative !== 0;
      }, h.prototype.neg = function() {
        return this.clone().ineg();
      }, h.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, h.prototype.iuor = function(M) {
        for (; this.length < M.length; )
          this.words[this.length++] = 0;
        for (var $ = 0; $ < M.length; $++)
          this.words[$] = this.words[$] | M.words[$];
        return this._strip();
      }, h.prototype.ior = function(M) {
        return g((this.negative | M.negative) === 0), this.iuor(M);
      }, h.prototype.or = function(M) {
        return this.length > M.length ? this.clone().ior(M) : M.clone().ior(this);
      }, h.prototype.uor = function(M) {
        return this.length > M.length ? this.clone().iuor(M) : M.clone().iuor(this);
      }, h.prototype.iuand = function(M) {
        var $;
        this.length > M.length ? $ = M : $ = this;
        for (var O = 0; O < $.length; O++)
          this.words[O] = this.words[O] & M.words[O];
        return this.length = $.length, this._strip();
      }, h.prototype.iand = function(M) {
        return g((this.negative | M.negative) === 0), this.iuand(M);
      }, h.prototype.and = function(M) {
        return this.length > M.length ? this.clone().iand(M) : M.clone().iand(this);
      }, h.prototype.uand = function(M) {
        return this.length > M.length ? this.clone().iuand(M) : M.clone().iuand(this);
      }, h.prototype.iuxor = function(M) {
        var $, O;
        this.length > M.length ? ($ = this, O = M) : ($ = M, O = this);
        for (var J = 0; J < O.length; J++)
          this.words[J] = $.words[J] ^ O.words[J];
        if (this !== $)
          for (; J < $.length; J++)
            this.words[J] = $.words[J];
        return this.length = $.length, this._strip();
      }, h.prototype.ixor = function(M) {
        return g((this.negative | M.negative) === 0), this.iuxor(M);
      }, h.prototype.xor = function(M) {
        return this.length > M.length ? this.clone().ixor(M) : M.clone().ixor(this);
      }, h.prototype.uxor = function(M) {
        return this.length > M.length ? this.clone().iuxor(M) : M.clone().iuxor(this);
      }, h.prototype.inotn = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = Math.ceil(M / 26) | 0, O = M % 26;
        this._expand($), O > 0 && $--;
        for (var J = 0; J < $; J++)
          this.words[J] = ~this.words[J] & 67108863;
        return O > 0 && (this.words[J] = ~this.words[J] & 67108863 >> 26 - O), this._strip();
      }, h.prototype.notn = function(M) {
        return this.clone().inotn(M);
      }, h.prototype.setn = function(M, $) {
        g(typeof M == "number" && M >= 0);
        var O = M / 26 | 0, J = M % 26;
        return this._expand(O + 1), $ ? this.words[O] = this.words[O] | 1 << J : this.words[O] = this.words[O] & ~(1 << J), this._strip();
      }, h.prototype.iadd = function(M) {
        var $;
        if (this.negative !== 0 && M.negative === 0)
          return this.negative = 0, $ = this.isub(M), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && M.negative !== 0)
          return M.negative = 0, $ = this.isub(M), M.negative = 1, $._normSign();
        var O, J;
        this.length > M.length ? (O = this, J = M) : (O = M, J = this);
        for (var Z = 0, K = 0; K < J.length; K++)
          $ = (O.words[K] | 0) + (J.words[K] | 0) + Z, this.words[K] = $ & 67108863, Z = $ >>> 26;
        for (; Z !== 0 && K < O.length; K++)
          $ = (O.words[K] | 0) + Z, this.words[K] = $ & 67108863, Z = $ >>> 26;
        if (this.length = O.length, Z !== 0)
          this.words[this.length] = Z, this.length++;
        else if (O !== this)
          for (; K < O.length; K++)
            this.words[K] = O.words[K];
        return this;
      }, h.prototype.add = function(M) {
        var $;
        return M.negative !== 0 && this.negative === 0 ? (M.negative = 0, $ = this.sub(M), M.negative ^= 1, $) : M.negative === 0 && this.negative !== 0 ? (this.negative = 0, $ = M.sub(this), this.negative = 1, $) : this.length > M.length ? this.clone().iadd(M) : M.clone().iadd(this);
      }, h.prototype.isub = function(M) {
        if (M.negative !== 0) {
          M.negative = 0;
          var $ = this.iadd(M);
          return M.negative = 1, $._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(M), this.negative = 1, this._normSign();
        var O = this.cmp(M);
        if (O === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var J, Z;
        O > 0 ? (J = this, Z = M) : (J = M, Z = this);
        for (var K = 0, z = 0; z < Z.length; z++)
          $ = (J.words[z] | 0) - (Z.words[z] | 0) + K, K = $ >> 26, this.words[z] = $ & 67108863;
        for (; K !== 0 && z < J.length; z++)
          $ = (J.words[z] | 0) + K, K = $ >> 26, this.words[z] = $ & 67108863;
        if (K === 0 && z < J.length && J !== this)
          for (; z < J.length; z++)
            this.words[z] = J.words[z];
        return this.length = Math.max(this.length, z), J !== this && (this.negative = 1), this._strip();
      }, h.prototype.sub = function(M) {
        return this.clone().isub(M);
      };
      function te(M, $, O) {
        O.negative = $.negative ^ M.negative;
        var J = M.length + $.length | 0;
        O.length = J, J = J - 1 | 0;
        var Z = M.words[0] | 0, K = $.words[0] | 0, z = Z * K, G = z & 67108863, D = z / 67108864 | 0;
        O.words[0] = G;
        for (var F = 1; F < J; F++) {
          for (var ae = D >>> 26, ge = D & 67108863, xe = Math.min(F, $.length - 1), ye = Math.max(0, F - M.length + 1); ye <= xe; ye++) {
            var oe = F - ye | 0;
            Z = M.words[oe] | 0, K = $.words[ye] | 0, z = Z * K + ge, ae += z / 67108864 | 0, ge = z & 67108863;
          }
          O.words[F] = ge | 0, D = ae | 0;
        }
        return D !== 0 ? O.words[F] = D | 0 : O.length--, O._strip();
      }
      var se = function(M, $, O) {
        var J = M.words, Z = $.words, K = O.words, z = 0, G, D, F, ae = J[0] | 0, ge = ae & 8191, xe = ae >>> 13, ye = J[1] | 0, oe = ye & 8191, fe = ye >>> 13, $e = J[2] | 0, Be = $e & 8191, be = $e >>> 13, ve = J[3] | 0, qe = ve & 8191, De = ve >>> 13, Ye = J[4] | 0, he = Ye & 8191, ue = Ye >>> 13, de = J[5] | 0, _e = de & 8191, Pe = de >>> 13, He = J[6] | 0, Ve = He & 8191, nt = He >>> 13, Ie = J[7] | 0, Fe = Ie & 8191, je = Ie >>> 13, Ke = J[8] | 0, ot = Ke & 8191, ut = Ke >>> 13, pt = J[9] | 0, ke = pt & 8191, Xe = pt >>> 13, at = Z[0] | 0, ht = at & 8191, We = at >>> 13, tt = Z[1] | 0, Te = tt & 8191, rt = tt >>> 13, mt = Z[2] | 0, Se = mt & 8191, et = mt >>> 13, Ze = Z[3] | 0, Le = Ze & 8191, ze = Ze >>> 13, Qe = Z[4] | 0, _t = Qe & 8191, ft = Qe >>> 13, dt = Z[5] | 0, Mt = dt & 8191, St = dt >>> 13, $t = Z[6] | 0, At = $t & 8191, Ae = $t >>> 13, Ce = Z[7] | 0, Oe = Ce & 8191, we = Ce >>> 13, Ue = Z[8] | 0, Je = Ue & 8191, Ge = Ue >>> 13, st = Z[9] | 0, ct = st & 8191, bt = st >>> 13;
        O.negative = M.negative ^ $.negative, O.length = 19, G = Math.imul(ge, ht), D = Math.imul(ge, We), D = D + Math.imul(xe, ht) | 0, F = Math.imul(xe, We);
        var wt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, G = Math.imul(oe, ht), D = Math.imul(oe, We), D = D + Math.imul(fe, ht) | 0, F = Math.imul(fe, We), G = G + Math.imul(ge, Te) | 0, D = D + Math.imul(ge, rt) | 0, D = D + Math.imul(xe, Te) | 0, F = F + Math.imul(xe, rt) | 0;
        var zt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, G = Math.imul(Be, ht), D = Math.imul(Be, We), D = D + Math.imul(be, ht) | 0, F = Math.imul(be, We), G = G + Math.imul(oe, Te) | 0, D = D + Math.imul(oe, rt) | 0, D = D + Math.imul(fe, Te) | 0, F = F + Math.imul(fe, rt) | 0, G = G + Math.imul(ge, Se) | 0, D = D + Math.imul(ge, et) | 0, D = D + Math.imul(xe, Se) | 0, F = F + Math.imul(xe, et) | 0;
        var Tt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, G = Math.imul(qe, ht), D = Math.imul(qe, We), D = D + Math.imul(De, ht) | 0, F = Math.imul(De, We), G = G + Math.imul(Be, Te) | 0, D = D + Math.imul(Be, rt) | 0, D = D + Math.imul(be, Te) | 0, F = F + Math.imul(be, rt) | 0, G = G + Math.imul(oe, Se) | 0, D = D + Math.imul(oe, et) | 0, D = D + Math.imul(fe, Se) | 0, F = F + Math.imul(fe, et) | 0, G = G + Math.imul(ge, Le) | 0, D = D + Math.imul(ge, ze) | 0, D = D + Math.imul(xe, Le) | 0, F = F + Math.imul(xe, ze) | 0;
        var Lt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, G = Math.imul(he, ht), D = Math.imul(he, We), D = D + Math.imul(ue, ht) | 0, F = Math.imul(ue, We), G = G + Math.imul(qe, Te) | 0, D = D + Math.imul(qe, rt) | 0, D = D + Math.imul(De, Te) | 0, F = F + Math.imul(De, rt) | 0, G = G + Math.imul(Be, Se) | 0, D = D + Math.imul(Be, et) | 0, D = D + Math.imul(be, Se) | 0, F = F + Math.imul(be, et) | 0, G = G + Math.imul(oe, Le) | 0, D = D + Math.imul(oe, ze) | 0, D = D + Math.imul(fe, Le) | 0, F = F + Math.imul(fe, ze) | 0, G = G + Math.imul(ge, _t) | 0, D = D + Math.imul(ge, ft) | 0, D = D + Math.imul(xe, _t) | 0, F = F + Math.imul(xe, ft) | 0;
        var jt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, G = Math.imul(_e, ht), D = Math.imul(_e, We), D = D + Math.imul(Pe, ht) | 0, F = Math.imul(Pe, We), G = G + Math.imul(he, Te) | 0, D = D + Math.imul(he, rt) | 0, D = D + Math.imul(ue, Te) | 0, F = F + Math.imul(ue, rt) | 0, G = G + Math.imul(qe, Se) | 0, D = D + Math.imul(qe, et) | 0, D = D + Math.imul(De, Se) | 0, F = F + Math.imul(De, et) | 0, G = G + Math.imul(Be, Le) | 0, D = D + Math.imul(Be, ze) | 0, D = D + Math.imul(be, Le) | 0, F = F + Math.imul(be, ze) | 0, G = G + Math.imul(oe, _t) | 0, D = D + Math.imul(oe, ft) | 0, D = D + Math.imul(fe, _t) | 0, F = F + Math.imul(fe, ft) | 0, G = G + Math.imul(ge, Mt) | 0, D = D + Math.imul(ge, St) | 0, D = D + Math.imul(xe, Mt) | 0, F = F + Math.imul(xe, St) | 0;
        var Ht = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, G = Math.imul(Ve, ht), D = Math.imul(Ve, We), D = D + Math.imul(nt, ht) | 0, F = Math.imul(nt, We), G = G + Math.imul(_e, Te) | 0, D = D + Math.imul(_e, rt) | 0, D = D + Math.imul(Pe, Te) | 0, F = F + Math.imul(Pe, rt) | 0, G = G + Math.imul(he, Se) | 0, D = D + Math.imul(he, et) | 0, D = D + Math.imul(ue, Se) | 0, F = F + Math.imul(ue, et) | 0, G = G + Math.imul(qe, Le) | 0, D = D + Math.imul(qe, ze) | 0, D = D + Math.imul(De, Le) | 0, F = F + Math.imul(De, ze) | 0, G = G + Math.imul(Be, _t) | 0, D = D + Math.imul(Be, ft) | 0, D = D + Math.imul(be, _t) | 0, F = F + Math.imul(be, ft) | 0, G = G + Math.imul(oe, Mt) | 0, D = D + Math.imul(oe, St) | 0, D = D + Math.imul(fe, Mt) | 0, F = F + Math.imul(fe, St) | 0, G = G + Math.imul(ge, At) | 0, D = D + Math.imul(ge, Ae) | 0, D = D + Math.imul(xe, At) | 0, F = F + Math.imul(xe, Ae) | 0;
        var Ft = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, G = Math.imul(Fe, ht), D = Math.imul(Fe, We), D = D + Math.imul(je, ht) | 0, F = Math.imul(je, We), G = G + Math.imul(Ve, Te) | 0, D = D + Math.imul(Ve, rt) | 0, D = D + Math.imul(nt, Te) | 0, F = F + Math.imul(nt, rt) | 0, G = G + Math.imul(_e, Se) | 0, D = D + Math.imul(_e, et) | 0, D = D + Math.imul(Pe, Se) | 0, F = F + Math.imul(Pe, et) | 0, G = G + Math.imul(he, Le) | 0, D = D + Math.imul(he, ze) | 0, D = D + Math.imul(ue, Le) | 0, F = F + Math.imul(ue, ze) | 0, G = G + Math.imul(qe, _t) | 0, D = D + Math.imul(qe, ft) | 0, D = D + Math.imul(De, _t) | 0, F = F + Math.imul(De, ft) | 0, G = G + Math.imul(Be, Mt) | 0, D = D + Math.imul(Be, St) | 0, D = D + Math.imul(be, Mt) | 0, F = F + Math.imul(be, St) | 0, G = G + Math.imul(oe, At) | 0, D = D + Math.imul(oe, Ae) | 0, D = D + Math.imul(fe, At) | 0, F = F + Math.imul(fe, Ae) | 0, G = G + Math.imul(ge, Oe) | 0, D = D + Math.imul(ge, we) | 0, D = D + Math.imul(xe, Oe) | 0, F = F + Math.imul(xe, we) | 0;
        var Nt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, G = Math.imul(ot, ht), D = Math.imul(ot, We), D = D + Math.imul(ut, ht) | 0, F = Math.imul(ut, We), G = G + Math.imul(Fe, Te) | 0, D = D + Math.imul(Fe, rt) | 0, D = D + Math.imul(je, Te) | 0, F = F + Math.imul(je, rt) | 0, G = G + Math.imul(Ve, Se) | 0, D = D + Math.imul(Ve, et) | 0, D = D + Math.imul(nt, Se) | 0, F = F + Math.imul(nt, et) | 0, G = G + Math.imul(_e, Le) | 0, D = D + Math.imul(_e, ze) | 0, D = D + Math.imul(Pe, Le) | 0, F = F + Math.imul(Pe, ze) | 0, G = G + Math.imul(he, _t) | 0, D = D + Math.imul(he, ft) | 0, D = D + Math.imul(ue, _t) | 0, F = F + Math.imul(ue, ft) | 0, G = G + Math.imul(qe, Mt) | 0, D = D + Math.imul(qe, St) | 0, D = D + Math.imul(De, Mt) | 0, F = F + Math.imul(De, St) | 0, G = G + Math.imul(Be, At) | 0, D = D + Math.imul(Be, Ae) | 0, D = D + Math.imul(be, At) | 0, F = F + Math.imul(be, Ae) | 0, G = G + Math.imul(oe, Oe) | 0, D = D + Math.imul(oe, we) | 0, D = D + Math.imul(fe, Oe) | 0, F = F + Math.imul(fe, we) | 0, G = G + Math.imul(ge, Je) | 0, D = D + Math.imul(ge, Ge) | 0, D = D + Math.imul(xe, Je) | 0, F = F + Math.imul(xe, Ge) | 0;
        var Dt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, G = Math.imul(ke, ht), D = Math.imul(ke, We), D = D + Math.imul(Xe, ht) | 0, F = Math.imul(Xe, We), G = G + Math.imul(ot, Te) | 0, D = D + Math.imul(ot, rt) | 0, D = D + Math.imul(ut, Te) | 0, F = F + Math.imul(ut, rt) | 0, G = G + Math.imul(Fe, Se) | 0, D = D + Math.imul(Fe, et) | 0, D = D + Math.imul(je, Se) | 0, F = F + Math.imul(je, et) | 0, G = G + Math.imul(Ve, Le) | 0, D = D + Math.imul(Ve, ze) | 0, D = D + Math.imul(nt, Le) | 0, F = F + Math.imul(nt, ze) | 0, G = G + Math.imul(_e, _t) | 0, D = D + Math.imul(_e, ft) | 0, D = D + Math.imul(Pe, _t) | 0, F = F + Math.imul(Pe, ft) | 0, G = G + Math.imul(he, Mt) | 0, D = D + Math.imul(he, St) | 0, D = D + Math.imul(ue, Mt) | 0, F = F + Math.imul(ue, St) | 0, G = G + Math.imul(qe, At) | 0, D = D + Math.imul(qe, Ae) | 0, D = D + Math.imul(De, At) | 0, F = F + Math.imul(De, Ae) | 0, G = G + Math.imul(Be, Oe) | 0, D = D + Math.imul(Be, we) | 0, D = D + Math.imul(be, Oe) | 0, F = F + Math.imul(be, we) | 0, G = G + Math.imul(oe, Je) | 0, D = D + Math.imul(oe, Ge) | 0, D = D + Math.imul(fe, Je) | 0, F = F + Math.imul(fe, Ge) | 0, G = G + Math.imul(ge, ct) | 0, D = D + Math.imul(ge, bt) | 0, D = D + Math.imul(xe, ct) | 0, F = F + Math.imul(xe, bt) | 0;
        var Ut = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, G = Math.imul(ke, Te), D = Math.imul(ke, rt), D = D + Math.imul(Xe, Te) | 0, F = Math.imul(Xe, rt), G = G + Math.imul(ot, Se) | 0, D = D + Math.imul(ot, et) | 0, D = D + Math.imul(ut, Se) | 0, F = F + Math.imul(ut, et) | 0, G = G + Math.imul(Fe, Le) | 0, D = D + Math.imul(Fe, ze) | 0, D = D + Math.imul(je, Le) | 0, F = F + Math.imul(je, ze) | 0, G = G + Math.imul(Ve, _t) | 0, D = D + Math.imul(Ve, ft) | 0, D = D + Math.imul(nt, _t) | 0, F = F + Math.imul(nt, ft) | 0, G = G + Math.imul(_e, Mt) | 0, D = D + Math.imul(_e, St) | 0, D = D + Math.imul(Pe, Mt) | 0, F = F + Math.imul(Pe, St) | 0, G = G + Math.imul(he, At) | 0, D = D + Math.imul(he, Ae) | 0, D = D + Math.imul(ue, At) | 0, F = F + Math.imul(ue, Ae) | 0, G = G + Math.imul(qe, Oe) | 0, D = D + Math.imul(qe, we) | 0, D = D + Math.imul(De, Oe) | 0, F = F + Math.imul(De, we) | 0, G = G + Math.imul(Be, Je) | 0, D = D + Math.imul(Be, Ge) | 0, D = D + Math.imul(be, Je) | 0, F = F + Math.imul(be, Ge) | 0, G = G + Math.imul(oe, ct) | 0, D = D + Math.imul(oe, bt) | 0, D = D + Math.imul(fe, ct) | 0, F = F + Math.imul(fe, bt) | 0;
        var kt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, G = Math.imul(ke, Se), D = Math.imul(ke, et), D = D + Math.imul(Xe, Se) | 0, F = Math.imul(Xe, et), G = G + Math.imul(ot, Le) | 0, D = D + Math.imul(ot, ze) | 0, D = D + Math.imul(ut, Le) | 0, F = F + Math.imul(ut, ze) | 0, G = G + Math.imul(Fe, _t) | 0, D = D + Math.imul(Fe, ft) | 0, D = D + Math.imul(je, _t) | 0, F = F + Math.imul(je, ft) | 0, G = G + Math.imul(Ve, Mt) | 0, D = D + Math.imul(Ve, St) | 0, D = D + Math.imul(nt, Mt) | 0, F = F + Math.imul(nt, St) | 0, G = G + Math.imul(_e, At) | 0, D = D + Math.imul(_e, Ae) | 0, D = D + Math.imul(Pe, At) | 0, F = F + Math.imul(Pe, Ae) | 0, G = G + Math.imul(he, Oe) | 0, D = D + Math.imul(he, we) | 0, D = D + Math.imul(ue, Oe) | 0, F = F + Math.imul(ue, we) | 0, G = G + Math.imul(qe, Je) | 0, D = D + Math.imul(qe, Ge) | 0, D = D + Math.imul(De, Je) | 0, F = F + Math.imul(De, Ge) | 0, G = G + Math.imul(Be, ct) | 0, D = D + Math.imul(Be, bt) | 0, D = D + Math.imul(be, ct) | 0, F = F + Math.imul(be, bt) | 0;
        var Ot = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, G = Math.imul(ke, Le), D = Math.imul(ke, ze), D = D + Math.imul(Xe, Le) | 0, F = Math.imul(Xe, ze), G = G + Math.imul(ot, _t) | 0, D = D + Math.imul(ot, ft) | 0, D = D + Math.imul(ut, _t) | 0, F = F + Math.imul(ut, ft) | 0, G = G + Math.imul(Fe, Mt) | 0, D = D + Math.imul(Fe, St) | 0, D = D + Math.imul(je, Mt) | 0, F = F + Math.imul(je, St) | 0, G = G + Math.imul(Ve, At) | 0, D = D + Math.imul(Ve, Ae) | 0, D = D + Math.imul(nt, At) | 0, F = F + Math.imul(nt, Ae) | 0, G = G + Math.imul(_e, Oe) | 0, D = D + Math.imul(_e, we) | 0, D = D + Math.imul(Pe, Oe) | 0, F = F + Math.imul(Pe, we) | 0, G = G + Math.imul(he, Je) | 0, D = D + Math.imul(he, Ge) | 0, D = D + Math.imul(ue, Je) | 0, F = F + Math.imul(ue, Ge) | 0, G = G + Math.imul(qe, ct) | 0, D = D + Math.imul(qe, bt) | 0, D = D + Math.imul(De, ct) | 0, F = F + Math.imul(De, bt) | 0;
        var It = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, G = Math.imul(ke, _t), D = Math.imul(ke, ft), D = D + Math.imul(Xe, _t) | 0, F = Math.imul(Xe, ft), G = G + Math.imul(ot, Mt) | 0, D = D + Math.imul(ot, St) | 0, D = D + Math.imul(ut, Mt) | 0, F = F + Math.imul(ut, St) | 0, G = G + Math.imul(Fe, At) | 0, D = D + Math.imul(Fe, Ae) | 0, D = D + Math.imul(je, At) | 0, F = F + Math.imul(je, Ae) | 0, G = G + Math.imul(Ve, Oe) | 0, D = D + Math.imul(Ve, we) | 0, D = D + Math.imul(nt, Oe) | 0, F = F + Math.imul(nt, we) | 0, G = G + Math.imul(_e, Je) | 0, D = D + Math.imul(_e, Ge) | 0, D = D + Math.imul(Pe, Je) | 0, F = F + Math.imul(Pe, Ge) | 0, G = G + Math.imul(he, ct) | 0, D = D + Math.imul(he, bt) | 0, D = D + Math.imul(ue, ct) | 0, F = F + Math.imul(ue, bt) | 0;
        var Pt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, G = Math.imul(ke, Mt), D = Math.imul(ke, St), D = D + Math.imul(Xe, Mt) | 0, F = Math.imul(Xe, St), G = G + Math.imul(ot, At) | 0, D = D + Math.imul(ot, Ae) | 0, D = D + Math.imul(ut, At) | 0, F = F + Math.imul(ut, Ae) | 0, G = G + Math.imul(Fe, Oe) | 0, D = D + Math.imul(Fe, we) | 0, D = D + Math.imul(je, Oe) | 0, F = F + Math.imul(je, we) | 0, G = G + Math.imul(Ve, Je) | 0, D = D + Math.imul(Ve, Ge) | 0, D = D + Math.imul(nt, Je) | 0, F = F + Math.imul(nt, Ge) | 0, G = G + Math.imul(_e, ct) | 0, D = D + Math.imul(_e, bt) | 0, D = D + Math.imul(Pe, ct) | 0, F = F + Math.imul(Pe, bt) | 0;
        var Ct = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, G = Math.imul(ke, At), D = Math.imul(ke, Ae), D = D + Math.imul(Xe, At) | 0, F = Math.imul(Xe, Ae), G = G + Math.imul(ot, Oe) | 0, D = D + Math.imul(ot, we) | 0, D = D + Math.imul(ut, Oe) | 0, F = F + Math.imul(ut, we) | 0, G = G + Math.imul(Fe, Je) | 0, D = D + Math.imul(Fe, Ge) | 0, D = D + Math.imul(je, Je) | 0, F = F + Math.imul(je, Ge) | 0, G = G + Math.imul(Ve, ct) | 0, D = D + Math.imul(Ve, bt) | 0, D = D + Math.imul(nt, ct) | 0, F = F + Math.imul(nt, bt) | 0;
        var Bt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, G = Math.imul(ke, Oe), D = Math.imul(ke, we), D = D + Math.imul(Xe, Oe) | 0, F = Math.imul(Xe, we), G = G + Math.imul(ot, Je) | 0, D = D + Math.imul(ot, Ge) | 0, D = D + Math.imul(ut, Je) | 0, F = F + Math.imul(ut, Ge) | 0, G = G + Math.imul(Fe, ct) | 0, D = D + Math.imul(Fe, bt) | 0, D = D + Math.imul(je, ct) | 0, F = F + Math.imul(je, bt) | 0;
        var vt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, G = Math.imul(ke, Je), D = Math.imul(ke, Ge), D = D + Math.imul(Xe, Je) | 0, F = Math.imul(Xe, Ge), G = G + Math.imul(ot, ct) | 0, D = D + Math.imul(ot, bt) | 0, D = D + Math.imul(ut, ct) | 0, F = F + Math.imul(ut, bt) | 0;
        var yt = (z + G | 0) + ((D & 8191) << 13) | 0;
        z = (F + (D >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, G = Math.imul(ke, ct), D = Math.imul(ke, bt), D = D + Math.imul(Xe, ct) | 0, F = Math.imul(Xe, bt);
        var xt = (z + G | 0) + ((D & 8191) << 13) | 0;
        return z = (F + (D >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, K[0] = wt, K[1] = zt, K[2] = Tt, K[3] = Lt, K[4] = jt, K[5] = Ht, K[6] = Ft, K[7] = Nt, K[8] = Dt, K[9] = Ut, K[10] = kt, K[11] = Ot, K[12] = It, K[13] = Pt, K[14] = Ct, K[15] = Bt, K[16] = vt, K[17] = yt, K[18] = xt, z !== 0 && (K[19] = z, O.length++), O;
      };
      Math.imul || (se = te);
      function le(M, $, O) {
        O.negative = $.negative ^ M.negative, O.length = M.length + $.length;
        for (var J = 0, Z = 0, K = 0; K < O.length - 1; K++) {
          var z = Z;
          Z = 0;
          for (var G = J & 67108863, D = Math.min(K, $.length - 1), F = Math.max(0, K - M.length + 1); F <= D; F++) {
            var ae = K - F, ge = M.words[ae] | 0, xe = $.words[F] | 0, ye = ge * xe, oe = ye & 67108863;
            z = z + (ye / 67108864 | 0) | 0, oe = oe + G | 0, G = oe & 67108863, z = z + (oe >>> 26) | 0, Z += z >>> 26, z &= 67108863;
          }
          O.words[K] = G, J = z, z = Z;
        }
        return J !== 0 ? O.words[K] = J : O.length--, O._strip();
      }
      function ce(M, $, O) {
        return le(M, $, O);
      }
      h.prototype.mulTo = function(M, $) {
        var O, J = this.length + M.length;
        return this.length === 10 && M.length === 10 ? O = se(this, M, $) : J < 63 ? O = te(this, M, $) : J < 1024 ? O = le(this, M, $) : O = ce(this, M, $), O;
      }, h.prototype.mul = function(M) {
        var $ = new h(null);
        return $.words = new Array(this.length + M.length), this.mulTo(M, $);
      }, h.prototype.mulf = function(M) {
        var $ = new h(null);
        return $.words = new Array(this.length + M.length), ce(this, M, $);
      }, h.prototype.imul = function(M) {
        return this.clone().mulTo(M, this);
      }, h.prototype.imuln = function(M) {
        var $ = M < 0;
        $ && (M = -M), g(typeof M == "number"), g(M < 67108864);
        for (var O = 0, J = 0; J < this.length; J++) {
          var Z = (this.words[J] | 0) * M, K = (Z & 67108863) + (O & 67108863);
          O >>= 26, O += Z / 67108864 | 0, O += K >>> 26, this.words[J] = K & 67108863;
        }
        return O !== 0 && (this.words[J] = O, this.length++), $ ? this.ineg() : this;
      }, h.prototype.muln = function(M) {
        return this.clone().imuln(M);
      }, h.prototype.sqr = function() {
        return this.mul(this);
      }, h.prototype.isqr = function() {
        return this.imul(this.clone());
      }, h.prototype.pow = function(M) {
        var $ = ie(M);
        if ($.length === 0)
          return new h(1);
        for (var O = this, J = 0; J < $.length && $[J] === 0; J++, O = O.sqr())
          ;
        if (++J < $.length)
          for (var Z = O.sqr(); J < $.length; J++, Z = Z.sqr())
            $[J] !== 0 && (O = O.mul(Z));
        return O;
      }, h.prototype.iushln = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = M % 26, O = (M - $) / 26, J = 67108863 >>> 26 - $ << 26 - $, Z;
        if ($ !== 0) {
          var K = 0;
          for (Z = 0; Z < this.length; Z++) {
            var z = this.words[Z] & J, G = (this.words[Z] | 0) - z << $;
            this.words[Z] = G | K, K = z >>> 26 - $;
          }
          K && (this.words[Z] = K, this.length++);
        }
        if (O !== 0) {
          for (Z = this.length - 1; Z >= 0; Z--)
            this.words[Z + O] = this.words[Z];
          for (Z = 0; Z < O; Z++)
            this.words[Z] = 0;
          this.length += O;
        }
        return this._strip();
      }, h.prototype.ishln = function(M) {
        return g(this.negative === 0), this.iushln(M);
      }, h.prototype.iushrn = function(M, $, O) {
        g(typeof M == "number" && M >= 0);
        var J;
        $ ? J = ($ - $ % 26) / 26 : J = 0;
        var Z = M % 26, K = Math.min((M - Z) / 26, this.length), z = 67108863 ^ 67108863 >>> Z << Z, G = O;
        if (J -= K, J = Math.max(0, J), G) {
          for (var D = 0; D < K; D++)
            G.words[D] = this.words[D];
          G.length = K;
        }
        if (K !== 0)
          if (this.length > K)
            for (this.length -= K, D = 0; D < this.length; D++)
              this.words[D] = this.words[D + K];
          else
            this.words[0] = 0, this.length = 1;
        var F = 0;
        for (D = this.length - 1; D >= 0 && (F !== 0 || D >= J); D--) {
          var ae = this.words[D] | 0;
          this.words[D] = F << 26 - Z | ae >>> Z, F = ae & z;
        }
        return G && F !== 0 && (G.words[G.length++] = F), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, h.prototype.ishrn = function(M, $, O) {
        return g(this.negative === 0), this.iushrn(M, $, O);
      }, h.prototype.shln = function(M) {
        return this.clone().ishln(M);
      }, h.prototype.ushln = function(M) {
        return this.clone().iushln(M);
      }, h.prototype.shrn = function(M) {
        return this.clone().ishrn(M);
      }, h.prototype.ushrn = function(M) {
        return this.clone().iushrn(M);
      }, h.prototype.testn = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = M % 26, O = (M - $) / 26, J = 1 << $;
        if (this.length <= O)
          return !1;
        var Z = this.words[O];
        return !!(Z & J);
      }, h.prototype.imaskn = function(M) {
        g(typeof M == "number" && M >= 0);
        var $ = M % 26, O = (M - $) / 26;
        if (g(this.negative === 0, "imaskn works only with positive numbers"), this.length <= O)
          return this;
        if ($ !== 0 && O++, this.length = Math.min(O, this.length), $ !== 0) {
          var J = 67108863 ^ 67108863 >>> $ << $;
          this.words[this.length - 1] &= J;
        }
        return this._strip();
      }, h.prototype.maskn = function(M) {
        return this.clone().imaskn(M);
      }, h.prototype.iaddn = function(M) {
        return g(typeof M == "number"), g(M < 67108864), M < 0 ? this.isubn(-M) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= M ? (this.words[0] = M - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(M), this.negative = 1, this) : this._iaddn(M);
      }, h.prototype._iaddn = function(M) {
        this.words[0] += M;
        for (var $ = 0; $ < this.length && this.words[$] >= 67108864; $++)
          this.words[$] -= 67108864, $ === this.length - 1 ? this.words[$ + 1] = 1 : this.words[$ + 1]++;
        return this.length = Math.max(this.length, $ + 1), this;
      }, h.prototype.isubn = function(M) {
        if (g(typeof M == "number"), g(M < 67108864), M < 0)
          return this.iaddn(-M);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(M), this.negative = 1, this;
        if (this.words[0] -= M, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var $ = 0; $ < this.length && this.words[$] < 0; $++)
            this.words[$] += 67108864, this.words[$ + 1] -= 1;
        return this._strip();
      }, h.prototype.addn = function(M) {
        return this.clone().iaddn(M);
      }, h.prototype.subn = function(M) {
        return this.clone().isubn(M);
      }, h.prototype.iabs = function() {
        return this.negative = 0, this;
      }, h.prototype.abs = function() {
        return this.clone().iabs();
      }, h.prototype._ishlnsubmul = function(M, $, O) {
        var J = M.length + O, Z;
        this._expand(J);
        var K, z = 0;
        for (Z = 0; Z < M.length; Z++) {
          K = (this.words[Z + O] | 0) + z;
          var G = (M.words[Z] | 0) * $;
          K -= G & 67108863, z = (K >> 26) - (G / 67108864 | 0), this.words[Z + O] = K & 67108863;
        }
        for (; Z < this.length - O; Z++)
          K = (this.words[Z + O] | 0) + z, z = K >> 26, this.words[Z + O] = K & 67108863;
        if (z === 0)
          return this._strip();
        for (g(z === -1), z = 0, Z = 0; Z < this.length; Z++)
          K = -(this.words[Z] | 0) + z, z = K >> 26, this.words[Z] = K & 67108863;
        return this.negative = 1, this._strip();
      }, h.prototype._wordDiv = function(M, $) {
        var O = this.length - M.length, J = this.clone(), Z = M, K = Z.words[Z.length - 1] | 0, z = this._countBits(K);
        O = 26 - z, O !== 0 && (Z = Z.ushln(O), J.iushln(O), K = Z.words[Z.length - 1] | 0);
        var G = J.length - Z.length, D;
        if ($ !== "mod") {
          D = new h(null), D.length = G + 1, D.words = new Array(D.length);
          for (var F = 0; F < D.length; F++)
            D.words[F] = 0;
        }
        var ae = J.clone()._ishlnsubmul(Z, 1, G);
        ae.negative === 0 && (J = ae, D && (D.words[G] = 1));
        for (var ge = G - 1; ge >= 0; ge--) {
          var xe = (J.words[Z.length + ge] | 0) * 67108864 + (J.words[Z.length + ge - 1] | 0);
          for (xe = Math.min(xe / K | 0, 67108863), J._ishlnsubmul(Z, xe, ge); J.negative !== 0; )
            xe--, J.negative = 0, J._ishlnsubmul(Z, 1, ge), J.isZero() || (J.negative ^= 1);
          D && (D.words[ge] = xe);
        }
        return D && D._strip(), J._strip(), $ !== "div" && O !== 0 && J.iushrn(O), {
          div: D || null,
          mod: J
        };
      }, h.prototype.divmod = function(M, $, O) {
        if (g(!M.isZero()), this.isZero())
          return {
            div: new h(0),
            mod: new h(0)
          };
        var J, Z, K;
        return this.negative !== 0 && M.negative === 0 ? (K = this.neg().divmod(M, $), $ !== "mod" && (J = K.div.neg()), $ !== "div" && (Z = K.mod.neg(), O && Z.negative !== 0 && Z.iadd(M)), {
          div: J,
          mod: Z
        }) : this.negative === 0 && M.negative !== 0 ? (K = this.divmod(M.neg(), $), $ !== "mod" && (J = K.div.neg()), {
          div: J,
          mod: K.mod
        }) : this.negative & M.negative ? (K = this.neg().divmod(M.neg(), $), $ !== "div" && (Z = K.mod.neg(), O && Z.negative !== 0 && Z.isub(M)), {
          div: K.div,
          mod: Z
        }) : M.length > this.length || this.cmp(M) < 0 ? {
          div: new h(0),
          mod: this
        } : M.length === 1 ? $ === "div" ? {
          div: this.divn(M.words[0]),
          mod: null
        } : $ === "mod" ? {
          div: null,
          mod: new h(this.modrn(M.words[0]))
        } : {
          div: this.divn(M.words[0]),
          mod: new h(this.modrn(M.words[0]))
        } : this._wordDiv(M, $);
      }, h.prototype.div = function(M) {
        return this.divmod(M, "div", !1).div;
      }, h.prototype.mod = function(M) {
        return this.divmod(M, "mod", !1).mod;
      }, h.prototype.umod = function(M) {
        return this.divmod(M, "mod", !0).mod;
      }, h.prototype.divRound = function(M) {
        var $ = this.divmod(M);
        if ($.mod.isZero())
          return $.div;
        var O = $.div.negative !== 0 ? $.mod.isub(M) : $.mod, J = M.ushrn(1), Z = M.andln(1), K = O.cmp(J);
        return K < 0 || Z === 1 && K === 0 ? $.div : $.div.negative !== 0 ? $.div.isubn(1) : $.div.iaddn(1);
      }, h.prototype.modrn = function(M) {
        var $ = M < 0;
        $ && (M = -M), g(M <= 67108863);
        for (var O = (1 << 26) % M, J = 0, Z = this.length - 1; Z >= 0; Z--)
          J = (O * J + (this.words[Z] | 0)) % M;
        return $ ? -J : J;
      }, h.prototype.modn = function(M) {
        return this.modrn(M);
      }, h.prototype.idivn = function(M) {
        var $ = M < 0;
        $ && (M = -M), g(M <= 67108863);
        for (var O = 0, J = this.length - 1; J >= 0; J--) {
          var Z = (this.words[J] | 0) + O * 67108864;
          this.words[J] = Z / M | 0, O = Z % M;
        }
        return this._strip(), $ ? this.ineg() : this;
      }, h.prototype.divn = function(M) {
        return this.clone().idivn(M);
      }, h.prototype.egcd = function(M) {
        g(M.negative === 0), g(!M.isZero());
        var $ = this, O = M.clone();
        $.negative !== 0 ? $ = $.umod(M) : $ = $.clone();
        for (var J = new h(1), Z = new h(0), K = new h(0), z = new h(1), G = 0; $.isEven() && O.isEven(); )
          $.iushrn(1), O.iushrn(1), ++G;
        for (var D = O.clone(), F = $.clone(); !$.isZero(); ) {
          for (var ae = 0, ge = 1; !($.words[0] & ge) && ae < 26; ++ae, ge <<= 1)
            ;
          if (ae > 0)
            for ($.iushrn(ae); ae-- > 0; )
              (J.isOdd() || Z.isOdd()) && (J.iadd(D), Z.isub(F)), J.iushrn(1), Z.iushrn(1);
          for (var xe = 0, ye = 1; !(O.words[0] & ye) && xe < 26; ++xe, ye <<= 1)
            ;
          if (xe > 0)
            for (O.iushrn(xe); xe-- > 0; )
              (K.isOdd() || z.isOdd()) && (K.iadd(D), z.isub(F)), K.iushrn(1), z.iushrn(1);
          $.cmp(O) >= 0 ? ($.isub(O), J.isub(K), Z.isub(z)) : (O.isub($), K.isub(J), z.isub(Z));
        }
        return {
          a: K,
          b: z,
          gcd: O.iushln(G)
        };
      }, h.prototype._invmp = function(M) {
        g(M.negative === 0), g(!M.isZero());
        var $ = this, O = M.clone();
        $.negative !== 0 ? $ = $.umod(M) : $ = $.clone();
        for (var J = new h(1), Z = new h(0), K = O.clone(); $.cmpn(1) > 0 && O.cmpn(1) > 0; ) {
          for (var z = 0, G = 1; !($.words[0] & G) && z < 26; ++z, G <<= 1)
            ;
          if (z > 0)
            for ($.iushrn(z); z-- > 0; )
              J.isOdd() && J.iadd(K), J.iushrn(1);
          for (var D = 0, F = 1; !(O.words[0] & F) && D < 26; ++D, F <<= 1)
            ;
          if (D > 0)
            for (O.iushrn(D); D-- > 0; )
              Z.isOdd() && Z.iadd(K), Z.iushrn(1);
          $.cmp(O) >= 0 ? ($.isub(O), J.isub(Z)) : (O.isub($), Z.isub(J));
        }
        var ae;
        return $.cmpn(1) === 0 ? ae = J : ae = Z, ae.cmpn(0) < 0 && ae.iadd(M), ae;
      }, h.prototype.gcd = function(M) {
        if (this.isZero())
          return M.abs();
        if (M.isZero())
          return this.abs();
        var $ = this.clone(), O = M.clone();
        $.negative = 0, O.negative = 0;
        for (var J = 0; $.isEven() && O.isEven(); J++)
          $.iushrn(1), O.iushrn(1);
        do {
          for (; $.isEven(); )
            $.iushrn(1);
          for (; O.isEven(); )
            O.iushrn(1);
          var Z = $.cmp(O);
          if (Z < 0) {
            var K = $;
            $ = O, O = K;
          } else if (Z === 0 || O.cmpn(1) === 0)
            break;
          $.isub(O);
        } while (!0);
        return O.iushln(J);
      }, h.prototype.invm = function(M) {
        return this.egcd(M).a.umod(M);
      }, h.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, h.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, h.prototype.andln = function(M) {
        return this.words[0] & M;
      }, h.prototype.bincn = function(M) {
        g(typeof M == "number");
        var $ = M % 26, O = (M - $) / 26, J = 1 << $;
        if (this.length <= O)
          return this._expand(O + 1), this.words[O] |= J, this;
        for (var Z = J, K = O; Z !== 0 && K < this.length; K++) {
          var z = this.words[K] | 0;
          z += Z, Z = z >>> 26, z &= 67108863, this.words[K] = z;
        }
        return Z !== 0 && (this.words[K] = Z, this.length++), this;
      }, h.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, h.prototype.cmpn = function(M) {
        var $ = M < 0;
        if (this.negative !== 0 && !$)
          return -1;
        if (this.negative === 0 && $)
          return 1;
        this._strip();
        var O;
        if (this.length > 1)
          O = 1;
        else {
          $ && (M = -M), g(M <= 67108863, "Number is too big");
          var J = this.words[0] | 0;
          O = J === M ? 0 : J < M ? -1 : 1;
        }
        return this.negative !== 0 ? -O | 0 : O;
      }, h.prototype.cmp = function(M) {
        if (this.negative !== 0 && M.negative === 0)
          return -1;
        if (this.negative === 0 && M.negative !== 0)
          return 1;
        var $ = this.ucmp(M);
        return this.negative !== 0 ? -$ | 0 : $;
      }, h.prototype.ucmp = function(M) {
        if (this.length > M.length)
          return 1;
        if (this.length < M.length)
          return -1;
        for (var $ = 0, O = this.length - 1; O >= 0; O--) {
          var J = this.words[O] | 0, Z = M.words[O] | 0;
          if (J !== Z) {
            J < Z ? $ = -1 : J > Z && ($ = 1);
            break;
          }
        }
        return $;
      }, h.prototype.gtn = function(M) {
        return this.cmpn(M) === 1;
      }, h.prototype.gt = function(M) {
        return this.cmp(M) === 1;
      }, h.prototype.gten = function(M) {
        return this.cmpn(M) >= 0;
      }, h.prototype.gte = function(M) {
        return this.cmp(M) >= 0;
      }, h.prototype.ltn = function(M) {
        return this.cmpn(M) === -1;
      }, h.prototype.lt = function(M) {
        return this.cmp(M) === -1;
      }, h.prototype.lten = function(M) {
        return this.cmpn(M) <= 0;
      }, h.prototype.lte = function(M) {
        return this.cmp(M) <= 0;
      }, h.prototype.eqn = function(M) {
        return this.cmpn(M) === 0;
      }, h.prototype.eq = function(M) {
        return this.cmp(M) === 0;
      }, h.red = function(M) {
        return new ne(M);
      }, h.prototype.toRed = function(M) {
        return g(!this.red, "Already a number in reduction context"), g(this.negative === 0, "red works only with positives"), M.convertTo(this)._forceRed(M);
      }, h.prototype.fromRed = function() {
        return g(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, h.prototype._forceRed = function(M) {
        return this.red = M, this;
      }, h.prototype.forceRed = function(M) {
        return g(!this.red, "Already a number in reduction context"), this._forceRed(M);
      }, h.prototype.redAdd = function(M) {
        return g(this.red, "redAdd works only with red numbers"), this.red.add(this, M);
      }, h.prototype.redIAdd = function(M) {
        return g(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, M);
      }, h.prototype.redSub = function(M) {
        return g(this.red, "redSub works only with red numbers"), this.red.sub(this, M);
      }, h.prototype.redISub = function(M) {
        return g(this.red, "redISub works only with red numbers"), this.red.isub(this, M);
      }, h.prototype.redShl = function(M) {
        return g(this.red, "redShl works only with red numbers"), this.red.shl(this, M);
      }, h.prototype.redMul = function(M) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, M), this.red.mul(this, M);
      }, h.prototype.redIMul = function(M) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, M), this.red.imul(this, M);
      }, h.prototype.redSqr = function() {
        return g(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, h.prototype.redISqr = function() {
        return g(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, h.prototype.redSqrt = function() {
        return g(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, h.prototype.redInvm = function() {
        return g(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, h.prototype.redNeg = function() {
        return g(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, h.prototype.redPow = function(M) {
        return g(this.red && !M.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, M);
      };
      var pe = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function me(M, $) {
        this.name = M, this.p = new h($, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var M = new h(null);
        return M.words = new Array(Math.ceil(this.n / 13)), M;
      }, me.prototype.ireduce = function(M) {
        var $ = M, O;
        do
          this.split($, this.tmp), $ = this.imulK($), $ = $.iadd(this.tmp), O = $.bitLength();
        while (O > this.n);
        var J = O < this.n ? -1 : $.ucmp(this.p);
        return J === 0 ? ($.words[0] = 0, $.length = 1) : J > 0 ? $.isub(this.p) : $.strip !== void 0 ? $.strip() : $._strip(), $;
      }, me.prototype.split = function(M, $) {
        M.iushrn(this.n, 0, $);
      }, me.prototype.imulK = function(M) {
        return M.imul(this.k);
      };
      function Me() {
        me.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      U(Me, me), Me.prototype.split = function(M, $) {
        for (var O = 4194303, J = Math.min(M.length, 9), Z = 0; Z < J; Z++)
          $.words[Z] = M.words[Z];
        if ($.length = J, M.length <= 9) {
          M.words[0] = 0, M.length = 1;
          return;
        }
        var K = M.words[9];
        for ($.words[$.length++] = K & O, Z = 10; Z < M.length; Z++) {
          var z = M.words[Z] | 0;
          M.words[Z - 10] = (z & O) << 4 | K >>> 22, K = z;
        }
        K >>>= 22, M.words[Z - 10] = K, K === 0 && M.length > 10 ? M.length -= 10 : M.length -= 9;
      }, Me.prototype.imulK = function(M) {
        M.words[M.length] = 0, M.words[M.length + 1] = 0, M.length += 2;
        for (var $ = 0, O = 0; O < M.length; O++) {
          var J = M.words[O] | 0;
          $ += J * 977, M.words[O] = $ & 67108863, $ = J * 64 + ($ / 67108864 | 0);
        }
        return M.words[M.length - 1] === 0 && (M.length--, M.words[M.length - 1] === 0 && M.length--), M;
      };
      function Ee() {
        me.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      U(Ee, me);
      function Re() {
        me.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      U(Re, me);
      function Ne() {
        me.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      U(Ne, me), Ne.prototype.imulK = function(M) {
        for (var $ = 0, O = 0; O < M.length; O++) {
          var J = (M.words[O] | 0) * 19 + $, Z = J & 67108863;
          J >>>= 26, M.words[O] = Z, $ = J;
        }
        return $ !== 0 && (M.words[M.length++] = $), M;
      }, h._prime = function(M) {
        if (pe[M])
          return pe[M];
        var $;
        if (M === "k256")
          $ = new Me();
        else if (M === "p224")
          $ = new Ee();
        else if (M === "p192")
          $ = new Re();
        else if (M === "p25519")
          $ = new Ne();
        else
          throw new Error("Unknown prime " + M);
        return pe[M] = $, $;
      };
      function ne(M) {
        if (typeof M == "string") {
          var $ = h._prime(M);
          this.m = $.p, this.prime = $;
        } else
          g(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
      }
      ne.prototype._verify1 = function(M) {
        g(M.negative === 0, "red works only with positives"), g(M.red, "red works only with red numbers");
      }, ne.prototype._verify2 = function(M, $) {
        g((M.negative | $.negative) === 0, "red works only with positives"), g(
          M.red && M.red === $.red,
          "red works only with red numbers"
        );
      }, ne.prototype.imod = function(M) {
        return this.prime ? this.prime.ireduce(M)._forceRed(this) : (B(M, M.umod(this.m)._forceRed(this)), M);
      }, ne.prototype.neg = function(M) {
        return M.isZero() ? M.clone() : this.m.sub(M)._forceRed(this);
      }, ne.prototype.add = function(M, $) {
        this._verify2(M, $);
        var O = M.add($);
        return O.cmp(this.m) >= 0 && O.isub(this.m), O._forceRed(this);
      }, ne.prototype.iadd = function(M, $) {
        this._verify2(M, $);
        var O = M.iadd($);
        return O.cmp(this.m) >= 0 && O.isub(this.m), O;
      }, ne.prototype.sub = function(M, $) {
        this._verify2(M, $);
        var O = M.sub($);
        return O.cmpn(0) < 0 && O.iadd(this.m), O._forceRed(this);
      }, ne.prototype.isub = function(M, $) {
        this._verify2(M, $);
        var O = M.isub($);
        return O.cmpn(0) < 0 && O.iadd(this.m), O;
      }, ne.prototype.shl = function(M, $) {
        return this._verify1(M), this.imod(M.ushln($));
      }, ne.prototype.imul = function(M, $) {
        return this._verify2(M, $), this.imod(M.imul($));
      }, ne.prototype.mul = function(M, $) {
        return this._verify2(M, $), this.imod(M.mul($));
      }, ne.prototype.isqr = function(M) {
        return this.imul(M, M.clone());
      }, ne.prototype.sqr = function(M) {
        return this.mul(M, M);
      }, ne.prototype.sqrt = function(M) {
        if (M.isZero())
          return M.clone();
        var $ = this.m.andln(3);
        if (g($ % 2 === 1), $ === 3) {
          var O = this.m.add(new h(1)).iushrn(2);
          return this.pow(M, O);
        }
        for (var J = this.m.subn(1), Z = 0; !J.isZero() && J.andln(1) === 0; )
          Z++, J.iushrn(1);
        g(!J.isZero());
        var K = new h(1).toRed(this), z = K.redNeg(), G = this.m.subn(1).iushrn(1), D = this.m.bitLength();
        for (D = new h(2 * D * D).toRed(this); this.pow(D, G).cmp(z) !== 0; )
          D.redIAdd(z);
        for (var F = this.pow(D, J), ae = this.pow(M, J.addn(1).iushrn(1)), ge = this.pow(M, J), xe = Z; ge.cmp(K) !== 0; ) {
          for (var ye = ge, oe = 0; ye.cmp(K) !== 0; oe++)
            ye = ye.redSqr();
          g(oe < xe);
          var fe = this.pow(F, new h(1).iushln(xe - oe - 1));
          ae = ae.redMul(fe), F = fe.redSqr(), ge = ge.redMul(F), xe = oe;
        }
        return ae;
      }, ne.prototype.invm = function(M) {
        var $ = M._invmp(this.m);
        return $.negative !== 0 ? ($.negative = 0, this.imod($).redNeg()) : this.imod($);
      }, ne.prototype.pow = function(M, $) {
        if ($.isZero())
          return new h(1).toRed(this);
        if ($.cmpn(1) === 0)
          return M.clone();
        var O = 4, J = new Array(1 << O);
        J[0] = new h(1).toRed(this), J[1] = M;
        for (var Z = 2; Z < J.length; Z++)
          J[Z] = this.mul(J[Z - 1], M);
        var K = J[0], z = 0, G = 0, D = $.bitLength() % 26;
        for (D === 0 && (D = 26), Z = $.length - 1; Z >= 0; Z--) {
          for (var F = $.words[Z], ae = D - 1; ae >= 0; ae--) {
            var ge = F >> ae & 1;
            if (K !== J[0] && (K = this.sqr(K)), ge === 0 && z === 0) {
              G = 0;
              continue;
            }
            z <<= 1, z |= ge, G++, !(G !== O && (Z !== 0 || ae !== 0)) && (K = this.mul(K, J[z]), G = 0, z = 0);
          }
          D = 26;
        }
        return K;
      }, ne.prototype.convertTo = function(M) {
        var $ = M.umod(this.m);
        return $ === M ? $.clone() : $;
      }, ne.prototype.convertFrom = function(M) {
        var $ = M.clone();
        return $.red = null, $;
      }, h.mont = function(M) {
        return new Y(M);
      };
      function Y(M) {
        ne.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      U(Y, ne), Y.prototype.convertTo = function(M) {
        return this.imod(M.ushln(this.shift));
      }, Y.prototype.convertFrom = function(M) {
        var $ = this.imod(M.mul(this.rinv));
        return $.red = null, $;
      }, Y.prototype.imul = function(M, $) {
        if (M.isZero() || $.isZero())
          return M.words[0] = 0, M.length = 1, M;
        var O = M.imul($), J = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Z = O.isub(J).iushrn(this.shift), K = Z;
        return Z.cmp(this.m) >= 0 ? K = Z.isub(this.m) : Z.cmpn(0) < 0 && (K = Z.iadd(this.m)), K._forceRed(this);
      }, Y.prototype.mul = function(M, $) {
        if (M.isZero() || $.isZero())
          return new h(0)._forceRed(this);
        var O = M.mul($), J = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Z = O.isub(J).iushrn(this.shift), K = Z;
        return Z.cmp(this.m) >= 0 ? K = Z.isub(this.m) : Z.cmpn(0) < 0 && (K = Z.iadd(this.m)), K._forceRed(this);
      }, Y.prototype.invm = function(M) {
        var $ = this.imod(M._invmp(this.m).mul(this.r2));
        return $._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$3)), bn$3.exports;
}
var asn1$1$1 = {}, asn1$2 = {}, api$1 = {}, vmBrowserify$1 = {}, hasRequiredVmBrowserify$1;
function requireVmBrowserify$1() {
  return hasRequiredVmBrowserify$1 || (hasRequiredVmBrowserify$1 = 1, function(exports) {
    var indexOf = function(e, o) {
      if (e.indexOf)
        return e.indexOf(o);
      for (var S = 0; S < e.length; S++)
        if (e[S] === o)
          return S;
      return -1;
    }, Object_keys = function(e) {
      if (Object.keys)
        return Object.keys(e);
      var o = [];
      for (var S in e)
        o.push(S);
      return o;
    }, forEach = function(e, o) {
      if (e.forEach)
        return e.forEach(o);
      for (var S = 0; S < e.length; S++)
        o(e[S], S, e);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(e, o, S) {
          Object.defineProperty(e, o, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: S
          });
        };
      } catch {
        return function(e, o, S) {
          e[o] = S;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(e) {
      if (!(this instanceof Script))
        return new Script(e);
      this.code = e;
    };
    Script.prototype.runInContext = function(e) {
      if (!(e instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var o = document.createElement("iframe");
      o.style || (o.style = {}), o.style.display = "none", document.body.appendChild(o);
      var S = o.contentWindow, g = S.eval, U = S.execScript;
      !g && U && (U.call(S, "null"), g = S.eval), forEach(Object_keys(e), function(A) {
        S[A] = e[A];
      }), forEach(globals, function(A) {
        e[A] && (S[A] = e[A]);
      });
      var h = Object_keys(S), q = g.call(S, this.code);
      return forEach(Object_keys(S), function(A) {
        (A in e || indexOf(h, A) === -1) && (e[A] = S[A]);
      }), forEach(globals, function(A) {
        A in e || defineProp(e, A, S[A]);
      }), document.body.removeChild(o), q;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(e) {
      var o = Script.createContext(e), S = this.runInContext(o);
      return e && forEach(Object_keys(o), function(g) {
        e[g] = o[g];
      }), S;
    }, forEach(Object_keys(Script.prototype), function(e) {
      exports[e] = Script[e] = function(o) {
        var S = Script(o);
        return S[e].apply(S, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(e) {
      return e instanceof Context;
    }, exports.createScript = function(e) {
      return exports.Script(e);
    }, exports.createContext = Script.createContext = function(e) {
      var o = new Context();
      return typeof e == "object" && forEach(Object_keys(e), function(S) {
        o[S] = e[S];
      }), o;
    };
  }(vmBrowserify$1)), vmBrowserify$1;
}
var hasRequiredApi$1;
function requireApi$1() {
  return hasRequiredApi$1 || (hasRequiredApi$1 = 1, function(e) {
    var o = requireAsn1$1$1(), S = requireInherits_browser$1(), g = e;
    g.define = function(h, q) {
      return new U(h, q);
    };
    function U(h, q) {
      this.name = h, this.body = q, this.decoders = {}, this.encoders = {};
    }
    U.prototype._createNamed = function(h) {
      var q;
      try {
        q = requireVmBrowserify$1().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        q = function(A) {
          this._initNamed(A);
        };
      }
      return S(q, h), q.prototype._initNamed = function(A) {
        h.call(this, A);
      }, new q(this);
    }, U.prototype._getDecoder = function(h) {
      return h = h || "der", this.decoders.hasOwnProperty(h) || (this.decoders[h] = this._createNamed(o.decoders[h])), this.decoders[h];
    }, U.prototype.decode = function(h, q, A) {
      return this._getDecoder(q).decode(h, A);
    }, U.prototype._getEncoder = function(h) {
      return h = h || "der", this.encoders.hasOwnProperty(h) || (this.encoders[h] = this._createNamed(o.encoders[h])), this.encoders[h];
    }, U.prototype.encode = function(h, q, A) {
      return this._getEncoder(q).encode(h, A);
    };
  }(api$1)), api$1;
}
var base$2 = {}, reporter$1 = {}, hasRequiredReporter$1;
function requireReporter$1() {
  if (hasRequiredReporter$1)
    return reporter$1;
  hasRequiredReporter$1 = 1;
  var e = requireInherits_browser$1();
  function o(g) {
    this._reporterState = {
      obj: null,
      path: [],
      options: g || {},
      errors: []
    };
  }
  reporter$1.Reporter = o, o.prototype.isError = function(g) {
    return g instanceof S;
  }, o.prototype.save = function() {
    var g = this._reporterState;
    return { obj: g.obj, pathLen: g.path.length };
  }, o.prototype.restore = function(g) {
    var U = this._reporterState;
    U.obj = g.obj, U.path = U.path.slice(0, g.pathLen);
  }, o.prototype.enterKey = function(g) {
    return this._reporterState.path.push(g);
  }, o.prototype.exitKey = function(g) {
    var U = this._reporterState;
    U.path = U.path.slice(0, g - 1);
  }, o.prototype.leaveKey = function(g, U, h) {
    var q = this._reporterState;
    this.exitKey(g), q.obj !== null && (q.obj[U] = h);
  }, o.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, o.prototype.enterObject = function() {
    var g = this._reporterState, U = g.obj;
    return g.obj = {}, U;
  }, o.prototype.leaveObject = function(g) {
    var U = this._reporterState, h = U.obj;
    return U.obj = g, h;
  }, o.prototype.error = function(g) {
    var U, h = this._reporterState, q = g instanceof S;
    if (q ? U = g : U = new S(h.path.map(function(A) {
      return "[" + JSON.stringify(A) + "]";
    }).join(""), g.message || g, g.stack), !h.options.partial)
      throw U;
    return q || h.errors.push(U), U;
  }, o.prototype.wrapResult = function(g) {
    var U = this._reporterState;
    return U.options.partial ? {
      result: this.isError(g) ? null : g,
      errors: U.errors
    } : g;
  };
  function S(g, U) {
    this.path = g, this.rethrow(U);
  }
  return e(S, Error), S.prototype.rethrow = function(g) {
    if (this.message = g + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, S), !this.stack)
      try {
        throw new Error(this.message);
      } catch (U) {
        this.stack = U.stack;
      }
    return this;
  }, reporter$1;
}
var buffer$2 = {}, hasRequiredBuffer$2;
function requireBuffer$2() {
  if (hasRequiredBuffer$2)
    return buffer$2;
  hasRequiredBuffer$2 = 1;
  var e = requireInherits_browser$1(), o = requireBase$2().Reporter, S = requireBuffer$1().Buffer;
  function g(h, q) {
    if (o.call(this, q), !S.isBuffer(h)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = h, this.offset = 0, this.length = h.length;
  }
  e(g, o), buffer$2.DecoderBuffer = g, g.prototype.save = function() {
    return { offset: this.offset, reporter: o.prototype.save.call(this) };
  }, g.prototype.restore = function(h) {
    var q = new g(this.base);
    return q.offset = h.offset, q.length = this.offset, this.offset = h.offset, o.prototype.restore.call(this, h.reporter), q;
  }, g.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, g.prototype.readUInt8 = function(h) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(h || "DecoderBuffer overrun");
  }, g.prototype.skip = function(h, q) {
    if (!(this.offset + h <= this.length))
      return this.error(q || "DecoderBuffer overrun");
    var A = new g(this.base);
    return A._reporterState = this._reporterState, A.offset = this.offset, A.length = this.offset + h, this.offset += h, A;
  }, g.prototype.raw = function(h) {
    return this.base.slice(h ? h.offset : this.offset, this.length);
  };
  function U(h, q) {
    if (Array.isArray(h))
      this.length = 0, this.value = h.map(function(A) {
        return A instanceof U || (A = new U(A, q)), this.length += A.length, A;
      }, this);
    else if (typeof h == "number") {
      if (!(0 <= h && h <= 255))
        return q.error("non-byte EncoderBuffer value");
      this.value = h, this.length = 1;
    } else if (typeof h == "string")
      this.value = h, this.length = S.byteLength(h);
    else if (S.isBuffer(h))
      this.value = h, this.length = h.length;
    else
      return q.error("Unsupported type: " + typeof h);
  }
  return buffer$2.EncoderBuffer = U, U.prototype.join = function(h, q) {
    return h || (h = new S(this.length)), q || (q = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(A) {
      A.join(h, q), q += A.length;
    }) : (typeof this.value == "number" ? h[q] = this.value : typeof this.value == "string" ? h.write(this.value, q) : S.isBuffer(this.value) && this.value.copy(h, q), q += this.length)), h;
  }, buffer$2;
}
var node$1, hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1)
    return node$1;
  hasRequiredNode$1 = 1;
  var e = requireBase$2().Reporter, o = requireBase$2().EncoderBuffer, S = requireBase$2().DecoderBuffer, g = requireMinimalisticAssert$1(), U = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], h = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(U), q = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function A(I, B) {
    var H = {};
    this._baseState = H, H.enc = I, H.parent = B || null, H.children = null, H.tag = null, H.args = null, H.reverseArgs = null, H.choice = null, H.optional = !1, H.any = !1, H.obj = !1, H.use = null, H.useDecoder = null, H.key = null, H.default = null, H.explicit = null, H.implicit = null, H.contains = null, H.parent || (H.children = [], this._wrap());
  }
  node$1 = A;
  var P = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return A.prototype.clone = function() {
    var I = this._baseState, B = {};
    P.forEach(function(V) {
      B[V] = I[V];
    });
    var H = new this.constructor(B.parent);
    return H._baseState = B, H;
  }, A.prototype._wrap = function() {
    var I = this._baseState;
    h.forEach(function(B) {
      this[B] = function() {
        var H = new this.constructor(this);
        return I.children.push(H), H[B].apply(H, arguments);
      };
    }, this);
  }, A.prototype._init = function(I) {
    var B = this._baseState;
    g(B.parent === null), I.call(this), B.children = B.children.filter(function(H) {
      return H._baseState.parent === this;
    }, this), g.equal(B.children.length, 1, "Root node can have only one child");
  }, A.prototype._useArgs = function(I) {
    var B = this._baseState, H = I.filter(function(V) {
      return V instanceof this.constructor;
    }, this);
    I = I.filter(function(V) {
      return !(V instanceof this.constructor);
    }, this), H.length !== 0 && (g(B.children === null), B.children = H, H.forEach(function(V) {
      V._baseState.parent = this;
    }, this)), I.length !== 0 && (g(B.args === null), B.args = I, B.reverseArgs = I.map(function(V) {
      if (typeof V != "object" || V.constructor !== Object)
        return V;
      var X = {};
      return Object.keys(V).forEach(function(Q) {
        Q == (Q | 0) && (Q |= 0);
        var ee = V[Q];
        X[ee] = Q;
      }), X;
    }));
  }, q.forEach(function(I) {
    A.prototype[I] = function() {
      var B = this._baseState;
      throw new Error(I + " not implemented for encoding: " + B.enc);
    };
  }), U.forEach(function(I) {
    A.prototype[I] = function() {
      var B = this._baseState, H = Array.prototype.slice.call(arguments);
      return g(B.tag === null), B.tag = I, this._useArgs(H), this;
    };
  }), A.prototype.use = function(I) {
    g(I);
    var B = this._baseState;
    return g(B.use === null), B.use = I, this;
  }, A.prototype.optional = function() {
    var I = this._baseState;
    return I.optional = !0, this;
  }, A.prototype.def = function(I) {
    var B = this._baseState;
    return g(B.default === null), B.default = I, B.optional = !0, this;
  }, A.prototype.explicit = function(I) {
    var B = this._baseState;
    return g(B.explicit === null && B.implicit === null), B.explicit = I, this;
  }, A.prototype.implicit = function(I) {
    var B = this._baseState;
    return g(B.explicit === null && B.implicit === null), B.implicit = I, this;
  }, A.prototype.obj = function() {
    var I = this._baseState, B = Array.prototype.slice.call(arguments);
    return I.obj = !0, B.length !== 0 && this._useArgs(B), this;
  }, A.prototype.key = function(I) {
    var B = this._baseState;
    return g(B.key === null), B.key = I, this;
  }, A.prototype.any = function() {
    var I = this._baseState;
    return I.any = !0, this;
  }, A.prototype.choice = function(I) {
    var B = this._baseState;
    return g(B.choice === null), B.choice = I, this._useArgs(Object.keys(I).map(function(H) {
      return I[H];
    })), this;
  }, A.prototype.contains = function(I) {
    var B = this._baseState;
    return g(B.use === null), B.contains = I, this;
  }, A.prototype._decode = function(I, B) {
    var H = this._baseState;
    if (H.parent === null)
      return I.wrapResult(H.children[0]._decode(I, B));
    var V = H.default, X = !0, Q = null;
    if (H.key !== null && (Q = I.enterKey(H.key)), H.optional) {
      var ee = null;
      if (H.explicit !== null ? ee = H.explicit : H.implicit !== null ? ee = H.implicit : H.tag !== null && (ee = H.tag), ee === null && !H.any) {
        var ie = I.save();
        try {
          H.choice === null ? this._decodeGeneric(H.tag, I, B) : this._decodeChoice(I, B), X = !0;
        } catch {
          X = !1;
        }
        I.restore(ie);
      } else if (X = this._peekTag(I, ee, H.any), I.isError(X))
        return X;
    }
    var te;
    if (H.obj && X && (te = I.enterObject()), X) {
      if (H.explicit !== null) {
        var se = this._decodeTag(I, H.explicit);
        if (I.isError(se))
          return se;
        I = se;
      }
      var le = I.offset;
      if (H.use === null && H.choice === null) {
        if (H.any)
          var ie = I.save();
        var ce = this._decodeTag(
          I,
          H.implicit !== null ? H.implicit : H.tag,
          H.any
        );
        if (I.isError(ce))
          return ce;
        H.any ? V = I.raw(ie) : I = ce;
      }
      if (B && B.track && H.tag !== null && B.track(I.path(), le, I.length, "tagged"), B && B.track && H.tag !== null && B.track(I.path(), I.offset, I.length, "content"), H.any ? V = V : H.choice === null ? V = this._decodeGeneric(H.tag, I, B) : V = this._decodeChoice(I, B), I.isError(V))
        return V;
      if (!H.any && H.choice === null && H.children !== null && H.children.forEach(function(me) {
        me._decode(I, B);
      }), H.contains && (H.tag === "octstr" || H.tag === "bitstr")) {
        var pe = new S(V);
        V = this._getUse(H.contains, I._reporterState.obj)._decode(pe, B);
      }
    }
    return H.obj && X && (V = I.leaveObject(te)), H.key !== null && (V !== null || X === !0) ? I.leaveKey(Q, H.key, V) : Q !== null && I.exitKey(Q), V;
  }, A.prototype._decodeGeneric = function(I, B, H) {
    var V = this._baseState;
    return I === "seq" || I === "set" ? null : I === "seqof" || I === "setof" ? this._decodeList(B, I, V.args[0], H) : /str$/.test(I) ? this._decodeStr(B, I, H) : I === "objid" && V.args ? this._decodeObjid(B, V.args[0], V.args[1], H) : I === "objid" ? this._decodeObjid(B, null, null, H) : I === "gentime" || I === "utctime" ? this._decodeTime(B, I, H) : I === "null_" ? this._decodeNull(B, H) : I === "bool" ? this._decodeBool(B, H) : I === "objDesc" ? this._decodeStr(B, I, H) : I === "int" || I === "enum" ? this._decodeInt(B, V.args && V.args[0], H) : V.use !== null ? this._getUse(V.use, B._reporterState.obj)._decode(B, H) : B.error("unknown tag: " + I);
  }, A.prototype._getUse = function(I, B) {
    var H = this._baseState;
    return H.useDecoder = this._use(I, B), g(H.useDecoder._baseState.parent === null), H.useDecoder = H.useDecoder._baseState.children[0], H.implicit !== H.useDecoder._baseState.implicit && (H.useDecoder = H.useDecoder.clone(), H.useDecoder._baseState.implicit = H.implicit), H.useDecoder;
  }, A.prototype._decodeChoice = function(I, B) {
    var H = this._baseState, V = null, X = !1;
    return Object.keys(H.choice).some(function(Q) {
      var ee = I.save(), ie = H.choice[Q];
      try {
        var te = ie._decode(I, B);
        if (I.isError(te))
          return !1;
        V = { type: Q, value: te }, X = !0;
      } catch {
        return I.restore(ee), !1;
      }
      return !0;
    }, this), X ? V : I.error("Choice not matched");
  }, A.prototype._createEncoderBuffer = function(I) {
    return new o(I, this.reporter);
  }, A.prototype._encode = function(I, B, H) {
    var V = this._baseState;
    if (!(V.default !== null && V.default === I)) {
      var X = this._encodeValue(I, B, H);
      if (X !== void 0 && !this._skipDefault(X, B, H))
        return X;
    }
  }, A.prototype._encodeValue = function(I, B, H) {
    var V = this._baseState;
    if (V.parent === null)
      return V.children[0]._encode(I, B || new e());
    var ie = null;
    if (this.reporter = B, V.optional && I === void 0)
      if (V.default !== null)
        I = V.default;
      else
        return;
    var X = null, Q = !1;
    if (V.any)
      ie = this._createEncoderBuffer(I);
    else if (V.choice)
      ie = this._encodeChoice(I, B);
    else if (V.contains)
      X = this._getUse(V.contains, H)._encode(I, B), Q = !0;
    else if (V.children)
      X = V.children.map(function(le) {
        if (le._baseState.tag === "null_")
          return le._encode(null, B, I);
        if (le._baseState.key === null)
          return B.error("Child should have a key");
        var ce = B.enterKey(le._baseState.key);
        if (typeof I != "object")
          return B.error("Child expected, but input is not object");
        var pe = le._encode(I[le._baseState.key], B, I);
        return B.leaveKey(ce), pe;
      }, this).filter(function(le) {
        return le;
      }), X = this._createEncoderBuffer(X);
    else if (V.tag === "seqof" || V.tag === "setof") {
      if (!(V.args && V.args.length === 1))
        return B.error("Too many args for : " + V.tag);
      if (!Array.isArray(I))
        return B.error("seqof/setof, but data is not Array");
      var ee = this.clone();
      ee._baseState.implicit = null, X = this._createEncoderBuffer(I.map(function(le) {
        var ce = this._baseState;
        return this._getUse(ce.args[0], I)._encode(le, B);
      }, ee));
    } else
      V.use !== null ? ie = this._getUse(V.use, H)._encode(I, B) : (X = this._encodePrimitive(V.tag, I), Q = !0);
    var ie;
    if (!V.any && V.choice === null) {
      var te = V.implicit !== null ? V.implicit : V.tag, se = V.implicit === null ? "universal" : "context";
      te === null ? V.use === null && B.error("Tag could be omitted only for .use()") : V.use === null && (ie = this._encodeComposite(te, Q, se, X));
    }
    return V.explicit !== null && (ie = this._encodeComposite(V.explicit, !1, "context", ie)), ie;
  }, A.prototype._encodeChoice = function(I, B) {
    var H = this._baseState, V = H.choice[I.type];
    return V || g(
      !1,
      I.type + " not found in " + JSON.stringify(Object.keys(H.choice))
    ), V._encode(I.value, B);
  }, A.prototype._encodePrimitive = function(I, B) {
    var H = this._baseState;
    if (/str$/.test(I))
      return this._encodeStr(B, I);
    if (I === "objid" && H.args)
      return this._encodeObjid(B, H.reverseArgs[0], H.args[1]);
    if (I === "objid")
      return this._encodeObjid(B, null, null);
    if (I === "gentime" || I === "utctime")
      return this._encodeTime(B, I);
    if (I === "null_")
      return this._encodeNull();
    if (I === "int" || I === "enum")
      return this._encodeInt(B, H.args && H.reverseArgs[0]);
    if (I === "bool")
      return this._encodeBool(B);
    if (I === "objDesc")
      return this._encodeStr(B, I);
    throw new Error("Unsupported tag: " + I);
  }, A.prototype._isNumstr = function(I) {
    return /^[0-9 ]*$/.test(I);
  }, A.prototype._isPrintstr = function(I) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(I);
  }, node$1;
}
var hasRequiredBase$2;
function requireBase$2() {
  return hasRequiredBase$2 || (hasRequiredBase$2 = 1, function(e) {
    var o = e;
    o.Reporter = requireReporter$1().Reporter, o.DecoderBuffer = requireBuffer$2().DecoderBuffer, o.EncoderBuffer = requireBuffer$2().EncoderBuffer, o.Node = requireNode$1();
  }(base$2)), base$2;
}
var constants$5 = {}, der$1 = {}, hasRequiredDer$2$1;
function requireDer$2$1() {
  return hasRequiredDer$2$1 || (hasRequiredDer$2$1 = 1, function(e) {
    var o = requireConstants$2();
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = o._reverse(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = o._reverse(e.tag);
  }(der$1)), der$1;
}
var hasRequiredConstants$2;
function requireConstants$2() {
  return hasRequiredConstants$2 || (hasRequiredConstants$2 = 1, function(e) {
    var o = e;
    o._reverse = function(S) {
      var g = {};
      return Object.keys(S).forEach(function(U) {
        (U | 0) == U && (U = U | 0);
        var h = S[U];
        g[h] = U;
      }), g;
    }, o.der = requireDer$2$1();
  }(constants$5)), constants$5;
}
var decoders$1 = {}, der_1$1$1, hasRequiredDer$1$1;
function requireDer$1$1() {
  if (hasRequiredDer$1$1)
    return der_1$1$1;
  hasRequiredDer$1$1 = 1;
  var e = requireInherits_browser$1(), o = requireAsn1$1$1(), S = o.base, g = o.bignum, U = o.constants.der;
  function h(I) {
    this.enc = "der", this.name = I.name, this.entity = I, this.tree = new q(), this.tree._init(I.body);
  }
  der_1$1$1 = h, h.prototype.decode = function(I, B) {
    return I instanceof S.DecoderBuffer || (I = new S.DecoderBuffer(I, B)), this.tree._decode(I, B);
  };
  function q(I) {
    S.Node.call(this, "der", I);
  }
  e(q, S.Node), q.prototype._peekTag = function(I, B, H) {
    if (I.isEmpty())
      return !1;
    var V = I.save(), X = A(I, 'Failed to peek tag: "' + B + '"');
    return I.isError(X) ? X : (I.restore(V), X.tag === B || X.tagStr === B || X.tagStr + "of" === B || H);
  }, q.prototype._decodeTag = function(I, B, H) {
    var V = A(
      I,
      'Failed to decode tag of "' + B + '"'
    );
    if (I.isError(V))
      return V;
    var X = P(
      I,
      V.primitive,
      'Failed to get length of "' + B + '"'
    );
    if (I.isError(X))
      return X;
    if (!H && V.tag !== B && V.tagStr !== B && V.tagStr + "of" !== B)
      return I.error('Failed to match tag: "' + B + '"');
    if (V.primitive || X !== null)
      return I.skip(X, 'Failed to match body of: "' + B + '"');
    var Q = I.save(), ee = this._skipUntilEnd(
      I,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return I.isError(ee) ? ee : (X = I.offset - Q.offset, I.restore(Q), I.skip(X, 'Failed to match body of: "' + B + '"'));
  }, q.prototype._skipUntilEnd = function(I, B) {
    for (; ; ) {
      var H = A(I, B);
      if (I.isError(H))
        return H;
      var V = P(I, H.primitive, B);
      if (I.isError(V))
        return V;
      var X;
      if (H.primitive || V !== null ? X = I.skip(V) : X = this._skipUntilEnd(I, B), I.isError(X))
        return X;
      if (H.tagStr === "end")
        break;
    }
  }, q.prototype._decodeList = function(I, B, H, V) {
    for (var X = []; !I.isEmpty(); ) {
      var Q = this._peekTag(I, "end");
      if (I.isError(Q))
        return Q;
      var ee = H.decode(I, "der", V);
      if (I.isError(ee) && Q)
        break;
      X.push(ee);
    }
    return X;
  }, q.prototype._decodeStr = function(I, B) {
    if (B === "bitstr") {
      var H = I.readUInt8();
      return I.isError(H) ? H : { unused: H, data: I.raw() };
    } else if (B === "bmpstr") {
      var V = I.raw();
      if (V.length % 2 === 1)
        return I.error("Decoding of string type: bmpstr length mismatch");
      for (var X = "", Q = 0; Q < V.length / 2; Q++)
        X += String.fromCharCode(V.readUInt16BE(Q * 2));
      return X;
    } else if (B === "numstr") {
      var ee = I.raw().toString("ascii");
      return this._isNumstr(ee) ? ee : I.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (B === "octstr" || B === "objDesc")
        return I.raw();
      if (B === "printstr") {
        var ie = I.raw().toString("ascii");
        return this._isPrintstr(ie) ? ie : I.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(B) ? I.raw().toString() : I.error("Decoding of string type: " + B + " unsupported");
    }
  }, q.prototype._decodeObjid = function(I, B, H) {
    for (var V, X = [], Q = 0; !I.isEmpty(); ) {
      var ee = I.readUInt8();
      Q <<= 7, Q |= ee & 127, ee & 128 || (X.push(Q), Q = 0);
    }
    ee & 128 && X.push(Q);
    var ie = X[0] / 40 | 0, te = X[0] % 40;
    if (H ? V = X : V = [ie, te].concat(X.slice(1)), B) {
      var se = B[V.join(" ")];
      se === void 0 && (se = B[V.join(".")]), se !== void 0 && (V = se);
    }
    return V;
  }, q.prototype._decodeTime = function(I, B) {
    var H = I.raw().toString();
    if (B === "gentime")
      var V = H.slice(0, 4) | 0, X = H.slice(4, 6) | 0, Q = H.slice(6, 8) | 0, ee = H.slice(8, 10) | 0, ie = H.slice(10, 12) | 0, te = H.slice(12, 14) | 0;
    else if (B === "utctime") {
      var V = H.slice(0, 2) | 0, X = H.slice(2, 4) | 0, Q = H.slice(4, 6) | 0, ee = H.slice(6, 8) | 0, ie = H.slice(8, 10) | 0, te = H.slice(10, 12) | 0;
      V < 70 ? V = 2e3 + V : V = 1900 + V;
    } else
      return I.error("Decoding " + B + " time is not supported yet");
    return Date.UTC(V, X - 1, Q, ee, ie, te, 0);
  }, q.prototype._decodeNull = function(I) {
    return null;
  }, q.prototype._decodeBool = function(I) {
    var B = I.readUInt8();
    return I.isError(B) ? B : B !== 0;
  }, q.prototype._decodeInt = function(I, B) {
    var H = I.raw(), V = new g(H);
    return B && (V = B[V.toString(10)] || V), V;
  }, q.prototype._use = function(I, B) {
    return typeof I == "function" && (I = I(B)), I._getDecoder("der").tree;
  };
  function A(I, B) {
    var H = I.readUInt8(B);
    if (I.isError(H))
      return H;
    var V = U.tagClass[H >> 6], X = (H & 32) === 0;
    if ((H & 31) === 31) {
      var Q = H;
      for (H = 0; (Q & 128) === 128; ) {
        if (Q = I.readUInt8(B), I.isError(Q))
          return Q;
        H <<= 7, H |= Q & 127;
      }
    } else
      H &= 31;
    var ee = U.tag[H];
    return {
      cls: V,
      primitive: X,
      tag: H,
      tagStr: ee
    };
  }
  function P(I, B, H) {
    var V = I.readUInt8(H);
    if (I.isError(V))
      return V;
    if (!B && V === 128)
      return null;
    if (!(V & 128))
      return V;
    var X = V & 127;
    if (X > 4)
      return I.error("length octect is too long");
    V = 0;
    for (var Q = 0; Q < X; Q++) {
      V <<= 8;
      var ee = I.readUInt8(H);
      if (I.isError(ee))
        return ee;
      V |= ee;
    }
    return V;
  }
  return der_1$1$1;
}
var pem$1$1, hasRequiredPem$1$1;
function requirePem$1$1() {
  if (hasRequiredPem$1$1)
    return pem$1$1;
  hasRequiredPem$1$1 = 1;
  var e = requireInherits_browser$1(), o = requireBuffer$1().Buffer, S = requireDer$1$1();
  function g(U) {
    S.call(this, U), this.enc = "pem";
  }
  return e(g, S), pem$1$1 = g, g.prototype.decode = function(U, h) {
    for (var q = U.toString().split(/[\r\n]+/g), A = h.label.toUpperCase(), P = /^-----(BEGIN|END) ([^-]+)-----$/, I = -1, B = -1, H = 0; H < q.length; H++) {
      var V = q[H].match(P);
      if (V !== null && V[2] === A)
        if (I === -1) {
          if (V[1] !== "BEGIN")
            break;
          I = H;
        } else {
          if (V[1] !== "END")
            break;
          B = H;
          break;
        }
    }
    if (I === -1 || B === -1)
      throw new Error("PEM section not found for: " + A);
    var X = q.slice(I + 1, B).join("");
    X.replace(/[^a-z0-9\+\/=]+/gi, "");
    var Q = new o(X, "base64");
    return S.prototype.decode.call(this, Q, h);
  }, pem$1$1;
}
var hasRequiredDecoders$1;
function requireDecoders$1() {
  return hasRequiredDecoders$1 || (hasRequiredDecoders$1 = 1, function(e) {
    var o = e;
    o.der = requireDer$1$1(), o.pem = requirePem$1$1();
  }(decoders$1)), decoders$1;
}
var encoders$1 = {}, der_1$2, hasRequiredDer$3;
function requireDer$3() {
  if (hasRequiredDer$3)
    return der_1$2;
  hasRequiredDer$3 = 1;
  var e = requireInherits_browser$1(), o = requireBuffer$1().Buffer, S = requireAsn1$1$1(), g = S.base, U = S.constants.der;
  function h(I) {
    this.enc = "der", this.name = I.name, this.entity = I, this.tree = new q(), this.tree._init(I.body);
  }
  der_1$2 = h, h.prototype.encode = function(I, B) {
    return this.tree._encode(I, B).join();
  };
  function q(I) {
    g.Node.call(this, "der", I);
  }
  e(q, g.Node), q.prototype._encodeComposite = function(I, B, H, V) {
    var X = P(I, B, H, this.reporter);
    if (V.length < 128) {
      var ie = new o(2);
      return ie[0] = X, ie[1] = V.length, this._createEncoderBuffer([ie, V]);
    }
    for (var Q = 1, ee = V.length; ee >= 256; ee >>= 8)
      Q++;
    var ie = new o(2 + Q);
    ie[0] = X, ie[1] = 128 | Q;
    for (var ee = 1 + Q, te = V.length; te > 0; ee--, te >>= 8)
      ie[ee] = te & 255;
    return this._createEncoderBuffer([ie, V]);
  }, q.prototype._encodeStr = function(I, B) {
    if (B === "bitstr")
      return this._createEncoderBuffer([I.unused | 0, I.data]);
    if (B === "bmpstr") {
      for (var H = new o(I.length * 2), V = 0; V < I.length; V++)
        H.writeUInt16BE(I.charCodeAt(V), V * 2);
      return this._createEncoderBuffer(H);
    } else
      return B === "numstr" ? this._isNumstr(I) ? this._createEncoderBuffer(I) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : B === "printstr" ? this._isPrintstr(I) ? this._createEncoderBuffer(I) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(B) ? this._createEncoderBuffer(I) : B === "objDesc" ? this._createEncoderBuffer(I) : this.reporter.error("Encoding of string type: " + B + " unsupported");
  }, q.prototype._encodeObjid = function(I, B, H) {
    if (typeof I == "string") {
      if (!B)
        return this.reporter.error("string objid given, but no values map found");
      if (!B.hasOwnProperty(I))
        return this.reporter.error("objid not found in values map");
      I = B[I].split(/[\s\.]+/g);
      for (var V = 0; V < I.length; V++)
        I[V] |= 0;
    } else if (Array.isArray(I)) {
      I = I.slice();
      for (var V = 0; V < I.length; V++)
        I[V] |= 0;
    }
    if (!Array.isArray(I))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(I));
    if (!H) {
      if (I[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      I.splice(0, 2, I[0] * 40 + I[1]);
    }
    for (var X = 0, V = 0; V < I.length; V++) {
      var Q = I[V];
      for (X++; Q >= 128; Q >>= 7)
        X++;
    }
    for (var ee = new o(X), ie = ee.length - 1, V = I.length - 1; V >= 0; V--) {
      var Q = I[V];
      for (ee[ie--] = Q & 127; (Q >>= 7) > 0; )
        ee[ie--] = 128 | Q & 127;
    }
    return this._createEncoderBuffer(ee);
  };
  function A(I) {
    return I < 10 ? "0" + I : I;
  }
  q.prototype._encodeTime = function(I, B) {
    var H, V = new Date(I);
    return B === "gentime" ? H = [
      A(V.getFullYear()),
      A(V.getUTCMonth() + 1),
      A(V.getUTCDate()),
      A(V.getUTCHours()),
      A(V.getUTCMinutes()),
      A(V.getUTCSeconds()),
      "Z"
    ].join("") : B === "utctime" ? H = [
      A(V.getFullYear() % 100),
      A(V.getUTCMonth() + 1),
      A(V.getUTCDate()),
      A(V.getUTCHours()),
      A(V.getUTCMinutes()),
      A(V.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + B + " time is not supported yet"), this._encodeStr(H, "octstr");
  }, q.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, q.prototype._encodeInt = function(I, B) {
    if (typeof I == "string") {
      if (!B)
        return this.reporter.error("String int or enum given, but no values map");
      if (!B.hasOwnProperty(I))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(I));
      I = B[I];
    }
    if (typeof I != "number" && !o.isBuffer(I)) {
      var H = I.toArray();
      !I.sign && H[0] & 128 && H.unshift(0), I = new o(H);
    }
    if (o.isBuffer(I)) {
      var V = I.length;
      I.length === 0 && V++;
      var X = new o(V);
      return I.copy(X), I.length === 0 && (X[0] = 0), this._createEncoderBuffer(X);
    }
    if (I < 128)
      return this._createEncoderBuffer(I);
    if (I < 256)
      return this._createEncoderBuffer([0, I]);
    for (var V = 1, Q = I; Q >= 256; Q >>= 8)
      V++;
    for (var X = new Array(V), Q = X.length - 1; Q >= 0; Q--)
      X[Q] = I & 255, I >>= 8;
    return X[0] & 128 && X.unshift(0), this._createEncoderBuffer(new o(X));
  }, q.prototype._encodeBool = function(I) {
    return this._createEncoderBuffer(I ? 255 : 0);
  }, q.prototype._use = function(I, B) {
    return typeof I == "function" && (I = I(B)), I._getEncoder("der").tree;
  }, q.prototype._skipDefault = function(I, B, H) {
    var V = this._baseState, X;
    if (V.default === null)
      return !1;
    var Q = I.join();
    if (V.defaultBuffer === void 0 && (V.defaultBuffer = this._encodeValue(V.default, B, H).join()), Q.length !== V.defaultBuffer.length)
      return !1;
    for (X = 0; X < Q.length; X++)
      if (Q[X] !== V.defaultBuffer[X])
        return !1;
    return !0;
  };
  function P(I, B, H, V) {
    var X;
    if (I === "seqof" ? I = "seq" : I === "setof" && (I = "set"), U.tagByName.hasOwnProperty(I))
      X = U.tagByName[I];
    else if (typeof I == "number" && (I | 0) === I)
      X = I;
    else
      return V.error("Unknown tag: " + I);
    return X >= 31 ? V.error("Multi-octet tag encoding unsupported") : (B || (X |= 32), X |= U.tagClassByName[H || "universal"] << 6, X);
  }
  return der_1$2;
}
var pem$2, hasRequiredPem$2;
function requirePem$2() {
  if (hasRequiredPem$2)
    return pem$2;
  hasRequiredPem$2 = 1;
  var e = requireInherits_browser$1(), o = requireDer$3();
  function S(g) {
    o.call(this, g), this.enc = "pem";
  }
  return e(S, o), pem$2 = S, S.prototype.encode = function(g, U) {
    for (var h = o.prototype.encode.call(this, g), q = h.toString("base64"), A = ["-----BEGIN " + U.label + "-----"], P = 0; P < q.length; P += 64)
      A.push(q.slice(P, P + 64));
    return A.push("-----END " + U.label + "-----"), A.join(`
`);
  }, pem$2;
}
var hasRequiredEncoders$1;
function requireEncoders$1() {
  return hasRequiredEncoders$1 || (hasRequiredEncoders$1 = 1, function(e) {
    var o = e;
    o.der = requireDer$3(), o.pem = requirePem$2();
  }(encoders$1)), encoders$1;
}
var hasRequiredAsn1$1$1;
function requireAsn1$1$1() {
  return hasRequiredAsn1$1$1 || (hasRequiredAsn1$1$1 = 1, function(e) {
    var o = e;
    o.bignum = requireBn$2(), o.define = requireApi$1().define, o.base = requireBase$2(), o.constants = requireConstants$2(), o.decoders = requireDecoders$1(), o.encoders = requireEncoders$1();
  }(asn1$2)), asn1$2;
}
var certificate$1, hasRequiredCertificate$1;
function requireCertificate$1() {
  if (hasRequiredCertificate$1)
    return certificate$1;
  hasRequiredCertificate$1 = 1;
  var e = requireAsn1$1$1(), o = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), S = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), g = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), U = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(g),
      this.key("subjectPublicKey").bitstr()
    );
  }), h = e.define("RelativeDistinguishedName", function() {
    this.setof(S);
  }), q = e.define("RDNSequence", function() {
    this.seqof(h);
  }), A = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(q)
    });
  }), P = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(o),
      this.key("notAfter").use(o)
    );
  }), I = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), B = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(g),
      this.key("issuer").use(A),
      this.key("validity").use(P),
      this.key("subject").use(A),
      this.key("subjectPublicKeyInfo").use(U),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(I).optional()
    );
  }), H = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(B),
      this.key("signatureAlgorithm").use(g),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate$1 = H, certificate$1;
}
var hasRequiredAsn1$2;
function requireAsn1$2() {
  if (hasRequiredAsn1$2)
    return asn1$1$1;
  hasRequiredAsn1$2 = 1;
  var e = requireAsn1$1$1();
  asn1$1$1.certificate = requireCertificate$1();
  var o = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1$1.RSAPrivateKey = o;
  var S = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1$1.RSAPublicKey = S;
  var g = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), U = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(g),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1$1.PublicKey = U;
  var h = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(g),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1$1.PrivateKey = h;
  var q = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1$1.EncryptedPrivateKey = q;
  var A = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1$1.DSAPrivateKey = A, asn1$1$1.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var P = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), I = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(P),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1$1.ECPrivateKey = I, asn1$1$1.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1$1;
}
const require$$1$3 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc$1, hasRequiredFixProc$1;
function requireFixProc$1() {
  if (hasRequiredFixProc$1)
    return fixProc$1;
  hasRequiredFixProc$1 = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, S = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, g = requireEvp_bytestokey$1(), U = requireBrowser$6$1(), h = requireSafeBuffer$1$1().Buffer;
  return fixProc$1 = function(q, A) {
    var P = q.toString(), I = P.match(e), B;
    if (I) {
      var H = "aes" + I[1], V = h.from(I[2], "hex"), X = h.from(I[3].replace(/[\r\n]/g, ""), "base64"), Q = g(A, V.slice(0, 8), parseInt(I[1], 10)).key, ee = [], ie = U.createDecipheriv(H, Q, V);
      ee.push(ie.update(X)), ee.push(ie.final()), B = h.concat(ee);
    } else {
      var te = P.match(S);
      B = h.from(te[2].replace(/[\r\n]/g, ""), "base64");
    }
    var se = P.match(o)[1];
    return {
      tag: se,
      data: B
    };
  }, fixProc$1;
}
var parseAsn1$1, hasRequiredParseAsn1$1;
function requireParseAsn1$1() {
  if (hasRequiredParseAsn1$1)
    return parseAsn1$1;
  hasRequiredParseAsn1$1 = 1;
  var e = requireAsn1$2(), o = require$$1$3, S = requireFixProc$1(), g = requireBrowser$6$1(), U = requireBrowser$7$1(), h = requireSafeBuffer$1$1().Buffer;
  function q(P, I) {
    var B = P.algorithm.decrypt.kde.kdeparams.salt, H = parseInt(P.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), V = o[P.algorithm.decrypt.cipher.algo.join(".")], X = P.algorithm.decrypt.cipher.iv, Q = P.subjectPrivateKey, ee = parseInt(V.split("-")[1], 10) / 8, ie = U.pbkdf2Sync(I, B, H, ee, "sha1"), te = g.createDecipheriv(V, ie, X), se = [];
    return se.push(te.update(Q)), se.push(te.final()), h.concat(se);
  }
  function A(P) {
    var I;
    typeof P == "object" && !h.isBuffer(P) && (I = P.passphrase, P = P.key), typeof P == "string" && (P = h.from(P));
    var B = S(P, I), H = B.tag, V = B.data, X, Q;
    switch (H) {
      case "CERTIFICATE":
        Q = e.certificate.decode(V, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (Q || (Q = e.PublicKey.decode(V, "der")), X = Q.algorithm.algorithm.join("."), X) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(Q.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return Q.subjectPrivateKey = Q.subjectPublicKey, {
              type: "ec",
              data: Q
            };
          case "1.2.840.10040.4.1":
            return Q.algorithm.params.pub_key = e.DSAparam.decode(Q.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: Q.algorithm.params
            };
          default:
            throw new Error("unknown key id " + X);
        }
      case "ENCRYPTED PRIVATE KEY":
        V = e.EncryptedPrivateKey.decode(V, "der"), V = q(V, I);
      case "PRIVATE KEY":
        switch (Q = e.PrivateKey.decode(V, "der"), X = Q.algorithm.algorithm.join("."), X) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(Q.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: Q.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(Q.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return Q.algorithm.params.priv_key = e.DSAparam.decode(Q.subjectPrivateKey, "der"), {
              type: "dsa",
              params: Q.algorithm.params
            };
          default:
            throw new Error("unknown key id " + X);
        }
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(V, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(V, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(V, "der")
        };
      case "EC PRIVATE KEY":
        return V = e.ECPrivateKey.decode(V, "der"), {
          curve: V.parameters.value,
          privateKey: V.privateKey
        };
      default:
        throw new Error("unknown key type " + H);
    }
  }
  return A.signature = e.signature, parseAsn1$1 = A, parseAsn1$1;
}
const require$$4$1 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1)
    return sign$2.exports;
  hasRequiredSign$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireBrowser$8$1(), S = requireBrowserifyRsa$1(), g = requireElliptic$1().ec, U = requireBn$3(), h = requireParseAsn1$1(), q = require$$4$1, A = 1;
  function P(te, se, le, ce, pe) {
    var me = h(se);
    if (me.curve) {
      if (ce !== "ecdsa" && ce !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return I(te, me);
    } else if (me.type === "dsa") {
      if (ce !== "dsa")
        throw new Error("wrong private key type");
      return B(te, me, le);
    }
    if (ce !== "rsa" && ce !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (se.padding !== void 0 && se.padding !== A)
      throw new Error("illegal or unsupported padding mode");
    te = e.concat([pe, te]);
    for (var Me = me.modulus.byteLength(), Ee = [0, 1]; te.length + Ee.length + 1 < Me; )
      Ee.push(255);
    Ee.push(0);
    for (var Re = -1; ++Re < te.length; )
      Ee.push(te[Re]);
    var Ne = S(Ee, me);
    return Ne;
  }
  function I(te, se) {
    var le = q[se.curve.join(".")];
    if (!le)
      throw new Error("unknown curve " + se.curve.join("."));
    var ce = new g(le), pe = ce.keyFromPrivate(se.privateKey), me = pe.sign(te);
    return e.from(me.toDER());
  }
  function B(te, se, le) {
    for (var ce = se.params.priv_key, pe = se.params.p, me = se.params.q, Me = se.params.g, Ee = new U(0), Re, Ne = X(te, me).mod(me), ne = !1, Y = V(ce, me, te, le); ne === !1; )
      Re = ee(me, Y, le), Ee = ie(Me, Re, pe, me), ne = Re.invm(me).imul(Ne.add(ce.mul(Ee))).mod(me), ne.cmpn(0) === 0 && (ne = !1, Ee = new U(0));
    return H(Ee, ne);
  }
  function H(te, se) {
    te = te.toArray(), se = se.toArray(), te[0] & 128 && (te = [0].concat(te)), se[0] & 128 && (se = [0].concat(se));
    var le = te.length + se.length + 4, ce = [
      48,
      le,
      2,
      te.length
    ];
    return ce = ce.concat(te, [2, se.length], se), e.from(ce);
  }
  function V(te, se, le, ce) {
    if (te = e.from(te.toArray()), te.length < se.byteLength()) {
      var pe = e.alloc(se.byteLength() - te.length);
      te = e.concat([pe, te]);
    }
    var me = le.length, Me = Q(le, se), Ee = e.alloc(me);
    Ee.fill(1);
    var Re = e.alloc(me);
    return Re = o(ce, Re).update(Ee).update(e.from([0])).update(te).update(Me).digest(), Ee = o(ce, Re).update(Ee).digest(), Re = o(ce, Re).update(Ee).update(e.from([1])).update(te).update(Me).digest(), Ee = o(ce, Re).update(Ee).digest(), { k: Re, v: Ee };
  }
  function X(te, se) {
    var le = new U(te), ce = (te.length << 3) - se.bitLength();
    return ce > 0 && le.ishrn(ce), le;
  }
  function Q(te, se) {
    te = X(te, se), te = te.mod(se);
    var le = e.from(te.toArray());
    if (le.length < se.byteLength()) {
      var ce = e.alloc(se.byteLength() - le.length);
      le = e.concat([ce, le]);
    }
    return le;
  }
  function ee(te, se, le) {
    var ce, pe;
    do {
      for (ce = e.alloc(0); ce.length * 8 < te.bitLength(); )
        se.v = o(le, se.k).update(se.v).digest(), ce = e.concat([ce, se.v]);
      pe = X(ce, te), se.k = o(le, se.k).update(se.v).update(e.from([0])).digest(), se.v = o(le, se.k).update(se.v).digest();
    } while (pe.cmp(te) !== -1);
    return pe;
  }
  function ie(te, se, le, ce) {
    return te.toRed(U.mont(le)).redPow(se).fromRed().mod(ce);
  }
  return sign$2.exports = P, sign$2.exports.getKey = V, sign$2.exports.makeKey = ee, sign$2.exports;
}
var verify_1$1, hasRequiredVerify$1;
function requireVerify$1() {
  if (hasRequiredVerify$1)
    return verify_1$1;
  hasRequiredVerify$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireBn$3(), S = requireElliptic$1().ec, g = requireParseAsn1$1(), U = require$$4$1;
  function h(I, B, H, V, X) {
    var Q = g(H);
    if (Q.type === "ec") {
      if (V !== "ecdsa" && V !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return q(I, B, Q);
    } else if (Q.type === "dsa") {
      if (V !== "dsa")
        throw new Error("wrong public key type");
      return A(I, B, Q);
    }
    if (V !== "rsa" && V !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    B = e.concat([X, B]);
    for (var ee = Q.modulus.byteLength(), ie = [1], te = 0; B.length + ie.length + 2 < ee; )
      ie.push(255), te += 1;
    ie.push(0);
    for (var se = -1; ++se < B.length; )
      ie.push(B[se]);
    ie = e.from(ie);
    var le = o.mont(Q.modulus);
    I = new o(I).toRed(le), I = I.redPow(new o(Q.publicExponent)), I = e.from(I.fromRed().toArray());
    var ce = te < 8 ? 1 : 0;
    for (ee = Math.min(I.length, ie.length), I.length !== ie.length && (ce = 1), se = -1; ++se < ee; )
      ce |= I[se] ^ ie[se];
    return ce === 0;
  }
  function q(I, B, H) {
    var V = U[H.data.algorithm.curve.join(".")];
    if (!V)
      throw new Error("unknown curve " + H.data.algorithm.curve.join("."));
    var X = new S(V), Q = H.data.subjectPrivateKey.data;
    return X.verify(B, I, Q);
  }
  function A(I, B, H) {
    var V = H.data.p, X = H.data.q, Q = H.data.g, ee = H.data.pub_key, ie = g.signature.decode(I, "der"), te = ie.s, se = ie.r;
    P(te, X), P(se, X);
    var le = o.mont(V), ce = te.invm(X), pe = Q.toRed(le).redPow(new o(B).mul(ce).mod(X)).fromRed().mul(ee.toRed(le).redPow(se.mul(ce).mod(X)).fromRed()).mod(V).mod(X);
    return pe.cmp(se) === 0;
  }
  function P(I, B) {
    if (I.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (I.cmp(B) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1$1 = h, verify_1$1;
}
var browser$3$1, hasRequiredBrowser$3$1;
function requireBrowser$3$1() {
  if (hasRequiredBrowser$3$1)
    return browser$3$1;
  hasRequiredBrowser$3$1 = 1;
  var e = requireSafeBuffer$1$1().Buffer, o = requireBrowser$9$1(), S = requireReadableBrowser$2(), g = requireInherits_browser$1(), U = requireSign$1(), h = requireVerify$1(), q = require$$6$1;
  Object.keys(q).forEach(function(H) {
    q[H].id = e.from(q[H].id, "hex"), q[H.toLowerCase()] = q[H];
  });
  function A(H) {
    S.Writable.call(this);
    var V = q[H];
    if (!V)
      throw new Error("Unknown message digest");
    this._hashType = V.hash, this._hash = o(V.hash), this._tag = V.id, this._signType = V.sign;
  }
  g(A, S.Writable), A.prototype._write = function(H, V, X) {
    this._hash.update(H), X();
  }, A.prototype.update = function(H, V) {
    return this._hash.update(typeof H == "string" ? e.from(H, V) : H), this;
  }, A.prototype.sign = function(H, V) {
    this.end();
    var X = this._hash.digest(), Q = U(X, H, this._hashType, this._signType, this._tag);
    return V ? Q.toString(V) : Q;
  };
  function P(H) {
    S.Writable.call(this);
    var V = q[H];
    if (!V)
      throw new Error("Unknown message digest");
    this._hash = o(V.hash), this._tag = V.id, this._signType = V.sign;
  }
  g(P, S.Writable), P.prototype._write = function(H, V, X) {
    this._hash.update(H), X();
  }, P.prototype.update = function(H, V) {
    return this._hash.update(typeof H == "string" ? e.from(H, V) : H), this;
  }, P.prototype.verify = function(H, V, X) {
    var Q = typeof V == "string" ? e.from(V, X) : V;
    this.end();
    var ee = this._hash.digest();
    return h(Q, ee, H, this._signType, this._tag);
  };
  function I(H) {
    return new A(H);
  }
  function B(H) {
    return new P(H);
  }
  return browser$3$1 = {
    Sign: I,
    Verify: B,
    createSign: I,
    createVerify: B
  }, browser$3$1;
}
var browser$2$1, hasRequiredBrowser$2$1;
function requireBrowser$2$1() {
  if (hasRequiredBrowser$2$1)
    return browser$2$1;
  hasRequiredBrowser$2$1 = 1;
  var e = requireElliptic$1(), o = requireBn$2();
  browser$2$1 = function(h) {
    return new g(h);
  };
  var S = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  S.p224 = S.secp224r1, S.p256 = S.secp256r1 = S.prime256v1, S.p192 = S.secp192r1 = S.prime192v1, S.p384 = S.secp384r1, S.p521 = S.secp521r1;
  function g(h) {
    this.curveType = S[h], this.curveType || (this.curveType = {
      name: h
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  g.prototype.generateKeys = function(h, q) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(h, q);
  }, g.prototype.computeSecret = function(h, q, A) {
    q = q || "utf8", bufferExports.Buffer.isBuffer(h) || (h = new bufferExports.Buffer(h, q));
    var P = this.curve.keyFromPublic(h).getPublic(), I = P.mul(this.keys.getPrivate()).getX();
    return U(I, A, this.curveType.byteLength);
  }, g.prototype.getPublicKey = function(h, q) {
    var A = this.keys.getPublic(q === "compressed", !0);
    return q === "hybrid" && (A[A.length - 1] % 2 ? A[0] = 7 : A[0] = 6), U(A, h);
  }, g.prototype.getPrivateKey = function(h) {
    return U(this.keys.getPrivate(), h);
  }, g.prototype.setPublicKey = function(h, q) {
    return q = q || "utf8", bufferExports.Buffer.isBuffer(h) || (h = new bufferExports.Buffer(h, q)), this.keys._importPublic(h), this;
  }, g.prototype.setPrivateKey = function(h, q) {
    q = q || "utf8", bufferExports.Buffer.isBuffer(h) || (h = new bufferExports.Buffer(h, q));
    var A = new o(h);
    return A = A.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(A), this;
  };
  function U(h, q, A) {
    Array.isArray(h) || (h = h.toArray());
    var P = new bufferExports.Buffer(h);
    if (A && P.length < A) {
      var I = new bufferExports.Buffer(A - P.length);
      I.fill(0), P = bufferExports.Buffer.concat([I, P]);
    }
    return q ? P.toString(q) : P;
  }
  return browser$2$1;
}
var browser$1$1 = {}, mgf$1, hasRequiredMgf$1;
function requireMgf$1() {
  if (hasRequiredMgf$1)
    return mgf$1;
  hasRequiredMgf$1 = 1;
  var e = requireBrowser$9$1(), o = requireSafeBuffer$1$1().Buffer;
  mgf$1 = function(g, U) {
    for (var h = o.alloc(0), q = 0, A; h.length < U; )
      A = S(q++), h = o.concat([h, e("sha1").update(g).update(A).digest()]);
    return h.slice(0, U);
  };
  function S(g) {
    var U = o.allocUnsafe(4);
    return U.writeUInt32BE(g, 0), U;
  }
  return mgf$1;
}
var xor$1, hasRequiredXor$1;
function requireXor$1() {
  return hasRequiredXor$1 || (hasRequiredXor$1 = 1, xor$1 = function(e, o) {
    for (var S = e.length, g = -1; ++g < S; )
      e[g] ^= o[g];
    return e;
  }), xor$1;
}
var withPublic_1$1, hasRequiredWithPublic$1;
function requireWithPublic$1() {
  if (hasRequiredWithPublic$1)
    return withPublic_1$1;
  hasRequiredWithPublic$1 = 1;
  var e = requireBn$2(), o = requireSafeBuffer$1$1().Buffer;
  function S(g, U) {
    return o.from(g.toRed(e.mont(U.modulus)).redPow(new e(U.publicExponent)).fromRed().toArray());
  }
  return withPublic_1$1 = S, withPublic_1$1;
}
var publicEncrypt$1, hasRequiredPublicEncrypt$1;
function requirePublicEncrypt$1() {
  if (hasRequiredPublicEncrypt$1)
    return publicEncrypt$1;
  hasRequiredPublicEncrypt$1 = 1;
  var e = requireParseAsn1$1(), o = requireBrowser$b$1(), S = requireBrowser$9$1(), g = requireMgf$1(), U = requireXor$1(), h = requireBn$2(), q = requireWithPublic$1(), A = requireBrowserifyRsa$1(), P = requireSafeBuffer$1$1().Buffer;
  publicEncrypt$1 = function(V, X, Q) {
    var ee;
    V.padding ? ee = V.padding : Q ? ee = 1 : ee = 4;
    var ie = e(V), te;
    if (ee === 4)
      te = I(ie, X);
    else if (ee === 1)
      te = B(ie, X, Q);
    else if (ee === 3) {
      if (te = new h(X), te.cmp(ie.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return Q ? A(te, ie) : q(te, ie);
  };
  function I(V, X) {
    var Q = V.modulus.byteLength(), ee = X.length, ie = S("sha1").update(P.alloc(0)).digest(), te = ie.length, se = 2 * te;
    if (ee > Q - se - 2)
      throw new Error("message too long");
    var le = P.alloc(Q - ee - se - 2), ce = Q - te - 1, pe = o(te), me = U(P.concat([ie, le, P.alloc(1, 1), X], ce), g(pe, ce)), Me = U(pe, g(me, te));
    return new h(P.concat([P.alloc(1), Me, me], Q));
  }
  function B(V, X, Q) {
    var ee = X.length, ie = V.modulus.byteLength();
    if (ee > ie - 11)
      throw new Error("message too long");
    var te;
    return Q ? te = P.alloc(ie - ee - 3, 255) : te = H(ie - ee - 3), new h(P.concat([P.from([0, Q ? 1 : 2]), te, P.alloc(1), X], ie));
  }
  function H(V) {
    for (var X = P.allocUnsafe(V), Q = 0, ee = o(V * 2), ie = 0, te; Q < V; )
      ie === ee.length && (ee = o(V * 2), ie = 0), te = ee[ie++], te && (X[Q++] = te);
    return X;
  }
  return publicEncrypt$1;
}
var privateDecrypt$1, hasRequiredPrivateDecrypt$1;
function requirePrivateDecrypt$1() {
  if (hasRequiredPrivateDecrypt$1)
    return privateDecrypt$1;
  hasRequiredPrivateDecrypt$1 = 1;
  var e = requireParseAsn1$1(), o = requireMgf$1(), S = requireXor$1(), g = requireBn$2(), U = requireBrowserifyRsa$1(), h = requireBrowser$9$1(), q = requireWithPublic$1(), A = requireSafeBuffer$1$1().Buffer;
  privateDecrypt$1 = function(H, V, X) {
    var Q;
    H.padding ? Q = H.padding : X ? Q = 1 : Q = 4;
    var ee = e(H), ie = ee.modulus.byteLength();
    if (V.length > ie || new g(V).cmp(ee.modulus) >= 0)
      throw new Error("decryption error");
    var te;
    X ? te = q(new g(V), ee) : te = U(V, ee);
    var se = A.alloc(ie - te.length);
    if (te = A.concat([se, te], ie), Q === 4)
      return P(ee, te);
    if (Q === 1)
      return I(ee, te, X);
    if (Q === 3)
      return te;
    throw new Error("unknown padding");
  };
  function P(H, V) {
    var X = H.modulus.byteLength(), Q = h("sha1").update(A.alloc(0)).digest(), ee = Q.length;
    if (V[0] !== 0)
      throw new Error("decryption error");
    var ie = V.slice(1, ee + 1), te = V.slice(ee + 1), se = S(ie, o(te, ee)), le = S(te, o(se, X - ee - 1));
    if (B(Q, le.slice(0, ee)))
      throw new Error("decryption error");
    for (var ce = ee; le[ce] === 0; )
      ce++;
    if (le[ce++] !== 1)
      throw new Error("decryption error");
    return le.slice(ce);
  }
  function I(H, V, X) {
    for (var Q = V.slice(0, 2), ee = 2, ie = 0; V[ee++] !== 0; )
      if (ee >= V.length) {
        ie++;
        break;
      }
    var te = V.slice(2, ee - 1);
    if ((Q.toString("hex") !== "0002" && !X || Q.toString("hex") !== "0001" && X) && ie++, te.length < 8 && ie++, ie)
      throw new Error("decryption error");
    return V.slice(ee);
  }
  function B(H, V) {
    H = A.from(H), V = A.from(V);
    var X = 0, Q = H.length;
    H.length !== V.length && (X++, Q = Math.min(H.length, V.length));
    for (var ee = -1; ++ee < Q; )
      X += H[ee] ^ V[ee];
    return X;
  }
  return privateDecrypt$1;
}
var hasRequiredBrowser$1$1;
function requireBrowser$1$1() {
  return hasRequiredBrowser$1$1 || (hasRequiredBrowser$1$1 = 1, function(e) {
    e.publicEncrypt = requirePublicEncrypt$1(), e.privateDecrypt = requirePrivateDecrypt$1(), e.privateEncrypt = function(o, S) {
      return e.publicEncrypt(o, S, !0);
    }, e.publicDecrypt = function(o, S) {
      return e.privateDecrypt(o, S, !0);
    };
  }(browser$1$1)), browser$1$1;
}
var browser$e = {}, hasRequiredBrowser$d;
function requireBrowser$d() {
  if (hasRequiredBrowser$d)
    return browser$e;
  hasRequiredBrowser$d = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var o = requireSafeBuffer$1$1(), S = requireBrowser$b$1(), g = o.Buffer, U = o.kMaxLength, h = commonjsGlobal.crypto || commonjsGlobal.msCrypto, q = Math.pow(2, 32) - 1;
  function A(V, X) {
    if (typeof V != "number" || V !== V)
      throw new TypeError("offset must be a number");
    if (V > q || V < 0)
      throw new TypeError("offset must be a uint32");
    if (V > U || V > X)
      throw new RangeError("offset out of range");
  }
  function P(V, X, Q) {
    if (typeof V != "number" || V !== V)
      throw new TypeError("size must be a number");
    if (V > q || V < 0)
      throw new TypeError("size must be a uint32");
    if (V + X > Q || V > U)
      throw new RangeError("buffer too small");
  }
  h && h.getRandomValues || !process$1.browser ? (browser$e.randomFill = I, browser$e.randomFillSync = H) : (browser$e.randomFill = e, browser$e.randomFillSync = e);
  function I(V, X, Q, ee) {
    if (!g.isBuffer(V) && !(V instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof X == "function")
      ee = X, X = 0, Q = V.length;
    else if (typeof Q == "function")
      ee = Q, Q = V.length - X;
    else if (typeof ee != "function")
      throw new TypeError('"cb" argument must be a function');
    return A(X, V.length), P(Q, X, V.length), B(V, X, Q, ee);
  }
  function B(V, X, Q, ee) {
    if (process$1.browser) {
      var ie = V.buffer, te = new Uint8Array(ie, X, Q);
      if (h.getRandomValues(te), ee) {
        process$1.nextTick(function() {
          ee(null, V);
        });
        return;
      }
      return V;
    }
    if (ee) {
      S(Q, function(le, ce) {
        if (le)
          return ee(le);
        ce.copy(V, X), ee(null, V);
      });
      return;
    }
    var se = S(Q);
    return se.copy(V, X), V;
  }
  function H(V, X, Q) {
    if (typeof X > "u" && (X = 0), !g.isBuffer(V) && !(V instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return A(X, V.length), Q === void 0 && (Q = V.length - X), P(Q, X, V.length), B(V, X, Q);
  }
  return browser$e;
}
var hasRequiredCryptoBrowserify$1;
function requireCryptoBrowserify$1() {
  if (hasRequiredCryptoBrowserify$1)
    return cryptoBrowserify$1;
  hasRequiredCryptoBrowserify$1 = 1, cryptoBrowserify$1.randomBytes = cryptoBrowserify$1.rng = cryptoBrowserify$1.pseudoRandomBytes = cryptoBrowserify$1.prng = requireBrowser$b$1(), cryptoBrowserify$1.createHash = cryptoBrowserify$1.Hash = requireBrowser$9$1(), cryptoBrowserify$1.createHmac = cryptoBrowserify$1.Hmac = requireBrowser$8$1();
  var e = requireAlgos$1(), o = Object.keys(e), S = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(o);
  cryptoBrowserify$1.getHashes = function() {
    return S;
  };
  var g = requireBrowser$7$1();
  cryptoBrowserify$1.pbkdf2 = g.pbkdf2, cryptoBrowserify$1.pbkdf2Sync = g.pbkdf2Sync;
  var U = requireBrowser$5$1();
  cryptoBrowserify$1.Cipher = U.Cipher, cryptoBrowserify$1.createCipher = U.createCipher, cryptoBrowserify$1.Cipheriv = U.Cipheriv, cryptoBrowserify$1.createCipheriv = U.createCipheriv, cryptoBrowserify$1.Decipher = U.Decipher, cryptoBrowserify$1.createDecipher = U.createDecipher, cryptoBrowserify$1.Decipheriv = U.Decipheriv, cryptoBrowserify$1.createDecipheriv = U.createDecipheriv, cryptoBrowserify$1.getCiphers = U.getCiphers, cryptoBrowserify$1.listCiphers = U.listCiphers;
  var h = requireBrowser$4$1();
  cryptoBrowserify$1.DiffieHellmanGroup = h.DiffieHellmanGroup, cryptoBrowserify$1.createDiffieHellmanGroup = h.createDiffieHellmanGroup, cryptoBrowserify$1.getDiffieHellman = h.getDiffieHellman, cryptoBrowserify$1.createDiffieHellman = h.createDiffieHellman, cryptoBrowserify$1.DiffieHellman = h.DiffieHellman;
  var q = requireBrowser$3$1();
  cryptoBrowserify$1.createSign = q.createSign, cryptoBrowserify$1.Sign = q.Sign, cryptoBrowserify$1.createVerify = q.createVerify, cryptoBrowserify$1.Verify = q.Verify, cryptoBrowserify$1.createECDH = requireBrowser$2$1();
  var A = requireBrowser$1$1();
  cryptoBrowserify$1.publicEncrypt = A.publicEncrypt, cryptoBrowserify$1.privateEncrypt = A.privateEncrypt, cryptoBrowserify$1.publicDecrypt = A.publicDecrypt, cryptoBrowserify$1.privateDecrypt = A.privateDecrypt;
  var P = requireBrowser$d();
  return cryptoBrowserify$1.randomFill = P.randomFill, cryptoBrowserify$1.randomFillSync = P.randomFillSync, cryptoBrowserify$1.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify$1.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify$1;
}
(function(e) {
  /**
   * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/bcrypt.js for details
   */
  (function(o, S) {
    typeof commonjsRequire$1 == "function" && e && e.exports ? e.exports = S() : (o.dcodeIO = o.dcodeIO || {}).bcrypt = S();
  })(commonjsGlobal, function() {
    var o = {}, S = null;
    function g(ne) {
      if (e && e.exports)
        try {
          return requireCryptoBrowserify$1().randomBytes(ne);
        } catch {
        }
      try {
        var Y;
        return (self.crypto || self.msCrypto).getRandomValues(Y = new Uint32Array(ne)), Array.prototype.slice.call(Y);
      } catch {
      }
      if (!S)
        throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
      return S(ne);
    }
    var U = !1;
    try {
      g(1), U = !0;
    } catch {
    }
    S = null, o.setRandomFallback = function(ne) {
      S = ne;
    }, o.genSaltSync = function(ne, Y) {
      if (ne = ne || ee, typeof ne != "number")
        throw Error("Illegal arguments: " + typeof ne + ", " + typeof Y);
      ne < 4 ? ne = 4 : ne > 31 && (ne = 31);
      var M = [];
      return M.push("$2a$"), ne < 10 && M.push("0"), M.push(ne.toString()), M.push("$"), M.push(H(g(Q), Q)), M.join("");
    }, o.genSalt = function(ne, Y, M) {
      if (typeof Y == "function" && (M = Y, Y = void 0), typeof ne == "function" && (M = ne, ne = void 0), typeof ne > "u")
        ne = ee;
      else if (typeof ne != "number")
        throw Error("illegal arguments: " + typeof ne);
      function $(O) {
        q(function() {
          try {
            O(null, o.genSaltSync(ne));
          } catch (J) {
            O(J);
          }
        });
      }
      if (M) {
        if (typeof M != "function")
          throw Error("Illegal callback: " + typeof M);
        $(M);
      } else
        return new Promise(function(O, J) {
          $(function(Z, K) {
            if (Z) {
              J(Z);
              return;
            }
            O(K);
          });
        });
    }, o.hashSync = function(ne, Y) {
      if (typeof Y > "u" && (Y = ee), typeof Y == "number" && (Y = o.genSaltSync(Y)), typeof ne != "string" || typeof Y != "string")
        throw Error("Illegal arguments: " + typeof ne + ", " + typeof Y);
      return Ne(ne, Y);
    }, o.hash = function(ne, Y, M, $) {
      function O(J) {
        typeof ne == "string" && typeof Y == "number" ? o.genSalt(Y, function(Z, K) {
          Ne(ne, K, J, $);
        }) : typeof ne == "string" && typeof Y == "string" ? Ne(ne, Y, J, $) : q(J.bind(this, Error("Illegal arguments: " + typeof ne + ", " + typeof Y)));
      }
      if (M) {
        if (typeof M != "function")
          throw Error("Illegal callback: " + typeof M);
        O(M);
      } else
        return new Promise(function(J, Z) {
          O(function(K, z) {
            if (K) {
              Z(K);
              return;
            }
            J(z);
          });
        });
    };
    function h(ne, Y) {
      for (var M = 0, $ = 0, O = 0, J = ne.length; O < J; ++O)
        ne.charCodeAt(O) === Y.charCodeAt(O) ? ++M : ++$;
      return M < 0 ? !1 : $ === 0;
    }
    o.compareSync = function(ne, Y) {
      if (typeof ne != "string" || typeof Y != "string")
        throw Error("Illegal arguments: " + typeof ne + ", " + typeof Y);
      return Y.length !== 60 ? !1 : h(o.hashSync(ne, Y.substr(0, Y.length - 31)), Y);
    }, o.compare = function(ne, Y, M, $) {
      function O(J) {
        if (typeof ne != "string" || typeof Y != "string") {
          q(J.bind(this, Error("Illegal arguments: " + typeof ne + ", " + typeof Y)));
          return;
        }
        if (Y.length !== 60) {
          q(J.bind(this, null, !1));
          return;
        }
        o.hash(ne, Y.substr(0, 29), function(Z, K) {
          Z ? J(Z) : J(null, h(K, Y));
        }, $);
      }
      if (M) {
        if (typeof M != "function")
          throw Error("Illegal callback: " + typeof M);
        O(M);
      } else
        return new Promise(function(J, Z) {
          O(function(K, z) {
            if (K) {
              Z(K);
              return;
            }
            J(z);
          });
        });
    }, o.getRounds = function(ne) {
      if (typeof ne != "string")
        throw Error("Illegal arguments: " + typeof ne);
      return parseInt(ne.split("$")[2], 10);
    }, o.getSalt = function(ne) {
      if (typeof ne != "string")
        throw Error("Illegal arguments: " + typeof ne);
      if (ne.length !== 60)
        throw Error("Illegal hash length: " + ne.length + " != 60");
      return ne.substring(0, 29);
    };
    var q = typeof process$1 < "u" && process$1 && typeof process$1.nextTick == "function" ? typeof setImmediate == "function" ? setImmediate : process$1.nextTick : setTimeout;
    function A(ne) {
      var Y = [], M = 0;
      return X.encodeUTF16toUTF8(function() {
        return M >= ne.length ? null : ne.charCodeAt(M++);
      }, function($) {
        Y.push($);
      }), Y;
    }
    var P = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), I = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ], B = String.fromCharCode;
    function H(ne, Y) {
      var M = 0, $ = [], O, J;
      if (Y <= 0 || Y > ne.length)
        throw Error("Illegal len: " + Y);
      for (; M < Y; ) {
        if (O = ne[M++] & 255, $.push(P[O >> 2 & 63]), O = (O & 3) << 4, M >= Y) {
          $.push(P[O & 63]);
          break;
        }
        if (J = ne[M++] & 255, O |= J >> 4 & 15, $.push(P[O & 63]), O = (J & 15) << 2, M >= Y) {
          $.push(P[O & 63]);
          break;
        }
        J = ne[M++] & 255, O |= J >> 6 & 3, $.push(P[O & 63]), $.push(P[J & 63]);
      }
      return $.join("");
    }
    function V(ne, Y) {
      var M = 0, $ = ne.length, O = 0, J = [], Z, K, z, G, D, F;
      if (Y <= 0)
        throw Error("Illegal len: " + Y);
      for (; M < $ - 1 && O < Y && (F = ne.charCodeAt(M++), Z = F < I.length ? I[F] : -1, F = ne.charCodeAt(M++), K = F < I.length ? I[F] : -1, !(Z == -1 || K == -1 || (D = Z << 2 >>> 0, D |= (K & 48) >> 4, J.push(B(D)), ++O >= Y || M >= $) || (F = ne.charCodeAt(M++), z = F < I.length ? I[F] : -1, z == -1) || (D = (K & 15) << 4 >>> 0, D |= (z & 60) >> 2, J.push(B(D)), ++O >= Y || M >= $))); )
        F = ne.charCodeAt(M++), G = F < I.length ? I[F] : -1, D = (z & 3) << 6 >>> 0, D |= G, J.push(B(D)), ++O;
      var ae = [];
      for (M = 0; M < O; M++)
        ae.push(J[M].charCodeAt(0));
      return ae;
    }
    var X = function() {
      var ne = {};
      return ne.MAX_CODEPOINT = 1114111, ne.encodeUTF8 = function(Y, M) {
        var $ = null;
        for (typeof Y == "number" && ($ = Y, Y = function() {
          return null;
        }); $ !== null || ($ = Y()) !== null; )
          $ < 128 ? M($ & 127) : $ < 2048 ? (M($ >> 6 & 31 | 192), M($ & 63 | 128)) : $ < 65536 ? (M($ >> 12 & 15 | 224), M($ >> 6 & 63 | 128), M($ & 63 | 128)) : (M($ >> 18 & 7 | 240), M($ >> 12 & 63 | 128), M($ >> 6 & 63 | 128), M($ & 63 | 128)), $ = null;
      }, ne.decodeUTF8 = function(Y, M) {
        for (var $, O, J, Z, K = function(z) {
          z = z.slice(0, z.indexOf(null));
          var G = Error(z.toString());
          throw G.name = "TruncatedError", G.bytes = z, G;
        }; ($ = Y()) !== null; )
          if (!($ & 128))
            M($);
          else if (($ & 224) === 192)
            (O = Y()) === null && K([$, O]), M(($ & 31) << 6 | O & 63);
          else if (($ & 240) === 224)
            ((O = Y()) === null || (J = Y()) === null) && K([$, O, J]), M(($ & 15) << 12 | (O & 63) << 6 | J & 63);
          else if (($ & 248) === 240)
            ((O = Y()) === null || (J = Y()) === null || (Z = Y()) === null) && K([$, O, J, Z]), M(($ & 7) << 18 | (O & 63) << 12 | (J & 63) << 6 | Z & 63);
          else
            throw RangeError("Illegal starting byte: " + $);
      }, ne.UTF16toUTF8 = function(Y, M) {
        for (var $, O = null; ($ = O !== null ? O : Y()) !== null; ) {
          if ($ >= 55296 && $ <= 57343 && (O = Y()) !== null && O >= 56320 && O <= 57343) {
            M(($ - 55296) * 1024 + O - 56320 + 65536), O = null;
            continue;
          }
          M($);
        }
        O !== null && M(O);
      }, ne.UTF8toUTF16 = function(Y, M) {
        var $ = null;
        for (typeof Y == "number" && ($ = Y, Y = function() {
          return null;
        }); $ !== null || ($ = Y()) !== null; )
          $ <= 65535 ? M($) : ($ -= 65536, M(($ >> 10) + 55296), M($ % 1024 + 56320)), $ = null;
      }, ne.encodeUTF16toUTF8 = function(Y, M) {
        ne.UTF16toUTF8(Y, function($) {
          ne.encodeUTF8($, M);
        });
      }, ne.decodeUTF8toUTF16 = function(Y, M) {
        ne.decodeUTF8(Y, function($) {
          ne.UTF8toUTF16($, M);
        });
      }, ne.calculateCodePoint = function(Y) {
        return Y < 128 ? 1 : Y < 2048 ? 2 : Y < 65536 ? 3 : 4;
      }, ne.calculateUTF8 = function(Y) {
        for (var M, $ = 0; (M = Y()) !== null; )
          $ += ne.calculateCodePoint(M);
        return $;
      }, ne.calculateUTF16asUTF8 = function(Y) {
        var M = 0, $ = 0;
        return ne.UTF16toUTF8(Y, function(O) {
          ++M, $ += ne.calculateCodePoint(O);
        }), [M, $];
      }, ne;
    }();
    Date.now = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    };
    var Q = 16, ee = 10, ie = 16, te = 100, se = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ], le = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      290971e4,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409e3,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ], ce = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    function pe(ne, Y, M, $) {
      var O, J = ne[Y], Z = ne[Y + 1];
      return J ^= M[0], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[1], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[2], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[3], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[4], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[5], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[6], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[7], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[8], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[9], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[10], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[11], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[12], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[13], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[14], O = $[J >>> 24], O += $[256 | J >> 16 & 255], O ^= $[512 | J >> 8 & 255], O += $[768 | J & 255], Z ^= O ^ M[15], O = $[Z >>> 24], O += $[256 | Z >> 16 & 255], O ^= $[512 | Z >> 8 & 255], O += $[768 | Z & 255], J ^= O ^ M[16], ne[Y] = Z ^ M[ie + 1], ne[Y + 1] = J, ne;
    }
    function me(ne, Y) {
      for (var M = 0, $ = 0; M < 4; ++M)
        $ = $ << 8 | ne[Y] & 255, Y = (Y + 1) % ne.length;
      return { key: $, offp: Y };
    }
    function Me(ne, Y, M) {
      for (var $ = 0, O = [0, 0], J = Y.length, Z = M.length, K, z = 0; z < J; z++)
        K = me(ne, $), $ = K.offp, Y[z] = Y[z] ^ K.key;
      for (z = 0; z < J; z += 2)
        O = pe(O, 0, Y, M), Y[z] = O[0], Y[z + 1] = O[1];
      for (z = 0; z < Z; z += 2)
        O = pe(O, 0, Y, M), M[z] = O[0], M[z + 1] = O[1];
    }
    function Ee(ne, Y, M, $) {
      for (var O = 0, J = [0, 0], Z = M.length, K = $.length, z, G = 0; G < Z; G++)
        z = me(Y, O), O = z.offp, M[G] = M[G] ^ z.key;
      for (O = 0, G = 0; G < Z; G += 2)
        z = me(ne, O), O = z.offp, J[0] ^= z.key, z = me(ne, O), O = z.offp, J[1] ^= z.key, J = pe(J, 0, M, $), M[G] = J[0], M[G + 1] = J[1];
      for (G = 0; G < K; G += 2)
        z = me(ne, O), O = z.offp, J[0] ^= z.key, z = me(ne, O), O = z.offp, J[1] ^= z.key, J = pe(J, 0, M, $), $[G] = J[0], $[G + 1] = J[1];
    }
    function Re(ne, Y, M, $, O) {
      var J = ce.slice(), Z = J.length, K;
      if (M < 4 || M > 31)
        if (K = Error("Illegal number of rounds (4-31): " + M), $) {
          q($.bind(this, K));
          return;
        } else
          throw K;
      if (Y.length !== Q)
        if (K = Error("Illegal salt length: " + Y.length + " != " + Q), $) {
          q($.bind(this, K));
          return;
        } else
          throw K;
      M = 1 << M >>> 0;
      var z, G, D = 0, F;
      Int32Array ? (z = new Int32Array(se), G = new Int32Array(le)) : (z = se.slice(), G = le.slice()), Ee(Y, ne, z, G);
      function ae() {
        if (O && O(D / M), D < M)
          for (var xe = Date.now(); D < M && (D = D + 1, Me(ne, z, G), Me(Y, z, G), !(Date.now() - xe > te)); )
            ;
        else {
          for (D = 0; D < 64; D++)
            for (F = 0; F < Z >> 1; F++)
              pe(J, F << 1, z, G);
          var ye = [];
          for (D = 0; D < Z; D++)
            ye.push((J[D] >> 24 & 255) >>> 0), ye.push((J[D] >> 16 & 255) >>> 0), ye.push((J[D] >> 8 & 255) >>> 0), ye.push((J[D] & 255) >>> 0);
          if ($) {
            $(null, ye);
            return;
          } else
            return ye;
        }
        $ && q(ae);
      }
      if (typeof $ < "u")
        ae();
      else
        for (var ge; ; )
          if (typeof (ge = ae()) < "u")
            return ge || [];
    }
    function Ne(ne, Y, M, $) {
      var O;
      if (typeof ne != "string" || typeof Y != "string")
        if (O = Error("Invalid string / salt: Not a string"), M) {
          q(M.bind(this, O));
          return;
        } else
          throw O;
      var J, Z;
      if (Y.charAt(0) !== "$" || Y.charAt(1) !== "2")
        if (O = Error("Invalid salt version: " + Y.substring(0, 2)), M) {
          q(M.bind(this, O));
          return;
        } else
          throw O;
      if (Y.charAt(2) === "$")
        J = "\0", Z = 3;
      else {
        if (J = Y.charAt(2), J !== "a" && J !== "b" && J !== "y" || Y.charAt(3) !== "$")
          if (O = Error("Invalid salt revision: " + Y.substring(2, 4)), M) {
            q(M.bind(this, O));
            return;
          } else
            throw O;
        Z = 4;
      }
      if (Y.charAt(Z + 2) > "$")
        if (O = Error("Missing salt rounds"), M) {
          q(M.bind(this, O));
          return;
        } else
          throw O;
      var K = parseInt(Y.substring(Z, Z + 1), 10) * 10, z = parseInt(Y.substring(Z + 1, Z + 2), 10), G = K + z, D = Y.substring(Z + 3, Z + 25);
      ne += J >= "a" ? "\0" : "";
      var F = A(ne), ae = V(D, Q);
      function ge(xe) {
        var ye = [];
        return ye.push("$2"), J >= "a" && ye.push(J), ye.push("$"), G < 10 && ye.push("0"), ye.push(G.toString()), ye.push("$"), ye.push(H(ae, ae.length)), ye.push(H(xe, ce.length * 4 - 1)), ye.join("");
      }
      if (typeof M > "u")
        return ge(Re(F, ae, G));
      Re(F, ae, G, function(xe, ye) {
        xe ? M(xe, null) : M(null, ge(ye));
      }, $);
    }
    return o.encodeBase64 = H, o.decodeBase64 = V, o;
  });
})(bcrypt$1);
var bcryptExports = bcrypt$1.exports;
const bcrypt = /* @__PURE__ */ getDefaultExportFromCjs(bcryptExports);
class FirebaseAuthAPI {
  constructor(o) {
    this.FIREBASE_AUTH_URL = "https://identitytoolkit.googleapis.com/v1/", this.BCRYPT_SALT = "$2a$10$QCJoWqnN.acrjPIgKYCthu";
    const S = new URL(this.FIREBASE_AUTH_URL);
    this.firebaseKey = o.apiKey, this.fetcher = new FetchAPI(S.toString());
  }
  checkError(o) {
    if (o.error)
      throw new Error(
        `Error code: ${o.error.code}, message: ${o.error.message}`
      );
  }
  async signUpWithEmailPassword(o, S, g = !0) {
    let U = S;
    g && (U = bcrypt.hashSync(S, this.BCRYPT_SALT));
    const h = JSON.stringify({
      email: o,
      password: U,
      returnSecureToken: !0
    }), q = await this.fetcher.send({
      url: "accounts:signUp",
      method: "POST",
      data: h,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(q.data), q.data;
  }
  async signInWithEmailPassword(o, S, g = !0) {
    let U = S;
    g && (U = bcrypt.hashSync(S, this.BCRYPT_SALT));
    const h = JSON.stringify({
      email: o,
      password: U,
      returnSecureToken: !0
    }), q = await this.fetcher.send({
      url: "accounts:signInWithPassword",
      method: "POST",
      data: h,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(q.data), q.data;
  }
  async getCurrentUser(o) {
    const S = JSON.stringify({
      idToken: o
    }), g = await this.fetcher.send({
      url: "accounts:lookup",
      method: "POST",
      data: S,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(g.data), g.data;
  }
  async getRefreshIdToken(o) {
    const S = JSON.stringify({
      grant_type: "refresh_token",
      refresh_token: o
    }), g = await this.fetcher.send({
      url: "token",
      method: "POST",
      data: S,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    }), U = g.data;
    return this.checkError(g.data), U.id_token;
  }
  async resetPassword(o, S, g = !0) {
    let U = S;
    g && (U = bcrypt.hashSync(S, this.BCRYPT_SALT));
    const h = JSON.stringify({
      oobCode: o,
      newPassword: U
    }), q = await this.fetcher.send({
      url: "accounts:resetPassword",
      method: "POST",
      data: h,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(q.data), q.data;
  }
  async verifyEmail(o) {
    const S = JSON.stringify({
      oobCode: o
    }), g = await this.fetcher.send({
      url: "accounts:update",
      method: "POST",
      data: S,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(g.data), g.data;
  }
  async signInWithCustomToken(o) {
    const S = JSON.stringify({
      token: o,
      returnSecureToken: !0
    }), g = await this.fetcher.send({
      url: "accounts:signInWithCustomToken",
      data: S,
      query: {
        key: this.firebaseKey
      },
      method: "POST",
      withCredentials: !1
    });
    return this.checkError(g.data), {
      idToken: g.data.idToken,
      refreshToken: g.data.refreshToken
    };
  }
  async updatePassword(o, S) {
    const g = bcrypt.hashSync(S, this.BCRYPT_SALT), U = JSON.stringify({
      idToken: o,
      password: g,
      returnSecureToken: !0
    }), h = await this.fetcher.send({
      url: "accounts:update",
      method: "POST",
      data: U,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(h.data), h.data;
  }
}
var u$2 = (e, o, S) => {
  if (!o.has(e))
    throw TypeError("Cannot " + S);
}, i$1 = (e, o, S) => (u$2(e, o, "read from private field"), S ? S.call(e) : o.get(e)), n$1 = (e, o, S) => {
  if (o.has(e))
    throw TypeError("Cannot add the same private member more than once");
  o instanceof WeakSet ? o.add(e) : o.set(e, S);
}, l$2;
const s$1 = class dr {
  static getLocalStorageEnabled() {
    let o = !1;
    try {
      o = window.localStorage && !0;
    } catch {
      o = !1;
    }
    return o;
  }
  static setAllLocalStorage(o, S) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const g = JSON.stringify(S);
    localStorage.setItem(i$1(this, l$2) + o, g);
  }
  static setLocalStorage(o, S, g) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const U = this.getAllLocalStorage(o);
    if (U) {
      U[S] = g, localStorage.setItem(
        i$1(this, l$2) + o,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(U)
      );
      return;
    }
    const h = { [S]: g };
    localStorage.setItem(
      i$1(this, l$2) + o,
      // btoa(JSON.stringify(newData)),
      JSON.stringify(h)
    );
  }
  static getLocalStorage(o, S) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const g = this.getAllLocalStorage(o);
    try {
      if (g)
        return JSON.parse(g[S]);
    } catch {
      return g[S];
    }
  }
  static getAllLocalStorage(o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    try {
      return localStorage.getItem(i$1(this, l$2) + o) ? (
        // ? JSON.parse(atob(localStorage.getItem(this.#COOKIE_NAME + appId)))
        JSON.parse(localStorage.getItem(i$1(this, l$2) + o))
      ) : void 0;
    } catch {
      return;
    }
  }
  static clearLocalStorage(o, S) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    if (this.getLocalStorage(o, S)) {
      const g = this.getAllLocalStorage(o);
      delete g[S], localStorage.setItem(
        i$1(this, l$2) + o,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(g)
      );
    }
  }
  static clearAllLocalStorage(o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(i$1(this, l$2) + o);
  }
  static setLoginUserLocalStorage(o, S, g) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const U = {};
    return U["firebase:wepin"] = Object.assign(
      { provider: S == null ? void 0 : S.provider },
      S == null ? void 0 : S.token
    ), U["wepin:connectUser"] = {
      accessToken: g.token.access,
      refreshToken: g.token.refresh
    }, U.user_id = g.userInfo.userId, U.user_info = {
      status: "success",
      userInfo: {
        userId: g.userInfo.userId,
        email: g.userInfo.email,
        provider: S.provider,
        use2FA: g.userInfo.use2FA >= 2
      }
    }, U.user_status = {
      loginStatus: g.loginStatus,
      pinRequired: g.loginStatus === "registerRequired" ? g.pinRequired : !1
    }, g.loginStatus !== "pinRequired" && g.walletId && (U.wallet_id = g.walletId, U.user_info.walletId = g.walletId), U.oauth_provider_pending = S.provider, dr.setAllLocalStorage(o, U), {
      userInfo: U.user_info,
      connectUser: U["wepin:connectUser"]
    };
  }
};
l$2 = /* @__PURE__ */ new WeakMap(), s$1.platform = "web", n$1(s$1, l$2, "wepin:auth:");
let c$1 = s$1;
const isErrorResponse = (e) => {
  const o = e.statusCode !== void 0 || e.status !== void 0, S = e.timestamp !== void 0 && e.message !== void 0 && e.path !== void 0;
  return o && S;
}, getBaseUrl$1 = (e) => {
  if (e.slice(0, 8) === "ak_live_")
    return "https://sdk.wepin.io/v1";
  if (e.slice(0, 8) === "ak_test_")
    return "https://stage-sdk.wepin.io/v1";
  if (e.slice(0, 7) === "ak_dev_")
    return "https://dev-sdk.wepin.io/v1";
  if (e.slice(0, 13) === "local_ak_dev_")
    return "https://local-sdk.wepin.io/v1";
  throw new Error("Invalid appKey");
};
class APIRequest {
  constructor({
    data: o,
    headers: S,
    url: g,
    query: U,
    withCredentials: h = !1,
    method: q
  }) {
    this.data = o, this.headers = S, this.url = g, this.query = U, this.withCredentials = h, this.method = q;
  }
}
const APIEvents = {
  request: "request",
  response: "response"
};
let InvalidTokenError$1 = class extends Error {
};
InvalidTokenError$1.prototype.name = "InvalidTokenError";
function b64DecodeUnicode$1(e) {
  return decodeURIComponent(atob(e).replace(/(.)/g, (o, S) => {
    let g = S.charCodeAt(0).toString(16).toUpperCase();
    return g.length < 2 && (g = "0" + g), "%" + g;
  }));
}
function base64UrlDecode$1(e) {
  let o = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (o.length % 4) {
    case 0:
      break;
    case 2:
      o += "==";
      break;
    case 3:
      o += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode$1(o);
  } catch {
    return atob(o);
  }
}
function jwtDecode$1(e, o) {
  if (typeof e != "string")
    throw new InvalidTokenError$1("Invalid token specified: must be a string");
  o || (o = {});
  const S = o.header === !0 ? 0 : 1, g = e.split(".")[S];
  if (typeof g != "string")
    throw new InvalidTokenError$1(`Invalid token specified: missing part #${S + 1}`);
  let U;
  try {
    U = base64UrlDecode$1(g);
  } catch (h) {
    throw new InvalidTokenError$1(`Invalid token specified: invalid base64 for part #${S + 1} (${h.message})`);
  }
  try {
    return JSON.parse(U);
  } catch (h) {
    throw new InvalidTokenError$1(`Invalid token specified: invalid json for part #${S + 1} (${h.message})`);
  }
}
const checkJwtToken = () => {
  const e = (o) => {
    var S;
    const g = o;
    return !g || ((S = jwtDecode$1(g)) == null ? void 0 : S.exp) <= Math.floor(Date.now() / 1e3) + 60;
  };
  return {
    // isExpiredAccessToken,
    checkTokenExpired: (o, S) => {
      if (!(o === "/app/info" || o === "/user/login" || o === "/user/oauth") && e(S)) {
        if (o !== "/access-token")
          throw new Error("token_expired");
        return;
      }
    }
  };
};
class WepinSDKFetchAPI extends FetchAPI {
  constructor(o, S) {
    super(), this.baseUrl = o, this.params = S, this.addListener(APIEvents.request, this.requestCallback), this.addListener(APIEvents.response, this.responseCallback);
  }
  async send(o, S) {
    await this.emitAsync(APIEvents.request, o, S || {});
    const { data: g, url: U, headers: h } = o, q = (() => {
      if (g instanceof FormData)
        return {};
    })();
    o.headers = Object.assign(h || {}, q);
    const A = await super.send(o, S);
    return this.setToken(U, A), await this.emitAsync(
      APIEvents.response,
      A,
      S || {}
    ), A;
  }
  setToken(o, S) {
    var g, U, h, q, A, P;
    isErrorResponse(S.data) || (o === "user/login" && (g = S.data) != null && g.token ? this.params.wepinFetch.setToken({
      accessToken: (U = S.data) == null ? void 0 : U.token.access,
      refreshToken: (h = S.data) == null ? void 0 : h.token.refresh
    }) : o === "/user/access-token" && (q = S.data) != null && q.token ? this.params.wepinFetch.setToken({
      accessToken: (A = S.data) == null ? void 0 : A.token,
      refreshToken: (P = this.params.wepinFetch.Token) == null ? void 0 : P.refreshToken
    }) : o === "user/logout" && this.params.wepinFetch.setToken());
  }
  async requestCallback(o, S) {
    var g, U, h;
    try {
      o.headers || (o.headers = {}), o.headers["X-API-KEY"] = this.params.appKey;
      const q = this.params.domain && this.params.domain.includes("localhost") ? "" : this.params.domain;
      if (o.headers["X-SDK-TYPE"] = this.params.sdk.type, o.headers["X-SDK-VERSION"] = this.params.sdk.version, o.headers["X-API-DOMAIN"] = q, o.url === "/user/access-token" && (o.query = {
        refresh_token: (g = this.params.wepinFetch.Token) == null ? void 0 : g.refreshToken
      }), S != null && S.ignoreCheckToken)
        return;
      try {
        const P = (U = this.params.wepinFetch.Token) == null ? void 0 : U.accessToken, { checkTokenExpired: I } = checkJwtToken();
        I(o.url, P);
      } catch {
        const P = new APIRequest({
          url: "/user/access-token",
          method: "GET",
          withCredentials: !0
        });
        await this.send(P, { ignoreCheckToken: !0 });
      }
      const A = (h = this.params.wepinFetch.Token) == null ? void 0 : h.accessToken;
      A && (o.headers.Authorization = `Bearer ${A}`);
    } catch {
      throw new Error("Unauthorized Error");
    }
  }
  async responseCallback(o) {
    if (o.status === 401)
      throw new Error("Unauthorized Error");
  }
  // private setUserInfo(url: string, response: any) {
  //   if (!isErrorResponse(response.data) && response.data?.userInfo) {
  //     // set token
  //     if (url === 'user/login') {
  //       WepinStorage.setLocalStorage('userInfo', response.data?.userInfo)
  //       if (response.data?.walletId) {
  //         WepinStorage.setLocalStorage('walletId', response.data?.walletId)
  //       }
  //     } else if (url === '/app/register') {
  //       if (response.data?.walletId) {
  //         WepinStorage.setLocalStorage('walletId', response.data?.walletId)
  //       }
  //     }
  //   }
  // }
}
class UserAPI {
  constructor(o) {
    this.fetcher = o, this.basePath = "/user";
  }
  // 2.1 Check User Email
  async checkEmailExist(o) {
    const S = new APIRequest({
      url: `${this.basePath}/check-user`,
      method: "GET",
      query: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.2 Get User PW State
  async getUserPasswordState(o) {
    const S = new APIRequest({
      url: `${this.basePath}/password-state`,
      method: "GET",
      query: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.3 Provider Login
  async oAuth(o, S) {
    const g = new APIRequest({
      url: `${this.basePath}/oauth/login/${S.provider}`,
      method: "GET",
      query: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(g, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.4 Verify User Email
  async verify(o) {
    const S = new APIRequest({
      url: `${this.basePath}/verify`,
      method: "POST",
      data: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.5 Login
  async login(o) {
    const S = new APIRequest({
      url: `${this.basePath}/login`,
      method: "POST",
      data: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S, { ignoreCheckToken: !0 })).data;
  }
  // 2.6 Update User PW State
  async updateUserPasswordState(o, S) {
    const g = new APIRequest({
      url: `${this.basePath}/${o.userId}/password-state`,
      method: "PATCH",
      data: S,
      withCredentials: !0
    });
    return (await this.fetcher.send(g)).data;
  }
  // 2.7 Update Terms Accepted
  async updateTermsAccepted(o, S) {
    const g = new APIRequest({
      url: `${this.basePath}/${o.userId}/terms-accepted`,
      method: "PATCH",
      data: S,
      withCredentials: !0
    });
    return (await this.fetcher.send(g)).data;
  }
  // 2.8 Get Access Token
  async refreshToken() {
    const o = new APIRequest({
      url: `${this.basePath}/access-token`,
      method: "GET",
      // query: {
      //   refresh_token: WepinStorage.getLocalStorage('token')?.refreshToken,
      // },
      withCredentials: !0
    });
    return (await this.fetcher.send(o, { ignoreCheckToken: !0 })).data;
  }
  // 2.9 Get Public Key
  async fetchKey() {
    const o = new APIRequest({
      url: `${this.basePath}/pubkey`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 2.11 Get Terms Accepted
  async getTermsAccepted(o) {
    const S = new APIRequest({
      url: `${this.basePath}/${o.userId}/terms-accepted`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 2.12 Logout
  async logout(o) {
    const S = new APIRequest({
      url: `${this.basePath}/${o.userId}/logout`,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 2.13 Get Firebase Config
  async getFirebaseConfig() {
    const o = new APIRequest({
      url: `${this.basePath}/firebase-config`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o, { ignoreCheckToken: !0 })).data;
  }
  // 2.14 Login OAuth idToken
  async loginOAuthIdToken(o) {
    const S = new APIRequest({
      url: `${this.basePath}/oauth/login/id-token`,
      method: "POST",
      data: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S, { ignoreCheckToken: !0 })).data;
  }
  // 2.15 Login OAuth AccessToken
  async loginOAuthAccessToken(o) {
    const S = new APIRequest({
      url: `${this.basePath}/oauth/login/access-token`,
      method: "POST",
      data: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S, { ignoreCheckToken: !0 })).data;
  }
  // 2.18 Get User Info
  async getUserInfo(o) {
    const S = new APIRequest({
      url: `${this.basePath}/${o.userId}/detail`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
}
class WalletAPI {
  constructor(o) {
    this.fetcher = o, this.basePath = "/wallet";
  }
  // 3.1 Verify Wallet PIN
  async verifyPin(o) {
    const S = new APIRequest({
      url: `${this.basePath}/pin/verify`,
      data: o,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 3.2 Change Wallet PIN
  async changePin(o) {
    const S = new APIRequest({
      url: `${this.basePath}/pin/change`,
      data: o,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 3.3 Get Wallet Info
  async fetchWalletInfo(o, S) {
    const g = new APIRequest({
      url: `${this.basePath}/${o.walletId}`,
      query: S,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(g)).data;
  }
  // 3.4 Get Wallet Key Info
  async getWalletKeyInfo(o, S) {
    const g = new APIRequest({
      url: `${this.basePath}/${o.walletId}/wallet-keyinfo`,
      query: S,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(g)).data;
  }
  // 3.5 Reset Wallet PIN Try Count
  async resetPinTryCount(o, S) {
    const g = new APIRequest({
      url: `${this.basePath}/${o.walletId}/pin/reset-try-count`,
      query: S,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(g)).data;
  }
}
class AppAPI {
  constructor(o) {
    this.fetcher = o, this.basePath = "/app";
  }
  // 1.1 Get Theme
  async getThemeById(o) {
    return (await fetch(`${this.fetcher.baseUrl}/app/theme/${o.id}`, {
      method: "GET"
    })).json();
  }
  async getLayoutById(o) {
    return (await fetch(`${this.fetcher.baseUrl}/app/layout/${o.id}`, {
      method: "GET"
    })).json();
  }
  // 1.3 Get App Info
  async getAppInfo(o) {
    const S = new APIRequest({
      url: `${this.basePath}/info`,
      query: o,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(S, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.4 Get App Coins
  async getAppCoins(o) {
    const S = new APIRequest({
      url: `${this.basePath}/coins`,
      method: "GET",
      query: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.5 Get App Theme
  async getAppTheme() {
    const o = new APIRequest({
      url: `${this.basePath}/theme`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.6 Register
  async register(o) {
    const S = new APIRequest({
      url: `${this.basePath}/register`,
      method: "POST",
      data: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
}
class AccountAPI {
  constructor(o) {
    this.fetcher = o, this.basePath = "/account";
  }
  // 4.1 Readdress
  async readdress(o) {
    const S = new APIRequest({
      url: `${this.basePath}/readdress`,
      data: o,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 4.2 Get App Account
  async getAppAccountList(o) {
    const S = new APIRequest({
      url: `${this.basePath}`,
      query: o,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
}
class AccountBalanceAPI {
  constructor(o) {
    this.fetcher = o, this.basePath = "/accountbalance";
  }
  // 5.1 Get Account Balance
  async getAccountBalance(o) {
    const S = new APIRequest({
      url: `${this.basePath}/${o.accountId}/balance`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
}
class NFTAPI {
  constructor(o) {
    this.fetcher = o, this.basePath = "/nft";
  }
  // 6.1 Get NFT supporting network list
  async getSupportingNetworkList() {
    const o = new APIRequest({
      url: `${this.basePath}/support-network`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      // ignoreCheckToken: true,
    })).data;
  }
  // 6.2 Get App NFTs
  async getAppNFTList(o) {
    const S = new APIRequest({
      url: this.basePath,
      method: "GET",
      query: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 6.3 Refresh NFTs
  async refreshAppNFTList(o) {
    const S = new APIRequest({
      url: `${this.basePath}/refresh`,
      method: "GET",
      query: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
}
class TransactionAPI {
  constructor(o) {
    this.fetcher = o, this.basePath = "/tx";
  }
  // 7.1 Sign transaction
  async sign(o) {
    const S = new APIRequest({
      url: `${this.basePath}/sign`,
      data: o,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 7.2 Broadcast Transaction
  async broadCast(o) {
    const S = new APIRequest({
      url: `${this.basePath}/broadcast`,
      data: o,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 7.3 Get prepare transaction data
  async prepareTransaction(o) {
    const S = new APIRequest({
      url: `${this.basePath}/prepare`,
      data: o,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
  // 7.4 Check Address validation
  async checkAddressValidation(o) {
    const S = new APIRequest({
      url: `${this.basePath}/check_address`,
      query: o,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(S)).data;
  }
}
class WepinSdkAPI {
  constructor(o, S) {
    const g = new WepinSDKFetchAPI(o, S);
    this.app = new AppAPI(g), this.user = new UserAPI(g), this.wallet = new WalletAPI(g), this.account = new AccountAPI(g), this.balance = new AccountBalanceAPI(g), this.nft = new NFTAPI(g), this.transaction = new TransactionAPI(g);
  }
}
class WepinFetch {
  constructor({
    appId: o,
    appKey: S,
    domain: g,
    sdk: U,
    storage: h
  }) {
    this.version = packageJson.version, this.appId = o, this._appKey = S, this._domain = g, this._token = void 0, this.sdk = U, this._wepinStorage = h ?? c$1;
  }
  async init() {
    const o = await WepinFetch.getFirebaseConfig(
      this._appKey,
      this.sdk.type,
      this.sdk.version
    );
    this.wepinFirebaseApi = new FirebaseAuthAPI(o), this.wepinApi = new WepinSdkAPI(getBaseUrl$1(this._appKey), {
      appId: this.appId,
      appKey: this._appKey,
      domain: this._domain,
      sdk: this.sdk,
      wepinFetch: this
    }), this._isInitialized = !0;
  }
  isInitialized() {
    return this._isInitialized;
  }
  static async getFirebaseConfig(o, S, g) {
    const U = getBaseUrl$1(o), h = await (await fetch(`${U}/user/firebase-config`, {
      method: "GET",
      headers: {
        "X-API-KEY": o,
        "X-SDK-TYPE": S,
        "X-SDK-VERSION": g,
        "Content-Type": "application/json"
      }
    })).text();
    return JSON.parse(atob(h));
  }
  get Token() {
    return this._token = this._wepinStorage.getLocalStorage(
      this.appId,
      "wepin:connectUser"
    ), this._token;
  }
  setToken(o) {
    this._token = o, o ? this._wepinStorage.setLocalStorage(this.appId, "wepin:connectUser", o) : this._wepinStorage.clearLocalStorage(this.appId, "wepin:connectUser");
  }
  // public finalize() {
  //   this._wepinStorage.clearLocalStorage(this.appId, 'wepin:connectUser')
  // }
}
var ProjectPlatformKind = /* @__PURE__ */ ((e) => (e[e.web = 1] = "web", e[e.android = 2] = "android", e[e.ios = 3] = "ios", e))(ProjectPlatformKind || {});
const w = class {
  static closeOverlay(o) {
    const S = document.querySelector(`#${o}`);
    S && S.parentNode && S.parentNode.removeChild(S);
  }
  static openOverlay(o) {
    const S = document.createElement("div");
    S.id = o, S.classList.add(this.CONST.overlayClassName), S.style.zIndex = "2147483647", S.style.display = "flex", S.style.alignItems = "center", S.style.justifyContent = "center", S.style.textAlign = "center", S.style.position = "fixed", S.style.left = "0px", S.style.right = "0px", S.style.top = "0px", S.style.bottom = "0px", S.style.left = "0px", S.style.background = "rgba(0,0,0,0.6)", S.style.color = "white", S.style.border = "2px solid #f1f1f1";
    const g = document.getElementsByClassName(
      this.CONST.overlayClassName
    );
    for (let U = 0; U < g.length; U++) {
      const h = g.item(U);
      h && h.remove();
    }
    document.body.appendChild(S);
  }
};
w.CONST = {
  overlayClassName: "wepin-widget__overlay"
};
let p = w;
const y = (e) => {
  const o = (e == null ? void 0 : e.width) || 375, S = (e == null ? void 0 : e.height) || 604, g = e != null && e.sLeft ? e == null ? void 0 : e.sLeft : window.screenLeft ? window.screenLeft : window.screenX ? window.screenX : 0, U = e != null && e.sTop ? e == null ? void 0 : e.sTop : window.screenTop ? window.screenTop : window.screenY ? window.screenY : 0, h = screen.width / 2 - o / 2 + g, q = screen.height / 2 - S / 2 + U;
  return `width=${o}, height=${S}, left=${h}, top=${q}scrollbars=yes, resizable=1, menubar=no, toolbar=no`;
}, m = (e) => {
  const o = document.createElement("iframe");
  return o.classList.add("wepin-sdk-widget-iframe"), o.setAttribute("frameborder", "0"), o.setAttribute("marginwidth", "0"), o.setAttribute("marginheight", "0"), o.style.width = "100%", e && e != null && e.isHide ? o.style.height = "0" : o.style.height = "100%", o.style.maxHeight = "100%", o.style.position = "fixed", o.style.bottom = "0", o.style.left = "0", o.style.zIndex = "408888000000", o.title = "wepin sdk webview", o.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; clipboard-read", o.allowFullscreen = !0, o;
}, v = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
  const o = Math.random() * 16 | 0;
  return (e == "x" ? o : o & 3 | 8).toString(16);
}), r = class hr extends p {
  constructor(o, S, g, U, h) {
    super(), this.isWidgetReady = !1, this.url = o, this.id = `id-${v()}`, this.isHide = h, h || hr.openOverlay(this.id), hr._webview[this.id] = S, this.type = g, this.EL = U, window.addEventListener("message", this.EL), this._open = !0;
  }
  get isOpen() {
    return this._open;
  }
  // For communicating with the Wepin instance
  // private _wepin: Wepin
  // public get Wepin() {
  //   return this._wepin
  // }
  // For communicating with the Webview
  // private _webview: HTMLIFrameElement
  static getWebview(o) {
    return hr._webview[o];
  }
  static clearWebview(o) {
    delete hr._webview[o];
  }
  static clearAllWebview() {
    this._webview = {};
  }
  close() {
    this.isHide || hr.closeOverlay(this.id), window.removeEventListener("message", this.EL), this._open = !1, this.isWidgetReady = !1, this._closeWebview();
  }
  response(o) {
    try {
      this._post(o);
    } catch (S) {
      console.error("Can not response message to the webview", S);
    }
  }
  request(o) {
    try {
      this._post(o);
    } catch (S) {
      console.error("Can not send message to the webview", S);
    }
  }
};
r._webview = {};
let l$1 = r;
class a extends l$1 {
  // is it necessary ?
  constructor({
    url: o,
    // wepin,
    frame: S,
    EL: g,
    isHide: U
  }) {
    super(o, S, "Frame", g, U), S.src = o, S.id = this.id;
    const h = document.querySelector("body");
    a.scrollPosition = window.pageYOffset, h.style.overflow = "hidden", h.style.position = "fixed", h.style.top = `-${a.scrollPosition}px`, h.style.width = "100%", document.body.appendChild(S);
  }
  static async openNew({
    url: o,
    EL: S,
    widgetOptions: g
  }) {
    const U = m({ isHide: g == null ? void 0 : g.isHide });
    return new a({
      url: o,
      // wepin,
      frame: U,
      EL: S,
      isHide: g == null ? void 0 : g.isHide
    });
  }
  expand() {
    const o = l$1.getWebview(this.id);
    o.style.height = "100%", o.style.borderRadius = "0";
  }
  shrink() {
    const o = l$1.getWebview(this.id);
    o.style.height = "604px", o.style.borderRadius = "12px 12px 0 0 ";
  }
  _closeWebview() {
    const o = setTimeout(() => {
      const S = l$1.getWebview(this.id), g = document.querySelector("body");
      g.style.removeProperty("overflow"), g.style.removeProperty("position"), g.style.removeProperty("top"), g.style.removeProperty("width"), window.scrollTo(0, a.scrollPosition), S && document.body.removeChild(S), l$1.clearWebview(this.id), clearTimeout(o);
    }, 500);
  }
  _post(o) {
    l$1.getWebview(this.id).contentWindow.postMessage(o, this.url);
  }
}
class d extends l$1 {
  constructor({
    url: o,
    webview: S,
    EL: g
  }) {
    super(o, S, "Window", g, !1);
  }
  //: NodeJS.Timer | number
  static async openNew({
    url: o,
    EL: S,
    widgetFeatures: g
  }) {
    const U = y(g), h = window.open(o, "Wepin_Widget", U), q = new d({
      url: o,
      webview: h,
      EL: S
    });
    if (!h)
      throw q.close(), new Error("popup window blocked");
    return this.timer = setInterval(() => {
      try {
        h && h.closed && (clearInterval(this.timer), q.close());
      } catch {
        clearInterval(this.timer), q.close();
      }
    }, 200), q;
  }
  expand() {
  }
  shrink() {
  }
  _closeWebview() {
    d.timer && (clearInterval(d.timer), d.timer = void 0);
    const o = l$1.getWebview(this.id);
    o && o.close(), l$1.clearWebview(this.id);
  }
  _post(o) {
    l$1.getWebview(this.id).postMessage(o, this.url);
  }
}
const x = "@wepin/modal-js", b = "0.0.1", f = "wepin widget modal", u$1 = "IoTrust, Co., Ltd.", W = "MIT", C = "./dist/wepin-modal-js.mjs", T = "dist/wepin-modal-js.umd.js", L = "./dist/src/index.d.ts", N = [
  "dist"
], _ = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, j = [
  "wepin",
  "wepinwallet",
  "wallet",
  "wepin-modal"
], E = {
  name: x,
  version: b,
  description: f,
  author: u$1,
  license: W,
  main: C,
  jsdelivr: T,
  types: L,
  files: N,
  scripts: _,
  keywords: j
};
class k {
  //   constructor(appKey: string, appId: string) {
  constructor() {
    this.platformType = "web", this._modalWindow = null, this._modalFrame = null, console.log(`WepinModal v${E.version}`), this.domain = window.location.origin;
  }
  //   async init() {
  //     // getAppInfo..
  //     this._appId
  //     this._appKey
  //     this._isInitialized = true
  //     return this._isInitialized
  //   }
  async openAuthBrowser(o, S) {
    return this._modalWindow = await d.openNew({
      url: o,
      EL: S
    }), this._modalWindow;
  }
  async openModal(o, S, g) {
    return this._modalFrame = await a.openNew({
      url: o,
      EL: S,
      widgetOptions: g
    }), this._modalFrame;
  }
  async closeAuthBrowser() {
    this._modalWindow && this._modalWindow.close();
  }
  async closeModal() {
    this._modalFrame && this._modalFrame.close();
  }
}
var u = (e, o, S) => {
  if (!o.has(e))
    throw TypeError("Cannot " + S);
}, i = (e, o, S) => (u(e, o, "read from private field"), S ? S.call(e) : o.get(e)), n = (e, o, S) => {
  if (o.has(e))
    throw TypeError("Cannot add the same private member more than once");
  o instanceof WeakSet ? o.add(e) : o.set(e, S);
}, l;
const s = class pr {
  static getLocalStorageEnabled() {
    let o = !1;
    try {
      o = window.localStorage && !0;
    } catch {
      o = !1;
    }
    return o;
  }
  static setAllLocalStorage(o, S) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const g = JSON.stringify(S);
    localStorage.setItem(i(this, l) + o, g);
  }
  static setLocalStorage(o, S, g) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const U = this.getAllLocalStorage(o);
    if (U) {
      U[S] = g, localStorage.setItem(
        i(this, l) + o,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(U)
      );
      return;
    }
    const h = { [S]: g };
    localStorage.setItem(
      i(this, l) + o,
      // btoa(JSON.stringify(newData)),
      JSON.stringify(h)
    );
  }
  static getLocalStorage(o, S) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const g = this.getAllLocalStorage(o);
    try {
      if (g)
        return JSON.parse(g[S]);
    } catch {
      return g[S];
    }
  }
  static getAllLocalStorage(o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    try {
      return localStorage.getItem(i(this, l) + o) ? (
        // ? JSON.parse(atob(localStorage.getItem(this.#COOKIE_NAME + appId)))
        JSON.parse(localStorage.getItem(i(this, l) + o))
      ) : void 0;
    } catch {
      return;
    }
  }
  static clearLocalStorage(o, S) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    if (this.getLocalStorage(o, S)) {
      const g = this.getAllLocalStorage(o);
      delete g[S], localStorage.setItem(
        i(this, l) + o,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(g)
      );
    }
  }
  static clearAllLocalStorage(o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(i(this, l) + o);
  }
  static setLoginUserLocalStorage(o, S, g) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const U = {};
    return U["firebase:wepin"] = Object.assign(
      { provider: S == null ? void 0 : S.provider },
      S == null ? void 0 : S.token
    ), U["wepin:connectUser"] = {
      accessToken: g.token.access,
      refreshToken: g.token.refresh
    }, U.user_id = g.userInfo.userId, U.user_info = {
      status: "success",
      userInfo: {
        userId: g.userInfo.userId,
        email: g.userInfo.email,
        provider: S.provider,
        use2FA: g.userInfo.use2FA >= 2
      }
    }, U.user_status = {
      loginStatus: g.loginStatus,
      pinRequired: g.loginStatus === "registerRequired" ? g.pinRequired : !1
    }, g.loginStatus !== "pinRequired" && g.walletId && (U.wallet_id = g.walletId, U.user_info.walletId = g.walletId), U.oauth_provider_pending = S.provider, pr.setAllLocalStorage(o, U), {
      userInfo: U.user_info,
      connectUser: U["wepin:connectUser"]
    };
  }
};
l = /* @__PURE__ */ new WeakMap(), s.platform = "web", n(s, l, "wepin:auth:");
let c = s;
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(e) {
  return decodeURIComponent(atob(e).replace(/(.)/g, (o, S) => {
    let g = S.charCodeAt(0).toString(16).toUpperCase();
    return g.length < 2 && (g = "0" + g), "%" + g;
  }));
}
function base64UrlDecode(e) {
  let o = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (o.length % 4) {
    case 0:
      break;
    case 2:
      o += "==";
      break;
    case 3:
      o += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(o);
  } catch {
    return atob(o);
  }
}
function jwtDecode(e, o) {
  if (typeof e != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  o || (o = {});
  const S = o.header === !0 ? 0 : 1, g = e.split(".")[S];
  if (typeof g != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${S + 1}`);
  let U;
  try {
    U = base64UrlDecode(g);
  } catch (h) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${S + 1} (${h.message})`);
  }
  try {
    return JSON.parse(U);
  } catch (h) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${S + 1} (${h.message})`);
  }
}
const InfoUrl = "https://delivery.wepin.io/sdk/provider/info.json", getRpcPromiseCallback = (e, o, S = !0) => (g, U) => {
  g || U.error ? o(g || U.error) : !S || Array.isArray(U) ? e(U) : e(U.result);
}, isValidChainId = (e) => !!e && typeof e == "string" && e.startsWith("0x"), getBaseUrl = (e) => {
  if (e.slice(0, 8) === "ak_live_")
    return new URL("https://v1-widget.wepin.io");
  if (e.slice(0, 8) === "ak_test_")
    return new URL("https://stage-v1-widget.wepin.io");
  if (e.slice(0, 7) === "ak_dev_")
    return new URL("https://dev-v1-widget.wepin.io");
  if (e.slice(0, 13) === "local_ak_dev_")
    return new URL("https://local-widget.wepin.io");
  throw new Error("Invalid appKey");
}, proxyToObject = (e) => {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map(proxyToObject);
  const o = {};
  for (const S of Object.keys(e))
    o[S] = proxyToObject(e[S]);
  return o;
}, getNetworkInfo = async () => await (await fetch(InfoUrl)).json(), getNetworkInfoByName = async (e) => {
  const S = (await getNetworkInfo()).networks.find(
    (g) => g.id.toLowerCase() === e.toLowerCase()
  );
  if (!S)
    throw new Error(
      `There is No network info about provided network : ${e}`
    );
  return {
    rpcUrl: S.rpcUrl,
    chainId: "0x" + S.chainId.toString(16)
  };
}, getNetworkByChainId = async (e) => {
  if (!isValidChainId(e))
    throw new Error(`Invalid chain ID: ${e}`);
  const S = (await getNetworkInfo()).networks.find((g) => g.chainId === Number(e));
  if (!S)
    throw new Error(`Invalid chain ID: ${e}`);
  return S.id.toLowerCase();
};
var dist$7 = {}, classes = {}, fastSafeStringify = stringify$1;
stringify$1.default = stringify$1;
stringify$1.stable = deterministicStringify;
stringify$1.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]", CIRCULAR_REPLACE_NODE = "[Circular]", arr = [], replacerStack = [];
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify$1(e, o, S, g) {
  typeof g > "u" && (g = defaultOptions()), decirc(e, "", 0, [], void 0, 0, g);
  var U;
  try {
    replacerStack.length === 0 ? U = JSON.stringify(e, o, S) : U = JSON.stringify(e, replaceGetterValues(o), S);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; arr.length !== 0; ) {
      var h = arr.pop();
      h.length === 4 ? Object.defineProperty(h[0], h[1], h[3]) : h[0][h[1]] = h[2];
    }
  }
  return U;
}
function setReplace(e, o, S, g) {
  var U = Object.getOwnPropertyDescriptor(g, S);
  U.get !== void 0 ? U.configurable ? (Object.defineProperty(g, S, { value: e }), arr.push([g, S, o, U])) : replacerStack.push([o, S, e]) : (g[S] = e, arr.push([g, S, o]));
}
function decirc(e, o, S, g, U, h, q) {
  h += 1;
  var A;
  if (typeof e == "object" && e !== null) {
    for (A = 0; A < g.length; A++)
      if (g[A] === e) {
        setReplace(CIRCULAR_REPLACE_NODE, e, o, U);
        return;
      }
    if (typeof q.depthLimit < "u" && h > q.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, e, o, U);
      return;
    }
    if (typeof q.edgesLimit < "u" && S + 1 > q.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, e, o, U);
      return;
    }
    if (g.push(e), Array.isArray(e))
      for (A = 0; A < e.length; A++)
        decirc(e[A], A, A, g, e, h, q);
    else {
      var P = Object.keys(e);
      for (A = 0; A < P.length; A++) {
        var I = P[A];
        decirc(e[I], I, A, g, e, h, q);
      }
    }
    g.pop();
  }
}
function compareFunction(e, o) {
  return e < o ? -1 : e > o ? 1 : 0;
}
function deterministicStringify(e, o, S, g) {
  typeof g > "u" && (g = defaultOptions());
  var U = deterministicDecirc(e, "", 0, [], void 0, 0, g) || e, h;
  try {
    replacerStack.length === 0 ? h = JSON.stringify(U, o, S) : h = JSON.stringify(U, replaceGetterValues(o), S);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; arr.length !== 0; ) {
      var q = arr.pop();
      q.length === 4 ? Object.defineProperty(q[0], q[1], q[3]) : q[0][q[1]] = q[2];
    }
  }
  return h;
}
function deterministicDecirc(e, o, S, g, U, h, q) {
  h += 1;
  var A;
  if (typeof e == "object" && e !== null) {
    for (A = 0; A < g.length; A++)
      if (g[A] === e) {
        setReplace(CIRCULAR_REPLACE_NODE, e, o, U);
        return;
      }
    try {
      if (typeof e.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof q.depthLimit < "u" && h > q.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, e, o, U);
      return;
    }
    if (typeof q.edgesLimit < "u" && S + 1 > q.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, e, o, U);
      return;
    }
    if (g.push(e), Array.isArray(e))
      for (A = 0; A < e.length; A++)
        deterministicDecirc(e[A], A, A, g, e, h, q);
    else {
      var P = {}, I = Object.keys(e).sort(compareFunction);
      for (A = 0; A < I.length; A++) {
        var B = I[A];
        deterministicDecirc(e[B], B, A, g, e, h, q), P[B] = e[B];
      }
      if (typeof U < "u")
        arr.push([U, o, e]), U[o] = P;
      else
        return P;
    }
    g.pop();
  }
}
function replaceGetterValues(e) {
  return e = typeof e < "u" ? e : function(o, S) {
    return S;
  }, function(o, S) {
    if (replacerStack.length > 0)
      for (var g = 0; g < replacerStack.length; g++) {
        var U = replacerStack[g];
        if (U[1] === o && U[0] === S) {
          S = U[2], replacerStack.splice(g, 1);
          break;
        }
      }
    return e.call(this, o, S);
  };
}
Object.defineProperty(classes, "__esModule", { value: !0 });
classes.EthereumProviderError = classes.EthereumRpcError = void 0;
const fast_safe_stringify_1 = fastSafeStringify;
class EthereumRpcError extends Error {
  constructor(o, S, g) {
    if (!Number.isInteger(o))
      throw new Error('"code" must be an integer.');
    if (!S || typeof S != "string")
      throw new Error('"message" must be a nonempty string.');
    super(S), this.code = o, g !== void 0 && (this.data = g);
  }
  /**
   * Returns a plain object with all public class properties.
   */
  serialize() {
    const o = {
      code: this.code,
      message: this.message
    };
    return this.data !== void 0 && (o.data = this.data), this.stack && (o.stack = this.stack), o;
  }
  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   */
  toString() {
    return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
  }
}
classes.EthereumRpcError = EthereumRpcError;
class EthereumProviderError extends EthereumRpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(o, S, g) {
    if (!isValidEthProviderCode(o))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(o, S, g);
  }
}
classes.EthereumProviderError = EthereumProviderError;
function isValidEthProviderCode(e) {
  return Number.isInteger(e) && e >= 1e3 && e <= 4999;
}
function stringifyReplacer(e, o) {
  if (o !== "[Circular]")
    return o;
}
var utils$8 = {}, errorConstants = {};
Object.defineProperty(errorConstants, "__esModule", { value: !0 });
errorConstants.errorValues = errorConstants.errorCodes = void 0;
errorConstants.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
errorConstants.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const o = errorConstants, S = classes, g = o.errorCodes.rpc.internal, U = "Unspecified error message. This is a bug, please report it.", h = {
    code: g,
    message: q(g)
  };
  e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function q(V, X = U) {
    if (Number.isInteger(V)) {
      const Q = V.toString();
      if (H(o.errorValues, Q))
        return o.errorValues[Q].message;
      if (I(V))
        return e.JSON_RPC_SERVER_ERROR_MESSAGE;
    }
    return X;
  }
  e.getMessageFromCode = q;
  function A(V) {
    if (!Number.isInteger(V))
      return !1;
    const X = V.toString();
    return !!(o.errorValues[X] || I(V));
  }
  e.isValidCode = A;
  function P(V, { fallbackError: X = h, shouldIncludeStack: Q = !1 } = {}) {
    var ee, ie;
    if (!X || !Number.isInteger(X.code) || typeof X.message != "string")
      throw new Error("Must provide fallback error with integer number code and string message.");
    if (V instanceof S.EthereumRpcError)
      return V.serialize();
    const te = {};
    if (V && typeof V == "object" && !Array.isArray(V) && H(V, "code") && A(V.code)) {
      const le = V;
      te.code = le.code, le.message && typeof le.message == "string" ? (te.message = le.message, H(le, "data") && (te.data = le.data)) : (te.message = q(te.code), te.data = { originalError: B(V) });
    } else {
      te.code = X.code;
      const le = (ee = V) === null || ee === void 0 ? void 0 : ee.message;
      te.message = le && typeof le == "string" ? le : X.message, te.data = { originalError: B(V) };
    }
    const se = (ie = V) === null || ie === void 0 ? void 0 : ie.stack;
    return Q && V && se && typeof se == "string" && (te.stack = se), te;
  }
  e.serializeError = P;
  function I(V) {
    return V >= -32099 && V <= -32e3;
  }
  function B(V) {
    return V && typeof V == "object" && !Array.isArray(V) ? Object.assign({}, V) : V;
  }
  function H(V, X) {
    return Object.prototype.hasOwnProperty.call(V, X);
  }
})(utils$8);
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.ethErrors = void 0;
const classes_1 = classes, utils_1$4 = utils$8, error_constants_1 = errorConstants;
errors$1.ethErrors = {
  rpc: {
    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     */
    parse: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, e),
    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     */
    invalidRequest: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, e),
    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     */
    invalidParams: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, e),
    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     */
    methodNotFound: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, e),
    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     */
    internal: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, e),
    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP-1474.
     */
    server: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: o } = e;
      if (!Number.isInteger(o) || o > -32005 || o < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return getEthJsonRpcError(o, e);
    },
    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     */
    invalidInput: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, e),
    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     */
    resourceNotFound: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, e),
    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     */
    resourceUnavailable: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, e),
    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     */
    transactionRejected: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, e),
    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     */
    methodNotSupported: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, e),
    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     */
    limitExceeded: (e) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, e)
  },
  provider: {
    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     */
    userRejectedRequest: (e) => getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, e),
    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     */
    unauthorized: (e) => getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, e),
    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     */
    unsupportedMethod: (e) => getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, e),
    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     */
    disconnected: (e) => getEthProviderError(error_constants_1.errorCodes.provider.disconnected, e),
    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     */
    chainDisconnected: (e) => getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, e),
    /**
     * Get a custom Ethereum Provider error.
     */
    custom: (e) => {
      if (!e || typeof e != "object" || Array.isArray(e))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: o, message: S, data: g } = e;
      if (!S || typeof S != "string")
        throw new Error('"message" must be a nonempty string');
      return new classes_1.EthereumProviderError(o, S, g);
    }
  }
};
function getEthJsonRpcError(e, o) {
  const [S, g] = parseOpts(o);
  return new classes_1.EthereumRpcError(e, S || utils_1$4.getMessageFromCode(e), g);
}
function getEthProviderError(e, o) {
  const [S, g] = parseOpts(o);
  return new classes_1.EthereumProviderError(e, S || utils_1$4.getMessageFromCode(e), g);
}
function parseOpts(e) {
  if (e) {
    if (typeof e == "string")
      return [e];
    if (typeof e == "object" && !Array.isArray(e)) {
      const { message: o, data: S } = e;
      if (o && typeof o != "string")
        throw new Error("Must specify string message.");
      return [o || void 0, S];
    }
  }
  return [];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
  const o = classes;
  Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
    return o.EthereumRpcError;
  } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
    return o.EthereumProviderError;
  } });
  const S = utils$8;
  Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
    return S.serializeError;
  } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
    return S.getMessageFromCode;
  } });
  const g = errors$1;
  Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
    return g.ethErrors;
  } });
  const U = errorConstants;
  Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
    return U.errorCodes;
  } });
})(dist$7);
var fastDeepEqual = function e(o, S) {
  if (o === S)
    return !0;
  if (o && S && typeof o == "object" && typeof S == "object") {
    if (o.constructor !== S.constructor)
      return !1;
    var g, U, h;
    if (Array.isArray(o)) {
      if (g = o.length, g != S.length)
        return !1;
      for (U = g; U-- !== 0; )
        if (!e(o[U], S[U]))
          return !1;
      return !0;
    }
    if (o.constructor === RegExp)
      return o.source === S.source && o.flags === S.flags;
    if (o.valueOf !== Object.prototype.valueOf)
      return o.valueOf() === S.valueOf();
    if (o.toString !== Object.prototype.toString)
      return o.toString() === S.toString();
    if (h = Object.keys(o), g = h.length, g !== Object.keys(S).length)
      return !1;
    for (U = g; U-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(S, h[U]))
        return !1;
    for (U = g; U-- !== 0; ) {
      var q = h[U];
      if (!e(o[q], S[q]))
        return !1;
    }
    return !0;
  }
  return o !== o && S !== S;
};
const equal = /* @__PURE__ */ getDefaultExportFromCjs$1(fastDeepEqual);
var dist$6 = {}, idRemapMiddleware = {}, getUniqueId$1 = {};
Object.defineProperty(getUniqueId$1, "__esModule", { value: !0 });
getUniqueId$1.getUniqueId = void 0;
const MAX$1 = 4294967295;
let idCounter = Math.floor(Math.random() * MAX$1);
function getUniqueId() {
  return idCounter = (idCounter + 1) % MAX$1, idCounter;
}
getUniqueId$1.getUniqueId = getUniqueId;
Object.defineProperty(idRemapMiddleware, "__esModule", { value: !0 });
idRemapMiddleware.createIdRemapMiddleware = void 0;
const getUniqueId_1 = getUniqueId$1;
function createIdRemapMiddleware() {
  return (e, o, S, g) => {
    const U = e.id, h = getUniqueId_1.getUniqueId();
    e.id = h, o.id = h, S((q) => {
      e.id = U, o.id = U, q();
    });
  };
}
idRemapMiddleware.createIdRemapMiddleware = createIdRemapMiddleware;
var createAsyncMiddleware$1 = {};
Object.defineProperty(createAsyncMiddleware$1, "__esModule", { value: !0 });
createAsyncMiddleware$1.createAsyncMiddleware = void 0;
function createAsyncMiddleware(e) {
  return async (o, S, g, U) => {
    let h;
    const q = new Promise((B) => {
      h = B;
    });
    let A = null, P = !1;
    const I = async () => {
      P = !0, g((B) => {
        A = B, h();
      }), await q;
    };
    try {
      await e(o, S, I), P ? (await q, A(null)) : U(null);
    } catch (B) {
      A ? A(B) : U(B);
    }
  };
}
createAsyncMiddleware$1.createAsyncMiddleware = createAsyncMiddleware;
var createScaffoldMiddleware$1 = {};
Object.defineProperty(createScaffoldMiddleware$1, "__esModule", { value: !0 });
createScaffoldMiddleware$1.createScaffoldMiddleware = void 0;
function createScaffoldMiddleware(e) {
  return (o, S, g, U) => {
    const h = e[o.method];
    return h === void 0 ? g() : typeof h == "function" ? h(o, S, g, U) : (S.result = h, U());
  };
}
createScaffoldMiddleware$1.createScaffoldMiddleware = createScaffoldMiddleware;
var JsonRpcEngine$1 = {}, safeEventEmitter = {}, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function e(o, S, g) {
  return Function.prototype.apply.call(o, S, g);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(o) {
  return Object.getOwnPropertyNames(o).concat(Object.getOwnPropertySymbols(o));
} : ReflectOwnKeys = function(o) {
  return Object.getOwnPropertyNames(o);
};
function ProcessEmitWarning(e) {
  console && console.warn && console.warn(e);
}
var NumberIsNaN = Number.isNaN || function e(o) {
  return o !== o;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || NumberIsNaN(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    defaultMaxListeners = e;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function e(o) {
  if (typeof o != "number" || o < 0 || NumberIsNaN(o))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + o + ".");
  return this._maxListeners = o, this;
};
function _getMaxListeners(e) {
  return e._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : e._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function e() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function e(o) {
  for (var S = [], g = 1; g < arguments.length; g++)
    S.push(arguments[g]);
  var U = o === "error", h = this._events;
  if (h !== void 0)
    U = U && h.error === void 0;
  else if (!U)
    return !1;
  if (U) {
    var q;
    if (S.length > 0 && (q = S[0]), q instanceof Error)
      throw q;
    var A = new Error("Unhandled error." + (q ? " (" + q.message + ")" : ""));
    throw A.context = q, A;
  }
  var P = h[o];
  if (P === void 0)
    return !1;
  if (typeof P == "function")
    ReflectApply(P, this, S);
  else
    for (var I = P.length, B = arrayClone$2(P, I), g = 0; g < I; ++g)
      ReflectApply(B[g], this, S);
  return !0;
};
function _addListener(e, o, S, g) {
  var U, h, q;
  if (checkListener(S), h = e._events, h === void 0 ? (h = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (h.newListener !== void 0 && (e.emit(
    "newListener",
    o,
    S.listener ? S.listener : S
  ), h = e._events), q = h[o]), q === void 0)
    q = h[o] = S, ++e._eventsCount;
  else if (typeof q == "function" ? q = h[o] = g ? [S, q] : [q, S] : g ? q.unshift(S) : q.push(S), U = _getMaxListeners(e), U > 0 && q.length > U && !q.warned) {
    q.warned = !0;
    var A = new Error("Possible EventEmitter memory leak detected. " + q.length + " " + String(o) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    A.name = "MaxListenersExceededWarning", A.emitter = e, A.type = o, A.count = q.length, ProcessEmitWarning(A);
  }
  return e;
}
EventEmitter.prototype.addListener = function e(o, S) {
  return _addListener(this, o, S, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function e(o, S) {
  return _addListener(this, o, S, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(e, o, S) {
  var g = { fired: !1, wrapFn: void 0, target: e, type: o, listener: S }, U = onceWrapper.bind(g);
  return U.listener = S, g.wrapFn = U, U;
}
EventEmitter.prototype.once = function e(o, S) {
  return checkListener(S), this.on(o, _onceWrap(this, o, S)), this;
};
EventEmitter.prototype.prependOnceListener = function e(o, S) {
  return checkListener(S), this.prependListener(o, _onceWrap(this, o, S)), this;
};
EventEmitter.prototype.removeListener = function e(o, S) {
  var g, U, h, q, A;
  if (checkListener(S), U = this._events, U === void 0)
    return this;
  if (g = U[o], g === void 0)
    return this;
  if (g === S || g.listener === S)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete U[o], U.removeListener && this.emit("removeListener", o, g.listener || S));
  else if (typeof g != "function") {
    for (h = -1, q = g.length - 1; q >= 0; q--)
      if (g[q] === S || g[q].listener === S) {
        A = g[q].listener, h = q;
        break;
      }
    if (h < 0)
      return this;
    h === 0 ? g.shift() : spliceOne(g, h), g.length === 1 && (U[o] = g[0]), U.removeListener !== void 0 && this.emit("removeListener", o, A || S);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function e(o) {
  var S, g, U;
  if (g = this._events, g === void 0)
    return this;
  if (g.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : g[o] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete g[o]), this;
  if (arguments.length === 0) {
    var h = Object.keys(g), q;
    for (U = 0; U < h.length; ++U)
      q = h[U], q !== "removeListener" && this.removeAllListeners(q);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (S = g[o], typeof S == "function")
    this.removeListener(o, S);
  else if (S !== void 0)
    for (U = S.length - 1; U >= 0; U--)
      this.removeListener(o, S[U]);
  return this;
};
function _listeners(e, o, S) {
  var g = e._events;
  if (g === void 0)
    return [];
  var U = g[o];
  return U === void 0 ? [] : typeof U == "function" ? S ? [U.listener || U] : [U] : S ? unwrapListeners(U) : arrayClone$2(U, U.length);
}
EventEmitter.prototype.listeners = function e(o) {
  return _listeners(this, o, !0);
};
EventEmitter.prototype.rawListeners = function e(o) {
  return _listeners(this, o, !1);
};
EventEmitter.listenerCount = function(e, o) {
  return typeof e.listenerCount == "function" ? e.listenerCount(o) : listenerCount.call(e, o);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(e) {
  var o = this._events;
  if (o !== void 0) {
    var S = o[e];
    if (typeof S == "function")
      return 1;
    if (S !== void 0)
      return S.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function e() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone$2(e, o) {
  for (var S = new Array(o), g = 0; g < o; ++g)
    S[g] = e[g];
  return S;
}
function spliceOne(e, o) {
  for (; o + 1 < e.length; o++)
    e[o] = e[o + 1];
  e.pop();
}
function unwrapListeners(e) {
  for (var o = new Array(e.length), S = 0; S < o.length; ++S)
    o[S] = e[S].listener || e[S];
  return o;
}
function once(e, o) {
  return new Promise(function(S, g) {
    function U(q) {
      e.removeListener(o, h), g(q);
    }
    function h() {
      typeof e.removeListener == "function" && e.removeListener("error", U), S([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(e, o, h, { once: !0 }), o !== "error" && addErrorHandlerIfEventEmitter(e, U, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(e, o, S) {
  typeof e.on == "function" && eventTargetAgnosticAddListener(e, "error", o, S);
}
function eventTargetAgnosticAddListener(e, o, S, g) {
  if (typeof e.on == "function")
    g.once ? e.once(o, S) : e.on(o, S);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(o, function U(h) {
      g.once && e.removeEventListener(o, U), S(h);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var eventsExports = events.exports;
Object.defineProperty(safeEventEmitter, "__esModule", { value: !0 });
const events_1$1 = eventsExports;
function safeApply$1(e, o, S) {
  try {
    Reflect.apply(e, o, S);
  } catch (g) {
    setTimeout(() => {
      throw g;
    });
  }
}
function arrayClone$1(e) {
  const o = e.length, S = new Array(o);
  for (let g = 0; g < o; g += 1)
    S[g] = e[g];
  return S;
}
let SafeEventEmitter$1 = class extends events_1$1.EventEmitter {
  emit(o, ...S) {
    let g = o === "error";
    const U = this._events;
    if (U !== void 0)
      g = g && U.error === void 0;
    else if (!g)
      return !1;
    if (g) {
      let q;
      if (S.length > 0 && ([q] = S), q instanceof Error)
        throw q;
      const A = new Error(`Unhandled error.${q ? ` (${q.message})` : ""}`);
      throw A.context = q, A;
    }
    const h = U[o];
    if (h === void 0)
      return !1;
    if (typeof h == "function")
      safeApply$1(h, this, S);
    else {
      const q = h.length, A = arrayClone$1(h);
      for (let P = 0; P < q; P += 1)
        safeApply$1(A[P], this, S);
    }
    return !0;
  }
};
safeEventEmitter.default = SafeEventEmitter$1;
var __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(JsonRpcEngine$1, "__esModule", { value: !0 });
JsonRpcEngine$1.JsonRpcEngine = void 0;
const safe_event_emitter_1$1 = __importDefault$7(safeEventEmitter), eth_rpc_errors_1$2 = dist$7;
class JsonRpcEngine extends safe_event_emitter_1$1.default {
  constructor() {
    super(), this._middleware = [];
  }
  /**
   * Add a middleware function to the engine's middleware stack.
   *
   * @param middleware - The middleware function to add.
   */
  push(o) {
    this._middleware.push(o);
  }
  handle(o, S) {
    if (S && typeof S != "function")
      throw new Error('"callback" must be a function if provided.');
    return Array.isArray(o) ? S ? this._handleBatch(o, S) : this._handleBatch(o) : S ? this._handle(o, S) : this._promiseHandle(o);
  }
  /**
   * Returns this engine as a middleware function that can be pushed to other
   * engines.
   *
   * @returns This engine as a middleware function.
   */
  asMiddleware() {
    return async (o, S, g, U) => {
      try {
        const [h, q, A] = await JsonRpcEngine._runAllMiddleware(o, S, this._middleware);
        return q ? (await JsonRpcEngine._runReturnHandlers(A), U(h)) : g(async (P) => {
          try {
            await JsonRpcEngine._runReturnHandlers(A);
          } catch (I) {
            return P(I);
          }
          return P();
        });
      } catch (h) {
        return U(h);
      }
    };
  }
  async _handleBatch(o, S) {
    try {
      const g = await Promise.all(
        // 1. Begin executing each request in the order received
        o.map(this._promiseHandle.bind(this))
      );
      return S ? S(null, g) : g;
    } catch (g) {
      if (S)
        return S(g);
      throw g;
    }
  }
  /**
   * A promise-wrapped _handle.
   */
  _promiseHandle(o) {
    return new Promise((S) => {
      this._handle(o, (g, U) => {
        S(U);
      });
    });
  }
  /**
   * Ensures that the request object is valid, processes it, and passes any
   * error and the response object to the given callback.
   *
   * Does not reject.
   */
  async _handle(o, S) {
    if (!o || Array.isArray(o) || typeof o != "object") {
      const q = new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof o}`, { request: o });
      return S(q, { id: void 0, jsonrpc: "2.0", error: q });
    }
    if (typeof o.method != "string") {
      const q = new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof o.method}`, { request: o });
      return S(q, { id: o.id, jsonrpc: "2.0", error: q });
    }
    const g = Object.assign({}, o), U = {
      id: g.id,
      jsonrpc: g.jsonrpc
    };
    let h = null;
    try {
      await this._processRequest(g, U);
    } catch (q) {
      h = q;
    }
    return h && (delete U.result, U.error || (U.error = eth_rpc_errors_1$2.serializeError(h))), S(h, U);
  }
  /**
   * For the given request and response, runs all middleware and their return
   * handlers, if any, and ensures that internal request processing semantics
   * are satisfied.
   */
  async _processRequest(o, S) {
    const [g, U, h] = await JsonRpcEngine._runAllMiddleware(o, S, this._middleware);
    if (JsonRpcEngine._checkForCompletion(o, S, U), await JsonRpcEngine._runReturnHandlers(h), g)
      throw g;
  }
  /**
   * Serially executes the given stack of middleware.
   *
   * @returns An array of any error encountered during middleware execution,
   * a boolean indicating whether the request was completed, and an array of
   * middleware-defined return handlers.
   */
  static async _runAllMiddleware(o, S, g) {
    const U = [];
    let h = null, q = !1;
    for (const A of g)
      if ([h, q] = await JsonRpcEngine._runMiddleware(o, S, A, U), q)
        break;
    return [h, q, U.reverse()];
  }
  /**
   * Runs an individual middleware.
   *
   * @returns An array of any error encountered during middleware exection,
   * and a boolean indicating whether the request should end.
   */
  static _runMiddleware(o, S, g, U) {
    return new Promise((h) => {
      const q = (P) => {
        const I = P || S.error;
        I && (S.error = eth_rpc_errors_1$2.serializeError(I)), h([I, !0]);
      }, A = (P) => {
        S.error ? q(S.error) : (P && (typeof P != "function" && q(new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof P}" for request:
${jsonify$1(o)}`, { request: o })), U.push(P)), h([null, !1]));
      };
      try {
        g(o, S, A, q);
      } catch (P) {
        q(P);
      }
    });
  }
  /**
   * Serially executes array of return handlers. The request and response are
   * assumed to be in their scope.
   */
  static async _runReturnHandlers(o) {
    for (const S of o)
      await new Promise((g, U) => {
        S((h) => h ? U(h) : g());
      });
  }
  /**
   * Throws an error if the response has neither a result nor an error, or if
   * the "isComplete" flag is falsy.
   */
  static _checkForCompletion(o, S, g) {
    if (!("result" in S) && !("error" in S))
      throw new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify$1(o)}`, { request: o });
    if (!g)
      throw new eth_rpc_errors_1$2.EthereumRpcError(eth_rpc_errors_1$2.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify$1(o)}`, { request: o });
  }
}
JsonRpcEngine$1.JsonRpcEngine = JsonRpcEngine;
function jsonify$1(e) {
  return JSON.stringify(e, null, 2);
}
var mergeMiddleware$1 = {};
Object.defineProperty(mergeMiddleware$1, "__esModule", { value: !0 });
mergeMiddleware$1.mergeMiddleware = void 0;
const JsonRpcEngine_1 = JsonRpcEngine$1;
function mergeMiddleware(e) {
  const o = new JsonRpcEngine_1.JsonRpcEngine();
  return e.forEach((S) => o.push(S)), o.asMiddleware();
}
mergeMiddleware$1.mergeMiddleware = mergeMiddleware;
(function(e) {
  var o = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(g, U, h, q) {
    q === void 0 && (q = h), Object.defineProperty(g, q, { enumerable: !0, get: function() {
      return U[h];
    } });
  } : function(g, U, h, q) {
    q === void 0 && (q = h), g[q] = U[h];
  }), S = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(g, U) {
    for (var h in g)
      h !== "default" && !Object.prototype.hasOwnProperty.call(U, h) && o(U, g, h);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), S(idRemapMiddleware, e), S(createAsyncMiddleware$1, e), S(createScaffoldMiddleware$1, e), S(getUniqueId$1, e), S(JsonRpcEngine$1, e), S(mergeMiddleware$1, e);
})(dist$6);
function safeApply(e, o, S) {
  try {
    Reflect.apply(e, o, S);
  } catch (g) {
    setTimeout(() => {
      throw g;
    });
  }
}
function arrayClone(e) {
  const o = e.length, S = new Array(o);
  for (let g = 0; g < o; g += 1)
    S[g] = e[g];
  return S;
}
class SafeEventEmitter extends eventsExports.EventEmitter {
  emit(o, ...S) {
    let g = o === "error";
    const U = this._events;
    if (U !== void 0)
      g = g && U.error === void 0;
    else if (!g)
      return !1;
    if (g) {
      let q;
      if (S.length > 0 && ([q] = S), q instanceof Error)
        throw q;
      const A = new Error(`Unhandled error.${q ? ` (${q.message})` : ""}`);
      throw A.context = q, A;
    }
    const h = U[o];
    if (h === void 0)
      return !1;
    if (typeof h == "function")
      safeApply(h, this, S);
    else {
      const q = h.length, A = arrayClone(h);
      for (let P = 0; P < q; P += 1)
        safeApply(A[P], this, S);
    }
    return !0;
  }
}
const PROVIDER_COOKIE_NAME = "provider:", getSelectedAddress = (e, o, S) => {
  const g = e.getLocalStorage(
    PROVIDER_COOKIE_NAME + o,
    "selectedAddress"
  );
  if (!g || !(g != null && g.length))
    return;
  const U = e.getLocalStorage(o, "user_id");
  return g == null ? void 0 : g.find(
    (q) => q.network === S && q.userId === U
  );
}, setSelectedAddress = (e, o, S, g) => {
  const U = e.getLocalStorage(
    PROVIDER_COOKIE_NAME + o,
    "selectedAddress"
  ), h = e.getLocalStorage(o, "user_id");
  if (!U || !(U != null && U.length)) {
    e.setLocalStorage(
      PROVIDER_COOKIE_NAME + o,
      "selectedAddress",
      [
        {
          userId: h,
          network: S,
          address: g == null ? void 0 : g.toLowerCase()
        }
      ]
    );
    return;
  }
  const q = U == null ? void 0 : U.findIndex(
    (A) => A.network === S && A.userId === h
  );
  q !== -1 ? U[q].address = g == null ? void 0 : g.toLowerCase() : U.push({
    userId: h,
    network: S,
    address: g == null ? void 0 : g.toLowerCase()
  }), e.setLocalStorage(
    PROVIDER_COOKIE_NAME + o,
    "selectedAddress",
    U
  );
};
var dist$5 = {}, blockCache = {}, loggingUtils = {}, dist$4 = {}, assert$4 = {};
class StructError extends TypeError {
  constructor(o, S) {
    let g;
    const { message: U, explanation: h, ...q } = o, { path: A } = o, P = A.length === 0 ? U : `At path: ${A.join(".")} -- ${U}`;
    super(h ?? P), h != null && (this.cause = P), Object.assign(this, q), this.name = this.constructor.name, this.failures = () => g ?? (g = [o, ...S()]);
  }
}
function isIterable(e) {
  return isObject(e) && typeof e[Symbol.iterator] == "function";
}
function isObject(e) {
  return typeof e == "object" && e != null;
}
function isPlainObject(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const o = Object.getPrototypeOf(e);
  return o === null || o === Object.prototype;
}
function print(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function shiftIterator(e) {
  const { done: o, value: S } = e.next();
  return o ? void 0 : S;
}
function toFailure(e, o, S, g) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: U, branch: h } = o, { type: q } = S, { refinement: A, message: P = `Expected a value of type \`${q}\`${A ? ` with refinement \`${A}\`` : ""}, but received: \`${print(g)}\`` } = e;
  return {
    value: g,
    type: q,
    refinement: A,
    key: U[U.length - 1],
    path: U,
    branch: h,
    ...e,
    message: P
  };
}
function* toFailures(e, o, S, g) {
  isIterable(e) || (e = [e]);
  for (const U of e) {
    const h = toFailure(U, o, S, g);
    h && (yield h);
  }
}
function* run(e, o, S = {}) {
  const { path: g = [], branch: U = [e], coerce: h = !1, mask: q = !1 } = S, A = { path: g, branch: U };
  if (h && (e = o.coercer(e, A), q && o.type !== "type" && isObject(o.schema) && isObject(e) && !Array.isArray(e)))
    for (const I in e)
      o.schema[I] === void 0 && delete e[I];
  let P = "valid";
  for (const I of o.validator(e, A))
    I.explanation = S.message, P = "not_valid", yield [I, void 0];
  for (let [I, B, H] of o.entries(e, A)) {
    const V = run(B, H, {
      path: I === void 0 ? g : [...g, I],
      branch: I === void 0 ? U : [...U, B],
      coerce: h,
      mask: q,
      message: S.message
    });
    for (const X of V)
      X[0] ? (P = X[0].refinement != null ? "not_refined" : "not_valid", yield [X[0], void 0]) : h && (B = X[1], I === void 0 ? e = B : e instanceof Map ? e.set(I, B) : e instanceof Set ? e.add(B) : isObject(e) && (B !== void 0 || I in e) && (e[I] = B));
  }
  if (P !== "not_valid")
    for (const I of o.refiner(e, A))
      I.explanation = S.message, P = "not_refined", yield [I, void 0];
  P === "valid" && (yield [void 0, e]);
}
class Struct {
  constructor(o) {
    const { type: S, schema: g, validator: U, refiner: h, coercer: q = (P) => P, entries: A = function* () {
    } } = o;
    this.type = S, this.schema = g, this.entries = A, this.coercer = q, U ? this.validator = (P, I) => {
      const B = U(P, I);
      return toFailures(B, I, this, P);
    } : this.validator = () => [], h ? this.refiner = (P, I) => {
      const B = h(P, I);
      return toFailures(B, I, this, P);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(o, S) {
    return assert$3(o, this, S);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(o, S) {
    return create(o, this, S);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(o) {
    return is(o, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(o, S) {
    return mask(o, this, S);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(o, S = {}) {
    return validate(o, this, S);
  }
}
function assert$3(e, o, S) {
  const g = validate(e, o, { message: S });
  if (g[0])
    throw g[0];
}
function create(e, o, S) {
  const g = validate(e, o, { coerce: !0, message: S });
  if (g[0])
    throw g[0];
  return g[1];
}
function mask(e, o, S) {
  const g = validate(e, o, { coerce: !0, mask: !0, message: S });
  if (g[0])
    throw g[0];
  return g[1];
}
function is(e, o) {
  return !validate(e, o)[0];
}
function validate(e, o, S = {}) {
  const g = run(e, o, S), U = shiftIterator(g);
  return U[0] ? [new StructError(U[0], function* () {
    for (const q of g)
      q[0] && (yield q[0]);
  }), void 0] : [void 0, U[1]];
}
function assign(...e) {
  const o = e[0].type === "type", S = e.map((U) => U.schema), g = Object.assign({}, ...S);
  return o ? type$1(g) : object(g);
}
function define$1(e, o) {
  return new Struct({ type: e, schema: null, validator: o });
}
function deprecated(e, o) {
  return new Struct({
    ...e,
    refiner: (S, g) => S === void 0 || e.refiner(S, g),
    validator(S, g) {
      return S === void 0 ? !0 : (o(S, g), e.validator(S, g));
    }
  });
}
function dynamic(e) {
  return new Struct({
    type: "dynamic",
    schema: null,
    *entries(o, S) {
      yield* e(o, S).entries(o, S);
    },
    validator(o, S) {
      return e(o, S).validator(o, S);
    },
    coercer(o, S) {
      return e(o, S).coercer(o, S);
    },
    refiner(o, S) {
      return e(o, S).refiner(o, S);
    }
  });
}
function lazy(e) {
  let o;
  return new Struct({
    type: "lazy",
    schema: null,
    *entries(S, g) {
      o ?? (o = e()), yield* o.entries(S, g);
    },
    validator(S, g) {
      return o ?? (o = e()), o.validator(S, g);
    },
    coercer(S, g) {
      return o ?? (o = e()), o.coercer(S, g);
    },
    refiner(S, g) {
      return o ?? (o = e()), o.refiner(S, g);
    }
  });
}
function omit(e, o) {
  const { schema: S } = e, g = { ...S };
  for (const U of o)
    delete g[U];
  switch (e.type) {
    case "type":
      return type$1(g);
    default:
      return object(g);
  }
}
function partial(e) {
  const o = e instanceof Struct, S = o ? { ...e.schema } : { ...e };
  for (const g in S)
    S[g] = optional(S[g]);
  return o && e.type === "type" ? type$1(S) : object(S);
}
function pick(e, o) {
  const { schema: S } = e, g = {};
  for (const U of o)
    g[U] = S[U];
  switch (e.type) {
    case "type":
      return type$1(g);
    default:
      return object(g);
  }
}
function struct(e, o) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), define$1(e, o);
}
function any() {
  return define$1("any", () => !0);
}
function array(e) {
  return new Struct({
    type: "array",
    schema: e,
    *entries(o) {
      if (e && Array.isArray(o))
        for (const [S, g] of o.entries())
          yield [S, g, e];
    },
    coercer(o) {
      return Array.isArray(o) ? o.slice() : o;
    },
    validator(o) {
      return Array.isArray(o) || `Expected an array value, but received: ${print(o)}`;
    }
  });
}
function bigint() {
  return define$1("bigint", (e) => typeof e == "bigint");
}
function boolean() {
  return define$1("boolean", (e) => typeof e == "boolean");
}
function date() {
  return define$1("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${print(e)}`);
}
function enums(e) {
  const o = {}, S = e.map((g) => print(g)).join();
  for (const g of e)
    o[g] = g;
  return new Struct({
    type: "enums",
    schema: o,
    validator(g) {
      return e.includes(g) || `Expected one of \`${S}\`, but received: ${print(g)}`;
    }
  });
}
function func() {
  return define$1("func", (e) => typeof e == "function" || `Expected a function, but received: ${print(e)}`);
}
function instance(e) {
  return define$1("instance", (o) => o instanceof e || `Expected a \`${e.name}\` instance, but received: ${print(o)}`);
}
function integer() {
  return define$1("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${print(e)}`);
}
function intersection(e) {
  return new Struct({
    type: "intersection",
    schema: null,
    *entries(o, S) {
      for (const g of e)
        yield* g.entries(o, S);
    },
    *validator(o, S) {
      for (const g of e)
        yield* g.validator(o, S);
    },
    *refiner(o, S) {
      for (const g of e)
        yield* g.refiner(o, S);
    }
  });
}
function literal(e) {
  const o = print(e), S = typeof e;
  return new Struct({
    type: "literal",
    schema: S === "string" || S === "number" || S === "boolean" ? e : null,
    validator(g) {
      return g === e || `Expected the literal \`${o}\`, but received: ${print(g)}`;
    }
  });
}
function map(e, o) {
  return new Struct({
    type: "map",
    schema: null,
    *entries(S) {
      if (e && o && S instanceof Map)
        for (const [g, U] of S.entries())
          yield [g, g, e], yield [g, U, o];
    },
    coercer(S) {
      return S instanceof Map ? new Map(S) : S;
    },
    validator(S) {
      return S instanceof Map || `Expected a \`Map\` object, but received: ${print(S)}`;
    }
  });
}
function never() {
  return define$1("never", () => !1);
}
function nullable(e) {
  return new Struct({
    ...e,
    validator: (o, S) => o === null || e.validator(o, S),
    refiner: (o, S) => o === null || e.refiner(o, S)
  });
}
function number$2() {
  return define$1("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${print(e)}`);
}
function object(e) {
  const o = e ? Object.keys(e) : [], S = never();
  return new Struct({
    type: "object",
    schema: e || null,
    *entries(g) {
      if (e && isObject(g)) {
        const U = new Set(Object.keys(g));
        for (const h of o)
          U.delete(h), yield [h, g[h], e[h]];
        for (const h of U)
          yield [h, g[h], S];
      }
    },
    validator(g) {
      return isObject(g) || `Expected an object, but received: ${print(g)}`;
    },
    coercer(g) {
      return isObject(g) ? { ...g } : g;
    }
  });
}
function optional(e) {
  return new Struct({
    ...e,
    validator: (o, S) => o === void 0 || e.validator(o, S),
    refiner: (o, S) => o === void 0 || e.refiner(o, S)
  });
}
function record(e, o) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(S) {
      if (isObject(S))
        for (const g in S) {
          const U = S[g];
          yield [g, g, e], yield [g, U, o];
        }
    },
    validator(S) {
      return isObject(S) || `Expected an object, but received: ${print(S)}`;
    }
  });
}
function regexp() {
  return define$1("regexp", (e) => e instanceof RegExp);
}
function set(e) {
  return new Struct({
    type: "set",
    schema: null,
    *entries(o) {
      if (e && o instanceof Set)
        for (const S of o)
          yield [S, S, e];
    },
    coercer(o) {
      return o instanceof Set ? new Set(o) : o;
    },
    validator(o) {
      return o instanceof Set || `Expected a \`Set\` object, but received: ${print(o)}`;
    }
  });
}
function string() {
  return define$1("string", (e) => typeof e == "string" || `Expected a string, but received: ${print(e)}`);
}
function tuple(e) {
  const o = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(S) {
      if (Array.isArray(S)) {
        const g = Math.max(e.length, S.length);
        for (let U = 0; U < g; U++)
          yield [U, S[U], e[U] || o];
      }
    },
    validator(S) {
      return Array.isArray(S) || `Expected an array, but received: ${print(S)}`;
    }
  });
}
function type$1(e) {
  const o = Object.keys(e);
  return new Struct({
    type: "type",
    schema: e,
    *entries(S) {
      if (isObject(S))
        for (const g of o)
          yield [g, S[g], e[g]];
    },
    validator(S) {
      return isObject(S) || `Expected an object, but received: ${print(S)}`;
    },
    coercer(S) {
      return isObject(S) ? { ...S } : S;
    }
  });
}
function union(e) {
  const o = e.map((S) => S.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(S) {
      for (const g of e) {
        const [U, h] = g.validate(S, { coerce: !0 });
        if (!U)
          return h;
      }
      return S;
    },
    validator(S, g) {
      const U = [];
      for (const h of e) {
        const [...q] = run(S, h, g), [A] = q;
        if (A[0])
          for (const [P] of q)
            P && U.push(P);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${o}\`, but received: ${print(S)}`,
        ...U
      ];
    }
  });
}
function unknown() {
  return define$1("unknown", () => !0);
}
function coerce$2(e, o, S) {
  return new Struct({
    ...e,
    coercer: (g, U) => is(g, o) ? e.coercer(S(g, U), U) : e.coercer(g, U)
  });
}
function defaulted(e, o, S = {}) {
  return coerce$2(e, unknown(), (g) => {
    const U = typeof o == "function" ? o() : o;
    if (g === void 0)
      return U;
    if (!S.strict && isPlainObject(g) && isPlainObject(U)) {
      const h = { ...g };
      let q = !1;
      for (const A in U)
        h[A] === void 0 && (h[A] = U[A], q = !0);
      if (q)
        return h;
    }
    return g;
  });
}
function trimmed(e) {
  return coerce$2(e, string(), (o) => o.trim());
}
function empty(e) {
  return refine(e, "empty", (o) => {
    const S = getSize(o);
    return S === 0 || `Expected an empty ${e.type} but received one with a size of \`${S}\``;
  });
}
function getSize(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function max$1(e, o, S = {}) {
  const { exclusive: g } = S;
  return refine(e, "max", (U) => g ? U < o : U <= o || `Expected a ${e.type} less than ${g ? "" : "or equal to "}${o} but received \`${U}\``);
}
function min(e, o, S = {}) {
  const { exclusive: g } = S;
  return refine(e, "min", (U) => g ? U > o : U >= o || `Expected a ${e.type} greater than ${g ? "" : "or equal to "}${o} but received \`${U}\``);
}
function nonempty(e) {
  return refine(e, "nonempty", (o) => getSize(o) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function pattern(e, o) {
  return refine(e, "pattern", (S) => o.test(S) || `Expected a ${e.type} matching \`/${o.source}/\` but received "${S}"`);
}
function size(e, o, S = o) {
  const g = `Expected a ${e.type}`, U = o === S ? `of \`${o}\`` : `between \`${o}\` and \`${S}\``;
  return refine(e, "size", (h) => {
    if (typeof h == "number" || h instanceof Date)
      return o <= h && h <= S || `${g} ${U} but received \`${h}\``;
    if (h instanceof Map || h instanceof Set) {
      const { size: q } = h;
      return o <= q && q <= S || `${g} with a size ${U} but received one with a size of \`${q}\``;
    } else {
      const { length: q } = h;
      return o <= q && q <= S || `${g} with a length ${U} but received one with a length of \`${q}\``;
    }
  });
}
function refine(e, o, S) {
  return new Struct({
    ...e,
    *refiner(g, U) {
      yield* e.refiner(g, U);
      const h = S(g, U), q = toFailures(h, U, e, g);
      for (const A of q)
        yield { ...A, refinement: o };
    }
  });
}
const dist$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct,
  StructError,
  any,
  array,
  assert: assert$3,
  assign,
  bigint,
  boolean,
  coerce: coerce$2,
  create,
  date,
  defaulted,
  define: define$1,
  deprecated,
  dynamic,
  empty,
  enums,
  func,
  instance,
  integer,
  intersection,
  is,
  lazy,
  literal,
  map,
  mask,
  max: max$1,
  min,
  never,
  nonempty,
  nullable,
  number: number$2,
  object,
  omit,
  optional,
  partial,
  pattern,
  pick,
  record,
  refine,
  regexp,
  set,
  size,
  string,
  struct,
  trimmed,
  tuple,
  type: type$1,
  union,
  unknown,
  validate
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist$3);
Object.defineProperty(assert$4, "__esModule", { value: !0 });
assert$4.assertExhaustive = assert$4.assertStruct = assert$4.assert = assert$4.AssertionError = void 0;
const superstruct_1$3 = require$$1$2;
function isErrorWithMessage(e) {
  return typeof e == "object" && e !== null && "message" in e;
}
function isConstructable(e) {
  var o, S;
  return typeof ((S = (o = e == null ? void 0 : e.prototype) === null || o === void 0 ? void 0 : o.constructor) === null || S === void 0 ? void 0 : S.name) == "string";
}
function getErrorMessage(e) {
  const o = isErrorWithMessage(e) ? e.message : String(e);
  return o.endsWith(".") ? o.slice(0, -1) : o;
}
function getError(e, o) {
  return isConstructable(e) ? new e({
    message: o
  }) : e({
    message: o
  });
}
class AssertionError extends Error {
  constructor(o) {
    super(o.message), this.code = "ERR_ASSERTION";
  }
}
assert$4.AssertionError = AssertionError;
function assert$2(e, o = "Assertion failed.", S = AssertionError) {
  if (!e)
    throw o instanceof Error ? o : getError(S, o);
}
assert$4.assert = assert$2;
function assertStruct(e, o, S = "Assertion failed", g = AssertionError) {
  try {
    (0, superstruct_1$3.assert)(e, o);
  } catch (U) {
    throw getError(g, `${S}: ${getErrorMessage(U)}.`);
  }
}
assert$4.assertStruct = assertStruct;
function assertExhaustive(e) {
  throw new Error("Invalid branch reached. Should be detected during compilation.");
}
assert$4.assertExhaustive = assertExhaustive;
var base64$1 = {};
Object.defineProperty(base64$1, "__esModule", { value: !0 });
base64$1.base64 = void 0;
const superstruct_1$2 = require$$1$2, assert_1$3 = assert$4, base64 = (e, o = {}) => {
  var S, g;
  const U = (S = o.paddingRequired) !== null && S !== void 0 ? S : !1, h = (g = o.characterSet) !== null && g !== void 0 ? g : "base64";
  let q;
  h === "base64" ? q = String.raw`[A-Za-z0-9+\/]` : ((0, assert_1$3.assert)(h === "base64url"), q = String.raw`[-_A-Za-z0-9]`);
  let A;
  return U ? A = new RegExp(`^(?:${q}{4})*(?:${q}{3}=|${q}{2}==)?$`, "u") : A = new RegExp(`^(?:${q}{4})*(?:${q}{2,3}|${q}{3}=|${q}{2}==)?$`, "u"), (0, superstruct_1$2.pattern)(e, A);
};
base64$1.base64 = base64;
var bytes$2 = {}, hex = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
  const o = require$$1$2, S = assert$4;
  e.HexStruct = (0, o.pattern)((0, o.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, o.pattern)((0, o.string)(), /^0x[0-9a-f]+$/iu);
  function g(I) {
    return (0, o.is)(I, e.HexStruct);
  }
  e.isHexString = g;
  function U(I) {
    return (0, o.is)(I, e.StrictHexStruct);
  }
  e.isStrictHexString = U;
  function h(I) {
    (0, S.assert)(g(I), "Value must be a hexadecimal string.");
  }
  e.assertIsHexString = h;
  function q(I) {
    (0, S.assert)(U(I), 'Value must be a hexadecimal string, starting with "0x".');
  }
  e.assertIsStrictHexString = q;
  function A(I) {
    return I.startsWith("0x") ? I : I.startsWith("0X") ? `0x${I.substring(2)}` : `0x${I}`;
  }
  e.add0x = A;
  function P(I) {
    return I.startsWith("0x") || I.startsWith("0X") ? I.substring(2) : I;
  }
  e.remove0x = P;
})(hex);
Object.defineProperty(bytes$2, "__esModule", { value: !0 });
bytes$2.createDataView = bytes$2.concatBytes = bytes$2.valueToBytes = bytes$2.stringToBytes = bytes$2.numberToBytes = bytes$2.signedBigIntToBytes = bytes$2.bigIntToBytes = bytes$2.hexToBytes = bytes$2.bytesToString = bytes$2.bytesToNumber = bytes$2.bytesToSignedBigInt = bytes$2.bytesToBigInt = bytes$2.bytesToHex = bytes$2.assertIsBytes = bytes$2.isBytes = void 0;
const assert_1$2 = assert$4, hex_1$2 = hex, HEX_MINIMUM_NUMBER_CHARACTER = 48, HEX_MAXIMUM_NUMBER_CHARACTER = 58, HEX_CHARACTER_OFFSET = 87;
function getPrecomputedHexValuesBuilder() {
  const e = [];
  return () => {
    if (e.length === 0)
      for (let o = 0; o < 256; o++)
        e.push(o.toString(16).padStart(2, "0"));
    return e;
  };
}
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
function isBytes$2(e) {
  return e instanceof Uint8Array;
}
bytes$2.isBytes = isBytes$2;
function assertIsBytes(e) {
  (0, assert_1$2.assert)(isBytes$2(e), "Value must be a Uint8Array.");
}
bytes$2.assertIsBytes = assertIsBytes;
function bytesToHex$2(e) {
  if (assertIsBytes(e), e.length === 0)
    return "0x";
  const o = getPrecomputedHexValues(), S = new Array(e.length);
  for (let g = 0; g < e.length; g++)
    S[g] = o[e[g]];
  return (0, hex_1$2.add0x)(S.join(""));
}
bytes$2.bytesToHex = bytesToHex$2;
function bytesToBigInt(e) {
  assertIsBytes(e);
  const o = bytesToHex$2(e);
  return BigInt(o);
}
bytes$2.bytesToBigInt = bytesToBigInt;
function bytesToSignedBigInt(e) {
  assertIsBytes(e);
  let o = BigInt(0);
  for (const S of e)
    o = (o << BigInt(8)) + BigInt(S);
  return BigInt.asIntN(e.length * 8, o);
}
bytes$2.bytesToSignedBigInt = bytesToSignedBigInt;
function bytesToNumber(e) {
  assertIsBytes(e);
  const o = bytesToBigInt(e);
  return (0, assert_1$2.assert)(o <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(o);
}
bytes$2.bytesToNumber = bytesToNumber;
function bytesToString(e) {
  return assertIsBytes(e), new TextDecoder().decode(e);
}
bytes$2.bytesToString = bytesToString;
function hexToBytes$2(e) {
  var o;
  if (((o = e == null ? void 0 : e.toLowerCase) === null || o === void 0 ? void 0 : o.call(e)) === "0x")
    return new Uint8Array();
  (0, hex_1$2.assertIsHexString)(e);
  const S = (0, hex_1$2.remove0x)(e).toLowerCase(), g = S.length % 2 === 0 ? S : `0${S}`, U = new Uint8Array(g.length / 2);
  for (let h = 0; h < U.length; h++) {
    const q = g.charCodeAt(h * 2), A = g.charCodeAt(h * 2 + 1), P = q - (q < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET), I = A - (A < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
    U[h] = P * 16 + I;
  }
  return U;
}
bytes$2.hexToBytes = hexToBytes$2;
function bigIntToBytes(e) {
  (0, assert_1$2.assert)(typeof e == "bigint", "Value must be a bigint."), (0, assert_1$2.assert)(e >= BigInt(0), "Value must be a non-negative bigint.");
  const o = e.toString(16);
  return hexToBytes$2(o);
}
bytes$2.bigIntToBytes = bigIntToBytes;
function bigIntFits(e, o) {
  (0, assert_1$2.assert)(o > 0);
  const S = e >> BigInt(31);
  return !((~e & S) + (e & ~S) >> BigInt(o * 8 + -1));
}
function signedBigIntToBytes(e, o) {
  (0, assert_1$2.assert)(typeof e == "bigint", "Value must be a bigint."), (0, assert_1$2.assert)(typeof o == "number", "Byte length must be a number."), (0, assert_1$2.assert)(o > 0, "Byte length must be greater than 0."), (0, assert_1$2.assert)(bigIntFits(e, o), "Byte length is too small to represent the given value.");
  let S = e;
  const g = new Uint8Array(o);
  for (let U = 0; U < g.length; U++)
    g[U] = Number(BigInt.asUintN(8, S)), S >>= BigInt(8);
  return g.reverse();
}
bytes$2.signedBigIntToBytes = signedBigIntToBytes;
function numberToBytes(e) {
  (0, assert_1$2.assert)(typeof e == "number", "Value must be a number."), (0, assert_1$2.assert)(e >= 0, "Value must be a non-negative number."), (0, assert_1$2.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToBytes` instead.");
  const o = e.toString(16);
  return hexToBytes$2(o);
}
bytes$2.numberToBytes = numberToBytes;
function stringToBytes(e) {
  return (0, assert_1$2.assert)(typeof e == "string", "Value must be a string."), new TextEncoder().encode(e);
}
bytes$2.stringToBytes = stringToBytes;
function valueToBytes(e) {
  if (typeof e == "bigint")
    return bigIntToBytes(e);
  if (typeof e == "number")
    return numberToBytes(e);
  if (typeof e == "string")
    return e.startsWith("0x") ? hexToBytes$2(e) : stringToBytes(e);
  if (isBytes$2(e))
    return e;
  throw new TypeError(`Unsupported value type: "${typeof e}".`);
}
bytes$2.valueToBytes = valueToBytes;
function concatBytes$2(e) {
  const o = new Array(e.length);
  let S = 0;
  for (let U = 0; U < e.length; U++) {
    const h = valueToBytes(e[U]);
    o[U] = h, S += h.length;
  }
  const g = new Uint8Array(S);
  for (let U = 0, h = 0; U < o.length; U++)
    g.set(o[U], h), h += o[U].length;
  return g;
}
bytes$2.concatBytes = concatBytes$2;
function createDataView(e) {
  if (typeof buffer$3.Buffer < "u" && e instanceof buffer$3.Buffer) {
    const o = e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
    return new DataView(o);
  }
  return new DataView(e.buffer, e.byteOffset, e.byteLength);
}
bytes$2.createDataView = createDataView;
var checksum = {};
Object.defineProperty(checksum, "__esModule", { value: !0 });
checksum.ChecksumStruct = void 0;
const superstruct_1$1 = require$$1$2, base64_1 = base64$1;
checksum.ChecksumStruct = (0, superstruct_1$1.size)((0, base64_1.base64)((0, superstruct_1$1.string)(), { paddingRequired: !0 }), 44, 44);
var coercers = {};
Object.defineProperty(coercers, "__esModule", { value: !0 });
coercers.createHex = coercers.createBytes = coercers.createBigInt = coercers.createNumber = void 0;
const superstruct_1 = require$$1$2, assert_1$1 = assert$4, bytes_1$3 = bytes$2, hex_1$1 = hex, NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1$1.StrictHexStruct]), NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number), BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
(0, superstruct_1.union)([hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1$1.StrictHexStruct]), bytes_1$3.hexToBytes), HexCoercer = (0, superstruct_1.coerce)(hex_1$1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1$3.bytesToHex);
function createNumber(e) {
  try {
    const o = (0, superstruct_1.create)(e, NumberCoercer);
    return (0, assert_1$1.assert)(Number.isFinite(o), `Expected a number-like value, got "${e}".`), o;
  } catch (o) {
    throw o instanceof superstruct_1.StructError ? new Error(`Expected a number-like value, got "${e}".`) : o;
  }
}
coercers.createNumber = createNumber;
function createBigInt(e) {
  try {
    return (0, superstruct_1.create)(e, BigIntCoercer);
  } catch (o) {
    throw o instanceof superstruct_1.StructError ? new Error(`Expected a number-like value, got "${String(o.value)}".`) : o;
  }
}
coercers.createBigInt = createBigInt;
function createBytes(e) {
  if (typeof e == "string" && e.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return (0, superstruct_1.create)(e, BytesCoercer);
  } catch (o) {
    throw o instanceof superstruct_1.StructError ? new Error(`Expected a bytes-like value, got "${String(o.value)}".`) : o;
  }
}
coercers.createBytes = createBytes;
function createHex(e) {
  if (e instanceof Uint8Array && e.length === 0 || typeof e == "string" && e.toLowerCase() === "0x")
    return "0x";
  try {
    return (0, superstruct_1.create)(e, HexCoercer);
  } catch (o) {
    throw o instanceof superstruct_1.StructError ? new Error(`Expected a bytes-like value, got "${String(o.value)}".`) : o;
  }
}
coercers.createHex = createHex;
var collections = {}, __classPrivateFieldSet = commonjsGlobal$1 && commonjsGlobal$1.__classPrivateFieldSet || function(e, o, S, g, U) {
  if (g === "m")
    throw new TypeError("Private method is not writable");
  if (g === "a" && !U)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof o == "function" ? e !== o || !U : !o.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return g === "a" ? U.call(e, S) : U ? U.value = S : o.set(e, S), S;
}, __classPrivateFieldGet = commonjsGlobal$1 && commonjsGlobal$1.__classPrivateFieldGet || function(e, o, S, g) {
  if (S === "a" && !g)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof o == "function" ? e !== o || !g : !o.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return S === "m" ? g : S === "a" ? g.call(e) : g ? g.value : o.get(e);
}, _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(collections, "__esModule", { value: !0 });
collections.FrozenSet = collections.FrozenMap = void 0;
class FrozenMap {
  constructor(o) {
    _FrozenMap_map.set(this, void 0), __classPrivateFieldSet(this, _FrozenMap_map, new Map(o), "f"), Object.freeze(this);
  }
  get size() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
  }
  [(_FrozenMap_map = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
  }
  entries() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
  }
  forEach(o, S) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((g, U, h) => o.call(S, g, U, this));
  }
  get(o) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(o);
  }
  has(o) {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(o);
  }
  keys() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
  }
  values() {
    return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([o, S]) => `${String(o)} => ${String(S)}`).join(", ")} ` : ""}}`;
  }
}
collections.FrozenMap = FrozenMap;
class FrozenSet {
  constructor(o) {
    _FrozenSet_set.set(this, void 0), __classPrivateFieldSet(this, _FrozenSet_set, new Set(o), "f"), Object.freeze(this);
  }
  get size() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
  }
  [(_FrozenSet_set = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
  }
  entries() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
  }
  forEach(o, S) {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((g, U, h) => o.call(S, g, U, this));
  }
  has(o) {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(o);
  }
  keys() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
  }
  values() {
    return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((o) => String(o)).join(", ")} ` : ""}}`;
  }
}
collections.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
var json = {}, misc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
  function o(I) {
    return Array.isArray(I) && I.length > 0;
  }
  e.isNonEmptyArray = o;
  function S(I) {
    return I == null;
  }
  e.isNullOrUndefined = S;
  function g(I) {
    return !!I && typeof I == "object" && !Array.isArray(I);
  }
  e.isObject = g;
  const U = (I, B) => Object.hasOwnProperty.call(I, B);
  e.hasProperty = U, function(I) {
    I[I.Null = 4] = "Null", I[I.Comma = 1] = "Comma", I[I.Wrapper = 1] = "Wrapper", I[I.True = 4] = "True", I[I.False = 5] = "False", I[I.Quote = 1] = "Quote", I[I.Colon = 1] = "Colon", I[I.Date = 24] = "Date";
  }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
  function h(I) {
    if (typeof I != "object" || I === null)
      return !1;
    try {
      let B = I;
      for (; Object.getPrototypeOf(B) !== null; )
        B = Object.getPrototypeOf(B);
      return Object.getPrototypeOf(I) === B;
    } catch {
      return !1;
    }
  }
  e.isPlainObject = h;
  function q(I) {
    return I.charCodeAt(0) <= 127;
  }
  e.isASCII = q;
  function A(I) {
    var B;
    return I.split("").reduce((V, X) => q(X) ? V + 1 : V + 2, 0) + ((B = I.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && B !== void 0 ? B : []).length;
  }
  e.calculateStringSize = A;
  function P(I) {
    return I.toString().length;
  }
  e.calculateNumberSize = P;
})(misc);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateJsonAndGetSize = e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.isValidJson = e.JsonStruct = void 0;
  const o = require$$1$2, S = assert$4, g = misc;
  e.JsonStruct = (0, o.define)("Json", (pe) => {
    const [me] = ce(pe, !0);
    return me ? !0 : "Expected a valid JSON-serializable value";
  });
  function U(pe) {
    return (0, o.is)(pe, e.JsonStruct);
  }
  e.isValidJson = U, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, o.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, o.nullable)((0, o.union)([(0, o.number)(), (0, o.string)()])), e.JsonRpcErrorStruct = (0, o.object)({
    code: (0, o.integer)(),
    message: (0, o.string)(),
    data: (0, o.optional)(e.JsonStruct),
    stack: (0, o.optional)((0, o.string)())
  }), e.JsonRpcParamsStruct = (0, o.optional)((0, o.union)([(0, o.record)((0, o.string)(), e.JsonStruct), (0, o.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, o.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    method: (0, o.string)(),
    params: e.JsonRpcParamsStruct
  }), e.JsonRpcNotificationStruct = (0, o.omit)(e.JsonRpcRequestStruct, ["id"]);
  function h(pe) {
    return (0, o.is)(pe, e.JsonRpcNotificationStruct);
  }
  e.isJsonRpcNotification = h;
  function q(pe, me) {
    (0, S.assertStruct)(pe, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", me);
  }
  e.assertIsJsonRpcNotification = q;
  function A(pe) {
    return (0, o.is)(pe, e.JsonRpcRequestStruct);
  }
  e.isJsonRpcRequest = A;
  function P(pe, me) {
    (0, S.assertStruct)(pe, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", me);
  }
  e.assertIsJsonRpcRequest = P, e.PendingJsonRpcResponseStruct = (0, o.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: (0, o.optional)((0, o.unknown)()),
    error: (0, o.optional)(e.JsonRpcErrorStruct)
  }), e.JsonRpcSuccessStruct = (0, o.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    result: e.JsonStruct
  }), e.JsonRpcFailureStruct = (0, o.object)({
    id: e.JsonRpcIdStruct,
    jsonrpc: e.JsonRpcVersionStruct,
    error: e.JsonRpcErrorStruct
  }), e.JsonRpcResponseStruct = (0, o.union)([
    e.JsonRpcSuccessStruct,
    e.JsonRpcFailureStruct
  ]);
  function I(pe) {
    return (0, o.is)(pe, e.PendingJsonRpcResponseStruct);
  }
  e.isPendingJsonRpcResponse = I;
  function B(pe, me) {
    (0, S.assertStruct)(pe, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", me);
  }
  e.assertIsPendingJsonRpcResponse = B;
  function H(pe) {
    return (0, o.is)(pe, e.JsonRpcResponseStruct);
  }
  e.isJsonRpcResponse = H;
  function V(pe, me) {
    (0, S.assertStruct)(pe, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", me);
  }
  e.assertIsJsonRpcResponse = V;
  function X(pe) {
    return (0, o.is)(pe, e.JsonRpcSuccessStruct);
  }
  e.isJsonRpcSuccess = X;
  function Q(pe, me) {
    (0, S.assertStruct)(pe, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", me);
  }
  e.assertIsJsonRpcSuccess = Q;
  function ee(pe) {
    return (0, o.is)(pe, e.JsonRpcFailureStruct);
  }
  e.isJsonRpcFailure = ee;
  function ie(pe, me) {
    (0, S.assertStruct)(pe, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", me);
  }
  e.assertIsJsonRpcFailure = ie;
  function te(pe) {
    return (0, o.is)(pe, e.JsonRpcErrorStruct);
  }
  e.isJsonRpcError = te;
  function se(pe, me) {
    (0, S.assertStruct)(pe, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", me);
  }
  e.assertIsJsonRpcError = se;
  function le(pe) {
    const { permitEmptyString: me, permitFractions: Me, permitNull: Ee } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, pe);
    return (Ne) => !!(typeof Ne == "number" && (Me || Number.isInteger(Ne)) || typeof Ne == "string" && (me || Ne.length > 0) || Ee && Ne === null);
  }
  e.getJsonRpcIdValidator = le;
  function ce(pe, me = !1) {
    const Me = /* @__PURE__ */ new Set();
    function Ee(Re, Ne) {
      if (Re === void 0)
        return [!1, 0];
      if (Re === null)
        return [!0, Ne ? 0 : g.JsonSize.Null];
      const ne = typeof Re;
      try {
        if (ne === "function")
          return [!1, 0];
        if (ne === "string" || Re instanceof String)
          return [
            !0,
            Ne ? 0 : (0, g.calculateStringSize)(Re) + g.JsonSize.Quote * 2
          ];
        if (ne === "boolean" || Re instanceof Boolean)
          return Ne ? [!0, 0] : [!0, Re == !0 ? g.JsonSize.True : g.JsonSize.False];
        if (ne === "number" || Re instanceof Number)
          return Ne ? [!0, 0] : [!0, (0, g.calculateNumberSize)(Re)];
        if (Re instanceof Date)
          return Ne ? [!0, 0] : [
            !0,
            // Note: Invalid dates will serialize to null
            isNaN(Re.getDate()) ? g.JsonSize.Null : g.JsonSize.Date + g.JsonSize.Quote * 2
          ];
      } catch {
        return [!1, 0];
      }
      if (!(0, g.isPlainObject)(Re) && !Array.isArray(Re))
        return [!1, 0];
      if (Me.has(Re))
        return [!1, 0];
      Me.add(Re);
      try {
        return [
          !0,
          Object.entries(Re).reduce(
            (Y, [M, $], O, J) => {
              let [Z, K] = Ee($, Ne);
              if (!Z)
                throw new Error("JSON validation did not pass. Validation process stopped.");
              if (Me.delete(Re), Ne)
                return 0;
              const z = Array.isArray(Re) ? 0 : M.length + g.JsonSize.Comma + g.JsonSize.Colon * 2, G = O < J.length - 1 ? g.JsonSize.Comma : 0;
              return Y + z + K + G;
            },
            // Starts at 2 because the serialized JSON string data (plain text)
            // will minimally contain {}/[]
            Ne ? 0 : g.JsonSize.Wrapper * 2
          )
        ];
      } catch {
        return [!1, 0];
      }
    }
    return Ee(pe, me);
  }
  e.validateJsonAndGetSize = ce;
})(json);
var logging = {}, browser$d = { exports: {} }, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var e = 1e3, o = e * 60, S = o * 60, g = S * 24, U = g * 7, h = g * 365.25;
  ms = function(B, H) {
    H = H || {};
    var V = typeof B;
    if (V === "string" && B.length > 0)
      return q(B);
    if (V === "number" && isFinite(B))
      return H.long ? P(B) : A(B);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(B)
    );
  };
  function q(B) {
    if (B = String(B), !(B.length > 100)) {
      var H = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        B
      );
      if (H) {
        var V = parseFloat(H[1]), X = (H[2] || "ms").toLowerCase();
        switch (X) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return V * h;
          case "weeks":
          case "week":
          case "w":
            return V * U;
          case "days":
          case "day":
          case "d":
            return V * g;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return V * S;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return V * o;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return V * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return V;
          default:
            return;
        }
      }
    }
  }
  function A(B) {
    var H = Math.abs(B);
    return H >= g ? Math.round(B / g) + "d" : H >= S ? Math.round(B / S) + "h" : H >= o ? Math.round(B / o) + "m" : H >= e ? Math.round(B / e) + "s" : B + "ms";
  }
  function P(B) {
    var H = Math.abs(B);
    return H >= g ? I(B, H, g, "day") : H >= S ? I(B, H, S, "hour") : H >= o ? I(B, H, o, "minute") : H >= e ? I(B, H, e, "second") : B + " ms";
  }
  function I(B, H, V, X) {
    var Q = H >= V * 1.5;
    return Math.round(B / V) + " " + X + (Q ? "s" : "");
  }
  return ms;
}
function setup(e) {
  S.debug = S, S.default = S, S.coerce = P, S.disable = h, S.enable = U, S.enabled = q, S.humanize = requireMs(), S.destroy = I, Object.keys(e).forEach((B) => {
    S[B] = e[B];
  }), S.names = [], S.skips = [], S.formatters = {};
  function o(B) {
    let H = 0;
    for (let V = 0; V < B.length; V++)
      H = (H << 5) - H + B.charCodeAt(V), H |= 0;
    return S.colors[Math.abs(H) % S.colors.length];
  }
  S.selectColor = o;
  function S(B) {
    let H, V = null, X, Q;
    function ee(...ie) {
      if (!ee.enabled)
        return;
      const te = ee, se = Number(/* @__PURE__ */ new Date()), le = se - (H || se);
      te.diff = le, te.prev = H, te.curr = se, H = se, ie[0] = S.coerce(ie[0]), typeof ie[0] != "string" && ie.unshift("%O");
      let ce = 0;
      ie[0] = ie[0].replace(/%([a-zA-Z%])/g, (me, Me) => {
        if (me === "%%")
          return "%";
        ce++;
        const Ee = S.formatters[Me];
        if (typeof Ee == "function") {
          const Re = ie[ce];
          me = Ee.call(te, Re), ie.splice(ce, 1), ce--;
        }
        return me;
      }), S.formatArgs.call(te, ie), (te.log || S.log).apply(te, ie);
    }
    return ee.namespace = B, ee.useColors = S.useColors(), ee.color = S.selectColor(B), ee.extend = g, ee.destroy = S.destroy, Object.defineProperty(ee, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => V !== null ? V : (X !== S.namespaces && (X = S.namespaces, Q = S.enabled(B)), Q),
      set: (ie) => {
        V = ie;
      }
    }), typeof S.init == "function" && S.init(ee), ee;
  }
  function g(B, H) {
    const V = S(this.namespace + (typeof H > "u" ? ":" : H) + B);
    return V.log = this.log, V;
  }
  function U(B) {
    S.save(B), S.namespaces = B, S.names = [], S.skips = [];
    let H;
    const V = (typeof B == "string" ? B : "").split(/[\s,]+/), X = V.length;
    for (H = 0; H < X; H++)
      V[H] && (B = V[H].replace(/\*/g, ".*?"), B[0] === "-" ? S.skips.push(new RegExp("^" + B.slice(1) + "$")) : S.names.push(new RegExp("^" + B + "$")));
  }
  function h() {
    const B = [
      ...S.names.map(A),
      ...S.skips.map(A).map((H) => "-" + H)
    ].join(",");
    return S.enable(""), B;
  }
  function q(B) {
    if (B[B.length - 1] === "*")
      return !0;
    let H, V;
    for (H = 0, V = S.skips.length; H < V; H++)
      if (S.skips[H].test(B))
        return !1;
    for (H = 0, V = S.names.length; H < V; H++)
      if (S.names[H].test(B))
        return !0;
    return !1;
  }
  function A(B) {
    return B.toString().substring(2, B.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function P(B) {
    return B instanceof Error ? B.stack || B.message : B;
  }
  function I() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return S.enable(S.load()), S;
}
var common$3 = setup;
(function(e, o) {
  o.formatArgs = g, o.save = U, o.load = h, o.useColors = S, o.storage = q(), o.destroy = /* @__PURE__ */ (() => {
    let P = !1;
    return () => {
      P || (P = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), o.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function S() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function g(P) {
    if (P[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + P[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const I = "color: " + this.color;
    P.splice(1, 0, I, "color: inherit");
    let B = 0, H = 0;
    P[0].replace(/%[a-zA-Z%]/g, (V) => {
      V !== "%%" && (B++, V === "%c" && (H = B));
    }), P.splice(H, 0, I);
  }
  o.log = console.debug || console.log || (() => {
  });
  function U(P) {
    try {
      P ? o.storage.setItem("debug", P) : o.storage.removeItem("debug");
    } catch {
    }
  }
  function h() {
    let P;
    try {
      P = o.storage.getItem("debug");
    } catch {
    }
    return !P && typeof process$3 < "u" && "env" in process$3 && (P = process$3.env.DEBUG), P;
  }
  function q() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = common$3(o);
  const { formatters: A } = e.exports;
  A.j = function(P) {
    try {
      return JSON.stringify(P);
    } catch (I) {
      return "[UnexpectedJSONParseError]: " + I.message;
    }
  };
})(browser$d, browser$d.exports);
var browserExports = browser$d.exports, __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(logging, "__esModule", { value: !0 });
logging.createModuleLogger = logging.createProjectLogger = void 0;
const debug_1$1 = __importDefault$6(browserExports), globalLogger = (0, debug_1$1.default)("metamask");
function createProjectLogger(e) {
  return globalLogger.extend(e);
}
logging.createProjectLogger = createProjectLogger;
function createModuleLogger(e, o) {
  return e.extend(o);
}
logging.createModuleLogger = createModuleLogger;
var number$1 = {};
Object.defineProperty(number$1, "__esModule", { value: !0 });
number$1.hexToBigInt = number$1.hexToNumber = number$1.bigIntToHex = number$1.numberToHex = void 0;
const assert_1 = assert$4, hex_1 = hex, numberToHex$1 = (e) => ((0, assert_1.assert)(typeof e == "number", "Value must be a number."), (0, assert_1.assert)(e >= 0, "Value must be a non-negative number."), (0, assert_1.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, hex_1.add0x)(e.toString(16)));
number$1.numberToHex = numberToHex$1;
const bigIntToHex = (e) => ((0, assert_1.assert)(typeof e == "bigint", "Value must be a bigint."), (0, assert_1.assert)(e >= 0, "Value must be a non-negative bigint."), (0, hex_1.add0x)(e.toString(16)));
number$1.bigIntToHex = bigIntToHex;
const hexToNumber$1 = (e) => {
  (0, hex_1.assertIsHexString)(e);
  const o = parseInt(e, 16);
  return (0, assert_1.assert)(Number.isSafeInteger(o), "Value is not a safe integer. Use `hexToBigInt` instead."), o;
};
number$1.hexToNumber = hexToNumber$1;
const hexToBigInt = (e) => ((0, hex_1.assertIsHexString)(e), BigInt((0, hex_1.add0x)(e)));
number$1.hexToBigInt = hexToBigInt;
var opaque = {};
Object.defineProperty(opaque, "__esModule", { value: !0 });
var time = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(h) {
    h[h.Millisecond = 1] = "Millisecond", h[h.Second = 1e3] = "Second", h[h.Minute = 6e4] = "Minute", h[h.Hour = 36e5] = "Hour", h[h.Day = 864e5] = "Day", h[h.Week = 6048e5] = "Week", h[h.Year = 31536e6] = "Year";
  }(e.Duration || (e.Duration = {}));
  const o = (h) => Number.isInteger(h) && h >= 0, S = (h, q) => {
    if (!o(h))
      throw new Error(`"${q}" must be a non-negative integer. Received: "${h}".`);
  };
  function g(h, q) {
    return S(h, "count"), h * q;
  }
  e.inMilliseconds = g;
  function U(h) {
    return S(h, "timestamp"), Date.now() - h;
  }
  e.timeSince = U;
})(time);
var versions = {}, re$2 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0", MAX_LENGTH$1 = 256, MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, MAX_SAFE_COMPONENT_LENGTH = 16, MAX_SAFE_BUILD_LENGTH = MAX_LENGTH$1 - 6, RELEASE_TYPES = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var constants$4 = {
  MAX_LENGTH: MAX_LENGTH$1,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const debug$1 = typeof process$3 == "object" && process$3.env && process$3.env.NODE_DEBUG && /\bsemver\b/i.test(process$3.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var debug_1 = debug$1;
(function(e, o) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: S,
    MAX_SAFE_BUILD_LENGTH: g,
    MAX_LENGTH: U
  } = constants$4, h = debug_1;
  o = e.exports = {};
  const q = o.re = [], A = o.safeRe = [], P = o.src = [], I = o.t = {};
  let B = 0;
  const H = "[a-zA-Z0-9-]", V = [
    ["\\s", 1],
    ["\\d", U],
    [H, g]
  ], X = (ee) => {
    for (const [ie, te] of V)
      ee = ee.split(`${ie}*`).join(`${ie}{0,${te}}`).split(`${ie}+`).join(`${ie}{1,${te}}`);
    return ee;
  }, Q = (ee, ie, te) => {
    const se = X(ie), le = B++;
    h(ee, le, ie), I[ee] = le, P[le] = ie, q[le] = new RegExp(ie, te ? "g" : void 0), A[le] = new RegExp(se, te ? "g" : void 0);
  };
  Q("NUMERICIDENTIFIER", "0|[1-9]\\d*"), Q("NUMERICIDENTIFIERLOOSE", "\\d+"), Q("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${H}*`), Q("MAINVERSION", `(${P[I.NUMERICIDENTIFIER]})\\.(${P[I.NUMERICIDENTIFIER]})\\.(${P[I.NUMERICIDENTIFIER]})`), Q("MAINVERSIONLOOSE", `(${P[I.NUMERICIDENTIFIERLOOSE]})\\.(${P[I.NUMERICIDENTIFIERLOOSE]})\\.(${P[I.NUMERICIDENTIFIERLOOSE]})`), Q("PRERELEASEIDENTIFIER", `(?:${P[I.NUMERICIDENTIFIER]}|${P[I.NONNUMERICIDENTIFIER]})`), Q("PRERELEASEIDENTIFIERLOOSE", `(?:${P[I.NUMERICIDENTIFIERLOOSE]}|${P[I.NONNUMERICIDENTIFIER]})`), Q("PRERELEASE", `(?:-(${P[I.PRERELEASEIDENTIFIER]}(?:\\.${P[I.PRERELEASEIDENTIFIER]})*))`), Q("PRERELEASELOOSE", `(?:-?(${P[I.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${P[I.PRERELEASEIDENTIFIERLOOSE]})*))`), Q("BUILDIDENTIFIER", `${H}+`), Q("BUILD", `(?:\\+(${P[I.BUILDIDENTIFIER]}(?:\\.${P[I.BUILDIDENTIFIER]})*))`), Q("FULLPLAIN", `v?${P[I.MAINVERSION]}${P[I.PRERELEASE]}?${P[I.BUILD]}?`), Q("FULL", `^${P[I.FULLPLAIN]}$`), Q("LOOSEPLAIN", `[v=\\s]*${P[I.MAINVERSIONLOOSE]}${P[I.PRERELEASELOOSE]}?${P[I.BUILD]}?`), Q("LOOSE", `^${P[I.LOOSEPLAIN]}$`), Q("GTLT", "((?:<|>)?=?)"), Q("XRANGEIDENTIFIERLOOSE", `${P[I.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), Q("XRANGEIDENTIFIER", `${P[I.NUMERICIDENTIFIER]}|x|X|\\*`), Q("XRANGEPLAIN", `[v=\\s]*(${P[I.XRANGEIDENTIFIER]})(?:\\.(${P[I.XRANGEIDENTIFIER]})(?:\\.(${P[I.XRANGEIDENTIFIER]})(?:${P[I.PRERELEASE]})?${P[I.BUILD]}?)?)?`), Q("XRANGEPLAINLOOSE", `[v=\\s]*(${P[I.XRANGEIDENTIFIERLOOSE]})(?:\\.(${P[I.XRANGEIDENTIFIERLOOSE]})(?:\\.(${P[I.XRANGEIDENTIFIERLOOSE]})(?:${P[I.PRERELEASELOOSE]})?${P[I.BUILD]}?)?)?`), Q("XRANGE", `^${P[I.GTLT]}\\s*${P[I.XRANGEPLAIN]}$`), Q("XRANGELOOSE", `^${P[I.GTLT]}\\s*${P[I.XRANGEPLAINLOOSE]}$`), Q("COERCEPLAIN", `(^|[^\\d])(\\d{1,${S}})(?:\\.(\\d{1,${S}}))?(?:\\.(\\d{1,${S}}))?`), Q("COERCE", `${P[I.COERCEPLAIN]}(?:$|[^\\d])`), Q("COERCEFULL", P[I.COERCEPLAIN] + `(?:${P[I.PRERELEASE]})?(?:${P[I.BUILD]})?(?:$|[^\\d])`), Q("COERCERTL", P[I.COERCE], !0), Q("COERCERTLFULL", P[I.COERCEFULL], !0), Q("LONETILDE", "(?:~>?)"), Q("TILDETRIM", `(\\s*)${P[I.LONETILDE]}\\s+`, !0), o.tildeTrimReplace = "$1~", Q("TILDE", `^${P[I.LONETILDE]}${P[I.XRANGEPLAIN]}$`), Q("TILDELOOSE", `^${P[I.LONETILDE]}${P[I.XRANGEPLAINLOOSE]}$`), Q("LONECARET", "(?:\\^)"), Q("CARETTRIM", `(\\s*)${P[I.LONECARET]}\\s+`, !0), o.caretTrimReplace = "$1^", Q("CARET", `^${P[I.LONECARET]}${P[I.XRANGEPLAIN]}$`), Q("CARETLOOSE", `^${P[I.LONECARET]}${P[I.XRANGEPLAINLOOSE]}$`), Q("COMPARATORLOOSE", `^${P[I.GTLT]}\\s*(${P[I.LOOSEPLAIN]})$|^$`), Q("COMPARATOR", `^${P[I.GTLT]}\\s*(${P[I.FULLPLAIN]})$|^$`), Q("COMPARATORTRIM", `(\\s*)${P[I.GTLT]}\\s*(${P[I.LOOSEPLAIN]}|${P[I.XRANGEPLAIN]})`, !0), o.comparatorTrimReplace = "$1$2$3", Q("HYPHENRANGE", `^\\s*(${P[I.XRANGEPLAIN]})\\s+-\\s+(${P[I.XRANGEPLAIN]})\\s*$`), Q("HYPHENRANGELOOSE", `^\\s*(${P[I.XRANGEPLAINLOOSE]})\\s+-\\s+(${P[I.XRANGEPLAINLOOSE]})\\s*$`), Q("STAR", "(<|>)?=?\\s*\\*"), Q("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), Q("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(re$2, re$2.exports);
var reExports = re$2.exports;
const looseOption = Object.freeze({ loose: !0 }), emptyOpts = Object.freeze({}), parseOptions$1 = (e) => e ? typeof e != "object" ? looseOption : e : emptyOpts;
var parseOptions_1 = parseOptions$1;
const numeric = /^[0-9]+$/, compareIdentifiers$1 = (e, o) => {
  const S = numeric.test(e), g = numeric.test(o);
  return S && g && (e = +e, o = +o), e === o ? 0 : S && !g ? -1 : g && !S ? 1 : e < o ? -1 : 1;
}, rcompareIdentifiers = (e, o) => compareIdentifiers$1(o, e);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug = debug_1, { MAX_LENGTH, MAX_SAFE_INTEGER } = constants$4, { safeRe: re$1, t: t$1 } = reExports, parseOptions = parseOptions_1, { compareIdentifiers } = identifiers$1;
let SemVer$d = class cr {
  constructor(o, S) {
    if (S = parseOptions(S), o instanceof cr) {
      if (o.loose === !!S.loose && o.includePrerelease === !!S.includePrerelease)
        return o;
      o = o.version;
    } else if (typeof o != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof o}".`);
    if (o.length > MAX_LENGTH)
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      );
    debug("SemVer", o, S), this.options = S, this.loose = !!S.loose, this.includePrerelease = !!S.includePrerelease;
    const g = o.trim().match(S.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL]);
    if (!g)
      throw new TypeError(`Invalid Version: ${o}`);
    if (this.raw = o, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > MAX_SAFE_INTEGER || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
      throw new TypeError("Invalid patch version");
    g[4] ? this.prerelease = g[4].split(".").map((U) => {
      if (/^[0-9]+$/.test(U)) {
        const h = +U;
        if (h >= 0 && h < MAX_SAFE_INTEGER)
          return h;
      }
      return U;
    }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(o) {
    if (debug("SemVer.compare", this.version, this.options, o), !(o instanceof cr)) {
      if (typeof o == "string" && o === this.version)
        return 0;
      o = new cr(o, this.options);
    }
    return o.version === this.version ? 0 : this.compareMain(o) || this.comparePre(o);
  }
  compareMain(o) {
    return o instanceof cr || (o = new cr(o, this.options)), compareIdentifiers(this.major, o.major) || compareIdentifiers(this.minor, o.minor) || compareIdentifiers(this.patch, o.patch);
  }
  comparePre(o) {
    if (o instanceof cr || (o = new cr(o, this.options)), this.prerelease.length && !o.prerelease.length)
      return -1;
    if (!this.prerelease.length && o.prerelease.length)
      return 1;
    if (!this.prerelease.length && !o.prerelease.length)
      return 0;
    let S = 0;
    do {
      const g = this.prerelease[S], U = o.prerelease[S];
      if (debug("prerelease compare", S, g, U), g === void 0 && U === void 0)
        return 0;
      if (U === void 0)
        return 1;
      if (g === void 0)
        return -1;
      if (g === U)
        continue;
      return compareIdentifiers(g, U);
    } while (++S);
  }
  compareBuild(o) {
    o instanceof cr || (o = new cr(o, this.options));
    let S = 0;
    do {
      const g = this.build[S], U = o.build[S];
      if (debug("prerelease compare", S, g, U), g === void 0 && U === void 0)
        return 0;
      if (U === void 0)
        return 1;
      if (g === void 0)
        return -1;
      if (g === U)
        continue;
      return compareIdentifiers(g, U);
    } while (++S);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(o, S, g) {
    switch (o) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", S, g);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", S, g);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", S, g), this.inc("pre", S, g);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", S, g), this.inc("pre", S, g);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const U = Number(g) ? 1 : 0;
        if (!S && g === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [U];
        else {
          let h = this.prerelease.length;
          for (; --h >= 0; )
            typeof this.prerelease[h] == "number" && (this.prerelease[h]++, h = -2);
          if (h === -1) {
            if (S === this.prerelease.join(".") && g === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(U);
          }
        }
        if (S) {
          let h = [S, U];
          g === !1 && (h = [S]), compareIdentifiers(this.prerelease[0], S) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = h) : this.prerelease = h;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${o}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var semver$1 = SemVer$d;
const SemVer$c = semver$1, parse$7 = (e, o, S = !1) => {
  if (e instanceof SemVer$c)
    return e;
  try {
    return new SemVer$c(e, o);
  } catch (g) {
    if (!S)
      return null;
    throw g;
  }
};
var parse_1 = parse$7;
const parse$6 = parse_1, valid$2 = (e, o) => {
  const S = parse$6(e, o);
  return S ? S.version : null;
};
var valid_1 = valid$2;
const parse$5 = parse_1, clean$1 = (e, o) => {
  const S = parse$5(e.trim().replace(/^[=v]+/, ""), o);
  return S ? S.version : null;
};
var clean_1 = clean$1;
const SemVer$b = semver$1, inc$1 = (e, o, S, g, U) => {
  typeof S == "string" && (U = g, g = S, S = void 0);
  try {
    return new SemVer$b(
      e instanceof SemVer$b ? e.version : e,
      S
    ).inc(o, g, U).version;
  } catch {
    return null;
  }
};
var inc_1 = inc$1;
const parse$4 = parse_1, diff$1 = (e, o) => {
  const S = parse$4(e, null, !0), g = parse$4(o, null, !0), U = S.compare(g);
  if (U === 0)
    return null;
  const h = U > 0, q = h ? S : g, A = h ? g : S, P = !!q.prerelease.length;
  if (!!A.prerelease.length && !P)
    return !A.patch && !A.minor ? "major" : q.patch ? "patch" : q.minor ? "minor" : "major";
  const B = P ? "pre" : "";
  return S.major !== g.major ? B + "major" : S.minor !== g.minor ? B + "minor" : S.patch !== g.patch ? B + "patch" : "prerelease";
};
var diff_1 = diff$1;
const SemVer$a = semver$1, major$1 = (e, o) => new SemVer$a(e, o).major;
var major_1 = major$1;
const SemVer$9 = semver$1, minor$1 = (e, o) => new SemVer$9(e, o).minor;
var minor_1 = minor$1;
const SemVer$8 = semver$1, patch$1 = (e, o) => new SemVer$8(e, o).patch;
var patch_1 = patch$1;
const parse$3 = parse_1, prerelease$1 = (e, o) => {
  const S = parse$3(e, o);
  return S && S.prerelease.length ? S.prerelease : null;
};
var prerelease_1 = prerelease$1;
const SemVer$7 = semver$1, compare$b = (e, o, S) => new SemVer$7(e, S).compare(new SemVer$7(o, S));
var compare_1 = compare$b;
const compare$a = compare_1, rcompare$1 = (e, o, S) => compare$a(o, e, S);
var rcompare_1 = rcompare$1;
const compare$9 = compare_1, compareLoose$1 = (e, o) => compare$9(e, o, !0);
var compareLoose_1 = compareLoose$1;
const SemVer$6 = semver$1, compareBuild$3 = (e, o, S) => {
  const g = new SemVer$6(e, S), U = new SemVer$6(o, S);
  return g.compare(U) || g.compareBuild(U);
};
var compareBuild_1 = compareBuild$3;
const compareBuild$2 = compareBuild_1, sort$1 = (e, o) => e.sort((S, g) => compareBuild$2(S, g, o));
var sort_1 = sort$1;
const compareBuild$1 = compareBuild_1, rsort$1 = (e, o) => e.sort((S, g) => compareBuild$1(g, S, o));
var rsort_1 = rsort$1;
const compare$8 = compare_1, gt$4 = (e, o, S) => compare$8(e, o, S) > 0;
var gt_1 = gt$4;
const compare$7 = compare_1, lt$3 = (e, o, S) => compare$7(e, o, S) < 0;
var lt_1 = lt$3;
const compare$6 = compare_1, eq$2 = (e, o, S) => compare$6(e, o, S) === 0;
var eq_1 = eq$2;
const compare$5 = compare_1, neq$2 = (e, o, S) => compare$5(e, o, S) !== 0;
var neq_1 = neq$2;
const compare$4 = compare_1, gte$3 = (e, o, S) => compare$4(e, o, S) >= 0;
var gte_1 = gte$3;
const compare$3 = compare_1, lte$3 = (e, o, S) => compare$3(e, o, S) <= 0;
var lte_1 = lte$3;
const eq$1 = eq_1, neq$1 = neq_1, gt$3 = gt_1, gte$2 = gte_1, lt$2 = lt_1, lte$2 = lte_1, cmp$1 = (e, o, S, g) => {
  switch (o) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof S == "object" && (S = S.version), e === S;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof S == "object" && (S = S.version), e !== S;
    case "":
    case "=":
    case "==":
      return eq$1(e, S, g);
    case "!=":
      return neq$1(e, S, g);
    case ">":
      return gt$3(e, S, g);
    case ">=":
      return gte$2(e, S, g);
    case "<":
      return lt$2(e, S, g);
    case "<=":
      return lte$2(e, S, g);
    default:
      throw new TypeError(`Invalid operator: ${o}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$5 = semver$1, parse$2 = parse_1, { safeRe: re, t } = reExports, coerce$1 = (e, o) => {
  if (e instanceof SemVer$5)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  o = o || {};
  let S = null;
  if (!o.rtl)
    S = e.match(o.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
  else {
    const P = o.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
    let I;
    for (; (I = P.exec(e)) && (!S || S.index + S[0].length !== e.length); )
      (!S || I.index + I[0].length !== S.index + S[0].length) && (S = I), P.lastIndex = I.index + I[1].length + I[2].length;
    P.lastIndex = -1;
  }
  if (S === null)
    return null;
  const g = S[2], U = S[3] || "0", h = S[4] || "0", q = o.includePrerelease && S[5] ? `-${S[5]}` : "", A = o.includePrerelease && S[6] ? `+${S[6]}` : "";
  return parse$2(`${g}.${U}.${h}${q}${A}`, o);
};
var coerce_1 = coerce$1, iterator, hasRequiredIterator;
function requireIterator() {
  return hasRequiredIterator || (hasRequiredIterator = 1, iterator = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let o = this.head; o; o = o.next)
        yield o.value;
    };
  }), iterator;
}
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(e) {
  var o = this;
  if (o instanceof Yallist$1 || (o = new Yallist$1()), o.tail = null, o.head = null, o.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(U) {
      o.push(U);
    });
  else if (arguments.length > 0)
    for (var S = 0, g = arguments.length; S < g; S++)
      o.push(arguments[S]);
  return o;
}
Yallist$1.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var o = e.next, S = e.prev;
  return o && (o.prev = S), S && (S.next = o), e === this.head && (this.head = o), e === this.tail && (this.tail = S), e.list.length--, e.next = null, e.prev = null, e.list = null, o;
};
Yallist$1.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var o = this.head;
    e.list = this, e.next = o, o && (o.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
Yallist$1.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var o = this.tail;
    e.list = this, e.prev = o, o && (o.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
Yallist$1.prototype.push = function() {
  for (var e = 0, o = arguments.length; e < o; e++)
    push(this, arguments[e]);
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var e = 0, o = arguments.length; e < o; e++)
    unshift(this, arguments[e]);
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
Yallist$1.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
Yallist$1.prototype.forEach = function(e, o) {
  o = o || this;
  for (var S = this.head, g = 0; S !== null; g++)
    e.call(o, S.value, g, this), S = S.next;
};
Yallist$1.prototype.forEachReverse = function(e, o) {
  o = o || this;
  for (var S = this.tail, g = this.length - 1; S !== null; g--)
    e.call(o, S.value, g, this), S = S.prev;
};
Yallist$1.prototype.get = function(e) {
  for (var o = 0, S = this.head; S !== null && o < e; o++)
    S = S.next;
  if (o === e && S !== null)
    return S.value;
};
Yallist$1.prototype.getReverse = function(e) {
  for (var o = 0, S = this.tail; S !== null && o < e; o++)
    S = S.prev;
  if (o === e && S !== null)
    return S.value;
};
Yallist$1.prototype.map = function(e, o) {
  o = o || this;
  for (var S = new Yallist$1(), g = this.head; g !== null; )
    S.push(e.call(o, g.value, this)), g = g.next;
  return S;
};
Yallist$1.prototype.mapReverse = function(e, o) {
  o = o || this;
  for (var S = new Yallist$1(), g = this.tail; g !== null; )
    S.push(e.call(o, g.value, this)), g = g.prev;
  return S;
};
Yallist$1.prototype.reduce = function(e, o) {
  var S, g = this.head;
  if (arguments.length > 1)
    S = o;
  else if (this.head)
    g = this.head.next, S = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var U = 0; g !== null; U++)
    S = e(S, g.value, U), g = g.next;
  return S;
};
Yallist$1.prototype.reduceReverse = function(e, o) {
  var S, g = this.tail;
  if (arguments.length > 1)
    S = o;
  else if (this.tail)
    g = this.tail.prev, S = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var U = this.length - 1; g !== null; U--)
    S = e(S, g.value, U), g = g.prev;
  return S;
};
Yallist$1.prototype.toArray = function() {
  for (var e = new Array(this.length), o = 0, S = this.head; S !== null; o++)
    e[o] = S.value, S = S.next;
  return e;
};
Yallist$1.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), o = 0, S = this.tail; S !== null; o++)
    e[o] = S.value, S = S.prev;
  return e;
};
Yallist$1.prototype.slice = function(e, o) {
  o = o || this.length, o < 0 && (o += this.length), e = e || 0, e < 0 && (e += this.length);
  var S = new Yallist$1();
  if (o < e || o < 0)
    return S;
  e < 0 && (e = 0), o > this.length && (o = this.length);
  for (var g = 0, U = this.head; U !== null && g < e; g++)
    U = U.next;
  for (; U !== null && g < o; g++, U = U.next)
    S.push(U.value);
  return S;
};
Yallist$1.prototype.sliceReverse = function(e, o) {
  o = o || this.length, o < 0 && (o += this.length), e = e || 0, e < 0 && (e += this.length);
  var S = new Yallist$1();
  if (o < e || o < 0)
    return S;
  e < 0 && (e = 0), o > this.length && (o = this.length);
  for (var g = this.length, U = this.tail; U !== null && g > o; g--)
    U = U.prev;
  for (; U !== null && g > e; g--, U = U.prev)
    S.push(U.value);
  return S;
};
Yallist$1.prototype.splice = function(e, o, ...S) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var g = 0, U = this.head; U !== null && g < e; g++)
    U = U.next;
  for (var h = [], g = 0; U && g < o; g++)
    h.push(U.value), U = this.removeNode(U);
  U === null && (U = this.tail), U !== this.head && U !== this.tail && (U = U.prev);
  for (var g = 0; g < S.length; g++)
    U = insert(this, U, S[g]);
  return h;
};
Yallist$1.prototype.reverse = function() {
  for (var e = this.head, o = this.tail, S = e; S !== null; S = S.prev) {
    var g = S.prev;
    S.prev = S.next, S.next = g;
  }
  return this.head = o, this.tail = e, this;
};
function insert(e, o, S) {
  var g = o === e.head ? new Node(S, null, o, e) : new Node(S, o, o.next, e);
  return g.next === null && (e.tail = g), g.prev === null && (e.head = g), e.length++, g;
}
function push(e, o) {
  e.tail = new Node(o, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function unshift(e, o) {
  e.head = new Node(o, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function Node(e, o, S, g) {
  if (!(this instanceof Node))
    return new Node(e, o, S, g);
  this.list = g, this.value = e, o ? (o.next = this, this.prev = o) : this.prev = null, S ? (S.prev = this, this.next = S) : this.next = null;
}
try {
  requireIterator()(Yallist$1);
} catch (e) {
}
const Yallist = yallist, MAX = Symbol("max"), LENGTH = Symbol("length"), LENGTH_CALCULATOR = Symbol("lengthCalculator"), ALLOW_STALE = Symbol("allowStale"), MAX_AGE = Symbol("maxAge"), DISPOSE = Symbol("dispose"), NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet"), LRU_LIST = Symbol("lruList"), CACHE = Symbol("cache"), UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet"), naiveLength = () => 1;
class LRUCache {
  constructor(o) {
    if (typeof o == "number" && (o = { max: o }), o || (o = {}), o.max && (typeof o.max != "number" || o.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = o.max || 1 / 0;
    const S = o.length || naiveLength;
    if (this[LENGTH_CALCULATOR] = typeof S != "function" ? naiveLength : S, this[ALLOW_STALE] = o.stale || !1, o.maxAge && typeof o.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = o.maxAge || 0, this[DISPOSE] = o.dispose, this[NO_DISPOSE_ON_SET] = o.noDisposeOnSet || !1, this[UPDATE_AGE_ON_GET] = o.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(o) {
    if (typeof o != "number" || o < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = o || 1 / 0, trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(o) {
    this[ALLOW_STALE] = !!o;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(o) {
    if (typeof o != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = o, trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(o) {
    typeof o != "function" && (o = naiveLength), o !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = o, this[LENGTH] = 0, this[LRU_LIST].forEach((S) => {
      S.length = this[LENGTH_CALCULATOR](S.value, S.key), this[LENGTH] += S.length;
    })), trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(o, S) {
    S = S || this;
    for (let g = this[LRU_LIST].tail; g !== null; ) {
      const U = g.prev;
      forEachStep(this, o, g, S), g = U;
    }
  }
  forEach(o, S) {
    S = S || this;
    for (let g = this[LRU_LIST].head; g !== null; ) {
      const U = g.next;
      forEachStep(this, o, g, S), g = U;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((o) => o.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((o) => o.value);
  }
  reset() {
    this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach((o) => this[DISPOSE](o.key, o.value)), this[CACHE] = /* @__PURE__ */ new Map(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((o) => isStale(this, o) ? !1 : {
      k: o.key,
      v: o.value,
      e: o.now + (o.maxAge || 0)
    }).toArray().filter((o) => o);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(o, S, g) {
    if (g = g || this[MAX_AGE], g && typeof g != "number")
      throw new TypeError("maxAge must be a number");
    const U = g ? Date.now() : 0, h = this[LENGTH_CALCULATOR](S, o);
    if (this[CACHE].has(o)) {
      if (h > this[MAX])
        return del(this, this[CACHE].get(o)), !1;
      const P = this[CACHE].get(o).value;
      return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](o, P.value)), P.now = U, P.maxAge = g, P.value = S, this[LENGTH] += h - P.length, P.length = h, this.get(o), trim(this), !0;
    }
    const q = new Entry(o, S, h, U, g);
    return q.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](o, S), !1) : (this[LENGTH] += q.length, this[LRU_LIST].unshift(q), this[CACHE].set(o, this[LRU_LIST].head), trim(this), !0);
  }
  has(o) {
    if (!this[CACHE].has(o))
      return !1;
    const S = this[CACHE].get(o).value;
    return !isStale(this, S);
  }
  get(o) {
    return get(this, o, !0);
  }
  peek(o) {
    return get(this, o, !1);
  }
  pop() {
    const o = this[LRU_LIST].tail;
    return o ? (del(this, o), o.value) : null;
  }
  del(o) {
    del(this, this[CACHE].get(o));
  }
  load(o) {
    this.reset();
    const S = Date.now();
    for (let g = o.length - 1; g >= 0; g--) {
      const U = o[g], h = U.e || 0;
      if (h === 0)
        this.set(U.k, U.v);
      else {
        const q = h - S;
        q > 0 && this.set(U.k, U.v, q);
      }
    }
  }
  prune() {
    this[CACHE].forEach((o, S) => get(this, S, !1));
  }
}
const get = (e, o, S) => {
  const g = e[CACHE].get(o);
  if (g) {
    const U = g.value;
    if (isStale(e, U)) {
      if (del(e, g), !e[ALLOW_STALE])
        return;
    } else
      S && (e[UPDATE_AGE_ON_GET] && (g.value.now = Date.now()), e[LRU_LIST].unshiftNode(g));
    return U.value;
  }
}, isStale = (e, o) => {
  if (!o || !o.maxAge && !e[MAX_AGE])
    return !1;
  const S = Date.now() - o.now;
  return o.maxAge ? S > o.maxAge : e[MAX_AGE] && S > e[MAX_AGE];
}, trim = (e) => {
  if (e[LENGTH] > e[MAX])
    for (let o = e[LRU_LIST].tail; e[LENGTH] > e[MAX] && o !== null; ) {
      const S = o.prev;
      del(e, o), o = S;
    }
}, del = (e, o) => {
  if (o) {
    const S = o.value;
    e[DISPOSE] && e[DISPOSE](S.key, S.value), e[LENGTH] -= S.length, e[CACHE].delete(S.key), e[LRU_LIST].removeNode(o);
  }
};
class Entry {
  constructor(o, S, g, U, h) {
    this.key = o, this.value = S, this.length = g, this.now = U, this.maxAge = h || 0;
  }
}
const forEachStep = (e, o, S, g) => {
  let U = S.value;
  isStale(e, U) && (del(e, S), e[ALLOW_STALE] || (U = void 0)), U && o.call(g, U.value, U.key, e);
};
var lruCache = LRUCache, range$1, hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range$1;
  hasRequiredRange = 1;
  class e {
    constructor($, O) {
      if (O = g(O), $ instanceof e)
        return $.loose === !!O.loose && $.includePrerelease === !!O.includePrerelease ? $ : new e($.raw, O);
      if ($ instanceof U)
        return this.raw = $.value, this.set = [[$]], this.format(), this;
      if (this.options = O, this.loose = !!O.loose, this.includePrerelease = !!O.includePrerelease, this.raw = $.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((J) => this.parseRange(J.trim())).filter((J) => J.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const J = this.set[0];
        if (this.set = this.set.filter((Z) => !Q(Z[0])), this.set.length === 0)
          this.set = [J];
        else if (this.set.length > 1) {
          for (const Z of this.set)
            if (Z.length === 1 && ee(Z[0])) {
              this.set = [Z];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map(($) => $.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange($) {
      const J = ((this.options.includePrerelease && V) | (this.options.loose && X)) + ":" + $, Z = S.get(J);
      if (Z)
        return Z;
      const K = this.options.loose, z = K ? A[P.HYPHENRANGELOOSE] : A[P.HYPHENRANGE];
      $ = $.replace(z, ne(this.options.includePrerelease)), h("hyphen replace", $), $ = $.replace(A[P.COMPARATORTRIM], I), h("comparator trim", $), $ = $.replace(A[P.TILDETRIM], B), h("tilde trim", $), $ = $.replace(A[P.CARETTRIM], H), h("caret trim", $);
      let G = $.split(" ").map((ge) => te(ge, this.options)).join(" ").split(/\s+/).map((ge) => Ne(ge, this.options));
      K && (G = G.filter((ge) => (h("loose invalid filter", ge, this.options), !!ge.match(A[P.COMPARATORLOOSE])))), h("range list", G);
      const D = /* @__PURE__ */ new Map(), F = G.map((ge) => new U(ge, this.options));
      for (const ge of F) {
        if (Q(ge))
          return [ge];
        D.set(ge.value, ge);
      }
      D.size > 1 && D.has("") && D.delete("");
      const ae = [...D.values()];
      return S.set(J, ae), ae;
    }
    intersects($, O) {
      if (!($ instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((J) => ie(J, O) && $.set.some((Z) => ie(Z, O) && J.every((K) => Z.every((z) => K.intersects(z, O)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test($) {
      if (!$)
        return !1;
      if (typeof $ == "string")
        try {
          $ = new q($, this.options);
        } catch {
          return !1;
        }
      for (let O = 0; O < this.set.length; O++)
        if (Y(this.set[O], $, this.options))
          return !0;
      return !1;
    }
  }
  range$1 = e;
  const o = lruCache, S = new o({ max: 1e3 }), g = parseOptions_1, U = requireComparator(), h = debug_1, q = semver$1, {
    safeRe: A,
    t: P,
    comparatorTrimReplace: I,
    tildeTrimReplace: B,
    caretTrimReplace: H
  } = reExports, { FLAG_INCLUDE_PRERELEASE: V, FLAG_LOOSE: X } = constants$4, Q = (M) => M.value === "<0.0.0-0", ee = (M) => M.value === "", ie = (M, $) => {
    let O = !0;
    const J = M.slice();
    let Z = J.pop();
    for (; O && J.length; )
      O = J.every((K) => Z.intersects(K, $)), Z = J.pop();
    return O;
  }, te = (M, $) => (h("comp", M, $), M = pe(M, $), h("caret", M), M = le(M, $), h("tildes", M), M = Me(M, $), h("xrange", M), M = Re(M, $), h("stars", M), M), se = (M) => !M || M.toLowerCase() === "x" || M === "*", le = (M, $) => M.trim().split(/\s+/).map((O) => ce(O, $)).join(" "), ce = (M, $) => {
    const O = $.loose ? A[P.TILDELOOSE] : A[P.TILDE];
    return M.replace(O, (J, Z, K, z, G) => {
      h("tilde", M, J, Z, K, z, G);
      let D;
      return se(Z) ? D = "" : se(K) ? D = `>=${Z}.0.0 <${+Z + 1}.0.0-0` : se(z) ? D = `>=${Z}.${K}.0 <${Z}.${+K + 1}.0-0` : G ? (h("replaceTilde pr", G), D = `>=${Z}.${K}.${z}-${G} <${Z}.${+K + 1}.0-0`) : D = `>=${Z}.${K}.${z} <${Z}.${+K + 1}.0-0`, h("tilde return", D), D;
    });
  }, pe = (M, $) => M.trim().split(/\s+/).map((O) => me(O, $)).join(" "), me = (M, $) => {
    h("caret", M, $);
    const O = $.loose ? A[P.CARETLOOSE] : A[P.CARET], J = $.includePrerelease ? "-0" : "";
    return M.replace(O, (Z, K, z, G, D) => {
      h("caret", M, Z, K, z, G, D);
      let F;
      return se(K) ? F = "" : se(z) ? F = `>=${K}.0.0${J} <${+K + 1}.0.0-0` : se(G) ? K === "0" ? F = `>=${K}.${z}.0${J} <${K}.${+z + 1}.0-0` : F = `>=${K}.${z}.0${J} <${+K + 1}.0.0-0` : D ? (h("replaceCaret pr", D), K === "0" ? z === "0" ? F = `>=${K}.${z}.${G}-${D} <${K}.${z}.${+G + 1}-0` : F = `>=${K}.${z}.${G}-${D} <${K}.${+z + 1}.0-0` : F = `>=${K}.${z}.${G}-${D} <${+K + 1}.0.0-0`) : (h("no pr"), K === "0" ? z === "0" ? F = `>=${K}.${z}.${G}${J} <${K}.${z}.${+G + 1}-0` : F = `>=${K}.${z}.${G}${J} <${K}.${+z + 1}.0-0` : F = `>=${K}.${z}.${G} <${+K + 1}.0.0-0`), h("caret return", F), F;
    });
  }, Me = (M, $) => (h("replaceXRanges", M, $), M.split(/\s+/).map((O) => Ee(O, $)).join(" ")), Ee = (M, $) => {
    M = M.trim();
    const O = $.loose ? A[P.XRANGELOOSE] : A[P.XRANGE];
    return M.replace(O, (J, Z, K, z, G, D) => {
      h("xRange", M, J, Z, K, z, G, D);
      const F = se(K), ae = F || se(z), ge = ae || se(G), xe = ge;
      return Z === "=" && xe && (Z = ""), D = $.includePrerelease ? "-0" : "", F ? Z === ">" || Z === "<" ? J = "<0.0.0-0" : J = "*" : Z && xe ? (ae && (z = 0), G = 0, Z === ">" ? (Z = ">=", ae ? (K = +K + 1, z = 0, G = 0) : (z = +z + 1, G = 0)) : Z === "<=" && (Z = "<", ae ? K = +K + 1 : z = +z + 1), Z === "<" && (D = "-0"), J = `${Z + K}.${z}.${G}${D}`) : ae ? J = `>=${K}.0.0${D} <${+K + 1}.0.0-0` : ge && (J = `>=${K}.${z}.0${D} <${K}.${+z + 1}.0-0`), h("xRange return", J), J;
    });
  }, Re = (M, $) => (h("replaceStars", M, $), M.trim().replace(A[P.STAR], "")), Ne = (M, $) => (h("replaceGTE0", M, $), M.trim().replace(A[$.includePrerelease ? P.GTE0PRE : P.GTE0], "")), ne = (M) => ($, O, J, Z, K, z, G, D, F, ae, ge, xe, ye) => (se(J) ? O = "" : se(Z) ? O = `>=${J}.0.0${M ? "-0" : ""}` : se(K) ? O = `>=${J}.${Z}.0${M ? "-0" : ""}` : z ? O = `>=${O}` : O = `>=${O}${M ? "-0" : ""}`, se(F) ? D = "" : se(ae) ? D = `<${+F + 1}.0.0-0` : se(ge) ? D = `<${F}.${+ae + 1}.0-0` : xe ? D = `<=${F}.${ae}.${ge}-${xe}` : M ? D = `<${F}.${ae}.${+ge + 1}-0` : D = `<=${D}`, `${O} ${D}`.trim()), Y = (M, $, O) => {
    for (let J = 0; J < M.length; J++)
      if (!M[J].test($))
        return !1;
    if ($.prerelease.length && !O.includePrerelease) {
      for (let J = 0; J < M.length; J++)
        if (h(M[J].semver), M[J].semver !== U.ANY && M[J].semver.prerelease.length > 0) {
          const Z = M[J].semver;
          if (Z.major === $.major && Z.minor === $.minor && Z.patch === $.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return range$1;
}
var comparator, hasRequiredComparator;
function requireComparator() {
  if (hasRequiredComparator)
    return comparator;
  hasRequiredComparator = 1;
  const e = Symbol("SemVer ANY");
  class o {
    static get ANY() {
      return e;
    }
    constructor(B, H) {
      if (H = S(H), B instanceof o) {
        if (B.loose === !!H.loose)
          return B;
        B = B.value;
      }
      B = B.trim().split(/\s+/).join(" "), q("comparator", B, H), this.options = H, this.loose = !!H.loose, this.parse(B), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, q("comp", this);
    }
    parse(B) {
      const H = this.options.loose ? g[U.COMPARATORLOOSE] : g[U.COMPARATOR], V = B.match(H);
      if (!V)
        throw new TypeError(`Invalid comparator: ${B}`);
      this.operator = V[1] !== void 0 ? V[1] : "", this.operator === "=" && (this.operator = ""), V[2] ? this.semver = new A(V[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(B) {
      if (q("Comparator.test", B, this.options.loose), this.semver === e || B === e)
        return !0;
      if (typeof B == "string")
        try {
          B = new A(B, this.options);
        } catch {
          return !1;
        }
      return h(B, this.operator, this.semver, this.options);
    }
    intersects(B, H) {
      if (!(B instanceof o))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new P(B.value, H).test(this.value) : B.operator === "" ? B.value === "" ? !0 : new P(this.value, H).test(B.semver) : (H = S(H), H.includePrerelease && (this.value === "<0.0.0-0" || B.value === "<0.0.0-0") || !H.includePrerelease && (this.value.startsWith("<0.0.0") || B.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && B.operator.startsWith(">") || this.operator.startsWith("<") && B.operator.startsWith("<") || this.semver.version === B.semver.version && this.operator.includes("=") && B.operator.includes("=") || h(this.semver, "<", B.semver, H) && this.operator.startsWith(">") && B.operator.startsWith("<") || h(this.semver, ">", B.semver, H) && this.operator.startsWith("<") && B.operator.startsWith(">")));
    }
  }
  comparator = o;
  const S = parseOptions_1, { safeRe: g, t: U } = reExports, h = cmp_1, q = debug_1, A = semver$1, P = requireRange();
  return comparator;
}
const Range$9 = requireRange(), satisfies$4 = (e, o, S) => {
  try {
    o = new Range$9(o, S);
  } catch {
    return !1;
  }
  return o.test(e);
};
var satisfies_1 = satisfies$4;
const Range$8 = requireRange(), toComparators$1 = (e, o) => new Range$8(e, o).set.map((S) => S.map((g) => g.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators$1;
const SemVer$4 = semver$1, Range$7 = requireRange(), maxSatisfying$1 = (e, o, S) => {
  let g = null, U = null, h = null;
  try {
    h = new Range$7(o, S);
  } catch {
    return null;
  }
  return e.forEach((q) => {
    h.test(q) && (!g || U.compare(q) === -1) && (g = q, U = new SemVer$4(g, S));
  }), g;
};
var maxSatisfying_1 = maxSatisfying$1;
const SemVer$3 = semver$1, Range$6 = requireRange(), minSatisfying$1 = (e, o, S) => {
  let g = null, U = null, h = null;
  try {
    h = new Range$6(o, S);
  } catch {
    return null;
  }
  return e.forEach((q) => {
    h.test(q) && (!g || U.compare(q) === 1) && (g = q, U = new SemVer$3(g, S));
  }), g;
};
var minSatisfying_1 = minSatisfying$1;
const SemVer$2 = semver$1, Range$5 = requireRange(), gt$2 = gt_1, minVersion$1 = (e, o) => {
  e = new Range$5(e, o);
  let S = new SemVer$2("0.0.0");
  if (e.test(S) || (S = new SemVer$2("0.0.0-0"), e.test(S)))
    return S;
  S = null;
  for (let g = 0; g < e.set.length; ++g) {
    const U = e.set[g];
    let h = null;
    U.forEach((q) => {
      const A = new SemVer$2(q.semver.version);
      switch (q.operator) {
        case ">":
          A.prerelease.length === 0 ? A.patch++ : A.prerelease.push(0), A.raw = A.format();
        case "":
        case ">=":
          (!h || gt$2(A, h)) && (h = A);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${q.operator}`);
      }
    }), h && (!S || gt$2(S, h)) && (S = h);
  }
  return S && e.test(S) ? S : null;
};
var minVersion_1 = minVersion$1;
const Range$4 = requireRange(), validRange$1 = (e, o) => {
  try {
    return new Range$4(e, o).range || "*";
  } catch {
    return null;
  }
};
var valid$1 = validRange$1;
const SemVer$1 = semver$1, Comparator$2 = requireComparator(), { ANY: ANY$1 } = Comparator$2, Range$3 = requireRange(), satisfies$3 = satisfies_1, gt$1 = gt_1, lt$1 = lt_1, lte$1 = lte_1, gte$1 = gte_1, outside$3 = (e, o, S, g) => {
  e = new SemVer$1(e, g), o = new Range$3(o, g);
  let U, h, q, A, P;
  switch (S) {
    case ">":
      U = gt$1, h = lte$1, q = lt$1, A = ">", P = ">=";
      break;
    case "<":
      U = lt$1, h = gte$1, q = gt$1, A = "<", P = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$3(e, o, g))
    return !1;
  for (let I = 0; I < o.set.length; ++I) {
    const B = o.set[I];
    let H = null, V = null;
    if (B.forEach((X) => {
      X.semver === ANY$1 && (X = new Comparator$2(">=0.0.0")), H = H || X, V = V || X, U(X.semver, H.semver, g) ? H = X : q(X.semver, V.semver, g) && (V = X);
    }), H.operator === A || H.operator === P || (!V.operator || V.operator === A) && h(e, V.semver))
      return !1;
    if (V.operator === P && q(e, V.semver))
      return !1;
  }
  return !0;
};
var outside_1 = outside$3;
const outside$2 = outside_1, gtr$1 = (e, o, S) => outside$2(e, o, ">", S);
var gtr_1 = gtr$1;
const outside$1 = outside_1, ltr$1 = (e, o, S) => outside$1(e, o, "<", S);
var ltr_1 = ltr$1;
const Range$2 = requireRange(), intersects$1 = (e, o, S) => (e = new Range$2(e, S), o = new Range$2(o, S), e.intersects(o, S));
var intersects_1 = intersects$1;
const satisfies$2 = satisfies_1, compare$2 = compare_1;
var simplify = (e, o, S) => {
  const g = [];
  let U = null, h = null;
  const q = e.sort((B, H) => compare$2(B, H, S));
  for (const B of q)
    satisfies$2(B, o, S) ? (h = B, U || (U = B)) : (h && g.push([U, h]), h = null, U = null);
  U && g.push([U, null]);
  const A = [];
  for (const [B, H] of g)
    B === H ? A.push(B) : !H && B === q[0] ? A.push("*") : H ? B === q[0] ? A.push(`<=${H}`) : A.push(`${B} - ${H}`) : A.push(`>=${B}`);
  const P = A.join(" || "), I = typeof o.raw == "string" ? o.raw : String(o);
  return P.length < I.length ? P : o;
};
const Range$1 = requireRange(), Comparator$1 = requireComparator(), { ANY } = Comparator$1, satisfies$1 = satisfies_1, compare$1 = compare_1, subset$1 = (e, o, S = {}) => {
  if (e === o)
    return !0;
  e = new Range$1(e, S), o = new Range$1(o, S);
  let g = !1;
  e:
    for (const U of e.set) {
      for (const h of o.set) {
        const q = simpleSubset(U, h, S);
        if (g = g || q !== null, q)
          continue e;
      }
      if (g)
        return !1;
    }
  return !0;
}, minimumVersionWithPreRelease = [new Comparator$1(">=0.0.0-0")], minimumVersion = [new Comparator$1(">=0.0.0")], simpleSubset = (e, o, S) => {
  if (e === o)
    return !0;
  if (e.length === 1 && e[0].semver === ANY) {
    if (o.length === 1 && o[0].semver === ANY)
      return !0;
    S.includePrerelease ? e = minimumVersionWithPreRelease : e = minimumVersion;
  }
  if (o.length === 1 && o[0].semver === ANY) {
    if (S.includePrerelease)
      return !0;
    o = minimumVersion;
  }
  const g = /* @__PURE__ */ new Set();
  let U, h;
  for (const X of e)
    X.operator === ">" || X.operator === ">=" ? U = higherGT(U, X, S) : X.operator === "<" || X.operator === "<=" ? h = lowerLT(h, X, S) : g.add(X.semver);
  if (g.size > 1)
    return null;
  let q;
  if (U && h) {
    if (q = compare$1(U.semver, h.semver, S), q > 0)
      return null;
    if (q === 0 && (U.operator !== ">=" || h.operator !== "<="))
      return null;
  }
  for (const X of g) {
    if (U && !satisfies$1(X, String(U), S) || h && !satisfies$1(X, String(h), S))
      return null;
    for (const Q of o)
      if (!satisfies$1(X, String(Q), S))
        return !1;
    return !0;
  }
  let A, P, I, B, H = h && !S.includePrerelease && h.semver.prerelease.length ? h.semver : !1, V = U && !S.includePrerelease && U.semver.prerelease.length ? U.semver : !1;
  H && H.prerelease.length === 1 && h.operator === "<" && H.prerelease[0] === 0 && (H = !1);
  for (const X of o) {
    if (B = B || X.operator === ">" || X.operator === ">=", I = I || X.operator === "<" || X.operator === "<=", U) {
      if (V && X.semver.prerelease && X.semver.prerelease.length && X.semver.major === V.major && X.semver.minor === V.minor && X.semver.patch === V.patch && (V = !1), X.operator === ">" || X.operator === ">=") {
        if (A = higherGT(U, X, S), A === X && A !== U)
          return !1;
      } else if (U.operator === ">=" && !satisfies$1(U.semver, String(X), S))
        return !1;
    }
    if (h) {
      if (H && X.semver.prerelease && X.semver.prerelease.length && X.semver.major === H.major && X.semver.minor === H.minor && X.semver.patch === H.patch && (H = !1), X.operator === "<" || X.operator === "<=") {
        if (P = lowerLT(h, X, S), P === X && P !== h)
          return !1;
      } else if (h.operator === "<=" && !satisfies$1(h.semver, String(X), S))
        return !1;
    }
    if (!X.operator && (h || U) && q !== 0)
      return !1;
  }
  return !(U && I && !h && q !== 0 || h && B && !U && q !== 0 || V || H);
}, higherGT = (e, o, S) => {
  if (!e)
    return o;
  const g = compare$1(e.semver, o.semver, S);
  return g > 0 ? e : g < 0 || o.operator === ">" && e.operator === ">=" ? o : e;
}, lowerLT = (e, o, S) => {
  if (!e)
    return o;
  const g = compare$1(e.semver, o.semver, S);
  return g < 0 ? e : g > 0 || o.operator === "<" && e.operator === "<=" ? o : e;
};
var subset_1 = subset$1;
const internalRe = reExports, constants$3 = constants$4, SemVer = semver$1, identifiers = identifiers$1, parse$1 = parse_1, valid = valid_1, clean = clean_1, inc = inc_1, diff = diff_1, major = major_1, minor = minor_1, patch = patch_1, prerelease = prerelease_1, compare = compare_1, rcompare = rcompare_1, compareLoose = compareLoose_1, compareBuild = compareBuild_1, sort = sort_1, rsort = rsort_1, gt = gt_1, lt = lt_1, eq = eq_1, neq = neq_1, gte = gte_1, lte = lte_1, cmp = cmp_1, coerce = coerce_1, Comparator = requireComparator(), Range = requireRange(), satisfies = satisfies_1, toComparators = toComparators_1, maxSatisfying = maxSatisfying_1, minSatisfying = minSatisfying_1, minVersion = minVersion_1, validRange = valid$1, outside = outside_1, gtr = gtr_1, ltr = ltr_1, intersects = intersects_1, simplifyRange = simplify, subset = subset_1;
var semver = {
  parse: parse$1,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants$3.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants$3.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
  const o = semver, S = require$$1$2, g = assert$4;
  e.VersionStruct = (0, S.refine)((0, S.string)(), "Version", (H) => (0, o.valid)(H) === null ? `Expected SemVer version, got "${H}"` : !0), e.VersionRangeStruct = (0, S.refine)((0, S.string)(), "Version range", (H) => (0, o.validRange)(H) === null ? `Expected SemVer range, got "${H}"` : !0);
  function U(H) {
    return (0, S.is)(H, e.VersionStruct);
  }
  e.isValidSemVerVersion = U;
  function h(H) {
    return (0, S.is)(H, e.VersionRangeStruct);
  }
  e.isValidSemVerRange = h;
  function q(H) {
    (0, g.assertStruct)(H, e.VersionStruct);
  }
  e.assertIsSemVerVersion = q;
  function A(H) {
    (0, g.assertStruct)(H, e.VersionRangeStruct);
  }
  e.assertIsSemVerRange = A;
  function P(H, V) {
    return (0, o.gt)(H, V);
  }
  e.gtVersion = P;
  function I(H, V) {
    return (0, o.gtr)(H, V);
  }
  e.gtRange = I;
  function B(H, V) {
    return (0, o.satisfies)(H, V, {
      includePrerelease: !0
    });
  }
  e.satisfiesVersionRange = B;
})(versions);
(function(e) {
  var o = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(g, U, h, q) {
    q === void 0 && (q = h);
    var A = Object.getOwnPropertyDescriptor(U, h);
    (!A || ("get" in A ? !U.__esModule : A.writable || A.configurable)) && (A = { enumerable: !0, get: function() {
      return U[h];
    } }), Object.defineProperty(g, q, A);
  } : function(g, U, h, q) {
    q === void 0 && (q = h), g[q] = U[h];
  }), S = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(g, U) {
    for (var h in g)
      h !== "default" && !Object.prototype.hasOwnProperty.call(U, h) && o(U, g, h);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), S(assert$4, e), S(base64$1, e), S(bytes$2, e), S(checksum, e), S(coercers, e), S(collections, e), S(hex, e), S(json, e), S(logging, e), S(misc, e), S(number$1, e), S(opaque, e), S(time, e), S(versions, e);
})(dist$4);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.createModuleLogger = e.projectLogger = void 0;
  const o = dist$4;
  Object.defineProperty(e, "createModuleLogger", { enumerable: !0, get: function() {
    return o.createModuleLogger;
  } }), e.projectLogger = o.createProjectLogger("eth-json-rpc-middleware");
})(loggingUtils);
var cache = {}, jsonify = {}, parse, hasRequiredParse;
function requireParse() {
  if (hasRequiredParse)
    return parse;
  hasRequiredParse = 1;
  var e, o, S = {
    '"': '"',
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "	"
  }, g;
  function U(X) {
    throw {
      name: "SyntaxError",
      message: X,
      at: e,
      text: g
    };
  }
  function h(X) {
    return X && X !== o && U("Expected '" + X + "' instead of '" + o + "'"), o = g.charAt(e), e += 1, o;
  }
  function q() {
    var X, Q = "";
    for (o === "-" && (Q = "-", h("-")); o >= "0" && o <= "9"; )
      Q += o, h();
    if (o === ".")
      for (Q += "."; h() && o >= "0" && o <= "9"; )
        Q += o;
    if (o === "e" || o === "E")
      for (Q += o, h(), (o === "-" || o === "+") && (Q += o, h()); o >= "0" && o <= "9"; )
        Q += o, h();
    return X = Number(Q), isFinite(X) || U("Bad number"), X;
  }
  function A() {
    var X, Q, ee = "", ie;
    if (o === '"')
      for (; h(); ) {
        if (o === '"')
          return h(), ee;
        if (o === "\\")
          if (h(), o === "u") {
            for (ie = 0, Q = 0; Q < 4 && (X = parseInt(h(), 16), !!isFinite(X)); Q += 1)
              ie = ie * 16 + X;
            ee += String.fromCharCode(ie);
          } else if (typeof S[o] == "string")
            ee += S[o];
          else
            break;
        else
          ee += o;
      }
    U("Bad string");
  }
  function P() {
    for (; o && o <= " "; )
      h();
  }
  function I() {
    switch (o) {
      case "t":
        return h("t"), h("r"), h("u"), h("e"), !0;
      case "f":
        return h("f"), h("a"), h("l"), h("s"), h("e"), !1;
      case "n":
        return h("n"), h("u"), h("l"), h("l"), null;
      default:
        U("Unexpected '" + o + "'");
    }
  }
  function B() {
    var X = [];
    if (o === "[") {
      if (h("["), P(), o === "]")
        return h("]"), X;
      for (; o; ) {
        if (X.push(V()), P(), o === "]")
          return h("]"), X;
        h(","), P();
      }
    }
    U("Bad array");
  }
  function H() {
    var X, Q = {};
    if (o === "{") {
      if (h("{"), P(), o === "}")
        return h("}"), Q;
      for (; o; ) {
        if (X = A(), P(), h(":"), Object.prototype.hasOwnProperty.call(Q, X) && U('Duplicate key "' + X + '"'), Q[X] = V(), P(), o === "}")
          return h("}"), Q;
        h(","), P();
      }
    }
    U("Bad object");
  }
  function V() {
    switch (P(), o) {
      case "{":
        return H();
      case "[":
        return B();
      case '"':
        return A();
      case "-":
        return q();
      default:
        return o >= "0" && o <= "9" ? q() : I();
    }
  }
  return parse = function(X, Q) {
    var ee;
    return g = X, e = 0, o = " ", ee = V(), P(), o && U("Syntax error"), typeof Q == "function" ? function ie(te, se) {
      var le, ce, pe = te[se];
      if (pe && typeof pe == "object")
        for (le in V)
          Object.prototype.hasOwnProperty.call(pe, le) && (ce = ie(pe, le), typeof ce > "u" ? delete pe[le] : pe[le] = ce);
      return Q.call(te, se, pe);
    }({ "": ee }, "") : ee;
  }, parse;
}
var stringify, hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify)
    return stringify;
  hasRequiredStringify = 1;
  var e = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, o, S, g = {
    // table of character substitutions
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  }, U;
  function h(A) {
    return e.lastIndex = 0, e.test(A) ? '"' + A.replace(e, function(P) {
      var I = g[P];
      return typeof I == "string" ? I : "\\u" + ("0000" + P.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + A + '"';
  }
  function q(A, P) {
    var I, B, H, V, X = o, Q, ee = P[A];
    switch (ee && typeof ee == "object" && typeof ee.toJSON == "function" && (ee = ee.toJSON(A)), typeof U == "function" && (ee = U.call(P, A, ee)), typeof ee) {
      case "string":
        return h(ee);
      case "number":
        return isFinite(ee) ? String(ee) : "null";
      case "boolean":
      case "null":
        return String(ee);
      case "object":
        if (!ee)
          return "null";
        if (o += S, Q = [], Object.prototype.toString.apply(ee) === "[object Array]") {
          for (V = ee.length, I = 0; I < V; I += 1)
            Q[I] = q(I, ee) || "null";
          return H = Q.length === 0 ? "[]" : o ? `[
` + o + Q.join(`,
` + o) + `
` + X + "]" : "[" + Q.join(",") + "]", o = X, H;
        }
        if (U && typeof U == "object")
          for (V = U.length, I = 0; I < V; I += 1)
            B = U[I], typeof B == "string" && (H = q(B, ee), H && Q.push(h(B) + (o ? ": " : ":") + H));
        else
          for (B in ee)
            Object.prototype.hasOwnProperty.call(ee, B) && (H = q(B, ee), H && Q.push(h(B) + (o ? ": " : ":") + H));
        return H = Q.length === 0 ? "{}" : o ? `{
` + o + Q.join(`,
` + o) + `
` + X + "}" : "{" + Q.join(",") + "}", o = X, H;
    }
  }
  return stringify = function(A, P, I) {
    var B;
    if (o = "", S = "", typeof I == "number")
      for (B = 0; B < I; B += 1)
        S += " ";
    else
      typeof I == "string" && (S = I);
    if (U = P, P && typeof P != "function" && (typeof P != "object" || typeof P.length != "number"))
      throw new Error("JSON.stringify");
    return q("", { "": A });
  }, stringify;
}
var hasRequiredJsonify;
function requireJsonify() {
  return hasRequiredJsonify || (hasRequiredJsonify = 1, jsonify.parse = requireParse(), jsonify.stringify = requireStringify()), jsonify;
}
var toString = {}.toString, isarray$1 = Array.isArray || function(e) {
  return toString.call(e) == "[object Array]";
}, toStr$1 = Object.prototype.toString, isArguments$1 = function e(o) {
  var S = toStr$1.call(o), g = S === "[object Arguments]";
  return g || (g = S !== "[object Array]" && o !== null && typeof o == "object" && typeof o.length == "number" && o.length >= 0 && toStr$1.call(o.callee) === "[object Function]"), g;
}, implementation$5, hasRequiredImplementation$3;
function requireImplementation$3() {
  if (hasRequiredImplementation$3)
    return implementation$5;
  hasRequiredImplementation$3 = 1;
  var e;
  if (!Object.keys) {
    var o = Object.prototype.hasOwnProperty, S = Object.prototype.toString, g = isArguments$1, U = Object.prototype.propertyIsEnumerable, h = !U.call({ toString: null }, "toString"), q = U.call(function() {
    }, "prototype"), A = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], P = function(V) {
      var X = V.constructor;
      return X && X.prototype === V;
    }, I = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, B = function() {
      if (typeof window > "u")
        return !1;
      for (var V in window)
        try {
          if (!I["$" + V] && o.call(window, V) && window[V] !== null && typeof window[V] == "object")
            try {
              P(window[V]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), H = function(V) {
      if (typeof window > "u" || !B)
        return P(V);
      try {
        return P(V);
      } catch {
        return !1;
      }
    };
    e = function(X) {
      var Q = X !== null && typeof X == "object", ee = S.call(X) === "[object Function]", ie = g(X), te = Q && S.call(X) === "[object String]", se = [];
      if (!Q && !ee && !ie)
        throw new TypeError("Object.keys called on a non-object");
      var le = q && ee;
      if (te && X.length > 0 && !o.call(X, 0))
        for (var ce = 0; ce < X.length; ++ce)
          se.push(String(ce));
      if (ie && X.length > 0)
        for (var pe = 0; pe < X.length; ++pe)
          se.push(String(pe));
      else
        for (var me in X)
          !(le && me === "prototype") && o.call(X, me) && se.push(String(me));
      if (h)
        for (var Me = H(X), Ee = 0; Ee < A.length; ++Ee)
          !(Me && A[Ee] === "constructor") && o.call(X, A[Ee]) && se.push(A[Ee]);
      return se;
    };
  }
  return implementation$5 = e, implementation$5;
}
var slice = Array.prototype.slice, isArgs = isArguments$1, origKeys = Object.keys, keysShim = origKeys ? function e(o) {
  return origKeys(o);
} : requireImplementation$3(), originalKeys = Object.keys;
keysShim.shim = function e() {
  if (Object.keys) {
    var o = function() {
      var S = Object.keys(arguments);
      return S && S.length === arguments.length;
    }(1, 2);
    o || (Object.keys = function(g) {
      return isArgs(g) ? originalKeys(slice.call(g)) : originalKeys(g);
    });
  } else
    Object.keys = keysShim;
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim, callBind$2 = { exports: {} }, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function e(o, S) {
  for (var g = [], U = 0; U < o.length; U += 1)
    g[U] = o[U];
  for (var h = 0; h < S.length; h += 1)
    g[h + o.length] = S[h];
  return g;
}, slicy = function e(o, S) {
  for (var g = [], U = S || 0, h = 0; U < o.length; U += 1, h += 1)
    g[h] = o[U];
  return g;
}, joiny = function(e, o) {
  for (var S = "", g = 0; g < e.length; g += 1)
    S += e[g], g + 1 < e.length && (S += o);
  return S;
}, implementation$4 = function e(o) {
  var S = this;
  if (typeof S != "function" || toStr.apply(S) !== funcType)
    throw new TypeError(ERROR_MESSAGE + S);
  for (var g = slicy(arguments, 1), U, h = function() {
    if (this instanceof U) {
      var B = S.apply(
        this,
        concatty(g, arguments)
      );
      return Object(B) === B ? B : this;
    }
    return S.apply(
      o,
      concatty(g, arguments)
    );
  }, q = max(0, S.length - g.length), A = [], P = 0; P < q; P++)
    A[P] = "$" + P;
  if (U = Function("binder", "return function (" + joiny(A, ",") + "){ return binder.apply(this,arguments); }")(h), S.prototype) {
    var I = function() {
    };
    I.prototype = S.prototype, U.prototype = new I(), I.prototype = null;
  }
  return U;
}, implementation$3 = implementation$4, functionBind = Function.prototype.bind || implementation$3, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, shams$1 = function e() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var o = {}, S = Symbol("test"), g = Object(S);
  if (typeof S == "string" || Object.prototype.toString.call(S) !== "[object Symbol]" || Object.prototype.toString.call(g) !== "[object Symbol]")
    return !1;
  var U = 42;
  o[S] = U;
  for (S in o)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(o).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(o).length !== 0)
    return !1;
  var h = Object.getOwnPropertySymbols(o);
  if (h.length !== 1 || h[0] !== S || !Object.prototype.propertyIsEnumerable.call(o, S))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var q = Object.getOwnPropertyDescriptor(o, S);
    if (q.value !== U || q.enumerable !== !0)
      return !1;
  }
  return !0;
}, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function e() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  __proto__: null,
  foo: {}
}, $Object = Object, hasProto$1 = function e() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
}, call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(e) {
  try {
    return $Function('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto = Object.getPrototypeOf || (hasProto ? function(e) {
  return e.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto ? undefined$1 : getProto(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto)
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto(getProto(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function e(o) {
  var S;
  if (o === "%AsyncFunction%")
    S = getEvalledConstructor("async function () {}");
  else if (o === "%GeneratorFunction%")
    S = getEvalledConstructor("function* () {}");
  else if (o === "%AsyncGeneratorFunction%")
    S = getEvalledConstructor("async function* () {}");
  else if (o === "%AsyncGenerator%") {
    var g = e("%AsyncGeneratorFunction%");
    g && (S = g.prototype);
  } else if (o === "%AsyncIteratorPrototype%") {
    var U = e("%AsyncGenerator%");
    U && getProto && (S = getProto(U.prototype));
  }
  return INTRINSICS[o] = S, S;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind = functionBind, hasOwn = hasown, $concat = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function e(o) {
  var S = $strSlice(o, 0, 1), g = $strSlice(o, -1);
  if (S === "%" && g !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (g === "%" && S !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var U = [];
  return $replace(o, rePropName, function(h, q, A, P) {
    U[U.length] = A ? $replace(P, reEscapeChar, "$1") : q || h;
  }), U;
}, getBaseIntrinsic = function e(o, S) {
  var g = o, U;
  if (hasOwn(LEGACY_ALIASES, g) && (U = LEGACY_ALIASES[g], g = "%" + U[0] + "%"), hasOwn(INTRINSICS, g)) {
    var h = INTRINSICS[g];
    if (h === needsEval && (h = doEval(g)), typeof h > "u" && !S)
      throw new $TypeError$2("intrinsic " + o + " exists, but is not available. Please file an issue!");
    return {
      alias: U,
      name: g,
      value: h
    };
  }
  throw new $SyntaxError$1("intrinsic " + o + " does not exist!");
}, getIntrinsic = function e(o, S) {
  if (typeof o != "string" || o.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof S != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, o) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var g = stringToPath(o), U = g.length > 0 ? g[0] : "", h = getBaseIntrinsic("%" + U + "%", S), q = h.name, A = h.value, P = !1, I = h.alias;
  I && (U = I[0], $spliceApply(g, $concat([0, 1], I)));
  for (var B = 1, H = !0; B < g.length; B += 1) {
    var V = g[B], X = $strSlice(V, 0, 1), Q = $strSlice(V, -1);
    if ((X === '"' || X === "'" || X === "`" || Q === '"' || Q === "'" || Q === "`") && X !== Q)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((V === "constructor" || !H) && (P = !0), U += "." + V, q = "%" + U + "%", hasOwn(INTRINSICS, q))
      A = INTRINSICS[q];
    else if (A != null) {
      if (!(V in A)) {
        if (!S)
          throw new $TypeError$2("base intrinsic for " + o + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && B + 1 >= g.length) {
        var ee = $gOPD$1(A, V);
        H = !!ee, H && "get" in ee && !("originalValue" in ee.get) ? A = ee.get : A = A[V];
      } else
        H = hasOwn(A, V), A = A[V];
      H && !P && (INTRINSICS[q] = A);
    }
  }
  return A;
}, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var e = getIntrinsic, o = e("%Object.defineProperty%", !0) || !1;
  if (o)
    try {
      o({}, "a", { value: 1 });
    } catch {
      o = !1;
    }
  return esDefineProperty = o, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function e(o, S, g) {
  if (!o || typeof o != "object" && typeof o != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof S != "string" && typeof S != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var U = arguments.length > 3 ? arguments[3] : null, h = arguments.length > 4 ? arguments[4] : null, q = arguments.length > 5 ? arguments[5] : null, A = arguments.length > 6 ? arguments[6] : !1, P = !!gopd && gopd(o, S);
  if ($defineProperty$1)
    $defineProperty$1(o, S, {
      configurable: q === null && P ? P.configurable : !q,
      enumerable: U === null && P ? P.enumerable : !U,
      value: g,
      writable: h === null && P ? P.writable : !h
    });
  else if (A || !U && !h && !q)
    o[S] = g;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function e() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function e() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function e(o, S) {
  if (typeof o != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof S != "number" || S < 0 || S > 4294967295 || $floor(S) !== S)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var g = arguments.length > 2 && !!arguments[2], U = !0, h = !0;
  if ("length" in o && gOPD) {
    var q = gOPD(o, "length");
    q && !q.configurable && (U = !1), q && !q.writable && (h = !1);
  }
  return (U || h || !g) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    o,
    "length",
    S,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    o,
    "length",
    S
  )), o;
};
(function(e) {
  var o = functionBind, S = getIntrinsic, g = setFunctionLength, U = type, h = S("%Function.prototype.apply%"), q = S("%Function.prototype.call%"), A = S("%Reflect.apply%", !0) || o.call(q, h), P = requireEsDefineProperty(), I = S("%Math.max%");
  e.exports = function(V) {
    if (typeof V != "function")
      throw new U("a function is required");
    var X = A(o, q, arguments);
    return g(
      X,
      1 + I(0, V.length - (arguments.length - 1)),
      !0
    );
  };
  var B = function() {
    return A(o, h, arguments);
  };
  P ? P(e.exports, "apply", { value: B }) : e.exports.apply = B;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$1 = function e(o, S) {
  var g = GetIntrinsic(o, !!S);
  return typeof g == "function" && $indexOf(o, ".prototype.") > -1 ? callBind$1(g) : g;
}, jsonStringify = (typeof JSON < "u" ? JSON : requireJsonify()).stringify, isArray$1 = isarray$1, objectKeys = objectKeys$1, callBind = callBindExports, callBound = callBound$1, $join = callBound("Array.prototype.join"), $push = callBound("Array.prototype.push"), strRepeat = function e(o, S) {
  for (var g = "", U = 0; U < o; U += 1)
    g += S;
  return g;
}, defaultReplacer = function(e, o, S) {
  return S;
}, jsonStableStringify = function e(o) {
  var S = arguments.length > 1 ? arguments[1] : void 0, g = S && S.space || "";
  typeof g == "number" && (g = strRepeat(g, " "));
  var U = !!S && typeof S.cycles == "boolean" && S.cycles, h = S && S.replacer ? callBind(S.replacer) : defaultReplacer, q = typeof S == "function" ? S : S && S.cmp, A = q && function(I) {
    var B = q.length > 2 && function(V) {
      return I[V];
    };
    return function(H, V) {
      return q(
        { key: H, value: I[H] },
        { key: V, value: I[V] },
        B ? { __proto__: null, get: B } : void 0
      );
    };
  }, P = [];
  return function I(B, H, V, X) {
    var Q = g ? `
` + strRepeat(X, g) : "", ee = g ? ": " : ":";
    if (V && V.toJSON && typeof V.toJSON == "function" && (V = V.toJSON()), V = h(B, H, V), V !== void 0) {
      if (typeof V != "object" || V === null)
        return jsonStringify(V);
      if (isArray$1(V)) {
        for (var le = [], ie = 0; ie < V.length; ie++) {
          var te = I(V, ie, V[ie], X + 1) || jsonStringify(null);
          $push(le, Q + g + te);
        }
        return "[" + $join(le, ",") + Q + "]";
      }
      if (P.indexOf(V) !== -1) {
        if (U)
          return jsonStringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      } else
        $push(P, V);
      for (var se = objectKeys(V).sort(A && A(V)), le = [], ie = 0; ie < se.length; ie++) {
        var H = se[ie], ce = I(V, H, V[H], X + 1);
        if (ce) {
          var pe = jsonStringify(H) + ee + ce;
          $push(le, Q + g + pe);
        }
      }
      return P.splice(P.indexOf(V), 1), "{" + $join(le, ",") + Q + "}";
    }
  }({ "": o }, "", o, 0);
}, __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cache, "__esModule", { value: !0 });
cache.cacheTypeForPayload = cache.blockTagParamIndex = cache.paramsWithoutBlockTag = cache.blockTagForPayload = cache.canCache = cache.cacheIdentifierForPayload = void 0;
const json_stable_stringify_1 = __importDefault$5(jsonStableStringify);
function cacheIdentifierForPayload(e, o) {
  var S;
  const g = o ? paramsWithoutBlockTag(e) : (S = e.params) !== null && S !== void 0 ? S : [];
  return canCache(e) ? `${e.method}:${json_stable_stringify_1.default(g)}` : null;
}
cache.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(e) {
  return cacheTypeForPayload(e) !== "never";
}
cache.canCache = canCache;
function blockTagForPayload(e) {
  if (!e.params)
    return;
  const o = blockTagParamIndex(e);
  if (!(o === void 0 || o >= e.params.length))
    return e.params[o];
}
cache.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(e) {
  if (!e.params)
    return [];
  const o = blockTagParamIndex(e);
  return o === void 0 || o >= e.params.length ? e.params : e.method === "eth_getBlockByNumber" ? e.params.slice(1) : e.params.slice(0, o);
}
cache.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(e) {
  switch (e.method) {
    case "eth_getStorageAt":
      return 2;
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
      return 1;
    case "eth_getBlockByNumber":
      return 0;
    default:
      return;
  }
}
cache.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(e) {
  switch (e.method) {
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
    case "test_permaCache":
      return "perma";
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
    case "test_forkCache":
      return "fork";
    case "eth_gasPrice":
    case "eth_blockNumber":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "test_blockCache":
      return "block";
    default:
      return "never";
  }
}
cache.cacheTypeForPayload = cacheTypeForPayload;
Object.defineProperty(blockCache, "__esModule", { value: !0 });
blockCache.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1$8 = dist$6, logging_utils_1$4 = loggingUtils, cache_1$4 = cache, log$4 = logging_utils_1$4.createModuleLogger(logging_utils_1$4.projectLogger, "block-cache"), emptyValues$1 = [void 0, null, "<nil>"];
class BlockCacheStrategy {
  constructor() {
    this.cache = {};
  }
  getBlockCacheForPayload(o, S) {
    const g = Number.parseInt(S, 16);
    let U = this.cache[g];
    if (!U) {
      const h = {};
      this.cache[g] = h, U = h;
    }
    return U;
  }
  async get(o, S) {
    const g = this.getBlockCacheForPayload(o, S), U = cache_1$4.cacheIdentifierForPayload(o, !0);
    return U ? g[U] : void 0;
  }
  async set(o, S, g) {
    if (!this.canCacheResult(o, g))
      return;
    const h = cache_1$4.cacheIdentifierForPayload(o, !0);
    if (!h)
      return;
    const q = this.getBlockCacheForPayload(o, S);
    q[h] = g;
  }
  canCacheRequest(o) {
    return !(!cache_1$4.canCache(o) || cache_1$4.blockTagForPayload(o) === "pending");
  }
  canCacheResult(o, S) {
    return !(emptyValues$1.includes(S) || o.method && ["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(o.method) && (!S || !S.blockHash || S.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000"));
  }
  // removes all block caches with block number lower than `oldBlockHex`
  clearBefore(o) {
    const S = Number.parseInt(o, 16);
    Object.keys(this.cache).map(Number).filter((g) => g < S).forEach((g) => delete this.cache[g]);
  }
}
function createBlockCacheMiddleware({ blockTracker: e } = {}) {
  if (!e)
    throw new Error("createBlockCacheMiddleware - No PollingBlockTracker specified");
  const o = new BlockCacheStrategy(), S = {
    perma: o,
    block: o,
    fork: o
  };
  return json_rpc_engine_1$8.createAsyncMiddleware(async (g, U, h) => {
    if (g.skipCache)
      return h();
    const q = cache_1$4.cacheTypeForPayload(g), A = S[q];
    if (!A || !A.canCacheRequest(g))
      return h();
    let P = cache_1$4.blockTagForPayload(g);
    P || (P = "latest"), log$4("blockTag = %o, req = %o", P, g);
    let I;
    if (P === "earliest")
      I = "0x00";
    else if (P === "latest") {
      log$4("Fetching latest block number to determine cache key");
      const H = await e.getLatestBlock();
      log$4("Clearing values stored under block numbers before %o", H), o.clearBefore(H), I = H;
    } else
      I = P;
    const B = await A.get(g, I);
    B === void 0 ? (log$4("No cache stored under block number %o, carrying request forward", I), await h(), log$4("Populating cache with", U), await A.set(g, I, U.result)) : (log$4("Cache hit, reusing cache result stored under block number %o", I), U.result = B);
  });
}
blockCache.createBlockCacheMiddleware = createBlockCacheMiddleware;
var blockRefRewrite = {};
Object.defineProperty(blockRefRewrite, "__esModule", { value: !0 });
blockRefRewrite.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1$7 = dist$6, cache_1$3 = cache;
function createBlockRefRewriteMiddleware({ blockTracker: e } = {}) {
  if (!e)
    throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
  return json_rpc_engine_1$7.createAsyncMiddleware(async (o, S, g) => {
    var U;
    const h = cache_1$3.blockTagParamIndex(o);
    if (h === void 0)
      return g();
    let q = (U = o.params) === null || U === void 0 ? void 0 : U[h];
    if (q === void 0 && (q = "latest"), q !== "latest")
      return g();
    const A = await e.getLatestBlock();
    return o.params && (o.params[h] = A), g();
  });
}
blockRefRewrite.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
var blockRef = {}, clone = { exports: {} };
(function(e) {
  var o = function() {
    function S(V, X) {
      return X != null && V instanceof X;
    }
    var g;
    try {
      g = Map;
    } catch {
      g = function() {
      };
    }
    var U;
    try {
      U = Set;
    } catch {
      U = function() {
      };
    }
    var h;
    try {
      h = Promise;
    } catch {
      h = function() {
      };
    }
    function q(V, X, Q, ee, ie) {
      typeof X == "object" && (Q = X.depth, ee = X.prototype, ie = X.includeNonEnumerable, X = X.circular);
      var te = [], se = [], le = typeof buffer$3.Buffer < "u";
      typeof X > "u" && (X = !0), typeof Q > "u" && (Q = 1 / 0);
      function ce(pe, me) {
        if (pe === null)
          return null;
        if (me === 0)
          return pe;
        var Me, Ee;
        if (typeof pe != "object")
          return pe;
        if (S(pe, g))
          Me = new g();
        else if (S(pe, U))
          Me = new U();
        else if (S(pe, h))
          Me = new h(function(Z, K) {
            pe.then(function(z) {
              Z(ce(z, me - 1));
            }, function(z) {
              K(ce(z, me - 1));
            });
          });
        else if (q.__isArray(pe))
          Me = [];
        else if (q.__isRegExp(pe))
          Me = new RegExp(pe.source, H(pe)), pe.lastIndex && (Me.lastIndex = pe.lastIndex);
        else if (q.__isDate(pe))
          Me = new Date(pe.getTime());
        else {
          if (le && buffer$3.Buffer.isBuffer(pe))
            return buffer$3.Buffer.allocUnsafe ? Me = buffer$3.Buffer.allocUnsafe(pe.length) : Me = new buffer$3.Buffer(pe.length), pe.copy(Me), Me;
          S(pe, Error) ? Me = Object.create(pe) : typeof ee > "u" ? (Ee = Object.getPrototypeOf(pe), Me = Object.create(Ee)) : (Me = Object.create(ee), Ee = ee);
        }
        if (X) {
          var Re = te.indexOf(pe);
          if (Re != -1)
            return se[Re];
          te.push(pe), se.push(Me);
        }
        S(pe, g) && pe.forEach(function(Z, K) {
          var z = ce(K, me - 1), G = ce(Z, me - 1);
          Me.set(z, G);
        }), S(pe, U) && pe.forEach(function(Z) {
          var K = ce(Z, me - 1);
          Me.add(K);
        });
        for (var Ne in pe) {
          var ne;
          Ee && (ne = Object.getOwnPropertyDescriptor(Ee, Ne)), !(ne && ne.set == null) && (Me[Ne] = ce(pe[Ne], me - 1));
        }
        if (Object.getOwnPropertySymbols)
          for (var Y = Object.getOwnPropertySymbols(pe), Ne = 0; Ne < Y.length; Ne++) {
            var M = Y[Ne], $ = Object.getOwnPropertyDescriptor(pe, M);
            $ && !$.enumerable && !ie || (Me[M] = ce(pe[M], me - 1), $.enumerable || Object.defineProperty(Me, M, {
              enumerable: !1
            }));
          }
        if (ie)
          for (var O = Object.getOwnPropertyNames(pe), Ne = 0; Ne < O.length; Ne++) {
            var J = O[Ne], $ = Object.getOwnPropertyDescriptor(pe, J);
            $ && $.enumerable || (Me[J] = ce(pe[J], me - 1), Object.defineProperty(Me, J, {
              enumerable: !1
            }));
          }
        return Me;
      }
      return ce(V, Q);
    }
    q.clonePrototype = function(X) {
      if (X === null)
        return null;
      var Q = function() {
      };
      return Q.prototype = X, new Q();
    };
    function A(V) {
      return Object.prototype.toString.call(V);
    }
    q.__objToStr = A;
    function P(V) {
      return typeof V == "object" && A(V) === "[object Date]";
    }
    q.__isDate = P;
    function I(V) {
      return typeof V == "object" && A(V) === "[object Array]";
    }
    q.__isArray = I;
    function B(V) {
      return typeof V == "object" && A(V) === "[object RegExp]";
    }
    q.__isRegExp = B;
    function H(V) {
      var X = "";
      return V.global && (X += "g"), V.ignoreCase && (X += "i"), V.multiline && (X += "m"), X;
    }
    return q.__getRegExpFlags = H, q;
  }();
  e.exports && (e.exports = o);
})(clone);
var cloneExports = clone.exports;
const processFn = (e, o) => function() {
  const S = o.promiseModule, g = new Array(arguments.length);
  for (let U = 0; U < arguments.length; U++)
    g[U] = arguments[U];
  return new S((U, h) => {
    o.errorFirst ? g.push(function(q, A) {
      if (o.multiArgs) {
        const P = new Array(arguments.length - 1);
        for (let I = 1; I < arguments.length; I++)
          P[I - 1] = arguments[I];
        q ? (P.unshift(q), h(P)) : U(P);
      } else
        q ? h(q) : U(A);
    }) : g.push(function(q) {
      if (o.multiArgs) {
        const A = new Array(arguments.length - 1);
        for (let P = 0; P < arguments.length; P++)
          A[P] = arguments[P];
        U(A);
      } else
        U(q);
    }), e.apply(this, g);
  });
};
var pify = (e, o) => {
  o = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: !0,
    promiseModule: Promise
  }, o);
  const S = (U) => {
    const h = (q) => typeof q == "string" ? U === q : q.test(U);
    return o.include ? o.include.some(h) : !o.exclude.some(h);
  };
  let g;
  typeof e == "function" ? g = function() {
    return o.excludeMain ? e.apply(this, arguments) : processFn(e, o).apply(this, arguments);
  } : g = Object.create(Object.getPrototypeOf(e));
  for (const U in e) {
    const h = e[U];
    g[U] = typeof h == "function" && S(U) ? processFn(h, o) : h;
  }
  return g;
}, __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(blockRef, "__esModule", { value: !0 });
blockRef.createBlockRefMiddleware = void 0;
const json_rpc_engine_1$6 = dist$6, clone_1$2 = __importDefault$4(cloneExports), pify_1$1 = __importDefault$4(pify), logging_utils_1$3 = loggingUtils, cache_1$2 = cache, log$3 = logging_utils_1$3.createModuleLogger(logging_utils_1$3.projectLogger, "block-ref");
function createBlockRefMiddleware({ provider: e, blockTracker: o } = {}) {
  if (!e)
    throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
  if (!o)
    throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
  return json_rpc_engine_1$6.createAsyncMiddleware(async (S, g, U) => {
    var h, q;
    const A = cache_1$2.blockTagParamIndex(S);
    if (A === void 0)
      return U();
    if (((q = (h = S.params) === null || h === void 0 ? void 0 : h[A]) !== null && q !== void 0 ? q : "latest") !== "latest")
      return log$3('blockRef is not "latest", carrying request forward'), U();
    const I = await o.getLatestBlock();
    log$3(`blockRef is "latest", setting param ${A} to latest block ${I}`);
    const B = clone_1$2.default(S);
    B.params && (B.params[A] = I), log$3("Performing another request %o", B);
    const H = await pify_1$1.default(e.sendAsync).call(e, B);
    g.result = H.result, g.error = H.error;
  });
}
blockRef.createBlockRefMiddleware = createBlockRefMiddleware;
var blockTrackerInspector = {};
Object.defineProperty(blockTrackerInspector, "__esModule", { value: !0 });
blockTrackerInspector.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1$5 = dist$6, logging_utils_1$2 = loggingUtils, log$2 = logging_utils_1$2.createModuleLogger(logging_utils_1$2.projectLogger, "block-tracker-inspector"), futureBlockRefRequests = [
  "eth_getTransactionByHash",
  "eth_getTransactionReceipt"
];
function createBlockTrackerInspectorMiddleware({ blockTracker: e }) {
  return json_rpc_engine_1$5.createAsyncMiddleware(async (o, S, g) => {
    var U;
    if (!futureBlockRefRequests.includes(o.method))
      return g();
    if (await g(), !!(!((U = S.result) === null || U === void 0) && U.blockNumber) && (log$2("res.result.blockNumber exists, proceeding. res = %o", S), typeof S.result.blockNumber == "string")) {
      const h = Number.parseInt(S.result.blockNumber, 16), q = Number.parseInt(e.getCurrentBlock(), 16);
      h > q && (log$2("blockNumber from response is greater than current block number, refreshing current block number"), await e.checkForLatestBlock());
    }
  });
}
blockTrackerInspector.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
var fetch$2 = {};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(fetch$2, "__esModule", { value: !0 });
fetch$2.createFetchConfigFromReq = fetch$2.createFetchMiddleware = void 0;
const json_rpc_engine_1$4 = dist$6, eth_rpc_errors_1$1 = dist$7, fetch$1 = commonjsGlobal$1.fetch || require$$3, btoa$1 = commonjsGlobal$1.btoa || require$$3, RETRIABLE_ERRORS = [
  // ignore server overload errors
  "Gateway timeout",
  "ETIMEDOUT",
  // ignore server sent html error pages
  // or truncated json responses
  "failed to parse response body",
  // ignore errors where http req failed to establish
  "Failed to fetch"
];
function createFetchMiddleware({ rpcUrl: e, originHttpHeaderKey: o }) {
  return json_rpc_engine_1$4.createAsyncMiddleware(async (S, g, U) => {
    const { fetchUrl: h, fetchParams: q } = createFetchConfigFromReq({
      req: S,
      rpcUrl: e,
      originHttpHeaderKey: o
    }), A = 5, P = 1e3;
    for (let I = 0; I < A; I++) {
      try {
        const B = await fetch$1(h, q);
        checkForHttpErrors(B);
        const H = await B.text();
        let V;
        try {
          V = JSON.parse(H);
        } catch {
          throw new Error(`FetchMiddleware - failed to parse response body: "${H}"`);
        }
        const X = parseResponse(B, V);
        g.result = X;
        return;
      } catch (B) {
        const H = B.toString();
        if (!RETRIABLE_ERRORS.some((X) => H.includes(X)))
          throw B;
      }
      await timeout$1(P);
    }
  });
}
fetch$2.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(e) {
  switch (e.status) {
    case 405:
      throw eth_rpc_errors_1$1.ethErrors.rpc.methodNotFound();
    case 418:
      throw createRatelimitError();
    case 503:
    case 504:
      throw createTimeoutError();
  }
}
function parseResponse(e, o) {
  if (e.status !== 200)
    throw eth_rpc_errors_1$1.ethErrors.rpc.internal({
      message: `Non-200 status code: '${e.status}'`,
      data: o
    });
  if (o.error)
    throw eth_rpc_errors_1$1.ethErrors.rpc.internal({
      data: o.error
    });
  return o.result;
}
function createFetchConfigFromReq({ req: e, rpcUrl: o, originHttpHeaderKey: S }) {
  const g = new URL(o), U = normalizeUrlFromParsed(g), h = {
    id: e.id,
    jsonrpc: e.jsonrpc,
    method: e.method,
    params: e.params
  }, q = e.origin, A = JSON.stringify(h), P = {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: A
  };
  if (g.username && g.password) {
    const I = `${g.username}:${g.password}`, B = btoa$1(I);
    P.headers.Authorization = `Basic ${B}`;
  }
  return S && q && (P.headers[S] = q), { fetchUrl: U, fetchParams: P };
}
fetch$2.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(e) {
  let o = "";
  return o += e.protocol, o += `//${e.hostname}`, e.port && (o += `:${e.port}`), o += `${e.pathname}`, o += `${e.search}`, o;
}
function createRatelimitError() {
  return eth_rpc_errors_1$1.ethErrors.rpc.internal({ message: "Request is being rate limited." });
}
function createTimeoutError() {
  let e = "Gateway timeout. The request took too long to process. ";
  return e += "This can happen when querying logs over too wide a block range.", eth_rpc_errors_1$1.ethErrors.rpc.internal({ message: e });
}
function timeout$1(e) {
  return new Promise((o) => setTimeout(o, e));
}
var inflightCache = {}, __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(inflightCache, "__esModule", { value: !0 });
inflightCache.createInflightCacheMiddleware = void 0;
const clone_1$1 = __importDefault$3(cloneExports), json_rpc_engine_1$3 = dist$6, logging_utils_1$1 = loggingUtils, cache_1$1 = cache, log$1 = logging_utils_1$1.createModuleLogger(logging_utils_1$1.projectLogger, "inflight-cache");
function createInflightCacheMiddleware() {
  const e = {};
  return json_rpc_engine_1$3.createAsyncMiddleware(async (g, U, h) => {
    if (g.skipCache)
      return h();
    const q = cache_1$1.cacheIdentifierForPayload(g);
    if (!q)
      return log$1("Request is not cacheable, proceeding. req = %o", g), h();
    let A = e[q];
    if (A) {
      log$1("Running %i handler(s) for request %o", A.length, g), await o(U, A);
      return;
    }
    A = [], e[q] = A, log$1("Carrying original request forward %o", g), await h(), delete e[q], log$1("Running %i collected handler(s) for request %o", A.length, g), S(U, A);
  });
  function o(g, U) {
    const { resolve: h, promise: q } = deferredPromise();
    return U.push((A) => {
      g.result = clone_1$1.default(A.result), g.error = clone_1$1.default(A.error), h();
    }), q;
  }
  function S(g, U) {
    setTimeout(() => {
      U.forEach((h) => {
        try {
          h(g);
        } catch (q) {
          console.error(q);
        }
      });
    });
  }
}
inflightCache.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
  let e;
  const o = new Promise((S) => {
    e = S;
  });
  return { resolve: e, promise: o };
}
var providerAsMiddleware$1 = {};
Object.defineProperty(providerAsMiddleware$1, "__esModule", { value: !0 });
providerAsMiddleware$1.ethersProviderAsMiddleware = providerAsMiddleware$1.providerAsMiddleware = void 0;
function providerAsMiddleware(e) {
  return (o, S, g, U) => {
    e.sendAsync(o, (h, q) => h instanceof Error ? U(h) : (Object.assign(S, q), U()));
  };
}
providerAsMiddleware$1.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(e) {
  return (o, S, g, U) => {
    e.send(o, (h, q) => h ? U(h) : (Object.assign(S, q), U()));
  };
}
providerAsMiddleware$1.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
var providerFromEngine$1 = {}, __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(providerFromEngine$1, "__esModule", { value: !0 });
providerFromEngine$1.providerFromEngine = void 0;
const safe_event_emitter_1 = __importDefault$2(safeEventEmitter);
function providerFromEngine(e) {
  const o = new safe_event_emitter_1.default();
  return o.sendAsync = (S, g) => {
    e.handle(S, g);
  }, o.send = (S, g) => {
    if (typeof g != "function")
      throw new Error('Must provide callback to "send" method.');
    e.handle(S, g);
  }, e.on && e.on("notification", (S) => {
    o.emit("data", null, S);
  }), o;
}
providerFromEngine$1.providerFromEngine = providerFromEngine;
var providerFromMiddleware$1 = {};
Object.defineProperty(providerFromMiddleware$1, "__esModule", { value: !0 });
providerFromMiddleware$1.providerFromMiddleware = void 0;
const json_rpc_engine_1$2 = dist$6, providerFromEngine_1 = providerFromEngine$1;
function providerFromMiddleware(e) {
  const o = new json_rpc_engine_1$2.JsonRpcEngine();
  return o.push(e), providerFromEngine_1.providerFromEngine(o);
}
providerFromMiddleware$1.providerFromMiddleware = providerFromMiddleware;
var retryOnEmpty = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(retryOnEmpty, "__esModule", { value: !0 });
retryOnEmpty.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault$1(cloneExports), json_rpc_engine_1$1 = dist$6, pify_1 = __importDefault$1(pify), logging_utils_1 = loggingUtils, cache_1 = cache, log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, "retry-on-empty"), emptyValues = [
  void 0,
  null,
  "<nil>"
];
function createRetryOnEmptyMiddleware({ provider: e, blockTracker: o } = {}) {
  if (!e)
    throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
  if (!o)
    throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
  return json_rpc_engine_1$1.createAsyncMiddleware(async (S, g, U) => {
    var h;
    const q = cache_1.blockTagParamIndex(S);
    if (q === void 0)
      return U();
    let A = (h = S.params) === null || h === void 0 ? void 0 : h[q];
    if (A === void 0 && (A = "latest"), ["latest", "pending"].includes(A))
      return U();
    const P = Number.parseInt(A.slice(2), 16);
    if (Number.isNaN(P))
      return U();
    const I = await o.getLatestBlock(), B = Number.parseInt(I.slice(2), 16);
    if (P > B)
      return log("Requested block number %o is higher than latest block number %o, falling through to original request", P, B), U();
    log("Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received", P, B);
    const H = clone_1.default(S), V = await retry(10, async () => {
      log("Performing request %o", H);
      const X = await pify_1.default(e.sendAsync).call(e, H);
      if (log("Response is %o", X), emptyValues.includes(X.result))
        throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(X)}" for request "${JSON.stringify(H)}"`);
      return X;
    });
    log("Copying result %o and error %o", V.result, V.error), g.result = V.result, g.error = V.error;
  });
}
retryOnEmpty.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(e, o) {
  for (let S = 0; S < e; S++)
    try {
      return await o();
    } catch {
      log("(call %i) Request failed, waiting 1s to retry again...", S + 1), await timeout(1e3);
    }
  throw log("Retries exhausted"), new Error("RetryOnEmptyMiddleware - retries exhausted");
}
function timeout(e) {
  return new Promise((o) => setTimeout(o, e));
}
var wallet = {}, dist$2 = {}, personalSign$1 = {}, dist$1 = {}, constants$2 = {}, secp256k1$2 = {}, secp256k1$1 = {}, sha256$2 = {}, _sha2 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
function number(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
_assert.number = number;
function bool(e) {
  if (typeof e != "boolean")
    throw new Error(`Expected boolean, not ${e}`);
}
_assert.bool = bool;
function isBytes$1(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function bytes$1(e, ...o) {
  if (!isBytes$1(e))
    throw new Error("Expected Uint8Array");
  if (o.length > 0 && !o.includes(e.length))
    throw new Error(`Expected Uint8Array of length ${o}, not of length=${e.length}`);
}
_assert.bytes = bytes$1;
function hash$2(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(e.outputLen), number(e.blockLen);
}
_assert.hash = hash$2;
function exists(e, o = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (o && e.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists;
function output(e, o) {
  bytes$1(e);
  const S = o.outputLen;
  if (e.length < S)
    throw new Error(`digestInto() expects output buffer of length at least ${S}`);
}
_assert.output = output;
const assert$1 = { number, bool, bytes: bytes$1, hash: hash$2, exists, output };
_assert.default = assert$1;
var utils$7 = {}, crypto = {};
Object.defineProperty(crypto, "__esModule", { value: !0 });
crypto.crypto = void 0;
crypto.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(e) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(e, "__esModule", { value: !0 }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
  const o = crypto, S = (Ee) => new Uint8Array(Ee.buffer, Ee.byteOffset, Ee.byteLength);
  e.u8 = S;
  const g = (Ee) => new Uint32Array(Ee.buffer, Ee.byteOffset, Math.floor(Ee.byteLength / 4));
  e.u32 = g;
  function U(Ee) {
    return Ee instanceof Uint8Array || Ee != null && typeof Ee == "object" && Ee.constructor.name === "Uint8Array";
  }
  const h = (Ee) => new DataView(Ee.buffer, Ee.byteOffset, Ee.byteLength);
  e.createView = h;
  const q = (Ee, Re) => Ee << 32 - Re | Ee >>> Re;
  if (e.rotr = q, e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !e.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const A = /* @__PURE__ */ Array.from({ length: 256 }, (Ee, Re) => Re.toString(16).padStart(2, "0"));
  function P(Ee) {
    if (!U(Ee))
      throw new Error("Uint8Array expected");
    let Re = "";
    for (let Ne = 0; Ne < Ee.length; Ne++)
      Re += A[Ee[Ne]];
    return Re;
  }
  e.bytesToHex = P;
  const I = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function B(Ee) {
    if (Ee >= I._0 && Ee <= I._9)
      return Ee - I._0;
    if (Ee >= I._A && Ee <= I._F)
      return Ee - (I._A - 10);
    if (Ee >= I._a && Ee <= I._f)
      return Ee - (I._a - 10);
  }
  function H(Ee) {
    if (typeof Ee != "string")
      throw new Error("hex string expected, got " + typeof Ee);
    const Re = Ee.length, Ne = Re / 2;
    if (Re % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + Re);
    const ne = new Uint8Array(Ne);
    for (let Y = 0, M = 0; Y < Ne; Y++, M += 2) {
      const $ = B(Ee.charCodeAt(M)), O = B(Ee.charCodeAt(M + 1));
      if ($ === void 0 || O === void 0) {
        const J = Ee[M] + Ee[M + 1];
        throw new Error('hex string expected, got non-hex character "' + J + '" at index ' + M);
      }
      ne[Y] = $ * 16 + O;
    }
    return ne;
  }
  e.hexToBytes = H;
  const V = async () => {
  };
  e.nextTick = V;
  async function X(Ee, Re, Ne) {
    let ne = Date.now();
    for (let Y = 0; Y < Ee; Y++) {
      Ne(Y);
      const M = Date.now() - ne;
      M >= 0 && M < Re || (await (0, e.nextTick)(), ne += M);
    }
  }
  e.asyncLoop = X;
  function Q(Ee) {
    if (typeof Ee != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof Ee}`);
    return new Uint8Array(new TextEncoder().encode(Ee));
  }
  e.utf8ToBytes = Q;
  function ee(Ee) {
    if (typeof Ee == "string" && (Ee = Q(Ee)), !U(Ee))
      throw new Error(`expected Uint8Array, got ${typeof Ee}`);
    return Ee;
  }
  e.toBytes = ee;
  function ie(...Ee) {
    let Re = 0;
    for (let ne = 0; ne < Ee.length; ne++) {
      const Y = Ee[ne];
      if (!U(Y))
        throw new Error("Uint8Array expected");
      Re += Y.length;
    }
    const Ne = new Uint8Array(Re);
    for (let ne = 0, Y = 0; ne < Ee.length; ne++) {
      const M = Ee[ne];
      Ne.set(M, Y), Y += M.length;
    }
    return Ne;
  }
  e.concatBytes = ie;
  class te {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  e.Hash = te;
  const se = {}.toString;
  function le(Ee, Re) {
    if (Re !== void 0 && se.call(Re) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(Ee, Re);
  }
  e.checkOpts = le;
  function ce(Ee) {
    const Re = (ne) => Ee().update(ee(ne)).digest(), Ne = Ee();
    return Re.outputLen = Ne.outputLen, Re.blockLen = Ne.blockLen, Re.create = () => Ee(), Re;
  }
  e.wrapConstructor = ce;
  function pe(Ee) {
    const Re = (ne, Y) => Ee(Y).update(ee(ne)).digest(), Ne = Ee({});
    return Re.outputLen = Ne.outputLen, Re.blockLen = Ne.blockLen, Re.create = (ne) => Ee(ne), Re;
  }
  e.wrapConstructorWithOpts = pe;
  function me(Ee) {
    const Re = (ne, Y) => Ee(Y).update(ee(ne)).digest(), Ne = Ee({});
    return Re.outputLen = Ne.outputLen, Re.blockLen = Ne.blockLen, Re.create = (ne) => Ee(ne), Re;
  }
  e.wrapXOFConstructorWithOpts = me;
  function Me(Ee = 32) {
    if (o.crypto && typeof o.crypto.getRandomValues == "function")
      return o.crypto.getRandomValues(new Uint8Array(Ee));
    throw new Error("crypto.getRandomValues must be defined");
  }
  e.randomBytes = Me;
})(utils$7);
Object.defineProperty(_sha2, "__esModule", { value: !0 });
_sha2.SHA2 = void 0;
const _assert_js_1$1 = _assert, utils_js_1$6 = utils$7;
function setBigUint64(e, o, S, g) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(o, S, g);
  const U = BigInt(32), h = BigInt(4294967295), q = Number(S >> U & h), A = Number(S & h), P = g ? 4 : 0, I = g ? 0 : 4;
  e.setUint32(o + P, q, g), e.setUint32(o + I, A, g);
}
class SHA2 extends utils_js_1$6.Hash {
  constructor(o, S, g, U) {
    super(), this.blockLen = o, this.outputLen = S, this.padOffset = g, this.isLE = U, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(o), this.view = (0, utils_js_1$6.createView)(this.buffer);
  }
  update(o) {
    (0, _assert_js_1$1.exists)(this);
    const { view: S, buffer: g, blockLen: U } = this;
    o = (0, utils_js_1$6.toBytes)(o);
    const h = o.length;
    for (let q = 0; q < h; ) {
      const A = Math.min(U - this.pos, h - q);
      if (A === U) {
        const P = (0, utils_js_1$6.createView)(o);
        for (; U <= h - q; q += U)
          this.process(P, q);
        continue;
      }
      g.set(o.subarray(q, q + A), this.pos), this.pos += A, q += A, this.pos === U && (this.process(S, 0), this.pos = 0);
    }
    return this.length += o.length, this.roundClean(), this;
  }
  digestInto(o) {
    (0, _assert_js_1$1.exists)(this), (0, _assert_js_1$1.output)(o, this), this.finished = !0;
    const { buffer: S, view: g, blockLen: U, isLE: h } = this;
    let { pos: q } = this;
    S[q++] = 128, this.buffer.subarray(q).fill(0), this.padOffset > U - q && (this.process(g, 0), q = 0);
    for (let H = q; H < U; H++)
      S[H] = 0;
    setBigUint64(g, U - 8, BigInt(this.length * 8), h), this.process(g, 0);
    const A = (0, utils_js_1$6.createView)(o), P = this.outputLen;
    if (P % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const I = P / 4, B = this.get();
    if (I > B.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let H = 0; H < I; H++)
      A.setUint32(4 * H, B[H], h);
  }
  digest() {
    const { buffer: o, outputLen: S } = this;
    this.digestInto(o);
    const g = o.slice(0, S);
    return this.destroy(), g;
  }
  _cloneInto(o) {
    o || (o = new this.constructor()), o.set(...this.get());
    const { blockLen: S, buffer: g, length: U, finished: h, destroyed: q, pos: A } = this;
    return o.length = U, o.pos = A, o.finished = h, o.destroyed = q, U % S && o.buffer.set(g), o;
  }
}
_sha2.SHA2 = SHA2;
Object.defineProperty(sha256$2, "__esModule", { value: !0 });
sha256$2.sha224 = sha256$2.sha256 = void 0;
const _sha2_js_1 = _sha2, utils_js_1$5 = utils$7, Chi = (e, o, S) => e & o ^ ~e & S, Maj = (e, o, S) => e & o ^ e & S ^ o & S, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: o, B: S, C: g, D: U, E: h, F: q, G: A, H: P } = this;
    return [o, S, g, U, h, q, A, P];
  }
  // prettier-ignore
  set(o, S, g, U, h, q, A, P) {
    this.A = o | 0, this.B = S | 0, this.C = g | 0, this.D = U | 0, this.E = h | 0, this.F = q | 0, this.G = A | 0, this.H = P | 0;
  }
  process(o, S) {
    for (let H = 0; H < 16; H++, S += 4)
      SHA256_W[H] = o.getUint32(S, !1);
    for (let H = 16; H < 64; H++) {
      const V = SHA256_W[H - 15], X = SHA256_W[H - 2], Q = (0, utils_js_1$5.rotr)(V, 7) ^ (0, utils_js_1$5.rotr)(V, 18) ^ V >>> 3, ee = (0, utils_js_1$5.rotr)(X, 17) ^ (0, utils_js_1$5.rotr)(X, 19) ^ X >>> 10;
      SHA256_W[H] = ee + SHA256_W[H - 7] + Q + SHA256_W[H - 16] | 0;
    }
    let { A: g, B: U, C: h, D: q, E: A, F: P, G: I, H: B } = this;
    for (let H = 0; H < 64; H++) {
      const V = (0, utils_js_1$5.rotr)(A, 6) ^ (0, utils_js_1$5.rotr)(A, 11) ^ (0, utils_js_1$5.rotr)(A, 25), X = B + V + Chi(A, P, I) + SHA256_K[H] + SHA256_W[H] | 0, ee = ((0, utils_js_1$5.rotr)(g, 2) ^ (0, utils_js_1$5.rotr)(g, 13) ^ (0, utils_js_1$5.rotr)(g, 22)) + Maj(g, U, h) | 0;
      B = I, I = P, P = A, A = q + X | 0, q = h, h = U, U = g, g = X + ee | 0;
    }
    g = g + this.A | 0, U = U + this.B | 0, h = h + this.C | 0, q = q + this.D | 0, A = A + this.E | 0, P = P + this.F | 0, I = I + this.G | 0, B = B + this.H | 0, this.set(g, U, h, q, A, P, I, B);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$2.sha256 = (0, utils_js_1$5.wrapConstructor)(() => new SHA256());
sha256$2.sha224 = (0, utils_js_1$5.wrapConstructor)(() => new SHA224());
var modular = {}, utils$6 = {};
Object.defineProperty(utils$6, "__esModule", { value: !0 });
utils$6.validateObject = utils$6.createHmacDrbg = utils$6.bitMask = utils$6.bitSet = utils$6.bitGet = utils$6.bitLen = utils$6.utf8ToBytes = utils$6.equalBytes = utils$6.concatBytes = utils$6.ensureBytes = utils$6.numberToVarBytesBE = utils$6.numberToBytesLE = utils$6.numberToBytesBE = utils$6.bytesToNumberLE = utils$6.bytesToNumberBE = utils$6.hexToBytes = utils$6.hexToNumber = utils$6.numberToHexUnpadded = utils$6.bytesToHex = utils$6.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$3 = BigInt(1), _2n$2 = BigInt(2);
function isBytes(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
utils$6.isBytes = isBytes;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (e, o) => o.toString(16).padStart(2, "0"));
function bytesToHex$1(e) {
  if (!isBytes(e))
    throw new Error("Uint8Array expected");
  let o = "";
  for (let S = 0; S < e.length; S++)
    o += hexes[e[S]];
  return o;
}
utils$6.bytesToHex = bytesToHex$1;
function numberToHexUnpadded(e) {
  const o = e.toString(16);
  return o.length & 1 ? `0${o}` : o;
}
utils$6.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
utils$6.hexToNumber = hexToNumber;
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(e) {
  if (e >= asciis._0 && e <= asciis._9)
    return e - asciis._0;
  if (e >= asciis._A && e <= asciis._F)
    return e - (asciis._A - 10);
  if (e >= asciis._a && e <= asciis._f)
    return e - (asciis._a - 10);
}
function hexToBytes$1(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const o = e.length, S = o / 2;
  if (o % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + o);
  const g = new Uint8Array(S);
  for (let U = 0, h = 0; U < S; U++, h += 2) {
    const q = asciiToBase16(e.charCodeAt(h)), A = asciiToBase16(e.charCodeAt(h + 1));
    if (q === void 0 || A === void 0) {
      const P = e[h] + e[h + 1];
      throw new Error('hex string expected, got non-hex character "' + P + '" at index ' + h);
    }
    g[U] = q * 16 + A;
  }
  return g;
}
utils$6.hexToBytes = hexToBytes$1;
function bytesToNumberBE(e) {
  return hexToNumber(bytesToHex$1(e));
}
utils$6.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(e) {
  if (!isBytes(e))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex$1(Uint8Array.from(e).reverse()));
}
utils$6.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(e, o) {
  return hexToBytes$1(e.toString(16).padStart(o * 2, "0"));
}
utils$6.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(e, o) {
  return numberToBytesBE(e, o).reverse();
}
utils$6.numberToBytesLE = numberToBytesLE;
function numberToVarBytesBE(e) {
  return hexToBytes$1(numberToHexUnpadded(e));
}
utils$6.numberToVarBytesBE = numberToVarBytesBE;
function ensureBytes(e, o, S) {
  let g;
  if (typeof o == "string")
    try {
      g = hexToBytes$1(o);
    } catch (h) {
      throw new Error(`${e} must be valid hex string, got "${o}". Cause: ${h}`);
    }
  else if (isBytes(o))
    g = Uint8Array.from(o);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const U = g.length;
  if (typeof S == "number" && U !== S)
    throw new Error(`${e} expected ${S} bytes, got ${U}`);
  return g;
}
utils$6.ensureBytes = ensureBytes;
function concatBytes$1(...e) {
  let o = 0;
  for (let U = 0; U < e.length; U++) {
    const h = e[U];
    if (!isBytes(h))
      throw new Error("Uint8Array expected");
    o += h.length;
  }
  let S = new Uint8Array(o), g = 0;
  for (let U = 0; U < e.length; U++) {
    const h = e[U];
    S.set(h, g), g += h.length;
  }
  return S;
}
utils$6.concatBytes = concatBytes$1;
function equalBytes(e, o) {
  if (e.length !== o.length)
    return !1;
  let S = 0;
  for (let g = 0; g < e.length; g++)
    S |= e[g] ^ o[g];
  return S === 0;
}
utils$6.equalBytes = equalBytes;
function utf8ToBytes$1(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
utils$6.utf8ToBytes = utf8ToBytes$1;
function bitLen(e) {
  let o;
  for (o = 0; e > _0n$3; e >>= _1n$3, o += 1)
    ;
  return o;
}
utils$6.bitLen = bitLen;
function bitGet(e, o) {
  return e >> BigInt(o) & _1n$3;
}
utils$6.bitGet = bitGet;
const bitSet = (e, o, S) => e | (S ? _1n$3 : _0n$3) << BigInt(o);
utils$6.bitSet = bitSet;
const bitMask = (e) => (_2n$2 << BigInt(e - 1)) - _1n$3;
utils$6.bitMask = bitMask;
const u8n = (e) => new Uint8Array(e), u8fr = (e) => Uint8Array.from(e);
function createHmacDrbg(e, o, S) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof o != "number" || o < 2)
    throw new Error("qByteLen must be a number");
  if (typeof S != "function")
    throw new Error("hmacFn must be a function");
  let g = u8n(e), U = u8n(e), h = 0;
  const q = () => {
    g.fill(1), U.fill(0), h = 0;
  }, A = (...H) => S(U, g, ...H), P = (H = u8n()) => {
    U = A(u8fr([0]), H), g = A(), H.length !== 0 && (U = A(u8fr([1]), H), g = A());
  }, I = () => {
    if (h++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let H = 0;
    const V = [];
    for (; H < o; ) {
      g = A();
      const X = g.slice();
      V.push(X), H += g.length;
    }
    return concatBytes$1(...V);
  };
  return (H, V) => {
    q(), P(H);
    let X;
    for (; !(X = V(I())); )
      P();
    return q(), X;
  };
}
utils$6.createHmacDrbg = createHmacDrbg;
const validatorFns = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || isBytes(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, o) => o.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function validateObject(e, o, S = {}) {
  const g = (U, h, q) => {
    const A = validatorFns[h];
    if (typeof A != "function")
      throw new Error(`Invalid validator "${h}", expected function`);
    const P = e[U];
    if (!(q && P === void 0) && !A(P, e))
      throw new Error(`Invalid param ${String(U)}=${P} (${typeof P}), expected ${h}`);
  };
  for (const [U, h] of Object.entries(o))
    g(U, h, !1);
  for (const [U, h] of Object.entries(S))
    g(U, h, !0);
  return e;
}
utils$6.validateObject = validateObject;
Object.defineProperty(modular, "__esModule", { value: !0 });
modular.mapHashToField = modular.getMinHashLength = modular.getFieldBytesLength = modular.hashToPrivateScalar = modular.FpSqrtEven = modular.FpSqrtOdd = modular.Field = modular.nLength = modular.FpIsSquare = modular.FpDiv = modular.FpInvertBatch = modular.FpPow = modular.validateField = modular.isNegativeLE = modular.FpSqrt = modular.tonelliShanks = modular.invert = modular.pow2 = modular.pow = modular.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1$4 = utils$6, _0n$2 = BigInt(0), _1n$2 = BigInt(1), _2n$1 = BigInt(2), _3n = BigInt(3), _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
BigInt(9);
BigInt(16);
function mod(e, o) {
  const S = e % o;
  return S >= _0n$2 ? S : o + S;
}
modular.mod = mod;
function pow(e, o, S) {
  if (S <= _0n$2 || o < _0n$2)
    throw new Error("Expected power/modulo > 0");
  if (S === _1n$2)
    return _0n$2;
  let g = _1n$2;
  for (; o > _0n$2; )
    o & _1n$2 && (g = g * e % S), e = e * e % S, o >>= _1n$2;
  return g;
}
modular.pow = pow;
function pow2(e, o, S) {
  let g = e;
  for (; o-- > _0n$2; )
    g *= g, g %= S;
  return g;
}
modular.pow2 = pow2;
function invert(e, o) {
  if (e === _0n$2 || o <= _0n$2)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${o}`);
  let S = mod(e, o), g = o, U = _0n$2, h = _1n$2;
  for (; S !== _0n$2; ) {
    const A = g / S, P = g % S, I = U - h * A;
    g = S, S = P, U = h, h = I;
  }
  if (g !== _1n$2)
    throw new Error("invert: does not exist");
  return mod(U, o);
}
modular.invert = invert;
function tonelliShanks(e) {
  const o = (e - _1n$2) / _2n$1;
  let S, g, U;
  for (S = e - _1n$2, g = 0; S % _2n$1 === _0n$2; S /= _2n$1, g++)
    ;
  for (U = _2n$1; U < e && pow(U, o, e) !== e - _1n$2; U++)
    ;
  if (g === 1) {
    const q = (e + _1n$2) / _4n;
    return function(P, I) {
      const B = P.pow(I, q);
      if (!P.eql(P.sqr(B), I))
        throw new Error("Cannot find square root");
      return B;
    };
  }
  const h = (S + _1n$2) / _2n$1;
  return function(A, P) {
    if (A.pow(P, o) === A.neg(A.ONE))
      throw new Error("Cannot find square root");
    let I = g, B = A.pow(A.mul(A.ONE, U), S), H = A.pow(P, h), V = A.pow(P, S);
    for (; !A.eql(V, A.ONE); ) {
      if (A.eql(V, A.ZERO))
        return A.ZERO;
      let X = 1;
      for (let ee = A.sqr(V); X < I && !A.eql(ee, A.ONE); X++)
        ee = A.sqr(ee);
      const Q = A.pow(B, _1n$2 << BigInt(I - X - 1));
      B = A.sqr(Q), H = A.mul(H, Q), V = A.mul(V, B), I = X;
    }
    return H;
  };
}
modular.tonelliShanks = tonelliShanks;
function FpSqrt(e) {
  if (e % _4n === _3n) {
    const o = (e + _1n$2) / _4n;
    return function(g, U) {
      const h = g.pow(U, o);
      if (!g.eql(g.sqr(h), U))
        throw new Error("Cannot find square root");
      return h;
    };
  }
  if (e % _8n === _5n) {
    const o = (e - _5n) / _8n;
    return function(g, U) {
      const h = g.mul(U, _2n$1), q = g.pow(h, o), A = g.mul(U, q), P = g.mul(g.mul(A, _2n$1), q), I = g.mul(A, g.sub(P, g.ONE));
      if (!g.eql(g.sqr(I), U))
        throw new Error("Cannot find square root");
      return I;
    };
  }
  return tonelliShanks(e);
}
modular.FpSqrt = FpSqrt;
const isNegativeLE = (e, o) => (mod(e, o) & _1n$2) === _1n$2;
modular.isNegativeLE = isNegativeLE;
const FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(e) {
  const o = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, S = FIELD_FIELDS.reduce((g, U) => (g[U] = "function", g), o);
  return (0, utils_js_1$4.validateObject)(e, S);
}
modular.validateField = validateField;
function FpPow(e, o, S) {
  if (S < _0n$2)
    throw new Error("Expected power > 0");
  if (S === _0n$2)
    return e.ONE;
  if (S === _1n$2)
    return o;
  let g = e.ONE, U = o;
  for (; S > _0n$2; )
    S & _1n$2 && (g = e.mul(g, U)), U = e.sqr(U), S >>= _1n$2;
  return g;
}
modular.FpPow = FpPow;
function FpInvertBatch(e, o) {
  const S = new Array(o.length), g = o.reduce((h, q, A) => e.is0(q) ? h : (S[A] = h, e.mul(h, q)), e.ONE), U = e.inv(g);
  return o.reduceRight((h, q, A) => e.is0(q) ? h : (S[A] = e.mul(h, S[A]), e.mul(h, q)), U), S;
}
modular.FpInvertBatch = FpInvertBatch;
function FpDiv(e, o, S) {
  return e.mul(o, typeof S == "bigint" ? invert(S, e.ORDER) : e.inv(S));
}
modular.FpDiv = FpDiv;
function FpIsSquare(e) {
  const o = (e.ORDER - _1n$2) / _2n$1;
  return (S) => {
    const g = e.pow(S, o);
    return e.eql(g, e.ZERO) || e.eql(g, e.ONE);
  };
}
modular.FpIsSquare = FpIsSquare;
function nLength(e, o) {
  const S = o !== void 0 ? o : e.toString(2).length, g = Math.ceil(S / 8);
  return { nBitLength: S, nByteLength: g };
}
modular.nLength = nLength;
function Field(e, o, S = !1, g = {}) {
  if (e <= _0n$2)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: U, nByteLength: h } = nLength(e, o);
  if (h > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const q = FpSqrt(e), A = Object.freeze({
    ORDER: e,
    BITS: U,
    BYTES: h,
    MASK: (0, utils_js_1$4.bitMask)(U),
    ZERO: _0n$2,
    ONE: _1n$2,
    create: (P) => mod(P, e),
    isValid: (P) => {
      if (typeof P != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof P}`);
      return _0n$2 <= P && P < e;
    },
    is0: (P) => P === _0n$2,
    isOdd: (P) => (P & _1n$2) === _1n$2,
    neg: (P) => mod(-P, e),
    eql: (P, I) => P === I,
    sqr: (P) => mod(P * P, e),
    add: (P, I) => mod(P + I, e),
    sub: (P, I) => mod(P - I, e),
    mul: (P, I) => mod(P * I, e),
    pow: (P, I) => FpPow(A, P, I),
    div: (P, I) => mod(P * invert(I, e), e),
    // Same as above, but doesn't normalize
    sqrN: (P) => P * P,
    addN: (P, I) => P + I,
    subN: (P, I) => P - I,
    mulN: (P, I) => P * I,
    inv: (P) => invert(P, e),
    sqrt: g.sqrt || ((P) => q(A, P)),
    invertBatch: (P) => FpInvertBatch(A, P),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (P, I, B) => B ? I : P,
    toBytes: (P) => S ? (0, utils_js_1$4.numberToBytesLE)(P, h) : (0, utils_js_1$4.numberToBytesBE)(P, h),
    fromBytes: (P) => {
      if (P.length !== h)
        throw new Error(`Fp.fromBytes: expected ${h}, got ${P.length}`);
      return S ? (0, utils_js_1$4.bytesToNumberLE)(P) : (0, utils_js_1$4.bytesToNumberBE)(P);
    }
  });
  return Object.freeze(A);
}
modular.Field = Field;
function FpSqrtOdd(e, o) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const S = e.sqrt(o);
  return e.isOdd(S) ? S : e.neg(S);
}
modular.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(e, o) {
  if (!e.isOdd)
    throw new Error("Field doesn't have isOdd");
  const S = e.sqrt(o);
  return e.isOdd(S) ? e.neg(S) : S;
}
modular.FpSqrtEven = FpSqrtEven;
function hashToPrivateScalar(e, o, S = !1) {
  e = (0, utils_js_1$4.ensureBytes)("privateHash", e);
  const g = e.length, U = nLength(o).nByteLength + 8;
  if (U < 24 || g < U || g > 1024)
    throw new Error(`hashToPrivateScalar: expected ${U}-1024 bytes of input, got ${g}`);
  const h = S ? (0, utils_js_1$4.bytesToNumberLE)(e) : (0, utils_js_1$4.bytesToNumberBE)(e);
  return mod(h, o - _1n$2) + _1n$2;
}
modular.hashToPrivateScalar = hashToPrivateScalar;
function getFieldBytesLength(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const o = e.toString(2).length;
  return Math.ceil(o / 8);
}
modular.getFieldBytesLength = getFieldBytesLength;
function getMinHashLength(e) {
  const o = getFieldBytesLength(e);
  return o + Math.ceil(o / 2);
}
modular.getMinHashLength = getMinHashLength;
function mapHashToField(e, o, S = !1) {
  const g = e.length, U = getFieldBytesLength(o), h = getMinHashLength(o);
  if (g < 16 || g < h || g > 1024)
    throw new Error(`expected ${h}-1024 bytes of input, got ${g}`);
  const q = S ? (0, utils_js_1$4.bytesToNumberBE)(e) : (0, utils_js_1$4.bytesToNumberLE)(e), A = mod(q, o - _1n$2) + _1n$2;
  return S ? (0, utils_js_1$4.numberToBytesLE)(A, U) : (0, utils_js_1$4.numberToBytesBE)(A, U);
}
modular.mapHashToField = mapHashToField;
var weierstrass = {}, curve$1 = {};
Object.defineProperty(curve$1, "__esModule", { value: !0 });
curve$1.validateBasic = curve$1.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const modular_js_1$1 = modular, utils_js_1$3 = utils$6, _0n$1 = BigInt(0), _1n$1 = BigInt(1);
function wNAF(e, o) {
  const S = (U, h) => {
    const q = h.negate();
    return U ? q : h;
  }, g = (U) => {
    const h = Math.ceil(o / U) + 1, q = 2 ** (U - 1);
    return { windows: h, windowSize: q };
  };
  return {
    constTimeNegate: S,
    // non-const time multiplication ladder
    unsafeLadder(U, h) {
      let q = e.ZERO, A = U;
      for (; h > _0n$1; )
        h & _1n$1 && (q = q.add(A)), A = A.double(), h >>= _1n$1;
      return q;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(U, h) {
      const { windows: q, windowSize: A } = g(h), P = [];
      let I = U, B = I;
      for (let H = 0; H < q; H++) {
        B = I, P.push(B);
        for (let V = 1; V < A; V++)
          B = B.add(I), P.push(B);
        I = B.double();
      }
      return P;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(U, h, q) {
      const { windows: A, windowSize: P } = g(U);
      let I = e.ZERO, B = e.BASE;
      const H = BigInt(2 ** U - 1), V = 2 ** U, X = BigInt(U);
      for (let Q = 0; Q < A; Q++) {
        const ee = Q * P;
        let ie = Number(q & H);
        q >>= X, ie > P && (ie -= V, q += _1n$1);
        const te = ee, se = ee + Math.abs(ie) - 1, le = Q % 2 !== 0, ce = ie < 0;
        ie === 0 ? B = B.add(S(le, h[te])) : I = I.add(S(ce, h[se]));
      }
      return { p: I, f: B };
    },
    wNAFCached(U, h, q, A) {
      const P = U._WINDOW_SIZE || 1;
      let I = h.get(U);
      return I || (I = this.precomputeWindow(U, P), P !== 1 && h.set(U, A(I))), this.wNAF(P, I, q);
    }
  };
}
curve$1.wNAF = wNAF;
function validateBasic(e) {
  return (0, modular_js_1$1.validateField)(e.Fp), (0, utils_js_1$3.validateObject)(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, modular_js_1$1.nLength)(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
curve$1.validateBasic = validateBasic;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.mapToCurveSimpleSWU = e.SWUFpSqrtRatio = e.weierstrass = e.weierstrassPoints = e.DER = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const o = modular, S = utils$6, g = utils$6, U = curve$1;
  function h(se) {
    const le = (0, U.validateBasic)(se);
    S.validateObject(le, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: ce, Fp: pe, a: me } = le;
    if (ce) {
      if (!pe.eql(me, pe.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof ce != "object" || typeof ce.beta != "bigint" || typeof ce.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...le });
  }
  const { bytesToNumberBE: q, hexToBytes: A } = S;
  e.DER = {
    // asn.1 DER encoding utils
    Err: class extends Error {
      constructor(le = "") {
        super(le);
      }
    },
    _parseInt(se) {
      const { Err: le } = e.DER;
      if (se.length < 2 || se[0] !== 2)
        throw new le("Invalid signature integer tag");
      const ce = se[1], pe = se.subarray(2, ce + 2);
      if (!ce || pe.length !== ce)
        throw new le("Invalid signature integer: wrong length");
      if (pe[0] & 128)
        throw new le("Invalid signature integer: negative");
      if (pe[0] === 0 && !(pe[1] & 128))
        throw new le("Invalid signature integer: unnecessary leading zero");
      return { d: q(pe), l: se.subarray(ce + 2) };
    },
    toSig(se) {
      const { Err: le } = e.DER, ce = typeof se == "string" ? A(se) : se;
      if (!S.isBytes(ce))
        throw new Error("ui8a expected");
      let pe = ce.length;
      if (pe < 2 || ce[0] != 48)
        throw new le("Invalid signature tag");
      if (ce[1] !== pe - 2)
        throw new le("Invalid signature: incorrect length");
      const { d: me, l: Me } = e.DER._parseInt(ce.subarray(2)), { d: Ee, l: Re } = e.DER._parseInt(Me);
      if (Re.length)
        throw new le("Invalid signature: left bytes after parsing");
      return { r: me, s: Ee };
    },
    hexFromSig(se) {
      const le = (ne) => Number.parseInt(ne[0], 16) & 8 ? "00" + ne : ne, ce = (ne) => {
        const Y = ne.toString(16);
        return Y.length & 1 ? `0${Y}` : Y;
      }, pe = le(ce(se.s)), me = le(ce(se.r)), Me = pe.length / 2, Ee = me.length / 2, Re = ce(Me), Ne = ce(Ee);
      return `30${ce(Ee + Me + 4)}02${Ne}${me}02${Re}${pe}`;
    }
  };
  const P = BigInt(0), I = BigInt(1), B = BigInt(2), H = BigInt(3), V = BigInt(4);
  function X(se) {
    const le = h(se), { Fp: ce } = le, pe = le.toBytes || ((J, Z, K) => {
      const z = Z.toAffine();
      return S.concatBytes(Uint8Array.from([4]), ce.toBytes(z.x), ce.toBytes(z.y));
    }), me = le.fromBytes || ((J) => {
      const Z = J.subarray(1), K = ce.fromBytes(Z.subarray(0, ce.BYTES)), z = ce.fromBytes(Z.subarray(ce.BYTES, 2 * ce.BYTES));
      return { x: K, y: z };
    });
    function Me(J) {
      const { a: Z, b: K } = le, z = ce.sqr(J), G = ce.mul(z, J);
      return ce.add(ce.add(G, ce.mul(J, Z)), K);
    }
    if (!ce.eql(ce.sqr(le.Gy), Me(le.Gx)))
      throw new Error("bad generator point: equation left != right");
    function Ee(J) {
      return typeof J == "bigint" && P < J && J < le.n;
    }
    function Re(J) {
      if (!Ee(J))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function Ne(J) {
      const { allowedPrivateKeyLengths: Z, nByteLength: K, wrapPrivateKey: z, n: G } = le;
      if (Z && typeof J != "bigint") {
        if (S.isBytes(J) && (J = S.bytesToHex(J)), typeof J != "string" || !Z.includes(J.length))
          throw new Error("Invalid key");
        J = J.padStart(K * 2, "0");
      }
      let D;
      try {
        D = typeof J == "bigint" ? J : S.bytesToNumberBE((0, g.ensureBytes)("private key", J, K));
      } catch {
        throw new Error(`private key must be ${K} bytes, hex or bigint, not ${typeof J}`);
      }
      return z && (D = o.mod(D, G)), Re(D), D;
    }
    const ne = /* @__PURE__ */ new Map();
    function Y(J) {
      if (!(J instanceof M))
        throw new Error("ProjectivePoint expected");
    }
    class M {
      constructor(Z, K, z) {
        if (this.px = Z, this.py = K, this.pz = z, Z == null || !ce.isValid(Z))
          throw new Error("x required");
        if (K == null || !ce.isValid(K))
          throw new Error("y required");
        if (z == null || !ce.isValid(z))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(Z) {
        const { x: K, y: z } = Z || {};
        if (!Z || !ce.isValid(K) || !ce.isValid(z))
          throw new Error("invalid affine point");
        if (Z instanceof M)
          throw new Error("projective point not allowed");
        const G = (D) => ce.eql(D, ce.ZERO);
        return G(K) && G(z) ? M.ZERO : new M(K, z, ce.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(Z) {
        const K = ce.invertBatch(Z.map((z) => z.pz));
        return Z.map((z, G) => z.toAffine(K[G])).map(M.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(Z) {
        const K = M.fromAffine(me((0, g.ensureBytes)("pointHex", Z)));
        return K.assertValidity(), K;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(Z) {
        return M.BASE.multiply(Ne(Z));
      }
      // "Private method", don't use it directly
      _setWindowSize(Z) {
        this._WINDOW_SIZE = Z, ne.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (le.allowInfinityPoint && !ce.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: Z, y: K } = this.toAffine();
        if (!ce.isValid(Z) || !ce.isValid(K))
          throw new Error("bad point: x or y not FE");
        const z = ce.sqr(K), G = Me(Z);
        if (!ce.eql(z, G))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: Z } = this.toAffine();
        if (ce.isOdd)
          return !ce.isOdd(Z);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(Z) {
        Y(Z);
        const { px: K, py: z, pz: G } = this, { px: D, py: F, pz: ae } = Z, ge = ce.eql(ce.mul(K, ae), ce.mul(D, G)), xe = ce.eql(ce.mul(z, ae), ce.mul(F, G));
        return ge && xe;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new M(this.px, ce.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: Z, b: K } = le, z = ce.mul(K, H), { px: G, py: D, pz: F } = this;
        let ae = ce.ZERO, ge = ce.ZERO, xe = ce.ZERO, ye = ce.mul(G, G), oe = ce.mul(D, D), fe = ce.mul(F, F), $e = ce.mul(G, D);
        return $e = ce.add($e, $e), xe = ce.mul(G, F), xe = ce.add(xe, xe), ae = ce.mul(Z, xe), ge = ce.mul(z, fe), ge = ce.add(ae, ge), ae = ce.sub(oe, ge), ge = ce.add(oe, ge), ge = ce.mul(ae, ge), ae = ce.mul($e, ae), xe = ce.mul(z, xe), fe = ce.mul(Z, fe), $e = ce.sub(ye, fe), $e = ce.mul(Z, $e), $e = ce.add($e, xe), xe = ce.add(ye, ye), ye = ce.add(xe, ye), ye = ce.add(ye, fe), ye = ce.mul(ye, $e), ge = ce.add(ge, ye), fe = ce.mul(D, F), fe = ce.add(fe, fe), ye = ce.mul(fe, $e), ae = ce.sub(ae, ye), xe = ce.mul(fe, oe), xe = ce.add(xe, xe), xe = ce.add(xe, xe), new M(ae, ge, xe);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(Z) {
        Y(Z);
        const { px: K, py: z, pz: G } = this, { px: D, py: F, pz: ae } = Z;
        let ge = ce.ZERO, xe = ce.ZERO, ye = ce.ZERO;
        const oe = le.a, fe = ce.mul(le.b, H);
        let $e = ce.mul(K, D), Be = ce.mul(z, F), be = ce.mul(G, ae), ve = ce.add(K, z), qe = ce.add(D, F);
        ve = ce.mul(ve, qe), qe = ce.add($e, Be), ve = ce.sub(ve, qe), qe = ce.add(K, G);
        let De = ce.add(D, ae);
        return qe = ce.mul(qe, De), De = ce.add($e, be), qe = ce.sub(qe, De), De = ce.add(z, G), ge = ce.add(F, ae), De = ce.mul(De, ge), ge = ce.add(Be, be), De = ce.sub(De, ge), ye = ce.mul(oe, qe), ge = ce.mul(fe, be), ye = ce.add(ge, ye), ge = ce.sub(Be, ye), ye = ce.add(Be, ye), xe = ce.mul(ge, ye), Be = ce.add($e, $e), Be = ce.add(Be, $e), be = ce.mul(oe, be), qe = ce.mul(fe, qe), Be = ce.add(Be, be), be = ce.sub($e, be), be = ce.mul(oe, be), qe = ce.add(qe, be), $e = ce.mul(Be, qe), xe = ce.add(xe, $e), $e = ce.mul(De, qe), ge = ce.mul(ve, ge), ge = ce.sub(ge, $e), $e = ce.mul(ve, Be), ye = ce.mul(De, ye), ye = ce.add(ye, $e), new M(ge, xe, ye);
      }
      subtract(Z) {
        return this.add(Z.negate());
      }
      is0() {
        return this.equals(M.ZERO);
      }
      wNAF(Z) {
        return O.wNAFCached(this, ne, Z, (K) => {
          const z = ce.invertBatch(K.map((G) => G.pz));
          return K.map((G, D) => G.toAffine(z[D])).map(M.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(Z) {
        const K = M.ZERO;
        if (Z === P)
          return K;
        if (Re(Z), Z === I)
          return this;
        const { endo: z } = le;
        if (!z)
          return O.unsafeLadder(this, Z);
        let { k1neg: G, k1: D, k2neg: F, k2: ae } = z.splitScalar(Z), ge = K, xe = K, ye = this;
        for (; D > P || ae > P; )
          D & I && (ge = ge.add(ye)), ae & I && (xe = xe.add(ye)), ye = ye.double(), D >>= I, ae >>= I;
        return G && (ge = ge.negate()), F && (xe = xe.negate()), xe = new M(ce.mul(xe.px, z.beta), xe.py, xe.pz), ge.add(xe);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(Z) {
        Re(Z);
        let K = Z, z, G;
        const { endo: D } = le;
        if (D) {
          const { k1neg: F, k1: ae, k2neg: ge, k2: xe } = D.splitScalar(K);
          let { p: ye, f: oe } = this.wNAF(ae), { p: fe, f: $e } = this.wNAF(xe);
          ye = O.constTimeNegate(F, ye), fe = O.constTimeNegate(ge, fe), fe = new M(ce.mul(fe.px, D.beta), fe.py, fe.pz), z = ye.add(fe), G = oe.add($e);
        } else {
          const { p: F, f: ae } = this.wNAF(K);
          z = F, G = ae;
        }
        return M.normalizeZ([z, G])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Z, K, z) {
        const G = M.BASE, D = (ae, ge) => ge === P || ge === I || !ae.equals(G) ? ae.multiplyUnsafe(ge) : ae.multiply(ge), F = D(this, K).add(D(Z, z));
        return F.is0() ? void 0 : F;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(Z) {
        const { px: K, py: z, pz: G } = this, D = this.is0();
        Z == null && (Z = D ? ce.ONE : ce.inv(G));
        const F = ce.mul(K, Z), ae = ce.mul(z, Z), ge = ce.mul(G, Z);
        if (D)
          return { x: ce.ZERO, y: ce.ZERO };
        if (!ce.eql(ge, ce.ONE))
          throw new Error("invZ was invalid");
        return { x: F, y: ae };
      }
      isTorsionFree() {
        const { h: Z, isTorsionFree: K } = le;
        if (Z === I)
          return !0;
        if (K)
          return K(M, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: Z, clearCofactor: K } = le;
        return Z === I ? this : K ? K(M, this) : this.multiplyUnsafe(le.h);
      }
      toRawBytes(Z = !0) {
        return this.assertValidity(), pe(M, this, Z);
      }
      toHex(Z = !0) {
        return S.bytesToHex(this.toRawBytes(Z));
      }
    }
    M.BASE = new M(le.Gx, le.Gy, ce.ONE), M.ZERO = new M(ce.ZERO, ce.ONE, ce.ZERO);
    const $ = le.nBitLength, O = (0, U.wNAF)(M, le.endo ? Math.ceil($ / 2) : $);
    return {
      CURVE: le,
      ProjectivePoint: M,
      normPrivateKeyToScalar: Ne,
      weierstrassEquation: Me,
      isWithinCurveOrder: Ee
    };
  }
  e.weierstrassPoints = X;
  function Q(se) {
    const le = (0, U.validateBasic)(se);
    return S.validateObject(le, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...le });
  }
  function ee(se) {
    const le = Q(se), { Fp: ce, n: pe } = le, me = ce.BYTES + 1, Me = 2 * ce.BYTES + 1;
    function Ee(qe) {
      return P < qe && qe < ce.ORDER;
    }
    function Re(qe) {
      return o.mod(qe, pe);
    }
    function Ne(qe) {
      return o.invert(qe, pe);
    }
    const { ProjectivePoint: ne, normPrivateKeyToScalar: Y, weierstrassEquation: M, isWithinCurveOrder: $ } = X({
      ...le,
      toBytes(qe, De, Ye) {
        const he = De.toAffine(), ue = ce.toBytes(he.x), de = S.concatBytes;
        return Ye ? de(Uint8Array.from([De.hasEvenY() ? 2 : 3]), ue) : de(Uint8Array.from([4]), ue, ce.toBytes(he.y));
      },
      fromBytes(qe) {
        const De = qe.length, Ye = qe[0], he = qe.subarray(1);
        if (De === me && (Ye === 2 || Ye === 3)) {
          const ue = S.bytesToNumberBE(he);
          if (!Ee(ue))
            throw new Error("Point is not on curve");
          const de = M(ue);
          let _e = ce.sqrt(de);
          const Pe = (_e & I) === I;
          return (Ye & 1) === 1 !== Pe && (_e = ce.neg(_e)), { x: ue, y: _e };
        } else if (De === Me && Ye === 4) {
          const ue = ce.fromBytes(he.subarray(0, ce.BYTES)), de = ce.fromBytes(he.subarray(ce.BYTES, 2 * ce.BYTES));
          return { x: ue, y: de };
        } else
          throw new Error(`Point of length ${De} was invalid. Expected ${me} compressed bytes or ${Me} uncompressed bytes`);
      }
    }), O = (qe) => S.bytesToHex(S.numberToBytesBE(qe, le.nByteLength));
    function J(qe) {
      const De = pe >> I;
      return qe > De;
    }
    function Z(qe) {
      return J(qe) ? Re(-qe) : qe;
    }
    const K = (qe, De, Ye) => S.bytesToNumberBE(qe.slice(De, Ye));
    class z {
      constructor(De, Ye, he) {
        this.r = De, this.s = Ye, this.recovery = he, this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(De) {
        const Ye = le.nByteLength;
        return De = (0, g.ensureBytes)("compactSignature", De, Ye * 2), new z(K(De, 0, Ye), K(De, Ye, 2 * Ye));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(De) {
        const { r: Ye, s: he } = e.DER.toSig((0, g.ensureBytes)("DER", De));
        return new z(Ye, he);
      }
      assertValidity() {
        if (!$(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!$(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(De) {
        return new z(this.r, this.s, De);
      }
      recoverPublicKey(De) {
        const { r: Ye, s: he, recovery: ue } = this, de = xe((0, g.ensureBytes)("msgHash", De));
        if (ue == null || ![0, 1, 2, 3].includes(ue))
          throw new Error("recovery id invalid");
        const _e = ue === 2 || ue === 3 ? Ye + le.n : Ye;
        if (_e >= ce.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const Pe = ue & 1 ? "03" : "02", He = ne.fromHex(Pe + O(_e)), Ve = Ne(_e), nt = Re(-de * Ve), Ie = Re(he * Ve), Fe = ne.BASE.multiplyAndAddUnsafe(He, nt, Ie);
        if (!Fe)
          throw new Error("point at infinify");
        return Fe.assertValidity(), Fe;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return J(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new z(this.r, Re(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return S.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return e.DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return S.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return O(this.r) + O(this.s);
      }
    }
    const G = {
      isValidPrivateKey(qe) {
        try {
          return Y(qe), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: Y,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const qe = o.getMinHashLength(le.n);
        return o.mapHashToField(le.randomBytes(qe), le.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(qe = 8, De = ne.BASE) {
        return De._setWindowSize(qe), De.multiply(BigInt(3)), De;
      }
    };
    function D(qe, De = !0) {
      return ne.fromPrivateKey(qe).toRawBytes(De);
    }
    function F(qe) {
      const De = S.isBytes(qe), Ye = typeof qe == "string", he = (De || Ye) && qe.length;
      return De ? he === me || he === Me : Ye ? he === 2 * me || he === 2 * Me : qe instanceof ne;
    }
    function ae(qe, De, Ye = !0) {
      if (F(qe))
        throw new Error("first arg must be private key");
      if (!F(De))
        throw new Error("second arg must be public key");
      return ne.fromHex(De).multiply(Y(qe)).toRawBytes(Ye);
    }
    const ge = le.bits2int || function(qe) {
      const De = S.bytesToNumberBE(qe), Ye = qe.length * 8 - le.nBitLength;
      return Ye > 0 ? De >> BigInt(Ye) : De;
    }, xe = le.bits2int_modN || function(qe) {
      return Re(ge(qe));
    }, ye = S.bitMask(le.nBitLength);
    function oe(qe) {
      if (typeof qe != "bigint")
        throw new Error("bigint expected");
      if (!(P <= qe && qe < ye))
        throw new Error(`bigint expected < 2^${le.nBitLength}`);
      return S.numberToBytesBE(qe, le.nByteLength);
    }
    function fe(qe, De, Ye = $e) {
      if (["recovered", "canonical"].some((Ke) => Ke in Ye))
        throw new Error("sign() legacy options not supported");
      const { hash: he, randomBytes: ue } = le;
      let { lowS: de, prehash: _e, extraEntropy: Pe } = Ye;
      de == null && (de = !0), qe = (0, g.ensureBytes)("msgHash", qe), _e && (qe = (0, g.ensureBytes)("prehashed msgHash", he(qe)));
      const He = xe(qe), Ve = Y(De), nt = [oe(Ve), oe(He)];
      if (Pe != null) {
        const Ke = Pe === !0 ? ue(ce.BYTES) : Pe;
        nt.push((0, g.ensureBytes)("extraEntropy", Ke));
      }
      const Ie = S.concatBytes(...nt), Fe = He;
      function je(Ke) {
        const ot = ge(Ke);
        if (!$(ot))
          return;
        const ut = Ne(ot), pt = ne.BASE.multiply(ot).toAffine(), ke = Re(pt.x);
        if (ke === P)
          return;
        const Xe = Re(ut * Re(Fe + ke * Ve));
        if (Xe === P)
          return;
        let at = (pt.x === ke ? 0 : 2) | Number(pt.y & I), ht = Xe;
        return de && J(Xe) && (ht = Z(Xe), at ^= 1), new z(ke, ht, at);
      }
      return { seed: Ie, k2sig: je };
    }
    const $e = { lowS: le.lowS, prehash: !1 }, Be = { lowS: le.lowS, prehash: !1 };
    function be(qe, De, Ye = $e) {
      const { seed: he, k2sig: ue } = fe(qe, De, Ye), de = le;
      return S.createHmacDrbg(de.hash.outputLen, de.nByteLength, de.hmac)(he, ue);
    }
    ne.BASE._setWindowSize(8);
    function ve(qe, De, Ye, he = Be) {
      var pt;
      const ue = qe;
      if (De = (0, g.ensureBytes)("msgHash", De), Ye = (0, g.ensureBytes)("publicKey", Ye), "strict" in he)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: de, prehash: _e } = he;
      let Pe, He;
      try {
        if (typeof ue == "string" || S.isBytes(ue))
          try {
            Pe = z.fromDER(ue);
          } catch (ke) {
            if (!(ke instanceof e.DER.Err))
              throw ke;
            Pe = z.fromCompact(ue);
          }
        else if (typeof ue == "object" && typeof ue.r == "bigint" && typeof ue.s == "bigint") {
          const { r: ke, s: Xe } = ue;
          Pe = new z(ke, Xe);
        } else
          throw new Error("PARSE");
        He = ne.fromHex(Ye);
      } catch (ke) {
        if (ke.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (de && Pe.hasHighS())
        return !1;
      _e && (De = le.hash(De));
      const { r: Ve, s: nt } = Pe, Ie = xe(De), Fe = Ne(nt), je = Re(Ie * Fe), Ke = Re(Ve * Fe), ot = (pt = ne.BASE.multiplyAndAddUnsafe(He, je, Ke)) == null ? void 0 : pt.toAffine();
      return ot ? Re(ot.x) === Ve : !1;
    }
    return {
      CURVE: le,
      getPublicKey: D,
      getSharedSecret: ae,
      sign: be,
      verify: ve,
      ProjectivePoint: ne,
      Signature: z,
      utils: G
    };
  }
  e.weierstrass = ee;
  function ie(se, le) {
    const ce = se.ORDER;
    let pe = P;
    for (let J = ce - I; J % B === P; J /= B)
      pe += I;
    const me = pe, Me = B << me - I - I, Ee = Me * B, Re = (ce - I) / Ee, Ne = (Re - I) / B, ne = Ee - I, Y = Me, M = se.pow(le, Re), $ = se.pow(le, (Re + I) / B);
    let O = (J, Z) => {
      let K = M, z = se.pow(Z, ne), G = se.sqr(z);
      G = se.mul(G, Z);
      let D = se.mul(J, G);
      D = se.pow(D, Ne), D = se.mul(D, z), z = se.mul(D, Z), G = se.mul(D, J);
      let F = se.mul(G, z);
      D = se.pow(F, Y);
      let ae = se.eql(D, se.ONE);
      z = se.mul(G, $), D = se.mul(F, K), G = se.cmov(z, G, ae), F = se.cmov(D, F, ae);
      for (let ge = me; ge > I; ge--) {
        let xe = ge - B;
        xe = B << xe - I;
        let ye = se.pow(F, xe);
        const oe = se.eql(ye, se.ONE);
        z = se.mul(G, K), K = se.mul(K, K), ye = se.mul(F, K), G = se.cmov(z, G, oe), F = se.cmov(ye, F, oe);
      }
      return { isValid: ae, value: G };
    };
    if (se.ORDER % V === H) {
      const J = (se.ORDER - H) / V, Z = se.sqrt(se.neg(le));
      O = (K, z) => {
        let G = se.sqr(z);
        const D = se.mul(K, z);
        G = se.mul(G, D);
        let F = se.pow(G, J);
        F = se.mul(F, D);
        const ae = se.mul(F, Z), ge = se.mul(se.sqr(F), z), xe = se.eql(ge, K);
        let ye = se.cmov(ae, F, xe);
        return { isValid: xe, value: ye };
      };
    }
    return O;
  }
  e.SWUFpSqrtRatio = ie;
  function te(se, le) {
    if (o.validateField(se), !se.isValid(le.A) || !se.isValid(le.B) || !se.isValid(le.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const ce = ie(se, le.Z);
    if (!se.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (pe) => {
      let me, Me, Ee, Re, Ne, ne, Y, M;
      me = se.sqr(pe), me = se.mul(me, le.Z), Me = se.sqr(me), Me = se.add(Me, me), Ee = se.add(Me, se.ONE), Ee = se.mul(Ee, le.B), Re = se.cmov(le.Z, se.neg(Me), !se.eql(Me, se.ZERO)), Re = se.mul(Re, le.A), Me = se.sqr(Ee), ne = se.sqr(Re), Ne = se.mul(ne, le.A), Me = se.add(Me, Ne), Me = se.mul(Me, Ee), ne = se.mul(ne, Re), Ne = se.mul(ne, le.B), Me = se.add(Me, Ne), Y = se.mul(me, Ee);
      const { isValid: $, value: O } = ce(Me, ne);
      M = se.mul(me, pe), M = se.mul(M, O), Y = se.cmov(Y, Ee, $), M = se.cmov(M, O, $);
      const J = se.isOdd(pe) === se.isOdd(M);
      return M = se.cmov(se.neg(M), M, J), Y = se.div(Y, Re), { x: Y, y: M };
    };
  }
  e.mapToCurveSimpleSWU = te;
})(weierstrass);
var hashToCurve = {};
Object.defineProperty(hashToCurve, "__esModule", { value: !0 });
hashToCurve.createHasher = hashToCurve.isogenyMap = hashToCurve.hash_to_field = hashToCurve.expand_message_xof = hashToCurve.expand_message_xmd = void 0;
const modular_js_1 = modular, utils_js_1$2 = utils$6;
function validateDST(e) {
  if ((0, utils_js_1$2.isBytes)(e))
    return e;
  if (typeof e == "string")
    return (0, utils_js_1$2.utf8ToBytes)(e);
  throw new Error("DST must be Uint8Array or string");
}
const os2ip = utils_js_1$2.bytesToNumberBE;
function i2osp(e, o) {
  if (e < 0 || e >= 1 << 8 * o)
    throw new Error(`bad I2OSP call: value=${e} length=${o}`);
  const S = Array.from({ length: o }).fill(0);
  for (let g = o - 1; g >= 0; g--)
    S[g] = e & 255, e >>>= 8;
  return new Uint8Array(S);
}
function strxor(e, o) {
  const S = new Uint8Array(e.length);
  for (let g = 0; g < e.length; g++)
    S[g] = e[g] ^ o[g];
  return S;
}
function abytes(e) {
  if (!(0, utils_js_1$2.isBytes)(e))
    throw new Error("Uint8Array expected");
}
function isNum(e) {
  if (!Number.isSafeInteger(e))
    throw new Error("number expected");
}
function expand_message_xmd(e, o, S, g) {
  abytes(e), abytes(o), isNum(S), o.length > 255 && (o = g((0, utils_js_1$2.concatBytes)((0, utils_js_1$2.utf8ToBytes)("H2C-OVERSIZE-DST-"), o)));
  const { outputLen: U, blockLen: h } = g, q = Math.ceil(S / U);
  if (q > 255)
    throw new Error("Invalid xmd length");
  const A = (0, utils_js_1$2.concatBytes)(o, i2osp(o.length, 1)), P = i2osp(0, h), I = i2osp(S, 2), B = new Array(q), H = g((0, utils_js_1$2.concatBytes)(P, e, I, i2osp(0, 1), A));
  B[0] = g((0, utils_js_1$2.concatBytes)(H, i2osp(1, 1), A));
  for (let X = 1; X <= q; X++) {
    const Q = [strxor(H, B[X - 1]), i2osp(X + 1, 1), A];
    B[X] = g((0, utils_js_1$2.concatBytes)(...Q));
  }
  return (0, utils_js_1$2.concatBytes)(...B).slice(0, S);
}
hashToCurve.expand_message_xmd = expand_message_xmd;
function expand_message_xof(e, o, S, g, U) {
  if (abytes(e), abytes(o), isNum(S), o.length > 255) {
    const h = Math.ceil(2 * g / 8);
    o = U.create({ dkLen: h }).update((0, utils_js_1$2.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(o).digest();
  }
  if (S > 65535 || o.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return U.create({ dkLen: S }).update(e).update(i2osp(S, 2)).update(o).update(i2osp(o.length, 1)).digest();
}
hashToCurve.expand_message_xof = expand_message_xof;
function hash_to_field(e, o, S) {
  (0, utils_js_1$2.validateObject)(S, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: g, k: U, m: h, hash: q, expand: A, DST: P } = S;
  abytes(e), isNum(o);
  const I = validateDST(P), B = g.toString(2).length, H = Math.ceil((B + U) / 8), V = o * h * H;
  let X;
  if (A === "xmd")
    X = expand_message_xmd(e, I, V, q);
  else if (A === "xof")
    X = expand_message_xof(e, I, V, U, q);
  else if (A === "_internal_pass")
    X = e;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const Q = new Array(o);
  for (let ee = 0; ee < o; ee++) {
    const ie = new Array(h);
    for (let te = 0; te < h; te++) {
      const se = H * (te + ee * h), le = X.subarray(se, se + H);
      ie[te] = (0, modular_js_1.mod)(os2ip(le), g);
    }
    Q[ee] = ie;
  }
  return Q;
}
hashToCurve.hash_to_field = hash_to_field;
function isogenyMap(e, o) {
  const S = o.map((g) => Array.from(g).reverse());
  return (g, U) => {
    const [h, q, A, P] = S.map((I) => I.reduce((B, H) => e.add(e.mul(B, g), H)));
    return g = e.div(h, q), U = e.mul(U, e.div(A, P)), { x: g, y: U };
  };
}
hashToCurve.isogenyMap = isogenyMap;
function createHasher(e, o, S) {
  if (typeof o != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(g, U) {
      const h = hash_to_field(g, 2, { ...S, DST: S.DST, ...U }), q = e.fromAffine(o(h[0])), A = e.fromAffine(o(h[1])), P = q.add(A).clearCofactor();
      return P.assertValidity(), P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(g, U) {
      const h = hash_to_field(g, 1, { ...S, DST: S.encodeDST, ...U }), q = e.fromAffine(o(h[0])).clearCofactor();
      return q.assertValidity(), q;
    }
  };
}
hashToCurve.createHasher = createHasher;
var _shortw_utils = {}, hmac$1 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.hmac = e.HMAC = void 0;
  const o = _assert, S = utils$7;
  class g extends S.Hash {
    constructor(q, A) {
      super(), this.finished = !1, this.destroyed = !1, (0, o.hash)(q);
      const P = (0, S.toBytes)(A);
      if (this.iHash = q.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const I = this.blockLen, B = new Uint8Array(I);
      B.set(P.length > I ? q.create().update(P).digest() : P);
      for (let H = 0; H < B.length; H++)
        B[H] ^= 54;
      this.iHash.update(B), this.oHash = q.create();
      for (let H = 0; H < B.length; H++)
        B[H] ^= 106;
      this.oHash.update(B), B.fill(0);
    }
    update(q) {
      return (0, o.exists)(this), this.iHash.update(q), this;
    }
    digestInto(q) {
      (0, o.exists)(this), (0, o.bytes)(q, this.outputLen), this.finished = !0, this.iHash.digestInto(q), this.oHash.update(q), this.oHash.digestInto(q), this.destroy();
    }
    digest() {
      const q = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(q), q;
    }
    _cloneInto(q) {
      q || (q = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: A, iHash: P, finished: I, destroyed: B, blockLen: H, outputLen: V } = this;
      return q = q, q.finished = I, q.destroyed = B, q.blockLen = H, q.outputLen = V, q.oHash = A._cloneInto(q.oHash), q.iHash = P._cloneInto(q.iHash), q;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  e.HMAC = g;
  const U = (h, q, A) => new g(h, q).update(A).digest();
  e.hmac = U, e.hmac.create = (h, q) => new g(h, q);
})(hmac$1);
Object.defineProperty(_shortw_utils, "__esModule", { value: !0 });
_shortw_utils.createCurve = _shortw_utils.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = hmac$1, utils_1$3 = utils$7, weierstrass_js_1 = weierstrass;
function getHash(e) {
  return {
    hash: e,
    hmac: (o, ...S) => (0, hmac_1.hmac)(e, o, (0, utils_1$3.concatBytes)(...S)),
    randomBytes: utils_1$3.randomBytes
  };
}
_shortw_utils.getHash = getHash;
function createCurve(e, o) {
  const S = (g) => (0, weierstrass_js_1.weierstrass)({ ...e, ...getHash(g) });
  return Object.freeze({ ...S(o), create: S });
}
_shortw_utils.createCurve = createCurve;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const o = sha256$2, S = utils$7, g = modular, U = weierstrass, h = utils$6, q = hashToCurve, A = _shortw_utils, P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), I = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), B = BigInt(1), H = BigInt(2), V = (z, G) => (z + G / H) / G;
  function X(z) {
    const G = P, D = BigInt(3), F = BigInt(6), ae = BigInt(11), ge = BigInt(22), xe = BigInt(23), ye = BigInt(44), oe = BigInt(88), fe = z * z * z % G, $e = fe * fe * z % G, Be = (0, g.pow2)($e, D, G) * $e % G, be = (0, g.pow2)(Be, D, G) * $e % G, ve = (0, g.pow2)(be, H, G) * fe % G, qe = (0, g.pow2)(ve, ae, G) * ve % G, De = (0, g.pow2)(qe, ge, G) * qe % G, Ye = (0, g.pow2)(De, ye, G) * De % G, he = (0, g.pow2)(Ye, oe, G) * Ye % G, ue = (0, g.pow2)(he, ye, G) * De % G, de = (0, g.pow2)(ue, D, G) * $e % G, _e = (0, g.pow2)(de, xe, G) * qe % G, Pe = (0, g.pow2)(_e, F, G) * fe % G, He = (0, g.pow2)(Pe, H, G);
    if (!Q.eql(Q.sqr(He), z))
      throw new Error("Cannot find square root");
    return He;
  }
  const Q = (0, g.Field)(P, void 0, void 0, { sqrt: X });
  e.secp256k1 = (0, A.createCurve)({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp: Q,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: I,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (z) => {
        const G = I, D = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), F = -B * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ae = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ge = D, xe = BigInt("0x100000000000000000000000000000000"), ye = V(ge * z, G), oe = V(-F * z, G);
        let fe = (0, g.mod)(z - ye * D - oe * ae, G), $e = (0, g.mod)(-ye * F - oe * ge, G);
        const Be = fe > xe, be = $e > xe;
        if (Be && (fe = G - fe), be && ($e = G - $e), fe > xe || $e > xe)
          throw new Error("splitScalar: Endomorphism failed, k=" + z);
        return { k1neg: Be, k1: fe, k2neg: be, k2: $e };
      }
    }
  }, o.sha256);
  const ee = BigInt(0), ie = (z) => typeof z == "bigint" && ee < z && z < P, te = (z) => typeof z == "bigint" && ee < z && z < I, se = {};
  function le(z, ...G) {
    let D = se[z];
    if (D === void 0) {
      const F = (0, o.sha256)(Uint8Array.from(z, (ae) => ae.charCodeAt(0)));
      D = (0, h.concatBytes)(F, F), se[z] = D;
    }
    return (0, o.sha256)((0, h.concatBytes)(D, ...G));
  }
  const ce = (z) => z.toRawBytes(!0).slice(1), pe = (z) => (0, h.numberToBytesBE)(z, 32), me = (z) => (0, g.mod)(z, P), Me = (z) => (0, g.mod)(z, I), Ee = e.secp256k1.ProjectivePoint, Re = (z, G, D) => Ee.BASE.multiplyAndAddUnsafe(z, G, D);
  function Ne(z) {
    let G = e.secp256k1.utils.normPrivateKeyToScalar(z), D = Ee.fromPrivateKey(G);
    return { scalar: D.hasEvenY() ? G : Me(-G), bytes: ce(D) };
  }
  function ne(z) {
    if (!ie(z))
      throw new Error("bad x: need 0 < x < p");
    const G = me(z * z), D = me(G * z + BigInt(7));
    let F = X(D);
    F % H !== ee && (F = me(-F));
    const ae = new Ee(z, F, B);
    return ae.assertValidity(), ae;
  }
  function Y(...z) {
    return Me((0, h.bytesToNumberBE)(le("BIP0340/challenge", ...z)));
  }
  function M(z) {
    return Ne(z).bytes;
  }
  function $(z, G, D = (0, S.randomBytes)(32)) {
    const F = (0, h.ensureBytes)("message", z), { bytes: ae, scalar: ge } = Ne(G), xe = (0, h.ensureBytes)("auxRand", D, 32), ye = pe(ge ^ (0, h.bytesToNumberBE)(le("BIP0340/aux", xe))), oe = le("BIP0340/nonce", ye, ae, F), fe = Me((0, h.bytesToNumberBE)(oe));
    if (fe === ee)
      throw new Error("sign failed: k is zero");
    const { bytes: $e, scalar: Be } = Ne(fe), be = Y($e, ae, F), ve = new Uint8Array(64);
    if (ve.set($e, 0), ve.set(pe(Me(Be + be * ge)), 32), !O(ve, F, ae))
      throw new Error("sign: Invalid signature produced");
    return ve;
  }
  function O(z, G, D) {
    const F = (0, h.ensureBytes)("signature", z, 64), ae = (0, h.ensureBytes)("message", G), ge = (0, h.ensureBytes)("publicKey", D, 32);
    try {
      const xe = ne((0, h.bytesToNumberBE)(ge)), ye = (0, h.bytesToNumberBE)(F.subarray(0, 32));
      if (!ie(ye))
        return !1;
      const oe = (0, h.bytesToNumberBE)(F.subarray(32, 64));
      if (!te(oe))
        return !1;
      const fe = Y(pe(ye), ce(xe), ae), $e = Re(xe, oe, Me(-fe));
      return !(!$e || !$e.hasEvenY() || $e.toAffine().x !== ye);
    } catch {
      return !1;
    }
  }
  e.schnorr = {
    getPublicKey: M,
    sign: $,
    verify: O,
    utils: {
      randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
      lift_x: ne,
      pointToBytes: ce,
      numberToBytesBE: h.numberToBytesBE,
      bytesToNumberBE: h.bytesToNumberBE,
      taggedHash: le,
      mod: g.mod
    }
  };
  const J = (0, q.isogenyMap)(Q, [
    // xNum
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ],
    // yNum
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ]
  ].map((z) => z.map((G) => BigInt(G)))), Z = (0, U.mapToCurveSimpleSWU)(Q, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: Q.create(BigInt("-11"))
  }), K = (0, q.createHasher)(e.secp256k1.ProjectivePoint, (z) => {
    const { x: G, y: D } = Z(Q.create(z[0]));
    return J(G, D);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: Q.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: o.sha256
  });
  e.hashToCurve = K.hashToCurve, e.encodeToCurve = K.encodeToCurve;
})(secp256k1$1);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.secp256k1 = void 0;
  var o = secp256k1$1;
  Object.defineProperty(e, "secp256k1", { enumerable: !0, get: function() {
    return o.secp256k1;
  } });
})(secp256k1$2);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MAX_WITHDRAWALS_PER_PAYLOAD = e.RLP_EMPTY_STRING = e.KECCAK256_RLP = e.KECCAK256_RLP_S = e.KECCAK256_RLP_ARRAY = e.KECCAK256_RLP_ARRAY_S = e.KECCAK256_NULL = e.KECCAK256_NULL_S = e.TWO_POW256 = e.SECP256K1_ORDER_DIV_2 = e.SECP256K1_ORDER = e.MAX_INTEGER_BIGINT = e.MAX_INTEGER = e.MAX_UINT64 = void 0;
  const o = buffer$3, S = secp256k1$2;
  e.MAX_UINT64 = BigInt("0xffffffffffffffff"), e.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), e.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), e.SECP256K1_ORDER = S.secp256k1.CURVE.n, e.SECP256K1_ORDER_DIV_2 = S.secp256k1.CURVE.n / BigInt(2), e.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), e.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", e.KECCAK256_NULL = o.Buffer.from(e.KECCAK256_NULL_S, "hex"), e.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", e.KECCAK256_RLP_ARRAY = o.Buffer.from(e.KECCAK256_RLP_ARRAY_S, "hex"), e.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", e.KECCAK256_RLP = o.Buffer.from(e.KECCAK256_RLP_S, "hex"), e.RLP_EMPTY_STRING = o.Buffer.from([128]), e.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
})(constants$2);
var units = {};
Object.defineProperty(units, "__esModule", { value: !0 });
units.GWEI_TO_WEI = void 0;
units.GWEI_TO_WEI = BigInt(1e9);
var account = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.RLP = dist.utils = dist.decode = dist.encode = void 0;
function encode$1(e) {
  if (Array.isArray(e)) {
    const S = [];
    let g = 0;
    for (let U = 0; U < e.length; U++) {
      const h = encode$1(e[U]);
      S.push(h), g += h.length;
    }
    return concatBytes(encodeLength(g, 192), ...S);
  }
  const o = toBytes(e);
  return o.length === 1 && o[0] < 128 ? o : concatBytes(encodeLength(o.length, 128), o);
}
dist.encode = encode$1;
function safeSlice(e, o, S) {
  if (S > e.length)
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  return e.slice(o, S);
}
function decodeLength(e) {
  if (e[0] === 0)
    throw new Error("invalid RLP: extra zeros");
  return parseHexByte(bytesToHex(e));
}
function encodeLength(e, o) {
  if (e < 56)
    return Uint8Array.from([e + o]);
  const S = numberToHex(e), g = S.length / 2, U = numberToHex(o + 55 + g);
  return Uint8Array.from(hexToBytes(U + S));
}
function decode$1(e, o = !1) {
  if (typeof e > "u" || e === null || e.length === 0)
    return Uint8Array.from([]);
  const S = toBytes(e), g = _decode(S);
  if (o)
    return g;
  if (g.remainder.length !== 0)
    throw new Error("invalid RLP: remainder must be zero");
  return g.data;
}
dist.decode = decode$1;
function _decode(e) {
  let o, S, g, U, h;
  const q = [], A = e[0];
  if (A <= 127)
    return {
      data: e.slice(0, 1),
      remainder: e.slice(1)
    };
  if (A <= 183) {
    if (o = A - 127, A === 128 ? g = Uint8Array.from([]) : g = safeSlice(e, 1, o), o === 2 && g[0] < 128)
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    return {
      data: g,
      remainder: e.slice(o)
    };
  } else if (A <= 191) {
    if (S = A - 182, e.length - 1 < S)
      throw new Error("invalid RLP: not enough bytes for string length");
    if (o = decodeLength(safeSlice(e, 1, S)), o <= 55)
      throw new Error("invalid RLP: expected string length to be greater than 55");
    return g = safeSlice(e, S, o + S), {
      data: g,
      remainder: e.slice(o + S)
    };
  } else if (A <= 247) {
    for (o = A - 191, U = safeSlice(e, 1, o); U.length; )
      h = _decode(U), q.push(h.data), U = h.remainder;
    return {
      data: q,
      remainder: e.slice(o)
    };
  } else {
    if (S = A - 246, o = decodeLength(safeSlice(e, 1, S)), o < 56)
      throw new Error("invalid RLP: encoded list too short");
    const P = S + o;
    if (P > e.length)
      throw new Error("invalid RLP: total length is larger than the data");
    for (U = safeSlice(e, S, P); U.length; )
      h = _decode(U), q.push(h.data), U = h.remainder;
    return {
      data: q,
      remainder: e.slice(P)
    };
  }
}
const cachedHexes = Array.from({ length: 256 }, (e, o) => o.toString(16).padStart(2, "0"));
function bytesToHex(e) {
  let o = "";
  for (let S = 0; S < e.length; S++)
    o += cachedHexes[e[S]];
  return o;
}
function parseHexByte(e) {
  const o = Number.parseInt(e, 16);
  if (Number.isNaN(o))
    throw new Error("Invalid byte sequence");
  return o;
}
function hexToBytes(e) {
  if (typeof e != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof e);
  if (e.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const o = new Uint8Array(e.length / 2);
  for (let S = 0; S < o.length; S++) {
    const g = S * 2;
    o[S] = parseHexByte(e.slice(g, g + 2));
  }
  return o;
}
function concatBytes(...e) {
  if (e.length === 1)
    return e[0];
  const o = e.reduce((g, U) => g + U.length, 0), S = new Uint8Array(o);
  for (let g = 0, U = 0; g < e.length; g++) {
    const h = e[g];
    S.set(h, U), U += h.length;
  }
  return S;
}
function utf8ToBytes(e) {
  return new TextEncoder().encode(e);
}
function numberToHex(e) {
  if (e < 0)
    throw new Error("Invalid integer as argument, must be unsigned!");
  const o = e.toString(16);
  return o.length % 2 ? `0${o}` : o;
}
function padToEven$2(e) {
  return e.length % 2 ? `0${e}` : e;
}
function isHexPrefixed$3(e) {
  return e.length >= 2 && e[0] === "0" && e[1] === "x";
}
function stripHexPrefix$2(e) {
  return typeof e != "string" ? e : isHexPrefixed$3(e) ? e.slice(2) : e;
}
function toBytes(e) {
  if (e instanceof Uint8Array)
    return e;
  if (typeof e == "string")
    return isHexPrefixed$3(e) ? hexToBytes(padToEven$2(stripHexPrefix$2(e))) : utf8ToBytes(e);
  if (typeof e == "number" || typeof e == "bigint")
    return e ? hexToBytes(numberToHex(e)) : Uint8Array.from([]);
  if (e == null)
    return Uint8Array.from([]);
  throw new Error("toBytes: received unsupported type " + typeof e);
}
dist.utils = {
  bytesToHex,
  concatBytes,
  hexToBytes,
  utf8ToBytes
};
dist.RLP = { encode: encode$1, decode: decode$1 };
var keccak = {}, sha3 = {}, _u64 = {};
Object.defineProperty(_u64, "__esModule", { value: !0 });
_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.add = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = _u64.split = _u64.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(e, o = !1) {
  return o ? { h: Number(e & U32_MASK64), l: Number(e >> _32n & U32_MASK64) } : { h: Number(e >> _32n & U32_MASK64) | 0, l: Number(e & U32_MASK64) | 0 };
}
_u64.fromBig = fromBig;
function split(e, o = !1) {
  let S = new Uint32Array(e.length), g = new Uint32Array(e.length);
  for (let U = 0; U < e.length; U++) {
    const { h, l: q } = fromBig(e[U], o);
    [S[U], g[U]] = [h, q];
  }
  return [S, g];
}
_u64.split = split;
const toBig = (e, o) => BigInt(e >>> 0) << _32n | BigInt(o >>> 0);
_u64.toBig = toBig;
const shrSH = (e, o, S) => e >>> S;
_u64.shrSH = shrSH;
const shrSL = (e, o, S) => e << 32 - S | o >>> S;
_u64.shrSL = shrSL;
const rotrSH = (e, o, S) => e >>> S | o << 32 - S;
_u64.rotrSH = rotrSH;
const rotrSL = (e, o, S) => e << 32 - S | o >>> S;
_u64.rotrSL = rotrSL;
const rotrBH = (e, o, S) => e << 64 - S | o >>> S - 32;
_u64.rotrBH = rotrBH;
const rotrBL = (e, o, S) => e >>> S - 32 | o << 64 - S;
_u64.rotrBL = rotrBL;
const rotr32H = (e, o) => o;
_u64.rotr32H = rotr32H;
const rotr32L = (e, o) => e;
_u64.rotr32L = rotr32L;
const rotlSH = (e, o, S) => e << S | o >>> 32 - S;
_u64.rotlSH = rotlSH;
const rotlSL = (e, o, S) => o << S | e >>> 32 - S;
_u64.rotlSL = rotlSL;
const rotlBH = (e, o, S) => o << S - 32 | e >>> 64 - S;
_u64.rotlBH = rotlBH;
const rotlBL = (e, o, S) => e << S - 32 | o >>> 64 - S;
_u64.rotlBL = rotlBL;
function add(e, o, S, g) {
  const U = (o >>> 0) + (g >>> 0);
  return { h: e + S + (U / 2 ** 32 | 0) | 0, l: U | 0 };
}
_u64.add = add;
const add3L = (e, o, S) => (e >>> 0) + (o >>> 0) + (S >>> 0);
_u64.add3L = add3L;
const add3H = (e, o, S, g) => o + S + g + (e / 2 ** 32 | 0) | 0;
_u64.add3H = add3H;
const add4L = (e, o, S, g) => (e >>> 0) + (o >>> 0) + (S >>> 0) + (g >>> 0);
_u64.add4L = add4L;
const add4H = (e, o, S, g, U) => o + S + g + U + (e / 2 ** 32 | 0) | 0;
_u64.add4H = add4H;
const add5L = (e, o, S, g, U) => (e >>> 0) + (o >>> 0) + (S >>> 0) + (g >>> 0) + (U >>> 0);
_u64.add5L = add5L;
const add5H = (e, o, S, g, U, h) => o + S + g + U + h + (e / 2 ** 32 | 0) | 0;
_u64.add5H = add5H;
const u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
_u64.default = u64;
Object.defineProperty(sha3, "__esModule", { value: !0 });
sha3.shake256 = sha3.shake128 = sha3.keccak_512 = sha3.keccak_384 = sha3.keccak_256 = sha3.keccak_224 = sha3.sha3_512 = sha3.sha3_384 = sha3.sha3_256 = sha3.sha3_224 = sha3.Keccak = sha3.keccakP = void 0;
const _assert_js_1 = _assert, _u64_js_1 = _u64, utils_js_1$1 = utils$7, [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _7n = /* @__PURE__ */ BigInt(7), _256n = /* @__PURE__ */ BigInt(256), _0x71n = /* @__PURE__ */ BigInt(113);
for (let e = 0, o = _1n, S = 1, g = 0; e < 24; e++) {
  [S, g] = [g, (2 * S + 3 * g) % 5], SHA3_PI.push(2 * (5 * g + S)), SHA3_ROTL.push((e + 1) * (e + 2) / 2 % 64);
  let U = _0n;
  for (let h = 0; h < 7; h++)
    o = (o << _1n ^ (o >> _7n) * _0x71n) % _256n, o & _2n && (U ^= _1n << (_1n << /* @__PURE__ */ BigInt(h)) - _1n);
  _SHA3_IOTA.push(U);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, !0), rotlH = (e, o, S) => S > 32 ? (0, _u64_js_1.rotlBH)(e, o, S) : (0, _u64_js_1.rotlSH)(e, o, S), rotlL = (e, o, S) => S > 32 ? (0, _u64_js_1.rotlBL)(e, o, S) : (0, _u64_js_1.rotlSL)(e, o, S);
function keccakP(e, o = 24) {
  const S = new Uint32Array(10);
  for (let g = 24 - o; g < 24; g++) {
    for (let q = 0; q < 10; q++)
      S[q] = e[q] ^ e[q + 10] ^ e[q + 20] ^ e[q + 30] ^ e[q + 40];
    for (let q = 0; q < 10; q += 2) {
      const A = (q + 8) % 10, P = (q + 2) % 10, I = S[P], B = S[P + 1], H = rotlH(I, B, 1) ^ S[A], V = rotlL(I, B, 1) ^ S[A + 1];
      for (let X = 0; X < 50; X += 10)
        e[q + X] ^= H, e[q + X + 1] ^= V;
    }
    let U = e[2], h = e[3];
    for (let q = 0; q < 24; q++) {
      const A = SHA3_ROTL[q], P = rotlH(U, h, A), I = rotlL(U, h, A), B = SHA3_PI[q];
      U = e[B], h = e[B + 1], e[B] = P, e[B + 1] = I;
    }
    for (let q = 0; q < 50; q += 10) {
      for (let A = 0; A < 10; A++)
        S[A] = e[q + A];
      for (let A = 0; A < 10; A++)
        e[q + A] ^= ~S[(A + 2) % 10] & S[(A + 4) % 10];
    }
    e[0] ^= SHA3_IOTA_H[g], e[1] ^= SHA3_IOTA_L[g];
  }
  S.fill(0);
}
sha3.keccakP = keccakP;
class Keccak extends utils_js_1$1.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(o, S, g, U = !1, h = 24) {
    if (super(), this.blockLen = o, this.suffix = S, this.outputLen = g, this.enableXOF = U, this.rounds = h, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, _assert_js_1.number)(g), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = (0, utils_js_1$1.u32)(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(o) {
    (0, _assert_js_1.exists)(this);
    const { blockLen: S, state: g } = this;
    o = (0, utils_js_1$1.toBytes)(o);
    const U = o.length;
    for (let h = 0; h < U; ) {
      const q = Math.min(S - this.pos, U - h);
      for (let A = 0; A < q; A++)
        g[this.pos++] ^= o[h++];
      this.pos === S && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: o, suffix: S, pos: g, blockLen: U } = this;
    o[g] ^= S, S & 128 && g === U - 1 && this.keccak(), o[U - 1] ^= 128, this.keccak();
  }
  writeInto(o) {
    (0, _assert_js_1.exists)(this, !1), (0, _assert_js_1.bytes)(o), this.finish();
    const S = this.state, { blockLen: g } = this;
    for (let U = 0, h = o.length; U < h; ) {
      this.posOut >= g && this.keccak();
      const q = Math.min(g - this.posOut, h - U);
      o.set(S.subarray(this.posOut, this.posOut + q), U), this.posOut += q, U += q;
    }
    return o;
  }
  xofInto(o) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(o);
  }
  xof(o) {
    return (0, _assert_js_1.number)(o), this.xofInto(new Uint8Array(o));
  }
  digestInto(o) {
    if ((0, _assert_js_1.output)(o, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(o), this.destroy(), o;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(o) {
    const { blockLen: S, suffix: g, outputLen: U, rounds: h, enableXOF: q } = this;
    return o || (o = new Keccak(S, g, U, q, h)), o.state32.set(this.state32), o.pos = this.pos, o.posOut = this.posOut, o.finished = this.finished, o.rounds = h, o.suffix = g, o.outputLen = U, o.enableXOF = q, o.destroyed = this.destroyed, o;
  }
}
sha3.Keccak = Keccak;
const gen = (e, o, S) => (0, utils_js_1$1.wrapConstructor)(() => new Keccak(o, e, S));
sha3.sha3_224 = gen(6, 144, 224 / 8);
sha3.sha3_256 = gen(6, 136, 256 / 8);
sha3.sha3_384 = gen(6, 104, 384 / 8);
sha3.sha3_512 = gen(6, 72, 512 / 8);
sha3.keccak_224 = gen(1, 144, 224 / 8);
sha3.keccak_256 = gen(1, 136, 256 / 8);
sha3.keccak_384 = gen(1, 104, 384 / 8);
sha3.keccak_512 = gen(1, 72, 512 / 8);
const genShake = (e, o, S) => (0, utils_js_1$1.wrapXOFConstructorWithOpts)((g = {}) => new Keccak(o, e, g.dkLen === void 0 ? S : g.dkLen, !0));
sha3.shake128 = genShake(31, 168, 128 / 8);
sha3.shake256 = genShake(31, 136, 256 / 8);
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var utils$5 = { exports: {} };
utils$5.exports;
(function(e, o) {
  var S = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(V) {
    return V && V.__esModule ? V : { default: V };
  };
  Object.defineProperty(o, "__esModule", { value: !0 }), o.crypto = o.wrapHash = o.equalsBytes = o.hexToBytes = o.bytesToUtf8 = o.utf8ToBytes = o.createView = o.concatBytes = o.toHex = o.bytesToHex = o.assertBytes = o.assertBool = void 0;
  const g = S(_assert), U = utils$7, h = g.default.bool;
  o.assertBool = h;
  const q = g.default.bytes;
  o.assertBytes = q;
  var A = utils$7;
  Object.defineProperty(o, "bytesToHex", { enumerable: !0, get: function() {
    return A.bytesToHex;
  } }), Object.defineProperty(o, "toHex", { enumerable: !0, get: function() {
    return A.bytesToHex;
  } }), Object.defineProperty(o, "concatBytes", { enumerable: !0, get: function() {
    return A.concatBytes;
  } }), Object.defineProperty(o, "createView", { enumerable: !0, get: function() {
    return A.createView;
  } }), Object.defineProperty(o, "utf8ToBytes", { enumerable: !0, get: function() {
    return A.utf8ToBytes;
  } });
  function P(V) {
    if (!(V instanceof Uint8Array))
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof V}`);
    return new TextDecoder().decode(V);
  }
  o.bytesToUtf8 = P;
  function I(V) {
    const X = V.startsWith("0x") ? V.substring(2) : V;
    return (0, U.hexToBytes)(X);
  }
  o.hexToBytes = I;
  function B(V, X) {
    if (V.length !== X.length)
      return !1;
    for (let Q = 0; Q < V.length; Q++)
      if (V[Q] !== X[Q])
        return !1;
    return !0;
  }
  o.equalsBytes = B;
  function H(V) {
    return (X) => (g.default.bytes(X), V(X));
  }
  o.wrapHash = H, o.crypto = (() => {
    const V = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, X = typeof commonjsRequire == "function" && commonjsRequire.bind(e);
    return {
      node: X && !V ? X("crypto") : void 0,
      web: V
    };
  })();
})(utils$5, utils$5.exports);
var utilsExports = utils$5.exports;
Object.defineProperty(keccak, "__esModule", { value: !0 });
keccak.keccak512 = keccak.keccak384 = keccak.keccak256 = keccak.keccak224 = void 0;
const sha3_1 = sha3, utils_js_1 = utilsExports;
keccak.keccak224 = (0, utils_js_1.wrapHash)(sha3_1.keccak_224);
keccak.keccak256 = (() => {
  const e = (0, utils_js_1.wrapHash)(sha3_1.keccak_256);
  return e.create = sha3_1.keccak_256.create, e;
})();
keccak.keccak384 = (0, utils_js_1.wrapHash)(sha3_1.keccak_384);
keccak.keccak512 = (0, utils_js_1.wrapHash)(sha3_1.keccak_512);
var bytes = {}, helpers = {}, internal = {};
Object.defineProperty(internal, "__esModule", { value: !0 });
internal.isHexString = internal.getKeys = internal.fromAscii = internal.fromUtf8 = internal.toAscii = internal.arrayContainsArray = internal.getBinarySize = internal.padToEven = internal.stripHexPrefix = internal.isHexPrefixed = void 0;
function isHexPrefixed$2(e) {
  if (typeof e != "string")
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof e}`);
  return e[0] === "0" && e[1] === "x";
}
internal.isHexPrefixed = isHexPrefixed$2;
const stripHexPrefix$1 = (e) => {
  if (typeof e != "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof e}`);
  return isHexPrefixed$2(e) ? e.slice(2) : e;
};
internal.stripHexPrefix = stripHexPrefix$1;
function padToEven$1(e) {
  let o = e;
  if (typeof o != "string")
    throw new Error(`[padToEven] value must be type 'string', received ${typeof o}`);
  return o.length % 2 && (o = `0${o}`), o;
}
internal.padToEven = padToEven$1;
function getBinarySize$1(e) {
  if (typeof e != "string")
    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof e}`);
  return buffer$3.Buffer.byteLength(e, "utf8");
}
internal.getBinarySize = getBinarySize$1;
function arrayContainsArray$1(e, o, S) {
  if (Array.isArray(e) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof e}'`);
  if (Array.isArray(o) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof o}'`);
  return o[S === !0 ? "some" : "every"]((g) => e.indexOf(g) >= 0);
}
internal.arrayContainsArray = arrayContainsArray$1;
function toAscii$1(e) {
  let o = "", S = 0;
  const g = e.length;
  for (e.substring(0, 2) === "0x" && (S = 2); S < g; S += 2) {
    const U = parseInt(e.substr(S, 2), 16);
    o += String.fromCharCode(U);
  }
  return o;
}
internal.toAscii = toAscii$1;
function fromUtf8$1(e) {
  const o = buffer$3.Buffer.from(e, "utf8");
  return `0x${padToEven$1(o.toString("hex")).replace(/^0+|0+$/g, "")}`;
}
internal.fromUtf8 = fromUtf8$1;
function fromAscii$1(e) {
  let o = "";
  for (let S = 0; S < e.length; S++) {
    const U = e.charCodeAt(S).toString(16);
    o += U.length < 2 ? `0${U}` : U;
  }
  return `0x${o}`;
}
internal.fromAscii = fromAscii$1;
function getKeys$1(e, o, S) {
  if (!Array.isArray(e))
    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof e}`);
  if (typeof o != "string")
    throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof e}`);
  const g = [];
  for (let U = 0; U < e.length; U++) {
    let h = e[U][o];
    if (S === !0 && !h)
      h = "";
    else if (typeof h != "string")
      throw new Error(`invalid abi - expected type 'string', received ${typeof h}`);
    g.push(h);
  }
  return g;
}
internal.getKeys = getKeys$1;
function isHexString$1(e, o) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || typeof o < "u" && o > 0 && e.length !== 2 + 2 * o);
}
internal.isHexString = isHexString$1;
Object.defineProperty(helpers, "__esModule", { value: !0 });
helpers.assertIsString = helpers.assertIsArray = helpers.assertIsBuffer = helpers.assertIsHexString = void 0;
const internal_1 = internal, assertIsHexString = function(e) {
  if (!(0, internal_1.isHexString)(e)) {
    const o = `This method only supports 0x-prefixed hex strings but input was: ${e}`;
    throw new Error(o);
  }
};
helpers.assertIsHexString = assertIsHexString;
const assertIsBuffer = function(e) {
  if (!buffer$3.Buffer.isBuffer(e)) {
    const o = `This method only supports Buffer but input was: ${e}`;
    throw new Error(o);
  }
};
helpers.assertIsBuffer = assertIsBuffer;
const assertIsArray = function(e) {
  if (!Array.isArray(e)) {
    const o = `This method only supports number arrays but input was: ${e}`;
    throw new Error(o);
  }
};
helpers.assertIsArray = assertIsArray;
const assertIsString = function(e) {
  if (typeof e != "string") {
    const o = `This method only supports strings but input was: ${e}`;
    throw new Error(o);
  }
};
helpers.assertIsString = assertIsString;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.intToUnpaddedBuffer = e.bigIntToUnpaddedBuffer = e.bigIntToHex = e.bufArrToArr = e.arrToBufArr = e.validateNoLeadingZeroes = e.baToJSON = e.toUtf8 = e.short = e.addHexPrefix = e.toUnsigned = e.fromSigned = e.bufferToInt = e.bigIntToBuffer = e.bufferToBigInt = e.bufferToHex = e.toBuffer = e.unpadHexString = e.unpadArray = e.unpadBuffer = e.setLengthRight = e.setLengthLeft = e.zeros = e.intToBuffer = e.intToHex = void 0;
  const o = helpers, S = internal, g = function($) {
    if (!Number.isSafeInteger($) || $ < 0)
      throw new Error(`Received an invalid integer type: ${$}`);
    return `0x${$.toString(16)}`;
  };
  e.intToHex = g;
  const U = function($) {
    const O = (0, e.intToHex)($);
    return buffer$3.Buffer.from((0, S.padToEven)(O.slice(2)), "hex");
  };
  e.intToBuffer = U;
  const h = function($) {
    return buffer$3.Buffer.allocUnsafe($).fill(0);
  };
  e.zeros = h;
  const q = function($, O, J) {
    const Z = (0, e.zeros)(O);
    return J ? $.length < O ? ($.copy(Z), Z) : $.slice(0, O) : $.length < O ? ($.copy(Z, O - $.length), Z) : $.slice(-O);
  }, A = function($, O) {
    return (0, o.assertIsBuffer)($), q($, O, !1);
  };
  e.setLengthLeft = A;
  const P = function($, O) {
    return (0, o.assertIsBuffer)($), q($, O, !0);
  };
  e.setLengthRight = P;
  const I = function($) {
    let O = $[0];
    for (; $.length > 0 && O.toString() === "0"; )
      $ = $.slice(1), O = $[0];
    return $;
  }, B = function($) {
    return (0, o.assertIsBuffer)($), I($);
  };
  e.unpadBuffer = B;
  const H = function($) {
    return (0, o.assertIsArray)($), I($);
  };
  e.unpadArray = H;
  const V = function($) {
    return (0, o.assertIsHexString)($), $ = (0, S.stripHexPrefix)($), "0x" + I($);
  };
  e.unpadHexString = V;
  const X = function($) {
    if ($ == null)
      return buffer$3.Buffer.allocUnsafe(0);
    if (buffer$3.Buffer.isBuffer($) || Array.isArray($) || $ instanceof Uint8Array)
      return buffer$3.Buffer.from($);
    if (typeof $ == "string") {
      if (!(0, S.isHexString)($))
        throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${$}`);
      return buffer$3.Buffer.from((0, S.padToEven)((0, S.stripHexPrefix)($)), "hex");
    }
    if (typeof $ == "number")
      return (0, e.intToBuffer)($);
    if (typeof $ == "bigint") {
      if ($ < BigInt(0))
        throw new Error(`Cannot convert negative bigint to buffer. Given: ${$}`);
      let O = $.toString(16);
      return O.length % 2 && (O = "0" + O), buffer$3.Buffer.from(O, "hex");
    }
    if ($.toArray)
      return buffer$3.Buffer.from($.toArray());
    if ($.toBuffer)
      return buffer$3.Buffer.from($.toBuffer());
    throw new Error("invalid type");
  };
  e.toBuffer = X;
  const Q = function($) {
    return $ = (0, e.toBuffer)($), "0x" + $.toString("hex");
  };
  e.bufferToHex = Q;
  function ee($) {
    const O = (0, e.bufferToHex)($);
    return BigInt(O === "0x" ? 0 : O);
  }
  e.bufferToBigInt = ee;
  function ie($) {
    return (0, e.toBuffer)("0x" + $.toString(16));
  }
  e.bigIntToBuffer = ie;
  const te = function($) {
    const O = Number(ee($));
    if (!Number.isSafeInteger(O))
      throw new Error("Number exceeds 53 bits");
    return O;
  };
  e.bufferToInt = te;
  const se = function($) {
    return BigInt.asIntN(256, ee($));
  };
  e.fromSigned = se;
  const le = function($) {
    return ie(BigInt.asUintN(256, $));
  };
  e.toUnsigned = le;
  const ce = function($) {
    return typeof $ != "string" || (0, S.isHexPrefixed)($) ? $ : "0x" + $;
  };
  e.addHexPrefix = ce;
  function pe($, O = 50) {
    const J = buffer$3.Buffer.isBuffer($) ? $.toString("hex") : $;
    return J.length <= O ? J : J.slice(0, O) + "";
  }
  e.short = pe;
  const me = function($) {
    const O = /^(00)+|(00)+$/g;
    if ($ = (0, S.stripHexPrefix)($), $.length % 2 !== 0)
      throw new Error("Invalid non-even hex string input for toUtf8() provided");
    return buffer$3.Buffer.from($.replace(O, ""), "hex").toString("utf8");
  };
  e.toUtf8 = me;
  const Me = function($) {
    if (buffer$3.Buffer.isBuffer($))
      return `0x${$.toString("hex")}`;
    if ($ instanceof Array) {
      const O = [];
      for (let J = 0; J < $.length; J++)
        O.push((0, e.baToJSON)($[J]));
      return O;
    }
  };
  e.baToJSON = Me;
  const Ee = function($) {
    for (const [O, J] of Object.entries($))
      if (J !== void 0 && J.length > 0 && J[0] === 0)
        throw new Error(`${O} cannot have leading zeroes, received: ${J.toString("hex")}`);
  };
  e.validateNoLeadingZeroes = Ee;
  function Re($) {
    return Array.isArray($) ? $.map((O) => Re(O)) : buffer$3.Buffer.from($);
  }
  e.arrToBufArr = Re;
  function Ne($) {
    return Array.isArray($) ? $.map((O) => Ne(O)) : Uint8Array.from($ ?? []);
  }
  e.bufArrToArr = Ne;
  const ne = ($) => "0x" + $.toString(16);
  e.bigIntToHex = ne;
  function Y($) {
    return (0, e.unpadBuffer)(ie($));
  }
  e.bigIntToUnpaddedBuffer = Y;
  function M($) {
    return (0, e.unpadBuffer)((0, e.intToBuffer)($));
  }
  e.intToUnpaddedBuffer = M;
})(bytes);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.accountBodyToRLP = e.accountBodyToSlim = e.accountBodyFromSlim = e.isZeroAddress = e.zeroAddress = e.importPublic = e.privateToAddress = e.privateToPublic = e.publicToAddress = e.pubToAddress = e.isValidPublic = e.isValidPrivate = e.generateAddress2 = e.generateAddress = e.isValidChecksumAddress = e.toChecksumAddress = e.isValidAddress = e.Account = void 0;
  const o = dist, S = keccak, g = secp256k1$2, U = utilsExports, h = bytes, q = constants$2, A = helpers, P = internal, I = BigInt(0);
  class B {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    constructor(M = I, $ = I, O = q.KECCAK256_RLP, J = q.KECCAK256_NULL) {
      this.nonce = M, this.balance = $, this.storageRoot = O, this.codeHash = J, this._validate();
    }
    static fromAccountData(M) {
      const { nonce: $, balance: O, storageRoot: J, codeHash: Z } = M;
      return new B($ !== void 0 ? (0, h.bufferToBigInt)((0, h.toBuffer)($)) : void 0, O !== void 0 ? (0, h.bufferToBigInt)((0, h.toBuffer)(O)) : void 0, J !== void 0 ? (0, h.toBuffer)(J) : void 0, Z !== void 0 ? (0, h.toBuffer)(Z) : void 0);
    }
    static fromRlpSerializedAccount(M) {
      const $ = (0, h.arrToBufArr)(o.RLP.decode(Uint8Array.from(M)));
      if (!Array.isArray($))
        throw new Error("Invalid serialized account input. Must be array");
      return this.fromValuesArray($);
    }
    static fromValuesArray(M) {
      const [$, O, J, Z] = M;
      return new B((0, h.bufferToBigInt)($), (0, h.bufferToBigInt)(O), J, Z);
    }
    _validate() {
      if (this.nonce < I)
        throw new Error("nonce must be greater than zero");
      if (this.balance < I)
        throw new Error("balance must be greater than zero");
      if (this.storageRoot.length !== 32)
        throw new Error("storageRoot must have a length of 32");
      if (this.codeHash.length !== 32)
        throw new Error("codeHash must have a length of 32");
    }
    /**
     * Returns a Buffer Array of the raw Buffers for the account, in order.
     */
    raw() {
      return [
        (0, h.bigIntToUnpaddedBuffer)(this.nonce),
        (0, h.bigIntToUnpaddedBuffer)(this.balance),
        this.storageRoot,
        this.codeHash
      ];
    }
    /**
     * Returns the RLP serialization of the account as a `Buffer`.
     */
    serialize() {
      return buffer$3.Buffer.from(o.RLP.encode((0, h.bufArrToArr)(this.raw())));
    }
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    isContract() {
      return !this.codeHash.equals(q.KECCAK256_NULL);
    }
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    isEmpty() {
      return this.balance === I && this.nonce === I && this.codeHash.equals(q.KECCAK256_NULL);
    }
  }
  e.Account = B;
  const H = function(Y) {
    try {
      (0, A.assertIsString)(Y);
    } catch {
      return !1;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(Y);
  };
  e.isValidAddress = H;
  const V = function(Y, M) {
    (0, A.assertIsHexString)(Y);
    const $ = (0, P.stripHexPrefix)(Y).toLowerCase();
    let O = "";
    M !== void 0 && (O = (0, h.bufferToBigInt)((0, h.toBuffer)(M)).toString() + "0x");
    const J = buffer$3.Buffer.from(O + $, "utf8"), Z = (0, U.bytesToHex)((0, S.keccak256)(J));
    let K = "0x";
    for (let z = 0; z < $.length; z++)
      parseInt(Z[z], 16) >= 8 ? K += $[z].toUpperCase() : K += $[z];
    return K;
  };
  e.toChecksumAddress = V;
  const X = function(Y, M) {
    return (0, e.isValidAddress)(Y) && (0, e.toChecksumAddress)(Y, M) === Y;
  };
  e.isValidChecksumAddress = X;
  const Q = function(Y, M) {
    return (0, A.assertIsBuffer)(Y), (0, A.assertIsBuffer)(M), (0, h.bufferToBigInt)(M) === BigInt(0) ? buffer$3.Buffer.from((0, S.keccak256)(o.RLP.encode((0, h.bufArrToArr)([Y, null])))).slice(-20) : buffer$3.Buffer.from((0, S.keccak256)(o.RLP.encode((0, h.bufArrToArr)([Y, M])))).slice(-20);
  };
  e.generateAddress = Q;
  const ee = function(Y, M, $) {
    if ((0, A.assertIsBuffer)(Y), (0, A.assertIsBuffer)(M), (0, A.assertIsBuffer)($), Y.length !== 20)
      throw new Error("Expected from to be of length 20");
    if (M.length !== 32)
      throw new Error("Expected salt to be of length 32");
    const O = (0, S.keccak256)(buffer$3.Buffer.concat([buffer$3.Buffer.from("ff", "hex"), Y, M, (0, S.keccak256)($)]));
    return (0, h.toBuffer)(O).slice(-20);
  };
  e.generateAddress2 = ee;
  const ie = function(Y) {
    return g.secp256k1.utils.isValidPrivateKey(Y);
  };
  e.isValidPrivate = ie;
  const te = function(Y, M = !1) {
    if ((0, A.assertIsBuffer)(Y), Y.length === 64)
      try {
        return g.secp256k1.ProjectivePoint.fromHex(buffer$3.Buffer.concat([buffer$3.Buffer.from([4]), Y])), !0;
      } catch {
        return !1;
      }
    if (!M)
      return !1;
    try {
      return g.secp256k1.ProjectivePoint.fromHex(Y), !0;
    } catch {
      return !1;
    }
  };
  e.isValidPublic = te;
  const se = function(Y, M = !1) {
    if ((0, A.assertIsBuffer)(Y), M && Y.length !== 64 && (Y = buffer$3.Buffer.from(g.secp256k1.ProjectivePoint.fromHex(Y).toRawBytes(!1).slice(1))), Y.length !== 64)
      throw new Error("Expected pubKey to be of length 64");
    return buffer$3.Buffer.from((0, S.keccak256)(Y)).slice(-20);
  };
  e.pubToAddress = se, e.publicToAddress = e.pubToAddress;
  const le = function(Y) {
    return (0, A.assertIsBuffer)(Y), buffer$3.Buffer.from(g.secp256k1.ProjectivePoint.fromPrivateKey(Y).toRawBytes(!1).slice(1));
  };
  e.privateToPublic = le;
  const ce = function(Y) {
    return (0, e.publicToAddress)((0, e.privateToPublic)(Y));
  };
  e.privateToAddress = ce;
  const pe = function(Y) {
    return (0, A.assertIsBuffer)(Y), Y.length !== 64 && (Y = buffer$3.Buffer.from(g.secp256k1.ProjectivePoint.fromHex(Y).toRawBytes(!1).slice(1))), Y;
  };
  e.importPublic = pe;
  const me = function() {
    const M = (0, h.zeros)(20);
    return (0, h.bufferToHex)(M);
  };
  e.zeroAddress = me;
  const Me = function(Y) {
    try {
      (0, A.assertIsString)(Y);
    } catch {
      return !1;
    }
    return (0, e.zeroAddress)() === Y;
  };
  e.isZeroAddress = Me;
  function Ee(Y) {
    const [M, $, O, J] = Y;
    return [
      M,
      $,
      (0, h.arrToBufArr)(O).length === 0 ? q.KECCAK256_RLP : O,
      (0, h.arrToBufArr)(J).length === 0 ? q.KECCAK256_NULL : J
    ];
  }
  e.accountBodyFromSlim = Ee;
  const Re = new Uint8Array(0);
  function Ne(Y) {
    const [M, $, O, J] = Y;
    return [
      M,
      $,
      (0, h.arrToBufArr)(O).equals(q.KECCAK256_RLP) ? Re : O,
      (0, h.arrToBufArr)(J).equals(q.KECCAK256_NULL) ? Re : J
    ];
  }
  e.accountBodyToSlim = Ne;
  function ne(Y, M = !0) {
    const $ = M ? Ee(Y) : Y;
    return (0, h.arrToBufArr)(o.RLP.encode($));
  }
  e.accountBodyToRLP = ne;
})(account);
var address = {};
Object.defineProperty(address, "__esModule", { value: !0 });
address.Address = void 0;
const account_1 = account, bytes_1$2 = bytes;
class Address {
  constructor(o) {
    if (o.length !== 20)
      throw new Error("Invalid address length");
    this.buf = o;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new Address((0, bytes_1$2.zeros)(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(o) {
    if (!(0, account_1.isValidAddress)(o))
      throw new Error("Invalid address");
    return new Address((0, bytes_1$2.toBuffer)(o));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(o) {
    if (!buffer$3.Buffer.isBuffer(o))
      throw new Error("Public key should be Buffer");
    const S = (0, account_1.pubToAddress)(o);
    return new Address(S);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(o) {
    if (!buffer$3.Buffer.isBuffer(o))
      throw new Error("Private key should be Buffer");
    const S = (0, account_1.privateToAddress)(o);
    return new Address(S);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(o, S) {
    if (typeof S != "bigint")
      throw new Error("Expected nonce to be a bigint");
    return new Address((0, account_1.generateAddress)(o.buf, (0, bytes_1$2.bigIntToBuffer)(S)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(o, S, g) {
    if (!buffer$3.Buffer.isBuffer(S))
      throw new Error("Expected salt to be a Buffer");
    if (!buffer$3.Buffer.isBuffer(g))
      throw new Error("Expected initCode to be a Buffer");
    return new Address((0, account_1.generateAddress2)(o.buf, S, g));
  }
  /**
   * Is address equal to another.
   */
  equals(o) {
    return this.buf.equals(o.buf);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(Address.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const o = (0, bytes_1$2.bufferToBigInt)(this.buf), S = BigInt(0), g = BigInt("0xffff");
    return o >= S && o <= g;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return "0x" + this.buf.toString("hex");
  }
  /**
   * Returns Buffer representation of address.
   */
  toBuffer() {
    return buffer$3.Buffer.from(this.buf);
  }
}
address.Address = Address;
var withdrawal = {}, types$2 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toType = e.TypeOutput = void 0;
  const o = bytes, S = internal;
  var g;
  (function(h) {
    h[h.Number = 0] = "Number", h[h.BigInt = 1] = "BigInt", h[h.Buffer = 2] = "Buffer", h[h.PrefixedHexString = 3] = "PrefixedHexString";
  })(g = e.TypeOutput || (e.TypeOutput = {}));
  function U(h, q) {
    if (h === null)
      return null;
    if (h === void 0)
      return;
    if (typeof h == "string" && !(0, S.isHexString)(h))
      throw new Error(`A string must be provided with a 0x-prefix, given: ${h}`);
    if (typeof h == "number" && !Number.isSafeInteger(h))
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const A = (0, o.toBuffer)(h);
    switch (q) {
      case g.Buffer:
        return A;
      case g.BigInt:
        return (0, o.bufferToBigInt)(A);
      case g.Number: {
        const P = (0, o.bufferToBigInt)(A);
        if (P > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        return Number(P);
      }
      case g.PrefixedHexString:
        return (0, o.bufferToHex)(A);
      default:
        throw new Error("unknown outputType");
    }
  }
  e.toType = U;
})(types$2);
Object.defineProperty(withdrawal, "__esModule", { value: !0 });
withdrawal.Withdrawal = void 0;
const address_1 = address, bytes_1$1 = bytes, types_1 = types$2;
class Withdrawal {
  /**
   * This constructor assigns and validates the values.
   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
   */
  constructor(o, S, g, U) {
    this.index = o, this.validatorIndex = S, this.address = g, this.amount = U;
  }
  static fromWithdrawalData(o) {
    const { index: S, validatorIndex: g, address: U, amount: h } = o, q = (0, types_1.toType)(S, types_1.TypeOutput.BigInt), A = (0, types_1.toType)(g, types_1.TypeOutput.BigInt), P = new address_1.Address((0, types_1.toType)(U, types_1.TypeOutput.Buffer)), I = (0, types_1.toType)(h, types_1.TypeOutput.BigInt);
    return new Withdrawal(q, A, P, I);
  }
  static fromValuesArray(o) {
    if (o.length !== 4)
      throw Error(`Invalid withdrawalArray length expected=4 actual=${o.length}`);
    const [S, g, U, h] = o;
    return Withdrawal.fromWithdrawalData({ index: S, validatorIndex: g, address: U, amount: h });
  }
  /**
   * Convert a withdrawal to a buffer array
   * @param withdrawal the withdrawal to convert
   * @returns buffer array of the withdrawal
   */
  static toBufferArray(o) {
    const { index: S, validatorIndex: g, address: U, amount: h } = o, q = (0, types_1.toType)(S, types_1.TypeOutput.BigInt) === BigInt(0) ? buffer$3.Buffer.alloc(0) : (0, types_1.toType)(S, types_1.TypeOutput.Buffer), A = (0, types_1.toType)(g, types_1.TypeOutput.BigInt) === BigInt(0) ? buffer$3.Buffer.alloc(0) : (0, types_1.toType)(g, types_1.TypeOutput.Buffer);
    let P;
    U instanceof address_1.Address ? P = U.buf : P = (0, types_1.toType)(U, types_1.TypeOutput.Buffer);
    const I = (0, types_1.toType)(h, types_1.TypeOutput.BigInt) === BigInt(0) ? buffer$3.Buffer.alloc(0) : (0, types_1.toType)(h, types_1.TypeOutput.Buffer);
    return [q, A, P, I];
  }
  raw() {
    return Withdrawal.toBufferArray(this);
  }
  toValue() {
    return {
      index: this.index,
      validatorIndex: this.validatorIndex,
      address: this.address.buf,
      amount: this.amount
    };
  }
  toJSON() {
    return {
      index: (0, bytes_1$1.bigIntToHex)(this.index),
      validatorIndex: (0, bytes_1$1.bigIntToHex)(this.validatorIndex),
      address: "0x" + this.address.buf.toString("hex"),
      amount: (0, bytes_1$1.bigIntToHex)(this.amount)
    };
  }
}
withdrawal.Withdrawal = Withdrawal;
var signature$2 = {};
Object.defineProperty(signature$2, "__esModule", { value: !0 });
signature$2.hashPersonalMessage = signature$2.isValidSignature = signature$2.fromRpcSig = signature$2.toCompactSig = signature$2.toRpcSig = signature$2.ecrecover = signature$2.ecsign = void 0;
const keccak_1 = keccak, secp256k1_1 = secp256k1$2, bytes_1 = bytes, constants_1 = constants$2, helpers_1 = helpers;
function ecsign(e, o, S) {
  const g = secp256k1_1.secp256k1.sign(e, o), U = g.toCompactRawBytes(), h = buffer$3.Buffer.from(U.slice(0, 32)), q = buffer$3.Buffer.from(U.slice(32, 64)), A = S === void 0 ? BigInt(g.recovery + 27) : BigInt(g.recovery + 35) + BigInt(S) * BigInt(2);
  return { r: h, s: q, v: A };
}
signature$2.ecsign = ecsign;
function calculateSigRecovery(e, o) {
  return e === BigInt(0) || e === BigInt(1) ? e : o === void 0 ? e - BigInt(27) : e - (o * BigInt(2) + BigInt(35));
}
function isValidSigRecovery(e) {
  return e === BigInt(0) || e === BigInt(1);
}
const ecrecover = function(e, o, S, g, U) {
  const h = buffer$3.Buffer.concat([(0, bytes_1.setLengthLeft)(S, 32), (0, bytes_1.setLengthLeft)(g, 32)], 64), q = calculateSigRecovery(o, U);
  if (!isValidSigRecovery(q))
    throw new Error("Invalid signature v value");
  const P = secp256k1_1.secp256k1.Signature.fromCompact(h).addRecoveryBit(Number(q)).recoverPublicKey(e);
  return buffer$3.Buffer.from(P.toRawBytes(!1).slice(1));
};
signature$2.ecrecover = ecrecover;
const toRpcSig = function(e, o, S, g) {
  const U = calculateSigRecovery(e, g);
  if (!isValidSigRecovery(U))
    throw new Error("Invalid signature v value");
  return (0, bytes_1.bufferToHex)(buffer$3.Buffer.concat([(0, bytes_1.setLengthLeft)(o, 32), (0, bytes_1.setLengthLeft)(S, 32), (0, bytes_1.toBuffer)(e)]));
};
signature$2.toRpcSig = toRpcSig;
const toCompactSig = function(e, o, S, g) {
  const U = calculateSigRecovery(e, g);
  if (!isValidSigRecovery(U))
    throw new Error("Invalid signature v value");
  let h = S;
  return (e > BigInt(28) && e % BigInt(2) === BigInt(1) || e === BigInt(1) || e === BigInt(28)) && (h = buffer$3.Buffer.from(S), h[0] |= 128), (0, bytes_1.bufferToHex)(buffer$3.Buffer.concat([(0, bytes_1.setLengthLeft)(o, 32), (0, bytes_1.setLengthLeft)(h, 32)]));
};
signature$2.toCompactSig = toCompactSig;
const fromRpcSig = function(e) {
  const o = (0, bytes_1.toBuffer)(e);
  let S, g, U;
  if (o.length >= 65)
    S = o.slice(0, 32), g = o.slice(32, 64), U = (0, bytes_1.bufferToBigInt)(o.slice(64));
  else if (o.length === 64)
    S = o.slice(0, 32), g = o.slice(32, 64), U = BigInt((0, bytes_1.bufferToInt)(o.slice(32, 33)) >> 7), g[0] &= 127;
  else
    throw new Error("Invalid signature length");
  return U < 27 && (U = U + BigInt(27)), {
    v: U,
    r: S,
    s: g
  };
};
signature$2.fromRpcSig = fromRpcSig;
const isValidSignature = function(e, o, S, g = !0, U) {
  if (o.length !== 32 || S.length !== 32 || !isValidSigRecovery(calculateSigRecovery(e, U)))
    return !1;
  const h = (0, bytes_1.bufferToBigInt)(o), q = (0, bytes_1.bufferToBigInt)(S);
  return !(h === BigInt(0) || h >= constants_1.SECP256K1_ORDER || q === BigInt(0) || q >= constants_1.SECP256K1_ORDER || g && q >= constants_1.SECP256K1_ORDER_DIV_2);
};
signature$2.isValidSignature = isValidSignature;
const hashPersonalMessage = function(e) {
  (0, helpers_1.assertIsBuffer)(e);
  const o = buffer$3.Buffer.from(`Ethereum Signed Message:
${e.length}`, "utf-8");
  return buffer$3.Buffer.from((0, keccak_1.keccak256)(buffer$3.Buffer.concat([o, e])));
};
signature$2.hashPersonalMessage = hashPersonalMessage;
var encoding = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.compactBytesToNibbles = e.bytesToNibbles = e.nibblesToCompactBytes = e.nibblesToBytes = e.hasTerminator = void 0;
  const o = (q) => q.length > 0 && q[q.length - 1] === 16;
  e.hasTerminator = o;
  const S = (q, A) => {
    for (let P = 0, I = 0; I < q.length; P += 1, I += 2)
      A[P] = q[I] << 4 | q[I + 1];
  };
  e.nibblesToBytes = S;
  const g = (q) => {
    let A = 0;
    (0, e.hasTerminator)(q) && (A = 1, q = q.subarray(0, q.length - 1));
    const P = new Uint8Array(q.length / 2 + 1);
    return P[0] = A << 5, (q.length & 1) === 1 && (P[0] |= 16, P[0] |= q[0], q = q.subarray(1)), (0, e.nibblesToBytes)(q, P.subarray(1)), P;
  };
  e.nibblesToCompactBytes = g;
  const U = (q) => {
    const A = q.length * 2 + 1, P = new Uint8Array(A);
    for (let I = 0; I < q.length; I++) {
      const B = q[I];
      P[I * 2] = B / 16, P[I * 2 + 1] = B % 16;
    }
    return P[A - 1] = 16, P;
  };
  e.bytesToNibbles = U;
  const h = (q) => {
    if (q.length === 0)
      return q;
    let A = (0, e.bytesToNibbles)(q);
    A[0] < 2 && (A = A.subarray(0, A.length - 1));
    const P = 2 - (A[0] & 1);
    return A.subarray(P);
  };
  e.compactBytesToNibbles = h;
})(encoding);
var asyncEventEmitter = {};
Object.defineProperty(asyncEventEmitter, "__esModule", { value: !0 });
asyncEventEmitter.AsyncEventEmitter = void 0;
const events_1 = eventsExports;
async function runInSeries(e, o, S) {
  let g;
  for await (const U of o)
    try {
      U.length < 2 ? U.call(e, S) : await new Promise((h, q) => {
        U.call(e, S, (A) => {
          A ? q(A) : h();
        });
      });
    } catch (h) {
      g = h;
    }
  if (g)
    throw g;
}
class AsyncEventEmitter extends events_1.EventEmitter {
  emit(o, ...S) {
    let [g, U] = S;
    const h = this;
    let q = h._events[o] ?? [];
    return U === void 0 && typeof g == "function" && (U = g, g = void 0), (o === "newListener" || o === "removeListener") && (g = {
      event: g,
      fn: U
    }, U = void 0), q = Array.isArray(q) ? q : [q], runInSeries(h, q.slice(), g).then(U).catch(U), h.listenerCount(o) > 0;
  }
  once(o, S) {
    const g = this;
    let U;
    if (typeof S != "function")
      throw new TypeError("listener must be a function");
    return S.length >= 2 ? U = function(h, q) {
      g.removeListener(o, U), S(h, q);
    } : U = function(h) {
      g.removeListener(o, U), S(h, U);
    }, g.on(o, U), g;
  }
  first(o, S) {
    let g = this._events[o] ?? [];
    if (typeof S != "function")
      throw new TypeError("listener must be a function");
    return Array.isArray(g) || (this._events[o] = g = [g]), g.unshift(S), this;
  }
  before(o, S, g) {
    return this.beforeOrAfter(o, S, g);
  }
  after(o, S, g) {
    return this.beforeOrAfter(o, S, g, "after");
  }
  beforeOrAfter(o, S, g, U) {
    let h = this._events[o] ?? [], q, A;
    const P = U === "after" ? 1 : 0;
    if (typeof g != "function")
      throw new TypeError("listener must be a function");
    if (typeof S != "function")
      throw new TypeError("target must be a function");
    for (Array.isArray(h) || (this._events[o] = h = [h]), A = h.length, q = h.length; q--; )
      if (h[q] === S) {
        A = q + P;
        break;
      }
    return h.splice(A, 0, g), this;
  }
  on(o, S) {
    return super.on(o, S);
  }
  addListener(o, S) {
    return super.addListener(o, S);
  }
  prependListener(o, S) {
    return super.prependListener(o, S);
  }
  prependOnceListener(o, S) {
    return super.prependOnceListener(o, S);
  }
  removeAllListeners(o) {
    return super.removeAllListeners(o);
  }
  removeListener(o, S) {
    return super.removeListener(o, S);
  }
  eventNames() {
    return super.eventNames();
  }
  listeners(o) {
    return super.listeners(o);
  }
  listenerCount(o) {
    return super.listenerCount(o);
  }
  getMaxListeners() {
    return super.getMaxListeners();
  }
  setMaxListeners(o) {
    return super.setMaxListeners(o);
  }
}
asyncEventEmitter.AsyncEventEmitter = AsyncEventEmitter;
var lock = {};
Object.defineProperty(lock, "__esModule", { value: !0 });
lock.Lock = void 0;
class Lock {
  constructor() {
    this.permits = 1, this.promiseResolverQueue = [];
  }
  /**
   * Returns a promise used to wait for a permit to become available. This method should be awaited on.
   * @returns  A promise that gets resolved when execution is allowed to proceed.
   */
  async acquire() {
    return this.permits > 0 ? (this.permits -= 1, Promise.resolve(!0)) : new Promise((o) => this.promiseResolverQueue.push(o));
  }
  /**
   * Increases the number of permits by one. If there are other functions waiting, one of them will
   * continue to execute in a future iteration of the event loop.
   */
  release() {
    if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0)
      console.warn("Lock.permits should never be > 0 when there is someone waiting.");
    else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
      this.permits -= 1;
      const o = this.promiseResolverQueue.shift();
      o && o(!0);
    }
  }
}
lock.Lock = Lock;
var provider = {}, microFtch = {}, streamHttp = {}, request = { exports: {} }, capability = {}, hasRequiredCapability;
function requireCapability() {
  return hasRequiredCapability || (hasRequiredCapability = 1, function(e) {
    e.fetch = U(commonjsGlobal$1.fetch) && U(commonjsGlobal$1.ReadableStream), e.writableStream = U(commonjsGlobal$1.WritableStream), e.abortController = U(commonjsGlobal$1.AbortController);
    var o;
    function S() {
      if (o !== void 0)
        return o;
      if (commonjsGlobal$1.XMLHttpRequest) {
        o = new commonjsGlobal$1.XMLHttpRequest();
        try {
          o.open("GET", commonjsGlobal$1.XDomainRequest ? "/" : "https://example.com");
        } catch {
          o = null;
        }
      } else
        o = null;
      return o;
    }
    function g(h) {
      var q = S();
      if (!q)
        return !1;
      try {
        return q.responseType = h, q.responseType === h;
      } catch {
      }
      return !1;
    }
    e.arraybuffer = e.fetch || g("arraybuffer"), e.msstream = !e.fetch && g("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && g("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || (S() ? U(S().overrideMimeType) : !1);
    function U(h) {
      return typeof h == "function";
    }
    o = null;
  }(capability)), capability;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(o, S) {
    S && (o.super_ = S, o.prototype = Object.create(S.prototype, {
      constructor: {
        value: o,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(o, S) {
    if (S) {
      o.super_ = S;
      var g = function() {
      };
      g.prototype = S.prototype, o.prototype = new g(), o.prototype.constructor = o;
    }
  }), inherits_browser.exports;
}
var response = {}, readableBrowser$1 = { exports: {} }, streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$1 = {}, shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var e = shams$1;
  return shams = function() {
    return e() && !!Symbol.toStringTag;
  }, shams;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var e = requireShams()(), o = callBound$1, S = o("Object.prototype.toString"), g = function(A) {
    return e && A && typeof A == "object" && Symbol.toStringTag in A ? !1 : S(A) === "[object Arguments]";
  }, U = function(A) {
    return g(A) ? !0 : A !== null && typeof A == "object" && typeof A.length == "number" && A.length >= 0 && S(A) !== "[object Array]" && S(A.callee) === "[object Function]";
  }, h = function() {
    return g(arguments);
  }();
  return g.isLegacyArguments = U, isArguments = h ? g : U, isArguments;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var e = Object.prototype.toString, o = Function.prototype.toString, S = /^\s*(?:function)?\*/, g = requireShams()(), U = Object.getPrototypeOf, h = function() {
    if (!g)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, q;
  return isGeneratorFunction = function(P) {
    if (typeof P != "function")
      return !1;
    if (S.test(o.call(P)))
      return !0;
    if (!g) {
      var I = e.call(P);
      return I === "[object GeneratorFunction]";
    }
    if (!U)
      return !1;
    if (typeof q > "u") {
      var B = h();
      q = B ? U(B) : !1;
    }
    return U(P) === q;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var e = Function.prototype.toString, o = typeof Reflect == "object" && Reflect !== null && Reflect.apply, S, g;
  if (typeof o == "function" && typeof Object.defineProperty == "function")
    try {
      S = Object.defineProperty({}, "length", {
        get: function() {
          throw g;
        }
      }), g = {}, o(function() {
        throw 42;
      }, null, S);
    } catch (se) {
      se !== g && (o = null);
    }
  else
    o = null;
  var U = /^\s*class\b/, h = function(le) {
    try {
      var ce = e.call(le);
      return U.test(ce);
    } catch {
      return !1;
    }
  }, q = function(le) {
    try {
      return h(le) ? !1 : (e.call(le), !0);
    } catch {
      return !1;
    }
  }, A = Object.prototype.toString, P = "[object Object]", I = "[object Function]", B = "[object GeneratorFunction]", H = "[object HTMLAllCollection]", V = "[object HTML document.all class]", X = "[object HTMLCollection]", Q = typeof Symbol == "function" && !!Symbol.toStringTag, ee = !(0 in [,]), ie = function() {
    return !1;
  };
  if (typeof document == "object") {
    var te = document.all;
    A.call(te) === A.call(document.all) && (ie = function(le) {
      if ((ee || !le) && (typeof le > "u" || typeof le == "object"))
        try {
          var ce = A.call(le);
          return (ce === H || ce === V || ce === X || ce === P) && le("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = o ? function(le) {
    if (ie(le))
      return !0;
    if (!le || typeof le != "function" && typeof le != "object")
      return !1;
    try {
      o(le, null, S);
    } catch (ce) {
      if (ce !== g)
        return !1;
    }
    return !h(le) && q(le);
  } : function(le) {
    if (ie(le))
      return !0;
    if (!le || typeof le != "function" && typeof le != "object")
      return !1;
    if (Q)
      return q(le);
    if (h(le))
      return !1;
    var ce = A.call(le);
    return ce !== I && ce !== B && !/^\[object HTML/.test(ce) ? !1 : q(le);
  }, isCallable;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var e = requireIsCallable(), o = Object.prototype.toString, S = Object.prototype.hasOwnProperty, g = function(P, I, B) {
    for (var H = 0, V = P.length; H < V; H++)
      S.call(P, H) && (B == null ? I(P[H], H, P) : I.call(B, P[H], H, P));
  }, U = function(P, I, B) {
    for (var H = 0, V = P.length; H < V; H++)
      B == null ? I(P.charAt(H), H, P) : I.call(B, P.charAt(H), H, P);
  }, h = function(P, I, B) {
    for (var H in P)
      S.call(P, H) && (B == null ? I(P[H], H, P) : I.call(B, P[H], H, P));
  }, q = function(P, I, B) {
    if (!e(I))
      throw new TypeError("iterator must be a function");
    var H;
    arguments.length >= 3 && (H = B), o.call(P) === "[object Array]" ? g(P, I, H) : typeof P == "string" ? U(P, I, H) : h(P, I, H);
  };
  return forEach_1 = q, forEach_1;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var e = requirePossibleTypedArrayNames(), o = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis;
  return availableTypedArrays = function() {
    for (var g = [], U = 0; U < e.length; U++)
      typeof o[e[U]] == "function" && (g[g.length] = e[U]);
    return g;
  }, availableTypedArrays;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var e = requireForEach(), o = requireAvailableTypedArrays(), S = callBindExports, g = callBound$1, U = gopd$1, h = g("Object.prototype.toString"), q = requireShams()(), A = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, P = o(), I = g("String.prototype.slice"), B = Object.getPrototypeOf, H = g("Array.prototype.indexOf", !0) || function(ie, te) {
    for (var se = 0; se < ie.length; se += 1)
      if (ie[se] === te)
        return se;
    return -1;
  }, V = { __proto__: null };
  q && U && B ? e(P, function(ee) {
    var ie = new A[ee]();
    if (Symbol.toStringTag in ie) {
      var te = B(ie), se = U(te, Symbol.toStringTag);
      if (!se) {
        var le = B(te);
        se = U(le, Symbol.toStringTag);
      }
      V["$" + ee] = S(se.get);
    }
  }) : e(P, function(ee) {
    var ie = new A[ee](), te = ie.slice || ie.set;
    te && (V["$" + ee] = S(te));
  });
  var X = function(ie) {
    var te = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      V,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(se, le) {
        if (!te)
          try {
            "$" + se(ie) === le && (te = I(le, 1));
          } catch {
          }
      }
    ), te;
  }, Q = function(ie) {
    var te = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      V,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(se, le) {
        if (!te)
          try {
            se(ie), te = I(le, 1);
          } catch {
          }
      }
    ), te;
  };
  return whichTypedArray = function(ie) {
    if (!ie || typeof ie != "object")
      return !1;
    if (!q) {
      var te = I(h(ie), 8, -1);
      return H(P, te) > -1 ? te : te !== "Object" ? !1 : Q(ie);
    }
    return U ? X(ie) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var e = requireWhichTypedArray();
  return isTypedArray = function(S) {
    return !!e(S);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(e) {
    var o = requireIsArguments(), S = requireIsGeneratorFunction(), g = requireWhichTypedArray(), U = requireIsTypedArray();
    function h(_e) {
      return _e.call.bind(_e);
    }
    var q = typeof BigInt < "u", A = typeof Symbol < "u", P = h(Object.prototype.toString), I = h(Number.prototype.valueOf), B = h(String.prototype.valueOf), H = h(Boolean.prototype.valueOf);
    if (q)
      var V = h(BigInt.prototype.valueOf);
    if (A)
      var X = h(Symbol.prototype.valueOf);
    function Q(_e, Pe) {
      if (typeof _e != "object")
        return !1;
      try {
        return Pe(_e), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = o, e.isGeneratorFunction = S, e.isTypedArray = U;
    function ee(_e) {
      return typeof Promise < "u" && _e instanceof Promise || _e !== null && typeof _e == "object" && typeof _e.then == "function" && typeof _e.catch == "function";
    }
    e.isPromise = ee;
    function ie(_e) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(_e) : U(_e) || ae(_e);
    }
    e.isArrayBufferView = ie;
    function te(_e) {
      return g(_e) === "Uint8Array";
    }
    e.isUint8Array = te;
    function se(_e) {
      return g(_e) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = se;
    function le(_e) {
      return g(_e) === "Uint16Array";
    }
    e.isUint16Array = le;
    function ce(_e) {
      return g(_e) === "Uint32Array";
    }
    e.isUint32Array = ce;
    function pe(_e) {
      return g(_e) === "Int8Array";
    }
    e.isInt8Array = pe;
    function me(_e) {
      return g(_e) === "Int16Array";
    }
    e.isInt16Array = me;
    function Me(_e) {
      return g(_e) === "Int32Array";
    }
    e.isInt32Array = Me;
    function Ee(_e) {
      return g(_e) === "Float32Array";
    }
    e.isFloat32Array = Ee;
    function Re(_e) {
      return g(_e) === "Float64Array";
    }
    e.isFloat64Array = Re;
    function Ne(_e) {
      return g(_e) === "BigInt64Array";
    }
    e.isBigInt64Array = Ne;
    function ne(_e) {
      return g(_e) === "BigUint64Array";
    }
    e.isBigUint64Array = ne;
    function Y(_e) {
      return P(_e) === "[object Map]";
    }
    Y.working = typeof Map < "u" && Y(/* @__PURE__ */ new Map());
    function M(_e) {
      return typeof Map > "u" ? !1 : Y.working ? Y(_e) : _e instanceof Map;
    }
    e.isMap = M;
    function $(_e) {
      return P(_e) === "[object Set]";
    }
    $.working = typeof Set < "u" && $(/* @__PURE__ */ new Set());
    function O(_e) {
      return typeof Set > "u" ? !1 : $.working ? $(_e) : _e instanceof Set;
    }
    e.isSet = O;
    function J(_e) {
      return P(_e) === "[object WeakMap]";
    }
    J.working = typeof WeakMap < "u" && J(/* @__PURE__ */ new WeakMap());
    function Z(_e) {
      return typeof WeakMap > "u" ? !1 : J.working ? J(_e) : _e instanceof WeakMap;
    }
    e.isWeakMap = Z;
    function K(_e) {
      return P(_e) === "[object WeakSet]";
    }
    K.working = typeof WeakSet < "u" && K(/* @__PURE__ */ new WeakSet());
    function z(_e) {
      return K(_e);
    }
    e.isWeakSet = z;
    function G(_e) {
      return P(_e) === "[object ArrayBuffer]";
    }
    G.working = typeof ArrayBuffer < "u" && G(new ArrayBuffer());
    function D(_e) {
      return typeof ArrayBuffer > "u" ? !1 : G.working ? G(_e) : _e instanceof ArrayBuffer;
    }
    e.isArrayBuffer = D;
    function F(_e) {
      return P(_e) === "[object DataView]";
    }
    F.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && F(new DataView(new ArrayBuffer(1), 0, 1));
    function ae(_e) {
      return typeof DataView > "u" ? !1 : F.working ? F(_e) : _e instanceof DataView;
    }
    e.isDataView = ae;
    var ge = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function xe(_e) {
      return P(_e) === "[object SharedArrayBuffer]";
    }
    function ye(_e) {
      return typeof ge > "u" ? !1 : (typeof xe.working > "u" && (xe.working = xe(new ge())), xe.working ? xe(_e) : _e instanceof ge);
    }
    e.isSharedArrayBuffer = ye;
    function oe(_e) {
      return P(_e) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = oe;
    function fe(_e) {
      return P(_e) === "[object Map Iterator]";
    }
    e.isMapIterator = fe;
    function $e(_e) {
      return P(_e) === "[object Set Iterator]";
    }
    e.isSetIterator = $e;
    function Be(_e) {
      return P(_e) === "[object Generator]";
    }
    e.isGeneratorObject = Be;
    function be(_e) {
      return P(_e) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = be;
    function ve(_e) {
      return Q(_e, I);
    }
    e.isNumberObject = ve;
    function qe(_e) {
      return Q(_e, B);
    }
    e.isStringObject = qe;
    function De(_e) {
      return Q(_e, H);
    }
    e.isBooleanObject = De;
    function Ye(_e) {
      return q && Q(_e, V);
    }
    e.isBigIntObject = Ye;
    function he(_e) {
      return A && Q(_e, X);
    }
    e.isSymbolObject = he;
    function ue(_e) {
      return ve(_e) || qe(_e) || De(_e) || Ye(_e) || he(_e);
    }
    e.isBoxedPrimitive = ue;
    function de(_e) {
      return typeof Uint8Array < "u" && (D(_e) || ye(_e));
    }
    e.isAnyArrayBuffer = de, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(_e) {
      Object.defineProperty(e, _e, {
        enumerable: !1,
        value: function() {
          throw new Error(_e + " is not supported in userland");
        }
      });
    });
  }(types$1)), types$1;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(o) {
    return o && typeof o == "object" && typeof o.copy == "function" && typeof o.fill == "function" && typeof o.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(e) {
    var o = Object.getOwnPropertyDescriptors || function(ae) {
      for (var ge = Object.keys(ae), xe = {}, ye = 0; ye < ge.length; ye++)
        xe[ge[ye]] = Object.getOwnPropertyDescriptor(ae, ge[ye]);
      return xe;
    }, S = /%[sdj%]/g;
    e.format = function(F) {
      if (!pe(F)) {
        for (var ae = [], ge = 0; ge < arguments.length; ge++)
          ae.push(q(arguments[ge]));
        return ae.join(" ");
      }
      for (var ge = 1, xe = arguments, ye = xe.length, oe = String(F).replace(S, function($e) {
        if ($e === "%%")
          return "%";
        if (ge >= ye)
          return $e;
        switch ($e) {
          case "%s":
            return String(xe[ge++]);
          case "%d":
            return Number(xe[ge++]);
          case "%j":
            try {
              return JSON.stringify(xe[ge++]);
            } catch {
              return "[Circular]";
            }
          default:
            return $e;
        }
      }), fe = xe[ge]; ge < ye; fe = xe[++ge])
        se(fe) || !Re(fe) ? oe += " " + fe : oe += " " + q(fe);
      return oe;
    }, e.deprecate = function(F, ae) {
      if (typeof process$3 < "u" && process$3.noDeprecation === !0)
        return F;
      if (typeof process$3 > "u")
        return function() {
          return e.deprecate(F, ae).apply(this, arguments);
        };
      var ge = !1;
      function xe() {
        if (!ge) {
          if (process$3.throwDeprecation)
            throw new Error(ae);
          process$3.traceDeprecation ? console.trace(ae) : console.error(ae), ge = !0;
        }
        return F.apply(this, arguments);
      }
      return xe;
    };
    var g = {}, U = /^$/;
    if (process$3.env.NODE_DEBUG) {
      var h = process$3.env.NODE_DEBUG;
      h = h.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), U = new RegExp("^" + h + "$", "i");
    }
    e.debuglog = function(F) {
      if (F = F.toUpperCase(), !g[F])
        if (U.test(F)) {
          var ae = process$3.pid;
          g[F] = function() {
            var ge = e.format.apply(e, arguments);
            console.error("%s %d: %s", F, ae, ge);
          };
        } else
          g[F] = function() {
          };
      return g[F];
    };
    function q(F, ae) {
      var ge = {
        seen: [],
        stylize: P
      };
      return arguments.length >= 3 && (ge.depth = arguments[2]), arguments.length >= 4 && (ge.colors = arguments[3]), te(ae) ? ge.showHidden = ae : ae && e._extend(ge, ae), Me(ge.showHidden) && (ge.showHidden = !1), Me(ge.depth) && (ge.depth = 2), Me(ge.colors) && (ge.colors = !1), Me(ge.customInspect) && (ge.customInspect = !0), ge.colors && (ge.stylize = A), B(ge, F, ge.depth);
    }
    e.inspect = q, q.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, q.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function A(F, ae) {
      var ge = q.styles[ae];
      return ge ? "\x1B[" + q.colors[ge][0] + "m" + F + "\x1B[" + q.colors[ge][1] + "m" : F;
    }
    function P(F, ae) {
      return F;
    }
    function I(F) {
      var ae = {};
      return F.forEach(function(ge, xe) {
        ae[ge] = !0;
      }), ae;
    }
    function B(F, ae, ge) {
      if (F.customInspect && ae && Y(ae.inspect) && // Filter out the util module, it's inspect function is special
      ae.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(ae.constructor && ae.constructor.prototype === ae)) {
        var xe = ae.inspect(ge, F);
        return pe(xe) || (xe = B(F, xe, ge)), xe;
      }
      var ye = H(F, ae);
      if (ye)
        return ye;
      var oe = Object.keys(ae), fe = I(oe);
      if (F.showHidden && (oe = Object.getOwnPropertyNames(ae)), ne(ae) && (oe.indexOf("message") >= 0 || oe.indexOf("description") >= 0))
        return V(ae);
      if (oe.length === 0) {
        if (Y(ae)) {
          var $e = ae.name ? ": " + ae.name : "";
          return F.stylize("[Function" + $e + "]", "special");
        }
        if (Ee(ae))
          return F.stylize(RegExp.prototype.toString.call(ae), "regexp");
        if (Ne(ae))
          return F.stylize(Date.prototype.toString.call(ae), "date");
        if (ne(ae))
          return V(ae);
      }
      var Be = "", be = !1, ve = ["{", "}"];
      if (ie(ae) && (be = !0, ve = ["[", "]"]), Y(ae)) {
        var qe = ae.name ? ": " + ae.name : "";
        Be = " [Function" + qe + "]";
      }
      if (Ee(ae) && (Be = " " + RegExp.prototype.toString.call(ae)), Ne(ae) && (Be = " " + Date.prototype.toUTCString.call(ae)), ne(ae) && (Be = " " + V(ae)), oe.length === 0 && (!be || ae.length == 0))
        return ve[0] + Be + ve[1];
      if (ge < 0)
        return Ee(ae) ? F.stylize(RegExp.prototype.toString.call(ae), "regexp") : F.stylize("[Object]", "special");
      F.seen.push(ae);
      var De;
      return be ? De = X(F, ae, ge, fe, oe) : De = oe.map(function(Ye) {
        return Q(F, ae, ge, fe, Ye, be);
      }), F.seen.pop(), ee(De, Be, ve);
    }
    function H(F, ae) {
      if (Me(ae))
        return F.stylize("undefined", "undefined");
      if (pe(ae)) {
        var ge = "'" + JSON.stringify(ae).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return F.stylize(ge, "string");
      }
      if (ce(ae))
        return F.stylize("" + ae, "number");
      if (te(ae))
        return F.stylize("" + ae, "boolean");
      if (se(ae))
        return F.stylize("null", "null");
    }
    function V(F) {
      return "[" + Error.prototype.toString.call(F) + "]";
    }
    function X(F, ae, ge, xe, ye) {
      for (var oe = [], fe = 0, $e = ae.length; fe < $e; ++fe)
        K(ae, String(fe)) ? oe.push(Q(
          F,
          ae,
          ge,
          xe,
          String(fe),
          !0
        )) : oe.push("");
      return ye.forEach(function(Be) {
        Be.match(/^\d+$/) || oe.push(Q(
          F,
          ae,
          ge,
          xe,
          Be,
          !0
        ));
      }), oe;
    }
    function Q(F, ae, ge, xe, ye, oe) {
      var fe, $e, Be;
      if (Be = Object.getOwnPropertyDescriptor(ae, ye) || { value: ae[ye] }, Be.get ? Be.set ? $e = F.stylize("[Getter/Setter]", "special") : $e = F.stylize("[Getter]", "special") : Be.set && ($e = F.stylize("[Setter]", "special")), K(xe, ye) || (fe = "[" + ye + "]"), $e || (F.seen.indexOf(Be.value) < 0 ? (se(ge) ? $e = B(F, Be.value, null) : $e = B(F, Be.value, ge - 1), $e.indexOf(`
`) > -1 && (oe ? $e = $e.split(`
`).map(function(be) {
        return "  " + be;
      }).join(`
`).slice(2) : $e = `
` + $e.split(`
`).map(function(be) {
        return "   " + be;
      }).join(`
`))) : $e = F.stylize("[Circular]", "special")), Me(fe)) {
        if (oe && ye.match(/^\d+$/))
          return $e;
        fe = JSON.stringify("" + ye), fe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (fe = fe.slice(1, -1), fe = F.stylize(fe, "name")) : (fe = fe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), fe = F.stylize(fe, "string"));
      }
      return fe + ": " + $e;
    }
    function ee(F, ae, ge) {
      var xe = F.reduce(function(ye, oe) {
        return oe.indexOf(`
`) >= 0, ye + oe.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return xe > 60 ? ge[0] + (ae === "" ? "" : ae + `
 `) + " " + F.join(`,
  `) + " " + ge[1] : ge[0] + ae + " " + F.join(", ") + " " + ge[1];
    }
    e.types = requireTypes();
    function ie(F) {
      return Array.isArray(F);
    }
    e.isArray = ie;
    function te(F) {
      return typeof F == "boolean";
    }
    e.isBoolean = te;
    function se(F) {
      return F === null;
    }
    e.isNull = se;
    function le(F) {
      return F == null;
    }
    e.isNullOrUndefined = le;
    function ce(F) {
      return typeof F == "number";
    }
    e.isNumber = ce;
    function pe(F) {
      return typeof F == "string";
    }
    e.isString = pe;
    function me(F) {
      return typeof F == "symbol";
    }
    e.isSymbol = me;
    function Me(F) {
      return F === void 0;
    }
    e.isUndefined = Me;
    function Ee(F) {
      return Re(F) && $(F) === "[object RegExp]";
    }
    e.isRegExp = Ee, e.types.isRegExp = Ee;
    function Re(F) {
      return typeof F == "object" && F !== null;
    }
    e.isObject = Re;
    function Ne(F) {
      return Re(F) && $(F) === "[object Date]";
    }
    e.isDate = Ne, e.types.isDate = Ne;
    function ne(F) {
      return Re(F) && ($(F) === "[object Error]" || F instanceof Error);
    }
    e.isError = ne, e.types.isNativeError = ne;
    function Y(F) {
      return typeof F == "function";
    }
    e.isFunction = Y;
    function M(F) {
      return F === null || typeof F == "boolean" || typeof F == "number" || typeof F == "string" || typeof F == "symbol" || // ES6 symbol
      typeof F > "u";
    }
    e.isPrimitive = M, e.isBuffer = requireIsBufferBrowser();
    function $(F) {
      return Object.prototype.toString.call(F);
    }
    function O(F) {
      return F < 10 ? "0" + F.toString(10) : F.toString(10);
    }
    var J = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Z() {
      var F = /* @__PURE__ */ new Date(), ae = [
        O(F.getHours()),
        O(F.getMinutes()),
        O(F.getSeconds())
      ].join(":");
      return [F.getDate(), J[F.getMonth()], ae].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", Z(), e.format.apply(e, arguments));
    }, e.inherits = requireInherits_browser(), e._extend = function(F, ae) {
      if (!ae || !Re(ae))
        return F;
      for (var ge = Object.keys(ae), xe = ge.length; xe--; )
        F[ge[xe]] = ae[ge[xe]];
      return F;
    };
    function K(F, ae) {
      return Object.prototype.hasOwnProperty.call(F, ae);
    }
    var z = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(ae) {
      if (typeof ae != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (z && ae[z]) {
        var ge = ae[z];
        if (typeof ge != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(ge, z, {
          value: ge,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ge;
      }
      function ge() {
        for (var xe, ye, oe = new Promise(function(Be, be) {
          xe = Be, ye = be;
        }), fe = [], $e = 0; $e < arguments.length; $e++)
          fe.push(arguments[$e]);
        fe.push(function(Be, be) {
          Be ? ye(Be) : xe(be);
        });
        try {
          ae.apply(this, fe);
        } catch (Be) {
          ye(Be);
        }
        return oe;
      }
      return Object.setPrototypeOf(ge, Object.getPrototypeOf(ae)), z && Object.defineProperty(ge, z, {
        value: ge,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        ge,
        o(ae)
      );
    }, e.promisify.custom = z;
    function G(F, ae) {
      if (!F) {
        var ge = new Error("Promise was rejected with a falsy value");
        ge.reason = F, F = ge;
      }
      return ae(F);
    }
    function D(F) {
      if (typeof F != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function ae() {
        for (var ge = [], xe = 0; xe < arguments.length; xe++)
          ge.push(arguments[xe]);
        var ye = ge.pop();
        if (typeof ye != "function")
          throw new TypeError("The last argument must be of type Function");
        var oe = this, fe = function() {
          return ye.apply(oe, arguments);
        };
        F.apply(this, ge).then(
          function($e) {
            process$3.nextTick(fe.bind(null, null, $e));
          },
          function($e) {
            process$3.nextTick(G.bind(null, $e, fe));
          }
        );
      }
      return Object.setPrototypeOf(ae, Object.getPrototypeOf(F)), Object.defineProperties(
        ae,
        o(F)
      ), ae;
    }
    e.callbackify = D;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function e(Q, ee) {
    var ie = Object.keys(Q);
    if (Object.getOwnPropertySymbols) {
      var te = Object.getOwnPropertySymbols(Q);
      ee && (te = te.filter(function(se) {
        return Object.getOwnPropertyDescriptor(Q, se).enumerable;
      })), ie.push.apply(ie, te);
    }
    return ie;
  }
  function o(Q) {
    for (var ee = 1; ee < arguments.length; ee++) {
      var ie = arguments[ee] != null ? arguments[ee] : {};
      ee % 2 ? e(Object(ie), !0).forEach(function(te) {
        S(Q, te, ie[te]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Q, Object.getOwnPropertyDescriptors(ie)) : e(Object(ie)).forEach(function(te) {
        Object.defineProperty(Q, te, Object.getOwnPropertyDescriptor(ie, te));
      });
    }
    return Q;
  }
  function S(Q, ee, ie) {
    return ee = q(ee), ee in Q ? Object.defineProperty(Q, ee, { value: ie, enumerable: !0, configurable: !0, writable: !0 }) : Q[ee] = ie, Q;
  }
  function g(Q, ee) {
    if (!(Q instanceof ee))
      throw new TypeError("Cannot call a class as a function");
  }
  function U(Q, ee) {
    for (var ie = 0; ie < ee.length; ie++) {
      var te = ee[ie];
      te.enumerable = te.enumerable || !1, te.configurable = !0, "value" in te && (te.writable = !0), Object.defineProperty(Q, q(te.key), te);
    }
  }
  function h(Q, ee, ie) {
    return ee && U(Q.prototype, ee), ie && U(Q, ie), Object.defineProperty(Q, "prototype", { writable: !1 }), Q;
  }
  function q(Q) {
    var ee = A(Q, "string");
    return typeof ee == "symbol" ? ee : String(ee);
  }
  function A(Q, ee) {
    if (typeof Q != "object" || Q === null)
      return Q;
    var ie = Q[Symbol.toPrimitive];
    if (ie !== void 0) {
      var te = ie.call(Q, ee || "default");
      if (typeof te != "object")
        return te;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ee === "string" ? String : Number)(Q);
  }
  var P = buffer$3, I = P.Buffer, B = requireUtil$1(), H = B.inspect, V = H && H.custom || "inspect";
  function X(Q, ee, ie) {
    I.prototype.copy.call(Q, ee, ie);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function Q() {
      g(this, Q), this.head = null, this.tail = null, this.length = 0;
    }
    return h(Q, [{
      key: "push",
      value: function(ie) {
        var te = {
          data: ie,
          next: null
        };
        this.length > 0 ? this.tail.next = te : this.head = te, this.tail = te, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ie) {
        var te = {
          data: ie,
          next: this.head
        };
        this.length === 0 && (this.tail = te), this.head = te, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ie = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ie;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ie) {
        if (this.length === 0)
          return "";
        for (var te = this.head, se = "" + te.data; te = te.next; )
          se += ie + te.data;
        return se;
      }
    }, {
      key: "concat",
      value: function(ie) {
        if (this.length === 0)
          return I.alloc(0);
        for (var te = I.allocUnsafe(ie >>> 0), se = this.head, le = 0; se; )
          X(se.data, te, le), le += se.data.length, se = se.next;
        return te;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ie, te) {
        var se;
        return ie < this.head.data.length ? (se = this.head.data.slice(0, ie), this.head.data = this.head.data.slice(ie)) : ie === this.head.data.length ? se = this.shift() : se = te ? this._getString(ie) : this._getBuffer(ie), se;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ie) {
        var te = this.head, se = 1, le = te.data;
        for (ie -= le.length; te = te.next; ) {
          var ce = te.data, pe = ie > ce.length ? ce.length : ie;
          if (pe === ce.length ? le += ce : le += ce.slice(0, ie), ie -= pe, ie === 0) {
            pe === ce.length ? (++se, te.next ? this.head = te.next : this.head = this.tail = null) : (this.head = te, te.data = ce.slice(pe));
            break;
          }
          ++se;
        }
        return this.length -= se, le;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ie) {
        var te = I.allocUnsafe(ie), se = this.head, le = 1;
        for (se.data.copy(te), ie -= se.data.length; se = se.next; ) {
          var ce = se.data, pe = ie > ce.length ? ce.length : ie;
          if (ce.copy(te, te.length - ie, 0, pe), ie -= pe, ie === 0) {
            pe === ce.length ? (++le, se.next ? this.head = se.next : this.head = this.tail = null) : (this.head = se, se.data = ce.slice(pe));
            break;
          }
          ++le;
        }
        return this.length -= le, te;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: V,
      value: function(ie, te) {
        return H(this, o(o({}, te), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Q;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1)
    return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function e(q, A) {
    var P = this, I = this._readableState && this._readableState.destroyed, B = this._writableState && this._writableState.destroyed;
    return I || B ? (A ? A(q) : q && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$3.nextTick(U, this, q)) : process$3.nextTick(U, this, q)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(q || null, function(H) {
      !A && H ? P._writableState ? P._writableState.errorEmitted ? process$3.nextTick(S, P) : (P._writableState.errorEmitted = !0, process$3.nextTick(o, P, H)) : process$3.nextTick(o, P, H) : A ? (process$3.nextTick(S, P), A(H)) : process$3.nextTick(S, P);
    }), this);
  }
  function o(q, A) {
    U(q, A), S(q);
  }
  function S(q) {
    q._writableState && !q._writableState.emitClose || q._readableState && !q._readableState.emitClose || q.emit("close");
  }
  function g() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function U(q, A) {
    q.emit("error", A);
  }
  function h(q, A) {
    var P = q._readableState, I = q._writableState;
    P && P.autoDestroy || I && I.autoDestroy ? q.destroy(A) : q.emit("error", A);
  }
  return destroy_1$1 = {
    destroy: e,
    undestroy: g,
    errorOrDestroy: h
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function e(A, P) {
    A.prototype = Object.create(P.prototype), A.prototype.constructor = A, A.__proto__ = P;
  }
  var o = {};
  function S(A, P, I) {
    I || (I = Error);
    function B(V, X, Q) {
      return typeof P == "string" ? P : P(V, X, Q);
    }
    var H = /* @__PURE__ */ function(V) {
      e(X, V);
      function X(Q, ee, ie) {
        return V.call(this, B(Q, ee, ie)) || this;
      }
      return X;
    }(I);
    H.prototype.name = I.name, H.prototype.code = A, o[A] = H;
  }
  function g(A, P) {
    if (Array.isArray(A)) {
      var I = A.length;
      return A = A.map(function(B) {
        return String(B);
      }), I > 2 ? "one of ".concat(P, " ").concat(A.slice(0, I - 1).join(", "), ", or ") + A[I - 1] : I === 2 ? "one of ".concat(P, " ").concat(A[0], " or ").concat(A[1]) : "of ".concat(P, " ").concat(A[0]);
    } else
      return "of ".concat(P, " ").concat(String(A));
  }
  function U(A, P, I) {
    return A.substr(!I || I < 0 ? 0 : +I, P.length) === P;
  }
  function h(A, P, I) {
    return (I === void 0 || I > A.length) && (I = A.length), A.substring(I - P.length, I) === P;
  }
  function q(A, P, I) {
    return typeof I != "number" && (I = 0), I + P.length > A.length ? !1 : A.indexOf(P, I) !== -1;
  }
  return S("ERR_INVALID_OPT_VALUE", function(A, P) {
    return 'The value "' + P + '" is invalid for option "' + A + '"';
  }, TypeError), S("ERR_INVALID_ARG_TYPE", function(A, P, I) {
    var B;
    typeof P == "string" && U(P, "not ") ? (B = "must not be", P = P.replace(/^not /, "")) : B = "must be";
    var H;
    if (h(A, " argument"))
      H = "The ".concat(A, " ").concat(B, " ").concat(g(P, "type"));
    else {
      var V = q(A, ".") ? "property" : "argument";
      H = 'The "'.concat(A, '" ').concat(V, " ").concat(B, " ").concat(g(P, "type"));
    }
    return H += ". Received type ".concat(typeof I), H;
  }, TypeError), S("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), S("ERR_METHOD_NOT_IMPLEMENTED", function(A) {
    return "The " + A + " method is not implemented";
  }), S("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), S("ERR_STREAM_DESTROYED", function(A) {
    return "Cannot call " + A + " after a stream was destroyed";
  }), S("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), S("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), S("ERR_STREAM_WRITE_AFTER_END", "write after end"), S("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), S("ERR_UNKNOWN_ENCODING", function(A) {
    return "Unknown encoding: " + A;
  }, TypeError), S("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = o, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state;
  hasRequiredState = 1;
  var e = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function o(g, U, h) {
    return g.highWaterMark != null ? g.highWaterMark : U ? g[h] : null;
  }
  function S(g, U, h, q) {
    var A = o(U, q, h);
    if (A != null) {
      if (!(isFinite(A) && Math.floor(A) === A) || A < 0) {
        var P = q ? h : "highWaterMark";
        throw new e(P, A);
      }
      return Math.floor(A);
    }
    return g.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: S
  }, state;
}
var browser$c, hasRequiredBrowser$c;
function requireBrowser$c() {
  if (hasRequiredBrowser$c)
    return browser$c;
  hasRequiredBrowser$c = 1, browser$c = e;
  function e(S, g) {
    if (o("noDeprecation"))
      return S;
    var U = !1;
    function h() {
      if (!U) {
        if (o("throwDeprecation"))
          throw new Error(g);
        o("traceDeprecation") ? console.trace(g) : console.warn(g), U = !0;
      }
      return S.apply(this, arguments);
    }
    return h;
  }
  function o(S) {
    try {
      if (!commonjsGlobal$1.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var g = commonjsGlobal$1.localStorage[S];
    return g == null ? !1 : String(g).toLowerCase() === "true";
  }
  return browser$c;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Ee;
  function e(ye) {
    var oe = this;
    this.next = null, this.entry = null, this.finish = function() {
      xe(oe, ye);
    };
  }
  var o;
  Ee.WritableState = me;
  var S = {
    deprecate: requireBrowser$c()
  }, g = requireStreamBrowser$1(), U = buffer$3.Buffer, h = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function q(ye) {
    return U.from(ye);
  }
  function A(ye) {
    return U.isBuffer(ye) || ye instanceof h;
  }
  var P = requireDestroy$1(), I = requireState(), B = I.getHighWaterMark, H = requireErrorsBrowser().codes, V = H.ERR_INVALID_ARG_TYPE, X = H.ERR_METHOD_NOT_IMPLEMENTED, Q = H.ERR_MULTIPLE_CALLBACK, ee = H.ERR_STREAM_CANNOT_PIPE, ie = H.ERR_STREAM_DESTROYED, te = H.ERR_STREAM_NULL_VALUES, se = H.ERR_STREAM_WRITE_AFTER_END, le = H.ERR_UNKNOWN_ENCODING, ce = P.errorOrDestroy;
  requireInherits_browser()(Ee, g);
  function pe() {
  }
  function me(ye, oe, fe) {
    o = o || require_stream_duplex$1(), ye = ye || {}, typeof fe != "boolean" && (fe = oe instanceof o), this.objectMode = !!ye.objectMode, fe && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = B(this, ye, "writableHighWaterMark", fe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var $e = ye.decodeStrings === !1;
    this.decodeStrings = !$e, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Be) {
      J(oe, Be);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  me.prototype.getBuffer = function() {
    for (var oe = this.bufferedRequest, fe = []; oe; )
      fe.push(oe), oe = oe.next;
    return fe;
  }, function() {
    try {
      Object.defineProperty(me.prototype, "buffer", {
        get: S.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Me;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Me = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ee, Symbol.hasInstance, {
    value: function(oe) {
      return Me.call(this, oe) ? !0 : this !== Ee ? !1 : oe && oe._writableState instanceof me;
    }
  })) : Me = function(oe) {
    return oe instanceof this;
  };
  function Ee(ye) {
    o = o || require_stream_duplex$1();
    var oe = this instanceof o;
    if (!oe && !Me.call(Ee, this))
      return new Ee(ye);
    this._writableState = new me(ye, this, oe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), g.call(this);
  }
  Ee.prototype.pipe = function() {
    ce(this, new ee());
  };
  function Re(ye, oe) {
    var fe = new se();
    ce(ye, fe), process$3.nextTick(oe, fe);
  }
  function Ne(ye, oe, fe, $e) {
    var Be;
    return fe === null ? Be = new te() : typeof fe != "string" && !oe.objectMode && (Be = new V("chunk", ["string", "Buffer"], fe)), Be ? (ce(ye, Be), process$3.nextTick($e, Be), !1) : !0;
  }
  Ee.prototype.write = function(ye, oe, fe) {
    var $e = this._writableState, Be = !1, be = !$e.objectMode && A(ye);
    return be && !U.isBuffer(ye) && (ye = q(ye)), typeof oe == "function" && (fe = oe, oe = null), be ? oe = "buffer" : oe || (oe = $e.defaultEncoding), typeof fe != "function" && (fe = pe), $e.ending ? Re(this, fe) : (be || Ne(this, $e, ye, fe)) && ($e.pendingcb++, Be = Y(this, $e, be, ye, oe, fe)), Be;
  }, Ee.prototype.cork = function() {
    this._writableState.corked++;
  }, Ee.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && z(this, ye));
  }, Ee.prototype.setDefaultEncoding = function(oe) {
    if (typeof oe == "string" && (oe = oe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((oe + "").toLowerCase()) > -1))
      throw new le(oe);
    return this._writableState.defaultEncoding = oe, this;
  }, Object.defineProperty(Ee.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function ne(ye, oe, fe) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof oe == "string" && (oe = U.from(oe, fe)), oe;
  }
  Object.defineProperty(Ee.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Y(ye, oe, fe, $e, Be, be) {
    if (!fe) {
      var ve = ne(oe, $e, Be);
      $e !== ve && (fe = !0, Be = "buffer", $e = ve);
    }
    var qe = oe.objectMode ? 1 : $e.length;
    oe.length += qe;
    var De = oe.length < oe.highWaterMark;
    if (De || (oe.needDrain = !0), oe.writing || oe.corked) {
      var Ye = oe.lastBufferedRequest;
      oe.lastBufferedRequest = {
        chunk: $e,
        encoding: Be,
        isBuf: fe,
        callback: be,
        next: null
      }, Ye ? Ye.next = oe.lastBufferedRequest : oe.bufferedRequest = oe.lastBufferedRequest, oe.bufferedRequestCount += 1;
    } else
      M(ye, oe, !1, qe, $e, Be, be);
    return De;
  }
  function M(ye, oe, fe, $e, Be, be, ve) {
    oe.writelen = $e, oe.writecb = ve, oe.writing = !0, oe.sync = !0, oe.destroyed ? oe.onwrite(new ie("write")) : fe ? ye._writev(Be, oe.onwrite) : ye._write(Be, be, oe.onwrite), oe.sync = !1;
  }
  function $(ye, oe, fe, $e, Be) {
    --oe.pendingcb, fe ? (process$3.nextTick(Be, $e), process$3.nextTick(ae, ye, oe), ye._writableState.errorEmitted = !0, ce(ye, $e)) : (Be($e), ye._writableState.errorEmitted = !0, ce(ye, $e), ae(ye, oe));
  }
  function O(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function J(ye, oe) {
    var fe = ye._writableState, $e = fe.sync, Be = fe.writecb;
    if (typeof Be != "function")
      throw new Q();
    if (O(fe), oe)
      $(ye, fe, $e, oe, Be);
    else {
      var be = G(fe) || ye.destroyed;
      !be && !fe.corked && !fe.bufferProcessing && fe.bufferedRequest && z(ye, fe), $e ? process$3.nextTick(Z, ye, fe, be, Be) : Z(ye, fe, be, Be);
    }
  }
  function Z(ye, oe, fe, $e) {
    fe || K(ye, oe), oe.pendingcb--, $e(), ae(ye, oe);
  }
  function K(ye, oe) {
    oe.length === 0 && oe.needDrain && (oe.needDrain = !1, ye.emit("drain"));
  }
  function z(ye, oe) {
    oe.bufferProcessing = !0;
    var fe = oe.bufferedRequest;
    if (ye._writev && fe && fe.next) {
      var $e = oe.bufferedRequestCount, Be = new Array($e), be = oe.corkedRequestsFree;
      be.entry = fe;
      for (var ve = 0, qe = !0; fe; )
        Be[ve] = fe, fe.isBuf || (qe = !1), fe = fe.next, ve += 1;
      Be.allBuffers = qe, M(ye, oe, !0, oe.length, Be, "", be.finish), oe.pendingcb++, oe.lastBufferedRequest = null, be.next ? (oe.corkedRequestsFree = be.next, be.next = null) : oe.corkedRequestsFree = new e(oe), oe.bufferedRequestCount = 0;
    } else {
      for (; fe; ) {
        var De = fe.chunk, Ye = fe.encoding, he = fe.callback, ue = oe.objectMode ? 1 : De.length;
        if (M(ye, oe, !1, ue, De, Ye, he), fe = fe.next, oe.bufferedRequestCount--, oe.writing)
          break;
      }
      fe === null && (oe.lastBufferedRequest = null);
    }
    oe.bufferedRequest = fe, oe.bufferProcessing = !1;
  }
  Ee.prototype._write = function(ye, oe, fe) {
    fe(new X("_write()"));
  }, Ee.prototype._writev = null, Ee.prototype.end = function(ye, oe, fe) {
    var $e = this._writableState;
    return typeof ye == "function" ? (fe = ye, ye = null, oe = null) : typeof oe == "function" && (fe = oe, oe = null), ye != null && this.write(ye, oe), $e.corked && ($e.corked = 1, this.uncork()), $e.ending || ge(this, $e, fe), this;
  }, Object.defineProperty(Ee.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function G(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function D(ye, oe) {
    ye._final(function(fe) {
      oe.pendingcb--, fe && ce(ye, fe), oe.prefinished = !0, ye.emit("prefinish"), ae(ye, oe);
    });
  }
  function F(ye, oe) {
    !oe.prefinished && !oe.finalCalled && (typeof ye._final == "function" && !oe.destroyed ? (oe.pendingcb++, oe.finalCalled = !0, process$3.nextTick(D, ye, oe)) : (oe.prefinished = !0, ye.emit("prefinish")));
  }
  function ae(ye, oe) {
    var fe = G(oe);
    if (fe && (F(ye, oe), oe.pendingcb === 0 && (oe.finished = !0, ye.emit("finish"), oe.autoDestroy))) {
      var $e = ye._readableState;
      (!$e || $e.autoDestroy && $e.endEmitted) && ye.destroy();
    }
    return fe;
  }
  function ge(ye, oe, fe) {
    oe.ending = !0, ae(ye, oe), fe && (oe.finished ? process$3.nextTick(fe) : ye.once("finish", fe)), oe.ended = !0, ye.writable = !1;
  }
  function xe(ye, oe, fe) {
    var $e = ye.entry;
    for (ye.entry = null; $e; ) {
      var Be = $e.callback;
      oe.pendingcb--, Be(fe), $e = $e.next;
    }
    oe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(Ee.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(oe) {
      this._writableState && (this._writableState.destroyed = oe);
    }
  }), Ee.prototype.destroy = P.destroy, Ee.prototype._undestroy = P.undestroy, Ee.prototype._destroy = function(ye, oe) {
    oe(ye);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var e = Object.keys || function(I) {
    var B = [];
    for (var H in I)
      B.push(H);
    return B;
  };
  _stream_duplex$1 = q;
  var o = require_stream_readable$1(), S = require_stream_writable$1();
  requireInherits_browser()(q, o);
  for (var g = e(S.prototype), U = 0; U < g.length; U++) {
    var h = g[U];
    q.prototype[h] || (q.prototype[h] = S.prototype[h]);
  }
  function q(I) {
    if (!(this instanceof q))
      return new q(I);
    o.call(this, I), S.call(this, I), this.allowHalfOpen = !0, I && (I.readable === !1 && (this.readable = !1), I.writable === !1 && (this.writable = !1), I.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", A)));
  }
  Object.defineProperty(q.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(q.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function A() {
    this._writableState.ended || process$3.nextTick(P, this);
  }
  function P(I) {
    I.end();
  }
  return Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(B) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = B, this._writableState.destroyed = B);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function(e, o) {
    var S = buffer$3, g = S.Buffer;
    function U(q, A) {
      for (var P in q)
        A[P] = q[P];
    }
    g.from && g.alloc && g.allocUnsafe && g.allocUnsafeSlow ? e.exports = S : (U(S, o), o.Buffer = h);
    function h(q, A, P) {
      return g(q, A, P);
    }
    h.prototype = Object.create(g.prototype), U(g, h), h.from = function(q, A, P) {
      if (typeof q == "number")
        throw new TypeError("Argument must not be a number");
      return g(q, A, P);
    }, h.alloc = function(q, A, P) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      var I = g(q);
      return A !== void 0 ? typeof P == "string" ? I.fill(A, P) : I.fill(A) : I.fill(0), I;
    }, h.allocUnsafe = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return g(q);
    }, h.allocUnsafeSlow = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return S.SlowBuffer(q);
    };
  }(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var e = requireSafeBuffer$1().Buffer, o = e.isEncoding || function(te) {
    switch (te = "" + te, te && te.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function S(te) {
    if (!te)
      return "utf8";
    for (var se; ; )
      switch (te) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return te;
        default:
          if (se)
            return;
          te = ("" + te).toLowerCase(), se = !0;
      }
  }
  function g(te) {
    var se = S(te);
    if (typeof se != "string" && (e.isEncoding === o || !o(te)))
      throw new Error("Unknown encoding: " + te);
    return se || te;
  }
  string_decoder.StringDecoder = U;
  function U(te) {
    this.encoding = g(te);
    var se;
    switch (this.encoding) {
      case "utf16le":
        this.text = H, this.end = V, se = 4;
        break;
      case "utf8":
        this.fillLast = P, se = 4;
        break;
      case "base64":
        this.text = X, this.end = Q, se = 3;
        break;
      default:
        this.write = ee, this.end = ie;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(se);
  }
  U.prototype.write = function(te) {
    if (te.length === 0)
      return "";
    var se, le;
    if (this.lastNeed) {
      if (se = this.fillLast(te), se === void 0)
        return "";
      le = this.lastNeed, this.lastNeed = 0;
    } else
      le = 0;
    return le < te.length ? se ? se + this.text(te, le) : this.text(te, le) : se || "";
  }, U.prototype.end = B, U.prototype.text = I, U.prototype.fillLast = function(te) {
    if (this.lastNeed <= te.length)
      return te.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    te.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, te.length), this.lastNeed -= te.length;
  };
  function h(te) {
    return te <= 127 ? 0 : te >> 5 === 6 ? 2 : te >> 4 === 14 ? 3 : te >> 3 === 30 ? 4 : te >> 6 === 2 ? -1 : -2;
  }
  function q(te, se, le) {
    var ce = se.length - 1;
    if (ce < le)
      return 0;
    var pe = h(se[ce]);
    return pe >= 0 ? (pe > 0 && (te.lastNeed = pe - 1), pe) : --ce < le || pe === -2 ? 0 : (pe = h(se[ce]), pe >= 0 ? (pe > 0 && (te.lastNeed = pe - 2), pe) : --ce < le || pe === -2 ? 0 : (pe = h(se[ce]), pe >= 0 ? (pe > 0 && (pe === 2 ? pe = 0 : te.lastNeed = pe - 3), pe) : 0));
  }
  function A(te, se, le) {
    if ((se[0] & 192) !== 128)
      return te.lastNeed = 0, "";
    if (te.lastNeed > 1 && se.length > 1) {
      if ((se[1] & 192) !== 128)
        return te.lastNeed = 1, "";
      if (te.lastNeed > 2 && se.length > 2 && (se[2] & 192) !== 128)
        return te.lastNeed = 2, "";
    }
  }
  function P(te) {
    var se = this.lastTotal - this.lastNeed, le = A(this, te);
    if (le !== void 0)
      return le;
    if (this.lastNeed <= te.length)
      return te.copy(this.lastChar, se, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    te.copy(this.lastChar, se, 0, te.length), this.lastNeed -= te.length;
  }
  function I(te, se) {
    var le = q(this, te, se);
    if (!this.lastNeed)
      return te.toString("utf8", se);
    this.lastTotal = le;
    var ce = te.length - (le - this.lastNeed);
    return te.copy(this.lastChar, 0, ce), te.toString("utf8", se, ce);
  }
  function B(te) {
    var se = te && te.length ? this.write(te) : "";
    return this.lastNeed ? se + "" : se;
  }
  function H(te, se) {
    if ((te.length - se) % 2 === 0) {
      var le = te.toString("utf16le", se);
      if (le) {
        var ce = le.charCodeAt(le.length - 1);
        if (ce >= 55296 && ce <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = te[te.length - 2], this.lastChar[1] = te[te.length - 1], le.slice(0, -1);
      }
      return le;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = te[te.length - 1], te.toString("utf16le", se, te.length - 1);
  }
  function V(te) {
    var se = te && te.length ? this.write(te) : "";
    if (this.lastNeed) {
      var le = this.lastTotal - this.lastNeed;
      return se + this.lastChar.toString("utf16le", 0, le);
    }
    return se;
  }
  function X(te, se) {
    var le = (te.length - se) % 3;
    return le === 0 ? te.toString("base64", se) : (this.lastNeed = 3 - le, this.lastTotal = 3, le === 1 ? this.lastChar[0] = te[te.length - 1] : (this.lastChar[0] = te[te.length - 2], this.lastChar[1] = te[te.length - 1]), te.toString("base64", se, te.length - le));
  }
  function Q(te) {
    var se = te && te.length ? this.write(te) : "";
    return this.lastNeed ? se + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : se;
  }
  function ee(te) {
    return te.toString(this.encoding);
  }
  function ie(te) {
    return te && te.length ? this.write(te) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream;
  hasRequiredEndOfStream = 1;
  var e = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function o(h) {
    var q = !1;
    return function() {
      if (!q) {
        q = !0;
        for (var A = arguments.length, P = new Array(A), I = 0; I < A; I++)
          P[I] = arguments[I];
        h.apply(this, P);
      }
    };
  }
  function S() {
  }
  function g(h) {
    return h.setHeader && typeof h.abort == "function";
  }
  function U(h, q, A) {
    if (typeof q == "function")
      return U(h, null, q);
    q || (q = {}), A = o(A || S);
    var P = q.readable || q.readable !== !1 && h.readable, I = q.writable || q.writable !== !1 && h.writable, B = function() {
      h.writable || V();
    }, H = h._writableState && h._writableState.finished, V = function() {
      I = !1, H = !0, P || A.call(h);
    }, X = h._readableState && h._readableState.endEmitted, Q = function() {
      P = !1, X = !0, I || A.call(h);
    }, ee = function(le) {
      A.call(h, le);
    }, ie = function() {
      var le;
      if (P && !X)
        return (!h._readableState || !h._readableState.ended) && (le = new e()), A.call(h, le);
      if (I && !H)
        return (!h._writableState || !h._writableState.ended) && (le = new e()), A.call(h, le);
    }, te = function() {
      h.req.on("finish", V);
    };
    return g(h) ? (h.on("complete", V), h.on("abort", ie), h.req ? te() : h.on("request", te)) : I && !h._writableState && (h.on("end", B), h.on("close", B)), h.on("end", Q), h.on("finish", V), q.error !== !1 && h.on("error", ee), h.on("close", ie), function() {
      h.removeListener("complete", V), h.removeListener("abort", ie), h.removeListener("request", te), h.req && h.req.removeListener("finish", V), h.removeListener("end", B), h.removeListener("close", B), h.removeListener("finish", V), h.removeListener("end", Q), h.removeListener("error", ee), h.removeListener("close", ie);
    };
  }
  return endOfStream = U, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var e;
  function o(le, ce, pe) {
    return ce = S(ce), ce in le ? Object.defineProperty(le, ce, { value: pe, enumerable: !0, configurable: !0, writable: !0 }) : le[ce] = pe, le;
  }
  function S(le) {
    var ce = g(le, "string");
    return typeof ce == "symbol" ? ce : String(ce);
  }
  function g(le, ce) {
    if (typeof le != "object" || le === null)
      return le;
    var pe = le[Symbol.toPrimitive];
    if (pe !== void 0) {
      var me = pe.call(le, ce || "default");
      if (typeof me != "object")
        return me;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ce === "string" ? String : Number)(le);
  }
  var U = requireEndOfStream(), h = Symbol("lastResolve"), q = Symbol("lastReject"), A = Symbol("error"), P = Symbol("ended"), I = Symbol("lastPromise"), B = Symbol("handlePromise"), H = Symbol("stream");
  function V(le, ce) {
    return {
      value: le,
      done: ce
    };
  }
  function X(le) {
    var ce = le[h];
    if (ce !== null) {
      var pe = le[H].read();
      pe !== null && (le[I] = null, le[h] = null, le[q] = null, ce(V(pe, !1)));
    }
  }
  function Q(le) {
    process$3.nextTick(X, le);
  }
  function ee(le, ce) {
    return function(pe, me) {
      le.then(function() {
        if (ce[P]) {
          pe(V(void 0, !0));
          return;
        }
        ce[B](pe, me);
      }, me);
    };
  }
  var ie = Object.getPrototypeOf(function() {
  }), te = Object.setPrototypeOf((e = {
    get stream() {
      return this[H];
    },
    next: function() {
      var ce = this, pe = this[A];
      if (pe !== null)
        return Promise.reject(pe);
      if (this[P])
        return Promise.resolve(V(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(Re, Ne) {
          process$3.nextTick(function() {
            ce[A] ? Ne(ce[A]) : Re(V(void 0, !0));
          });
        });
      var me = this[I], Me;
      if (me)
        Me = new Promise(ee(me, this));
      else {
        var Ee = this[H].read();
        if (Ee !== null)
          return Promise.resolve(V(Ee, !1));
        Me = new Promise(this[B]);
      }
      return this[I] = Me, Me;
    }
  }, o(e, Symbol.asyncIterator, function() {
    return this;
  }), o(e, "return", function() {
    var ce = this;
    return new Promise(function(pe, me) {
      ce[H].destroy(null, function(Me) {
        if (Me) {
          me(Me);
          return;
        }
        pe(V(void 0, !0));
      });
    });
  }), e), ie), se = function(ce) {
    var pe, me = Object.create(te, (pe = {}, o(pe, H, {
      value: ce,
      writable: !0
    }), o(pe, h, {
      value: null,
      writable: !0
    }), o(pe, q, {
      value: null,
      writable: !0
    }), o(pe, A, {
      value: null,
      writable: !0
    }), o(pe, P, {
      value: ce._readableState.endEmitted,
      writable: !0
    }), o(pe, B, {
      value: function(Ee, Re) {
        var Ne = me[H].read();
        Ne ? (me[I] = null, me[h] = null, me[q] = null, Ee(V(Ne, !1))) : (me[h] = Ee, me[q] = Re);
      },
      writable: !0
    }), pe));
    return me[I] = null, U(ce, function(Me) {
      if (Me && Me.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Ee = me[q];
        Ee !== null && (me[I] = null, me[h] = null, me[q] = null, Ee(Me)), me[A] = Me;
        return;
      }
      var Re = me[h];
      Re !== null && (me[I] = null, me[h] = null, me[q] = null, Re(V(void 0, !0))), me[P] = !0;
    }), ce.on("readable", Q.bind(null, me)), me;
  };
  return async_iterator = se, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Re;
  var e;
  Re.ReadableState = Ee, eventsExports.EventEmitter;
  var o = function(ve, qe) {
    return ve.listeners(qe).length;
  }, S = requireStreamBrowser$1(), g = buffer$3.Buffer, U = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function h(be) {
    return g.from(be);
  }
  function q(be) {
    return g.isBuffer(be) || be instanceof U;
  }
  var A = requireUtil$1(), P;
  A && A.debuglog ? P = A.debuglog("stream") : P = function() {
  };
  var I = requireBuffer_list(), B = requireDestroy$1(), H = requireState(), V = H.getHighWaterMark, X = requireErrorsBrowser().codes, Q = X.ERR_INVALID_ARG_TYPE, ee = X.ERR_STREAM_PUSH_AFTER_EOF, ie = X.ERR_METHOD_NOT_IMPLEMENTED, te = X.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, se, le, ce;
  requireInherits_browser()(Re, S);
  var pe = B.errorOrDestroy, me = ["error", "close", "destroy", "pause", "resume"];
  function Me(be, ve, qe) {
    if (typeof be.prependListener == "function")
      return be.prependListener(ve, qe);
    !be._events || !be._events[ve] ? be.on(ve, qe) : Array.isArray(be._events[ve]) ? be._events[ve].unshift(qe) : be._events[ve] = [qe, be._events[ve]];
  }
  function Ee(be, ve, qe) {
    e = e || require_stream_duplex$1(), be = be || {}, typeof qe != "boolean" && (qe = ve instanceof e), this.objectMode = !!be.objectMode, qe && (this.objectMode = this.objectMode || !!be.readableObjectMode), this.highWaterMark = V(this, be, "readableHighWaterMark", qe), this.buffer = new I(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = be.emitClose !== !1, this.autoDestroy = !!be.autoDestroy, this.destroyed = !1, this.defaultEncoding = be.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, be.encoding && (se || (se = requireString_decoder().StringDecoder), this.decoder = new se(be.encoding), this.encoding = be.encoding);
  }
  function Re(be) {
    if (e = e || require_stream_duplex$1(), !(this instanceof Re))
      return new Re(be);
    var ve = this instanceof e;
    this._readableState = new Ee(be, this, ve), this.readable = !0, be && (typeof be.read == "function" && (this._read = be.read), typeof be.destroy == "function" && (this._destroy = be.destroy)), S.call(this);
  }
  Object.defineProperty(Re.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(ve) {
      this._readableState && (this._readableState.destroyed = ve);
    }
  }), Re.prototype.destroy = B.destroy, Re.prototype._undestroy = B.undestroy, Re.prototype._destroy = function(be, ve) {
    ve(be);
  }, Re.prototype.push = function(be, ve) {
    var qe = this._readableState, De;
    return qe.objectMode ? De = !0 : typeof be == "string" && (ve = ve || qe.defaultEncoding, ve !== qe.encoding && (be = g.from(be, ve), ve = ""), De = !0), Ne(this, be, ve, !1, De);
  }, Re.prototype.unshift = function(be) {
    return Ne(this, be, null, !0, !1);
  };
  function Ne(be, ve, qe, De, Ye) {
    P("readableAddChunk", ve);
    var he = be._readableState;
    if (ve === null)
      he.reading = !1, J(be, he);
    else {
      var ue;
      if (Ye || (ue = Y(he, ve)), ue)
        pe(be, ue);
      else if (he.objectMode || ve && ve.length > 0)
        if (typeof ve != "string" && !he.objectMode && Object.getPrototypeOf(ve) !== g.prototype && (ve = h(ve)), De)
          he.endEmitted ? pe(be, new te()) : ne(be, he, ve, !0);
        else if (he.ended)
          pe(be, new ee());
        else {
          if (he.destroyed)
            return !1;
          he.reading = !1, he.decoder && !qe ? (ve = he.decoder.write(ve), he.objectMode || ve.length !== 0 ? ne(be, he, ve, !1) : z(be, he)) : ne(be, he, ve, !1);
        }
      else
        De || (he.reading = !1, z(be, he));
    }
    return !he.ended && (he.length < he.highWaterMark || he.length === 0);
  }
  function ne(be, ve, qe, De) {
    ve.flowing && ve.length === 0 && !ve.sync ? (ve.awaitDrain = 0, be.emit("data", qe)) : (ve.length += ve.objectMode ? 1 : qe.length, De ? ve.buffer.unshift(qe) : ve.buffer.push(qe), ve.needReadable && Z(be)), z(be, ve);
  }
  function Y(be, ve) {
    var qe;
    return !q(ve) && typeof ve != "string" && ve !== void 0 && !be.objectMode && (qe = new Q("chunk", ["string", "Buffer", "Uint8Array"], ve)), qe;
  }
  Re.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Re.prototype.setEncoding = function(be) {
    se || (se = requireString_decoder().StringDecoder);
    var ve = new se(be);
    this._readableState.decoder = ve, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var qe = this._readableState.buffer.head, De = ""; qe !== null; )
      De += ve.write(qe.data), qe = qe.next;
    return this._readableState.buffer.clear(), De !== "" && this._readableState.buffer.push(De), this._readableState.length = De.length, this;
  };
  var M = 1073741824;
  function $(be) {
    return be >= M ? be = M : (be--, be |= be >>> 1, be |= be >>> 2, be |= be >>> 4, be |= be >>> 8, be |= be >>> 16, be++), be;
  }
  function O(be, ve) {
    return be <= 0 || ve.length === 0 && ve.ended ? 0 : ve.objectMode ? 1 : be !== be ? ve.flowing && ve.length ? ve.buffer.head.data.length : ve.length : (be > ve.highWaterMark && (ve.highWaterMark = $(be)), be <= ve.length ? be : ve.ended ? ve.length : (ve.needReadable = !0, 0));
  }
  Re.prototype.read = function(be) {
    P("read", be), be = parseInt(be, 10);
    var ve = this._readableState, qe = be;
    if (be !== 0 && (ve.emittedReadable = !1), be === 0 && ve.needReadable && ((ve.highWaterMark !== 0 ? ve.length >= ve.highWaterMark : ve.length > 0) || ve.ended))
      return P("read: emitReadable", ve.length, ve.ended), ve.length === 0 && ve.ended ? fe(this) : Z(this), null;
    if (be = O(be, ve), be === 0 && ve.ended)
      return ve.length === 0 && fe(this), null;
    var De = ve.needReadable;
    P("need readable", De), (ve.length === 0 || ve.length - be < ve.highWaterMark) && (De = !0, P("length less than watermark", De)), ve.ended || ve.reading ? (De = !1, P("reading or ended", De)) : De && (P("do read"), ve.reading = !0, ve.sync = !0, ve.length === 0 && (ve.needReadable = !0), this._read(ve.highWaterMark), ve.sync = !1, ve.reading || (be = O(qe, ve)));
    var Ye;
    return be > 0 ? Ye = oe(be, ve) : Ye = null, Ye === null ? (ve.needReadable = ve.length <= ve.highWaterMark, be = 0) : (ve.length -= be, ve.awaitDrain = 0), ve.length === 0 && (ve.ended || (ve.needReadable = !0), qe !== be && ve.ended && fe(this)), Ye !== null && this.emit("data", Ye), Ye;
  };
  function J(be, ve) {
    if (P("onEofChunk"), !ve.ended) {
      if (ve.decoder) {
        var qe = ve.decoder.end();
        qe && qe.length && (ve.buffer.push(qe), ve.length += ve.objectMode ? 1 : qe.length);
      }
      ve.ended = !0, ve.sync ? Z(be) : (ve.needReadable = !1, ve.emittedReadable || (ve.emittedReadable = !0, K(be)));
    }
  }
  function Z(be) {
    var ve = be._readableState;
    P("emitReadable", ve.needReadable, ve.emittedReadable), ve.needReadable = !1, ve.emittedReadable || (P("emitReadable", ve.flowing), ve.emittedReadable = !0, process$3.nextTick(K, be));
  }
  function K(be) {
    var ve = be._readableState;
    P("emitReadable_", ve.destroyed, ve.length, ve.ended), !ve.destroyed && (ve.length || ve.ended) && (be.emit("readable"), ve.emittedReadable = !1), ve.needReadable = !ve.flowing && !ve.ended && ve.length <= ve.highWaterMark, ye(be);
  }
  function z(be, ve) {
    ve.readingMore || (ve.readingMore = !0, process$3.nextTick(G, be, ve));
  }
  function G(be, ve) {
    for (; !ve.reading && !ve.ended && (ve.length < ve.highWaterMark || ve.flowing && ve.length === 0); ) {
      var qe = ve.length;
      if (P("maybeReadMore read 0"), be.read(0), qe === ve.length)
        break;
    }
    ve.readingMore = !1;
  }
  Re.prototype._read = function(be) {
    pe(this, new ie("_read()"));
  }, Re.prototype.pipe = function(be, ve) {
    var qe = this, De = this._readableState;
    switch (De.pipesCount) {
      case 0:
        De.pipes = be;
        break;
      case 1:
        De.pipes = [De.pipes, be];
        break;
      default:
        De.pipes.push(be);
        break;
    }
    De.pipesCount += 1, P("pipe count=%d opts=%j", De.pipesCount, ve);
    var Ye = (!ve || ve.end !== !1) && be !== process$3.stdout && be !== process$3.stderr, he = Ye ? de : je;
    De.endEmitted ? process$3.nextTick(he) : qe.once("end", he), be.on("unpipe", ue);
    function ue(Ke, ot) {
      P("onunpipe"), Ke === qe && ot && ot.hasUnpiped === !1 && (ot.hasUnpiped = !0, He());
    }
    function de() {
      P("onend"), be.end();
    }
    var _e = D(qe);
    be.on("drain", _e);
    var Pe = !1;
    function He() {
      P("cleanup"), be.removeListener("close", Ie), be.removeListener("finish", Fe), be.removeListener("drain", _e), be.removeListener("error", nt), be.removeListener("unpipe", ue), qe.removeListener("end", de), qe.removeListener("end", je), qe.removeListener("data", Ve), Pe = !0, De.awaitDrain && (!be._writableState || be._writableState.needDrain) && _e();
    }
    qe.on("data", Ve);
    function Ve(Ke) {
      P("ondata");
      var ot = be.write(Ke);
      P("dest.write", ot), ot === !1 && ((De.pipesCount === 1 && De.pipes === be || De.pipesCount > 1 && Be(De.pipes, be) !== -1) && !Pe && (P("false write response, pause", De.awaitDrain), De.awaitDrain++), qe.pause());
    }
    function nt(Ke) {
      P("onerror", Ke), je(), be.removeListener("error", nt), o(be, "error") === 0 && pe(be, Ke);
    }
    Me(be, "error", nt);
    function Ie() {
      be.removeListener("finish", Fe), je();
    }
    be.once("close", Ie);
    function Fe() {
      P("onfinish"), be.removeListener("close", Ie), je();
    }
    be.once("finish", Fe);
    function je() {
      P("unpipe"), qe.unpipe(be);
    }
    return be.emit("pipe", qe), De.flowing || (P("pipe resume"), qe.resume()), be;
  };
  function D(be) {
    return function() {
      var qe = be._readableState;
      P("pipeOnDrain", qe.awaitDrain), qe.awaitDrain && qe.awaitDrain--, qe.awaitDrain === 0 && o(be, "data") && (qe.flowing = !0, ye(be));
    };
  }
  Re.prototype.unpipe = function(be) {
    var ve = this._readableState, qe = {
      hasUnpiped: !1
    };
    if (ve.pipesCount === 0)
      return this;
    if (ve.pipesCount === 1)
      return be && be !== ve.pipes ? this : (be || (be = ve.pipes), ve.pipes = null, ve.pipesCount = 0, ve.flowing = !1, be && be.emit("unpipe", this, qe), this);
    if (!be) {
      var De = ve.pipes, Ye = ve.pipesCount;
      ve.pipes = null, ve.pipesCount = 0, ve.flowing = !1;
      for (var he = 0; he < Ye; he++)
        De[he].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var ue = Be(ve.pipes, be);
    return ue === -1 ? this : (ve.pipes.splice(ue, 1), ve.pipesCount -= 1, ve.pipesCount === 1 && (ve.pipes = ve.pipes[0]), be.emit("unpipe", this, qe), this);
  }, Re.prototype.on = function(be, ve) {
    var qe = S.prototype.on.call(this, be, ve), De = this._readableState;
    return be === "data" ? (De.readableListening = this.listenerCount("readable") > 0, De.flowing !== !1 && this.resume()) : be === "readable" && !De.endEmitted && !De.readableListening && (De.readableListening = De.needReadable = !0, De.flowing = !1, De.emittedReadable = !1, P("on readable", De.length, De.reading), De.length ? Z(this) : De.reading || process$3.nextTick(ae, this)), qe;
  }, Re.prototype.addListener = Re.prototype.on, Re.prototype.removeListener = function(be, ve) {
    var qe = S.prototype.removeListener.call(this, be, ve);
    return be === "readable" && process$3.nextTick(F, this), qe;
  }, Re.prototype.removeAllListeners = function(be) {
    var ve = S.prototype.removeAllListeners.apply(this, arguments);
    return (be === "readable" || be === void 0) && process$3.nextTick(F, this), ve;
  };
  function F(be) {
    var ve = be._readableState;
    ve.readableListening = be.listenerCount("readable") > 0, ve.resumeScheduled && !ve.paused ? ve.flowing = !0 : be.listenerCount("data") > 0 && be.resume();
  }
  function ae(be) {
    P("readable nexttick read 0"), be.read(0);
  }
  Re.prototype.resume = function() {
    var be = this._readableState;
    return be.flowing || (P("resume"), be.flowing = !be.readableListening, ge(this, be)), be.paused = !1, this;
  };
  function ge(be, ve) {
    ve.resumeScheduled || (ve.resumeScheduled = !0, process$3.nextTick(xe, be, ve));
  }
  function xe(be, ve) {
    P("resume", ve.reading), ve.reading || be.read(0), ve.resumeScheduled = !1, be.emit("resume"), ye(be), ve.flowing && !ve.reading && be.read(0);
  }
  Re.prototype.pause = function() {
    return P("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (P("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(be) {
    var ve = be._readableState;
    for (P("flow", ve.flowing); ve.flowing && be.read() !== null; )
      ;
  }
  Re.prototype.wrap = function(be) {
    var ve = this, qe = this._readableState, De = !1;
    be.on("end", function() {
      if (P("wrapped end"), qe.decoder && !qe.ended) {
        var ue = qe.decoder.end();
        ue && ue.length && ve.push(ue);
      }
      ve.push(null);
    }), be.on("data", function(ue) {
      if (P("wrapped data"), qe.decoder && (ue = qe.decoder.write(ue)), !(qe.objectMode && ue == null) && !(!qe.objectMode && (!ue || !ue.length))) {
        var de = ve.push(ue);
        de || (De = !0, be.pause());
      }
    });
    for (var Ye in be)
      this[Ye] === void 0 && typeof be[Ye] == "function" && (this[Ye] = /* @__PURE__ */ function(de) {
        return function() {
          return be[de].apply(be, arguments);
        };
      }(Ye));
    for (var he = 0; he < me.length; he++)
      be.on(me[he], this.emit.bind(this, me[he]));
    return this._read = function(ue) {
      P("wrapped _read", ue), De && (De = !1, be.resume());
    }, this;
  }, typeof Symbol == "function" && (Re.prototype[Symbol.asyncIterator] = function() {
    return le === void 0 && (le = requireAsync_iterator()), le(this);
  }), Object.defineProperty(Re.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Re.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Re.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(ve) {
      this._readableState && (this._readableState.flowing = ve);
    }
  }), Re._fromList = oe, Object.defineProperty(Re.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function oe(be, ve) {
    if (ve.length === 0)
      return null;
    var qe;
    return ve.objectMode ? qe = ve.buffer.shift() : !be || be >= ve.length ? (ve.decoder ? qe = ve.buffer.join("") : ve.buffer.length === 1 ? qe = ve.buffer.first() : qe = ve.buffer.concat(ve.length), ve.buffer.clear()) : qe = ve.buffer.consume(be, ve.decoder), qe;
  }
  function fe(be) {
    var ve = be._readableState;
    P("endReadable", ve.endEmitted), ve.endEmitted || (ve.ended = !0, process$3.nextTick($e, ve, be));
  }
  function $e(be, ve) {
    if (P("endReadableNT", be.endEmitted, be.length), !be.endEmitted && be.length === 0 && (be.endEmitted = !0, ve.readable = !1, ve.emit("end"), be.autoDestroy)) {
      var qe = ve._writableState;
      (!qe || qe.autoDestroy && qe.finished) && ve.destroy();
    }
  }
  typeof Symbol == "function" && (Re.from = function(be, ve) {
    return ce === void 0 && (ce = requireFromBrowser()), ce(Re, be, ve);
  });
  function Be(be, ve) {
    for (var qe = 0, De = be.length; qe < De; qe++)
      if (be[qe] === ve)
        return qe;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1)
    return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = A;
  var e = requireErrorsBrowser().codes, o = e.ERR_METHOD_NOT_IMPLEMENTED, S = e.ERR_MULTIPLE_CALLBACK, g = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, U = e.ERR_TRANSFORM_WITH_LENGTH_0, h = require_stream_duplex$1();
  requireInherits_browser()(A, h);
  function q(B, H) {
    var V = this._transformState;
    V.transforming = !1;
    var X = V.writecb;
    if (X === null)
      return this.emit("error", new S());
    V.writechunk = null, V.writecb = null, H != null && this.push(H), X(B);
    var Q = this._readableState;
    Q.reading = !1, (Q.needReadable || Q.length < Q.highWaterMark) && this._read(Q.highWaterMark);
  }
  function A(B) {
    if (!(this instanceof A))
      return new A(B);
    h.call(this, B), this._transformState = {
      afterTransform: q.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", P);
  }
  function P() {
    var B = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(H, V) {
      I(B, H, V);
    }) : I(this, null, null);
  }
  A.prototype.push = function(B, H) {
    return this._transformState.needTransform = !1, h.prototype.push.call(this, B, H);
  }, A.prototype._transform = function(B, H, V) {
    V(new o("_transform()"));
  }, A.prototype._write = function(B, H, V) {
    var X = this._transformState;
    if (X.writecb = V, X.writechunk = B, X.writeencoding = H, !X.transforming) {
      var Q = this._readableState;
      (X.needTransform || Q.needReadable || Q.length < Q.highWaterMark) && this._read(Q.highWaterMark);
    }
  }, A.prototype._read = function(B) {
    var H = this._transformState;
    H.writechunk !== null && !H.transforming ? (H.transforming = !0, this._transform(H.writechunk, H.writeencoding, H.afterTransform)) : H.needTransform = !0;
  }, A.prototype._destroy = function(B, H) {
    h.prototype._destroy.call(this, B, function(V) {
      H(V);
    });
  };
  function I(B, H, V) {
    if (H)
      return B.emit("error", H);
    if (V != null && B.push(V), B._writableState.length)
      throw new U();
    if (B._transformState.transforming)
      throw new g();
    return B.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1)
    return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = o;
  var e = require_stream_transform$1();
  requireInherits_browser()(o, e);
  function o(S) {
    if (!(this instanceof o))
      return new o(S);
    e.call(this, S);
  }
  return o.prototype._transform = function(S, g, U) {
    U(null, S);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1;
  hasRequiredPipeline = 1;
  var e;
  function o(V) {
    var X = !1;
    return function() {
      X || (X = !0, V.apply(void 0, arguments));
    };
  }
  var S = requireErrorsBrowser().codes, g = S.ERR_MISSING_ARGS, U = S.ERR_STREAM_DESTROYED;
  function h(V) {
    if (V)
      throw V;
  }
  function q(V) {
    return V.setHeader && typeof V.abort == "function";
  }
  function A(V, X, Q, ee) {
    ee = o(ee);
    var ie = !1;
    V.on("close", function() {
      ie = !0;
    }), e === void 0 && (e = requireEndOfStream()), e(V, {
      readable: X,
      writable: Q
    }, function(se) {
      if (se)
        return ee(se);
      ie = !0, ee();
    });
    var te = !1;
    return function(se) {
      if (!ie && !te) {
        if (te = !0, q(V))
          return V.abort();
        if (typeof V.destroy == "function")
          return V.destroy();
        ee(se || new U("pipe"));
      }
    };
  }
  function P(V) {
    V();
  }
  function I(V, X) {
    return V.pipe(X);
  }
  function B(V) {
    return !V.length || typeof V[V.length - 1] != "function" ? h : V.pop();
  }
  function H() {
    for (var V = arguments.length, X = new Array(V), Q = 0; Q < V; Q++)
      X[Q] = arguments[Q];
    var ee = B(X);
    if (Array.isArray(X[0]) && (X = X[0]), X.length < 2)
      throw new g("streams");
    var ie, te = X.map(function(se, le) {
      var ce = le < X.length - 1, pe = le > 0;
      return A(se, ce, pe, function(me) {
        ie || (ie = me), me && te.forEach(P), !ce && (te.forEach(P), ee(ie));
      });
    });
    return X.reduce(I);
  }
  return pipeline_1 = H, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(e, o) {
    o = e.exports = require_stream_readable$1(), o.Stream = o, o.Readable = o, o.Writable = require_stream_writable$1(), o.Duplex = require_stream_duplex$1(), o.Transform = require_stream_transform$1(), o.PassThrough = require_stream_passthrough$1(), o.finished = requireEndOfStream(), o.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse)
    return response;
  hasRequiredResponse = 1;
  var e = requireCapability(), o = requireInherits_browser(), S = requireReadableBrowser$1(), g = response.readyStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  }, U = response.IncomingMessage = function(h, q, A, P) {
    var I = this;
    if (S.Readable.call(I), I._mode = A, I.headers = {}, I.rawHeaders = [], I.trailers = {}, I.rawTrailers = [], I.on("end", function() {
      process$3.nextTick(function() {
        I.emit("close");
      });
    }), A === "fetch") {
      let ee = function() {
        H.read().then(function(ie) {
          if (!I._destroyed) {
            if (P(ie.done), ie.done) {
              I.push(null);
              return;
            }
            I.push(buffer$3.Buffer.from(ie.value)), ee();
          }
        }).catch(function(ie) {
          P(!0), I._destroyed || I.emit("error", ie);
        });
      };
      if (I._fetchResponse = q, I.url = q.url, I.statusCode = q.status, I.statusMessage = q.statusText, q.headers.forEach(function(ie, te) {
        I.headers[te.toLowerCase()] = ie, I.rawHeaders.push(te, ie);
      }), e.writableStream) {
        var B = new WritableStream({
          write: function(ie) {
            return P(!1), new Promise(function(te, se) {
              I._destroyed ? se() : I.push(buffer$3.Buffer.from(ie)) ? te() : I._resumeFetch = te;
            });
          },
          close: function() {
            P(!0), I._destroyed || I.push(null);
          },
          abort: function(ie) {
            P(!0), I._destroyed || I.emit("error", ie);
          }
        });
        try {
          q.body.pipeTo(B).catch(function(ie) {
            P(!0), I._destroyed || I.emit("error", ie);
          });
          return;
        } catch {
        }
      }
      var H = q.body.getReader();
      ee();
    } else {
      I._xhr = h, I._pos = 0, I.url = h.responseURL, I.statusCode = h.status, I.statusMessage = h.statusText;
      var V = h.getAllResponseHeaders().split(/\r?\n/);
      if (V.forEach(function(ee) {
        var ie = ee.match(/^([^:]+):\s*(.*)/);
        if (ie) {
          var te = ie[1].toLowerCase();
          te === "set-cookie" ? (I.headers[te] === void 0 && (I.headers[te] = []), I.headers[te].push(ie[2])) : I.headers[te] !== void 0 ? I.headers[te] += ", " + ie[2] : I.headers[te] = ie[2], I.rawHeaders.push(ie[1], ie[2]);
        }
      }), I._charset = "x-user-defined", !e.overrideMimeType) {
        var X = I.rawHeaders["mime-type"];
        if (X) {
          var Q = X.match(/;\s*charset=([^;])(;|$)/);
          Q && (I._charset = Q[1].toLowerCase());
        }
        I._charset || (I._charset = "utf-8");
      }
    }
  };
  return o(U, S.Readable), U.prototype._read = function() {
    var h = this, q = h._resumeFetch;
    q && (h._resumeFetch = null, q());
  }, U.prototype._onXHRProgress = function(h) {
    var q = this, A = q._xhr, P = null;
    switch (q._mode) {
      case "text":
        if (P = A.responseText, P.length > q._pos) {
          var I = P.substr(q._pos);
          if (q._charset === "x-user-defined") {
            for (var B = buffer$3.Buffer.alloc(I.length), H = 0; H < I.length; H++)
              B[H] = I.charCodeAt(H) & 255;
            q.push(B);
          } else
            q.push(I, q._charset);
          q._pos = P.length;
        }
        break;
      case "arraybuffer":
        if (A.readyState !== g.DONE || !A.response)
          break;
        P = A.response, q.push(buffer$3.Buffer.from(new Uint8Array(P)));
        break;
      case "moz-chunked-arraybuffer":
        if (P = A.response, A.readyState !== g.LOADING || !P)
          break;
        q.push(buffer$3.Buffer.from(new Uint8Array(P)));
        break;
      case "ms-stream":
        if (P = A.response, A.readyState !== g.LOADING)
          break;
        var V = new commonjsGlobal$1.MSStreamReader();
        V.onprogress = function() {
          V.result.byteLength > q._pos && (q.push(buffer$3.Buffer.from(new Uint8Array(V.result.slice(q._pos)))), q._pos = V.result.byteLength);
        }, V.onload = function() {
          h(!0), q.push(null);
        }, V.readAsArrayBuffer(P);
        break;
    }
    q._xhr.readyState === g.DONE && q._mode !== "ms-stream" && (h(!0), q.push(null));
  }, response;
}
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest)
    return request.exports;
  hasRequiredRequest = 1;
  var e = requireCapability(), o = requireInherits_browser(), S = requireResponse(), g = requireReadableBrowser$1(), U = S.IncomingMessage, h = S.readyStates;
  function q(B, H) {
    return e.fetch && H ? "fetch" : e.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : e.msstream ? "ms-stream" : e.arraybuffer && B ? "arraybuffer" : "text";
  }
  var A = request.exports = function(B) {
    var H = this;
    g.Writable.call(H), H._opts = B, H._body = [], H._headers = {}, B.auth && H.setHeader("Authorization", "Basic " + buffer$3.Buffer.from(B.auth).toString("base64")), Object.keys(B.headers).forEach(function(Q) {
      H.setHeader(Q, B.headers[Q]);
    });
    var V, X = !0;
    if (B.mode === "disable-fetch" || "requestTimeout" in B && !e.abortController)
      X = !1, V = !0;
    else if (B.mode === "prefer-streaming")
      V = !1;
    else if (B.mode === "allow-wrong-content-type")
      V = !e.overrideMimeType;
    else if (!B.mode || B.mode === "default" || B.mode === "prefer-fast")
      V = !0;
    else
      throw new Error("Invalid value for opts.mode");
    H._mode = q(V, X), H._fetchTimer = null, H._socketTimeout = null, H._socketTimer = null, H.on("finish", function() {
      H._onFinish();
    });
  };
  o(A, g.Writable), A.prototype.setHeader = function(B, H) {
    var V = this, X = B.toLowerCase();
    I.indexOf(X) === -1 && (V._headers[X] = {
      name: B,
      value: H
    });
  }, A.prototype.getHeader = function(B) {
    var H = this._headers[B.toLowerCase()];
    return H ? H.value : null;
  }, A.prototype.removeHeader = function(B) {
    var H = this;
    delete H._headers[B.toLowerCase()];
  }, A.prototype._onFinish = function() {
    var B = this;
    if (!B._destroyed) {
      var H = B._opts;
      "timeout" in H && H.timeout !== 0 && B.setTimeout(H.timeout);
      var V = B._headers, X = null;
      H.method !== "GET" && H.method !== "HEAD" && (X = new Blob(B._body, {
        type: (V["content-type"] || {}).value || ""
      }));
      var Q = [];
      if (Object.keys(V).forEach(function(se) {
        var le = V[se].name, ce = V[se].value;
        Array.isArray(ce) ? ce.forEach(function(pe) {
          Q.push([le, pe]);
        }) : Q.push([le, ce]);
      }), B._mode === "fetch") {
        var ee = null;
        if (e.abortController) {
          var ie = new AbortController();
          ee = ie.signal, B._fetchAbortController = ie, "requestTimeout" in H && H.requestTimeout !== 0 && (B._fetchTimer = commonjsGlobal$1.setTimeout(function() {
            B.emit("requestTimeout"), B._fetchAbortController && B._fetchAbortController.abort();
          }, H.requestTimeout));
        }
        commonjsGlobal$1.fetch(B._opts.url, {
          method: B._opts.method,
          headers: Q,
          body: X || void 0,
          mode: "cors",
          credentials: H.withCredentials ? "include" : "same-origin",
          signal: ee
        }).then(function(se) {
          B._fetchResponse = se, B._resetTimers(!1), B._connect();
        }, function(se) {
          B._resetTimers(!0), B._destroyed || B.emit("error", se);
        });
      } else {
        var te = B._xhr = new commonjsGlobal$1.XMLHttpRequest();
        try {
          te.open(B._opts.method, B._opts.url, !0);
        } catch (se) {
          process$3.nextTick(function() {
            B.emit("error", se);
          });
          return;
        }
        "responseType" in te && (te.responseType = B._mode), "withCredentials" in te && (te.withCredentials = !!H.withCredentials), B._mode === "text" && "overrideMimeType" in te && te.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in H && (te.timeout = H.requestTimeout, te.ontimeout = function() {
          B.emit("requestTimeout");
        }), Q.forEach(function(se) {
          te.setRequestHeader(se[0], se[1]);
        }), B._response = null, te.onreadystatechange = function() {
          switch (te.readyState) {
            case h.LOADING:
            case h.DONE:
              B._onXHRProgress();
              break;
          }
        }, B._mode === "moz-chunked-arraybuffer" && (te.onprogress = function() {
          B._onXHRProgress();
        }), te.onerror = function() {
          B._destroyed || (B._resetTimers(!0), B.emit("error", new Error("XHR error")));
        };
        try {
          te.send(X);
        } catch (se) {
          process$3.nextTick(function() {
            B.emit("error", se);
          });
          return;
        }
      }
    }
  };
  function P(B) {
    try {
      var H = B.status;
      return H !== null && H !== 0;
    } catch {
      return !1;
    }
  }
  A.prototype._onXHRProgress = function() {
    var B = this;
    B._resetTimers(!1), !(!P(B._xhr) || B._destroyed) && (B._response || B._connect(), B._response._onXHRProgress(B._resetTimers.bind(B)));
  }, A.prototype._connect = function() {
    var B = this;
    B._destroyed || (B._response = new U(B._xhr, B._fetchResponse, B._mode, B._resetTimers.bind(B)), B._response.on("error", function(H) {
      B.emit("error", H);
    }), B.emit("response", B._response));
  }, A.prototype._write = function(B, H, V) {
    var X = this;
    X._body.push(B), V();
  }, A.prototype._resetTimers = function(B) {
    var H = this;
    commonjsGlobal$1.clearTimeout(H._socketTimer), H._socketTimer = null, B ? (commonjsGlobal$1.clearTimeout(H._fetchTimer), H._fetchTimer = null) : H._socketTimeout && (H._socketTimer = commonjsGlobal$1.setTimeout(function() {
      H.emit("timeout");
    }, H._socketTimeout));
  }, A.prototype.abort = A.prototype.destroy = function(B) {
    var H = this;
    H._destroyed = !0, H._resetTimers(!0), H._response && (H._response._destroyed = !0), H._xhr ? H._xhr.abort() : H._fetchAbortController && H._fetchAbortController.abort(), B && H.emit("error", B);
  }, A.prototype.end = function(B, H, V) {
    var X = this;
    typeof B == "function" && (V = B, B = void 0), g.Writable.prototype.end.call(X, B, H, V);
  }, A.prototype.setTimeout = function(B, H) {
    var V = this;
    H && V.once("timeout", H), V._socketTimeout = B, V._resetTimers(!1);
  }, A.prototype.flushHeaders = function() {
  }, A.prototype.setNoDelay = function() {
  }, A.prototype.setSocketKeepAlive = function() {
  };
  var I = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];
  return request.exports;
}
var immutable, hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable)
    return immutable;
  hasRequiredImmutable = 1, immutable = o;
  var e = Object.prototype.hasOwnProperty;
  function o() {
    for (var S = {}, g = 0; g < arguments.length; g++) {
      var U = arguments[g];
      for (var h in U)
        e.call(U, h) && (S[h] = U[h]);
    }
    return S;
  }
  return immutable;
}
var browser$b, hasRequiredBrowser$b;
function requireBrowser$b() {
  return hasRequiredBrowser$b || (hasRequiredBrowser$b = 1, browser$b = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    207: "Multi-Status",
    208: "Already Reported",
    226: "IM Used",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    305: "Use Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    421: "Misdirected Request",
    422: "Unprocessable Entity",
    423: "Locked",
    424: "Failed Dependency",
    425: "Unordered Collection",
    426: "Upgrade Required",
    428: "Precondition Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    509: "Bandwidth Limit Exceeded",
    510: "Not Extended",
    511: "Network Authentication Required"
  }), browser$b;
}
var url = { exports: {} }, punycode = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
punycode.exports;
var hasRequiredPunycode;
function requirePunycode() {
  return hasRequiredPunycode || (hasRequiredPunycode = 1, function(e, o) {
    (function(S) {
      var g = o && !o.nodeType && o, U = e && !e.nodeType && e, h = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1;
      (h.global === h || h.window === h || h.self === h) && (S = h);
      var q, A = 2147483647, P = 36, I = 1, B = 26, H = 38, V = 700, X = 72, Q = 128, ee = "-", ie = /^xn--/, te = /[^\x20-\x7E]/, se = /[\x2E\u3002\uFF0E\uFF61]/g, le = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, ce = P - I, pe = Math.floor, me = String.fromCharCode, Me;
      function Ee(G) {
        throw new RangeError(le[G]);
      }
      function Re(G, D) {
        for (var F = G.length, ae = []; F--; )
          ae[F] = D(G[F]);
        return ae;
      }
      function Ne(G, D) {
        var F = G.split("@"), ae = "";
        F.length > 1 && (ae = F[0] + "@", G = F[1]), G = G.replace(se, ".");
        var ge = G.split("."), xe = Re(ge, D).join(".");
        return ae + xe;
      }
      function ne(G) {
        for (var D = [], F = 0, ae = G.length, ge, xe; F < ae; )
          ge = G.charCodeAt(F++), ge >= 55296 && ge <= 56319 && F < ae ? (xe = G.charCodeAt(F++), (xe & 64512) == 56320 ? D.push(((ge & 1023) << 10) + (xe & 1023) + 65536) : (D.push(ge), F--)) : D.push(ge);
        return D;
      }
      function Y(G) {
        return Re(G, function(D) {
          var F = "";
          return D > 65535 && (D -= 65536, F += me(D >>> 10 & 1023 | 55296), D = 56320 | D & 1023), F += me(D), F;
        }).join("");
      }
      function M(G) {
        return G - 48 < 10 ? G - 22 : G - 65 < 26 ? G - 65 : G - 97 < 26 ? G - 97 : P;
      }
      function $(G, D) {
        return G + 22 + 75 * (G < 26) - ((D != 0) << 5);
      }
      function O(G, D, F) {
        var ae = 0;
        for (G = F ? pe(G / V) : G >> 1, G += pe(G / D); G > ce * B >> 1; ae += P)
          G = pe(G / ce);
        return pe(ae + (ce + 1) * G / (G + H));
      }
      function J(G) {
        var D = [], F = G.length, ae, ge = 0, xe = Q, ye = X, oe, fe, $e, Be, be, ve, qe, De, Ye;
        for (oe = G.lastIndexOf(ee), oe < 0 && (oe = 0), fe = 0; fe < oe; ++fe)
          G.charCodeAt(fe) >= 128 && Ee("not-basic"), D.push(G.charCodeAt(fe));
        for ($e = oe > 0 ? oe + 1 : 0; $e < F; ) {
          for (Be = ge, be = 1, ve = P; $e >= F && Ee("invalid-input"), qe = M(G.charCodeAt($e++)), (qe >= P || qe > pe((A - ge) / be)) && Ee("overflow"), ge += qe * be, De = ve <= ye ? I : ve >= ye + B ? B : ve - ye, !(qe < De); ve += P)
            Ye = P - De, be > pe(A / Ye) && Ee("overflow"), be *= Ye;
          ae = D.length + 1, ye = O(ge - Be, ae, Be == 0), pe(ge / ae) > A - xe && Ee("overflow"), xe += pe(ge / ae), ge %= ae, D.splice(ge++, 0, xe);
        }
        return Y(D);
      }
      function Z(G) {
        var D, F, ae, ge, xe, ye, oe, fe, $e, Be, be, ve = [], qe, De, Ye, he;
        for (G = ne(G), qe = G.length, D = Q, F = 0, xe = X, ye = 0; ye < qe; ++ye)
          be = G[ye], be < 128 && ve.push(me(be));
        for (ae = ge = ve.length, ge && ve.push(ee); ae < qe; ) {
          for (oe = A, ye = 0; ye < qe; ++ye)
            be = G[ye], be >= D && be < oe && (oe = be);
          for (De = ae + 1, oe - D > pe((A - F) / De) && Ee("overflow"), F += (oe - D) * De, D = oe, ye = 0; ye < qe; ++ye)
            if (be = G[ye], be < D && ++F > A && Ee("overflow"), be == D) {
              for (fe = F, $e = P; Be = $e <= xe ? I : $e >= xe + B ? B : $e - xe, !(fe < Be); $e += P)
                he = fe - Be, Ye = P - Be, ve.push(
                  me($(Be + he % Ye, 0))
                ), fe = pe(he / Ye);
              ve.push(me($(fe, 0))), xe = O(F, De, ae == ge), F = 0, ++ae;
            }
          ++F, ++D;
        }
        return ve.join("");
      }
      function K(G) {
        return Ne(G, function(D) {
          return ie.test(D) ? J(D.slice(4).toLowerCase()) : D;
        });
      }
      function z(G) {
        return Ne(G, function(D) {
          return te.test(D) ? "xn--" + Z(D) : D;
        });
      }
      if (q = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: ne,
          encode: Y
        },
        decode: J,
        encode: Z,
        toASCII: z,
        toUnicode: K
      }, g && U)
        if (e.exports == g)
          U.exports = q;
        else
          for (Me in q)
            q.hasOwnProperty(Me) && (g[Me] = q[Me]);
      else
        S.punycode = q;
    })(commonjsGlobal$1);
  }(punycode, punycode.exports)), punycode.exports;
}
var querystring = { exports: {} }, querystringEs3 = {}, decode, hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode)
    return decode;
  hasRequiredDecode = 1;
  function e(S, g) {
    return Object.prototype.hasOwnProperty.call(S, g);
  }
  decode = function(S, g, U, h) {
    g = g || "&", U = U || "=";
    var q = {};
    if (typeof S != "string" || S.length === 0)
      return q;
    var A = /\+/g;
    S = S.split(g);
    var P = 1e3;
    h && typeof h.maxKeys == "number" && (P = h.maxKeys);
    var I = S.length;
    P > 0 && I > P && (I = P);
    for (var B = 0; B < I; ++B) {
      var H = S[B].replace(A, "%20"), V = H.indexOf(U), X, Q, ee, ie;
      V >= 0 ? (X = H.substr(0, V), Q = H.substr(V + 1)) : (X = H, Q = ""), ee = decodeURIComponent(X), ie = decodeURIComponent(Q), e(q, ee) ? o(q[ee]) ? q[ee].push(ie) : q[ee] = [q[ee], ie] : q[ee] = ie;
    }
    return q;
  };
  var o = Array.isArray || function(S) {
    return Object.prototype.toString.call(S) === "[object Array]";
  };
  return decode;
}
var encode, hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode)
    return encode;
  hasRequiredEncode = 1;
  var e = function(U) {
    switch (typeof U) {
      case "string":
        return U;
      case "boolean":
        return U ? "true" : "false";
      case "number":
        return isFinite(U) ? U : "";
      default:
        return "";
    }
  };
  encode = function(U, h, q, A) {
    return h = h || "&", q = q || "=", U === null && (U = void 0), typeof U == "object" ? S(g(U), function(P) {
      var I = encodeURIComponent(e(P)) + q;
      return o(U[P]) ? S(U[P], function(B) {
        return I + encodeURIComponent(e(B));
      }).join(h) : I + encodeURIComponent(e(U[P]));
    }).join(h) : A ? encodeURIComponent(e(A)) + q + encodeURIComponent(e(U)) : "";
  };
  var o = Array.isArray || function(U) {
    return Object.prototype.toString.call(U) === "[object Array]";
  };
  function S(U, h) {
    if (U.map)
      return U.map(h);
    for (var q = [], A = 0; A < U.length; A++)
      q.push(h(U[A], A));
    return q;
  }
  var g = Object.keys || function(U) {
    var h = [];
    for (var q in U)
      Object.prototype.hasOwnProperty.call(U, q) && h.push(q);
    return h;
  };
  return encode;
}
var hasRequiredQuerystringEs3;
function requireQuerystringEs3() {
  return hasRequiredQuerystringEs3 || (hasRequiredQuerystringEs3 = 1, querystringEs3.decode = querystringEs3.parse = requireDecode(), querystringEs3.encode = querystringEs3.stringify = requireEncode()), querystringEs3;
}
var hasRequiredQuerystring;
function requireQuerystring() {
  return hasRequiredQuerystring || (hasRequiredQuerystring = 1, function(e, o) {
    Object.defineProperty(o, "__esModule", { value: !0 });
    var S = requireQuerystringEs3();
    function g(q) {
      return encodeURIComponent(q);
    }
    function U(q) {
      return decodeURIComponent(q);
    }
    var h = {
      decode: S.decode,
      encode: S.encode,
      parse: S.parse,
      stringify: S.stringify,
      escape: g,
      unescape: U
    };
    Object.defineProperty(o, "decode", {
      enumerable: !0,
      get: function() {
        return S.decode;
      }
    }), Object.defineProperty(o, "encode", {
      enumerable: !0,
      get: function() {
        return S.encode;
      }
    }), Object.defineProperty(o, "parse", {
      enumerable: !0,
      get: function() {
        return S.parse;
      }
    }), Object.defineProperty(o, "stringify", {
      enumerable: !0,
      get: function() {
        return S.stringify;
      }
    }), o.default = h, o.escape = g, o.unescape = U, o = e.exports = h;
  }(querystring, querystring.exports)), querystring.exports;
}
var hasRequiredUrl;
function requireUrl() {
  return hasRequiredUrl || (hasRequiredUrl = 1, function(e, o) {
    Object.defineProperty(o, "__esModule", { value: !0 });
    var S = requirePunycode(), g = requireQuerystring();
    function U(Ie) {
      return Ie && typeof Ie == "object" && "default" in Ie ? Ie : { default: Ie };
    }
    var h = /* @__PURE__ */ U(S), q = /* @__PURE__ */ U(g), A = {
      isString: function(Ie) {
        return typeof Ie == "string";
      },
      isObject: function(Ie) {
        return typeof Ie == "object" && Ie !== null;
      },
      isNull: function(Ie) {
        return Ie === null;
      },
      isNullOrUndefined: function(Ie) {
        return Ie == null;
      }
    }, P = h.default, I = A, B = O, H = Z, V = K, X = J, Q = ee;
    function ee() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var ie = /^([a-z0-9.+-]+:)/i, te = /:[0-9]*$/, se = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, le = ["<", ">", '"', "`", " ", "\r", `
`, "	"], ce = ["{", "}", "|", "\\", "^", "`"].concat(le), pe = ["'"].concat(ce), me = ["%", "/", "?", ";", "#"].concat(pe), Me = ["/", "?", "#"], Ee = 255, Re = /^[+a-z0-9A-Z_-]{0,63}$/, Ne = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, ne = {
      javascript: !0,
      "javascript:": !0
    }, Y = {
      javascript: !0,
      "javascript:": !0
    }, M = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0
    }, $ = q.default;
    function O(Ie, Fe, je) {
      if (Ie && I.isObject(Ie) && Ie instanceof ee)
        return Ie;
      var Ke = new ee();
      return Ke.parse(Ie, Fe, je), Ke;
    }
    ee.prototype.parse = function(Ie, Fe, je) {
      if (!I.isString(Ie))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof Ie);
      var Ke = Ie.indexOf("?"), ot = Ke !== -1 && Ke < Ie.indexOf("#") ? "?" : "#", ut = Ie.split(ot), pt = /\\/g;
      ut[0] = ut[0].replace(pt, "/"), Ie = ut.join(ot);
      var ke = Ie;
      if (ke = ke.trim(), !je && Ie.split("#").length === 1) {
        var Xe = se.exec(ke);
        if (Xe)
          return this.path = ke, this.href = ke, this.pathname = Xe[1], Xe[2] ? (this.search = Xe[2], Fe ? this.query = $.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : Fe && (this.search = "", this.query = {}), this;
      }
      var at = ie.exec(ke);
      if (at) {
        at = at[0];
        var ht = at.toLowerCase();
        this.protocol = ht, ke = ke.substr(at.length);
      }
      if (je || at || ke.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var We = ke.substr(0, 2) === "//";
        We && !(at && Y[at]) && (ke = ke.substr(2), this.slashes = !0);
      }
      if (!Y[at] && (We || at && !M[at])) {
        for (var tt = -1, Te = 0; Te < Me.length; Te++) {
          var rt = ke.indexOf(Me[Te]);
          rt !== -1 && (tt === -1 || rt < tt) && (tt = rt);
        }
        var mt, Se;
        tt === -1 ? Se = ke.lastIndexOf("@") : Se = ke.lastIndexOf("@", tt), Se !== -1 && (mt = ke.slice(0, Se), ke = ke.slice(Se + 1), this.auth = decodeURIComponent(mt)), tt = -1;
        for (var Te = 0; Te < me.length; Te++) {
          var rt = ke.indexOf(me[Te]);
          rt !== -1 && (tt === -1 || rt < tt) && (tt = rt);
        }
        tt === -1 && (tt = ke.length), this.host = ke.slice(0, tt), ke = ke.slice(tt), this.parseHost(), this.hostname = this.hostname || "";
        var et = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!et)
          for (var Ze = this.hostname.split(/\./), Te = 0, Le = Ze.length; Te < Le; Te++) {
            var ze = Ze[Te];
            if (ze && !ze.match(Re)) {
              for (var Qe = "", _t = 0, ft = ze.length; _t < ft; _t++)
                ze.charCodeAt(_t) > 127 ? Qe += "x" : Qe += ze[_t];
              if (!Qe.match(Re)) {
                var dt = Ze.slice(0, Te), Mt = Ze.slice(Te + 1), St = ze.match(Ne);
                St && (dt.push(St[1]), Mt.unshift(St[2])), Mt.length && (ke = "/" + Mt.join(".") + ke), this.hostname = dt.join(".");
                break;
              }
            }
          }
        this.hostname.length > Ee ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), et || (this.hostname = P.toASCII(this.hostname));
        var $t = this.port ? ":" + this.port : "", At = this.hostname || "";
        this.host = At + $t, this.href += this.host, et && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), ke[0] !== "/" && (ke = "/" + ke));
      }
      if (!ne[ht])
        for (var Te = 0, Le = pe.length; Te < Le; Te++) {
          var Ae = pe[Te];
          if (ke.indexOf(Ae) !== -1) {
            var Ce = encodeURIComponent(Ae);
            Ce === Ae && (Ce = escape(Ae)), ke = ke.split(Ae).join(Ce);
          }
        }
      var Oe = ke.indexOf("#");
      Oe !== -1 && (this.hash = ke.substr(Oe), ke = ke.slice(0, Oe));
      var we = ke.indexOf("?");
      if (we !== -1 ? (this.search = ke.substr(we), this.query = ke.substr(we + 1), Fe && (this.query = $.parse(this.query)), ke = ke.slice(0, we)) : Fe && (this.search = "", this.query = {}), ke && (this.pathname = ke), M[ht] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var $t = this.pathname || "", Ue = this.search || "";
        this.path = $t + Ue;
      }
      return this.href = this.format(), this;
    };
    function J(Ie) {
      return I.isString(Ie) && (Ie = O(Ie)), Ie instanceof ee ? Ie.format() : ee.prototype.format.call(Ie);
    }
    ee.prototype.format = function() {
      var Ie = this.auth || "";
      Ie && (Ie = encodeURIComponent(Ie), Ie = Ie.replace(/%3A/i, ":"), Ie += "@");
      var Fe = this.protocol || "", je = this.pathname || "", Ke = this.hash || "", ot = !1, ut = "";
      this.host ? ot = Ie + this.host : this.hostname && (ot = Ie + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (ot += ":" + this.port)), this.query && I.isObject(this.query) && Object.keys(this.query).length && (ut = $.stringify(this.query));
      var pt = this.search || ut && "?" + ut || "";
      return Fe && Fe.substr(-1) !== ":" && (Fe += ":"), this.slashes || (!Fe || M[Fe]) && ot !== !1 ? (ot = "//" + (ot || ""), je && je.charAt(0) !== "/" && (je = "/" + je)) : ot || (ot = ""), Ke && Ke.charAt(0) !== "#" && (Ke = "#" + Ke), pt && pt.charAt(0) !== "?" && (pt = "?" + pt), je = je.replace(/[?#]/g, function(ke) {
        return encodeURIComponent(ke);
      }), pt = pt.replace("#", "%23"), Fe + ot + je + pt + Ke;
    };
    function Z(Ie, Fe) {
      return O(Ie, !1, !0).resolve(Fe);
    }
    ee.prototype.resolve = function(Ie) {
      return this.resolveObject(O(Ie, !1, !0)).format();
    };
    function K(Ie, Fe) {
      return Ie ? O(Ie, !1, !0).resolveObject(Fe) : Fe;
    }
    ee.prototype.resolveObject = function(Ie) {
      if (I.isString(Ie)) {
        var Fe = new ee();
        Fe.parse(Ie, !1, !0), Ie = Fe;
      }
      for (var je = new ee(), Ke = Object.keys(this), ot = 0; ot < Ke.length; ot++) {
        var ut = Ke[ot];
        je[ut] = this[ut];
      }
      if (je.hash = Ie.hash, Ie.href === "")
        return je.href = je.format(), je;
      if (Ie.slashes && !Ie.protocol) {
        for (var pt = Object.keys(Ie), ke = 0; ke < pt.length; ke++) {
          var Xe = pt[ke];
          Xe !== "protocol" && (je[Xe] = Ie[Xe]);
        }
        return M[je.protocol] && je.hostname && !je.pathname && (je.path = je.pathname = "/"), je.href = je.format(), je;
      }
      if (Ie.protocol && Ie.protocol !== je.protocol) {
        if (!M[Ie.protocol]) {
          for (var at = Object.keys(Ie), ht = 0; ht < at.length; ht++) {
            var We = at[ht];
            je[We] = Ie[We];
          }
          return je.href = je.format(), je;
        }
        if (je.protocol = Ie.protocol, !Ie.host && !Y[Ie.protocol]) {
          for (var Le = (Ie.pathname || "").split("/"); Le.length && !(Ie.host = Le.shift()); )
            ;
          Ie.host || (Ie.host = ""), Ie.hostname || (Ie.hostname = ""), Le[0] !== "" && Le.unshift(""), Le.length < 2 && Le.unshift(""), je.pathname = Le.join("/");
        } else
          je.pathname = Ie.pathname;
        if (je.search = Ie.search, je.query = Ie.query, je.host = Ie.host || "", je.auth = Ie.auth, je.hostname = Ie.hostname || Ie.host, je.port = Ie.port, je.pathname || je.search) {
          var tt = je.pathname || "", Te = je.search || "";
          je.path = tt + Te;
        }
        return je.slashes = je.slashes || Ie.slashes, je.href = je.format(), je;
      }
      var rt = je.pathname && je.pathname.charAt(0) === "/", mt = Ie.host || Ie.pathname && Ie.pathname.charAt(0) === "/", Se = mt || rt || je.host && Ie.pathname, et = Se, Ze = je.pathname && je.pathname.split("/") || [], Le = Ie.pathname && Ie.pathname.split("/") || [], ze = je.protocol && !M[je.protocol];
      if (ze && (je.hostname = "", je.port = null, je.host && (Ze[0] === "" ? Ze[0] = je.host : Ze.unshift(je.host)), je.host = "", Ie.protocol && (Ie.hostname = null, Ie.port = null, Ie.host && (Le[0] === "" ? Le[0] = Ie.host : Le.unshift(Ie.host)), Ie.host = null), Se = Se && (Le[0] === "" || Ze[0] === "")), mt)
        je.host = Ie.host || Ie.host === "" ? Ie.host : je.host, je.hostname = Ie.hostname || Ie.hostname === "" ? Ie.hostname : je.hostname, je.search = Ie.search, je.query = Ie.query, Ze = Le;
      else if (Le.length)
        Ze || (Ze = []), Ze.pop(), Ze = Ze.concat(Le), je.search = Ie.search, je.query = Ie.query;
      else if (!I.isNullOrUndefined(Ie.search)) {
        if (ze) {
          je.hostname = je.host = Ze.shift();
          var Qe = je.host && je.host.indexOf("@") > 0 ? je.host.split("@") : !1;
          Qe && (je.auth = Qe.shift(), je.host = je.hostname = Qe.shift());
        }
        return je.search = Ie.search, je.query = Ie.query, (!I.isNull(je.pathname) || !I.isNull(je.search)) && (je.path = (je.pathname ? je.pathname : "") + (je.search ? je.search : "")), je.href = je.format(), je;
      }
      if (!Ze.length)
        return je.pathname = null, je.search ? je.path = "/" + je.search : je.path = null, je.href = je.format(), je;
      for (var _t = Ze.slice(-1)[0], ft = (je.host || Ie.host || Ze.length > 1) && (_t === "." || _t === "..") || _t === "", dt = 0, Mt = Ze.length; Mt >= 0; Mt--)
        _t = Ze[Mt], _t === "." ? Ze.splice(Mt, 1) : _t === ".." ? (Ze.splice(Mt, 1), dt++) : dt && (Ze.splice(Mt, 1), dt--);
      if (!Se && !et)
        for (; dt--; dt)
          Ze.unshift("..");
      Se && Ze[0] !== "" && (!Ze[0] || Ze[0].charAt(0) !== "/") && Ze.unshift(""), ft && Ze.join("/").substr(-1) !== "/" && Ze.push("");
      var St = Ze[0] === "" || Ze[0] && Ze[0].charAt(0) === "/";
      if (ze) {
        je.hostname = je.host = St ? "" : Ze.length ? Ze.shift() : "";
        var Qe = je.host && je.host.indexOf("@") > 0 ? je.host.split("@") : !1;
        Qe && (je.auth = Qe.shift(), je.host = je.hostname = Qe.shift());
      }
      return Se = Se || je.host && Ze.length, Se && !St && Ze.unshift(""), Ze.length ? je.pathname = Ze.join("/") : (je.pathname = null, je.path = null), (!I.isNull(je.pathname) || !I.isNull(je.search)) && (je.path = (je.pathname ? je.pathname : "") + (je.search ? je.search : "")), je.auth = Ie.auth || je.auth, je.slashes = je.slashes || Ie.slashes, je.href = je.format(), je;
    }, ee.prototype.parseHost = function() {
      var Ie = this.host, Fe = te.exec(Ie);
      Fe && (Fe = Fe[0], Fe !== ":" && (this.port = Fe.substr(1)), Ie = Ie.substr(0, Ie.length - Fe.length)), Ie && (this.hostname = Ie);
    };
    function z(Ie, Fe) {
      for (var je = 0, Ke = Ie.length - 1; Ke >= 0; Ke--) {
        var ot = Ie[Ke];
        ot === "." ? Ie.splice(Ke, 1) : ot === ".." ? (Ie.splice(Ke, 1), je++) : je && (Ie.splice(Ke, 1), je--);
      }
      if (Fe)
        for (; je--; je)
          Ie.unshift("..");
      return Ie;
    }
    function G() {
      for (var Ie = "", Fe = !1, je = arguments.length - 1; je >= -1 && !Fe; je--) {
        var Ke = je >= 0 ? arguments[je] : "/";
        if (typeof Ke != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!Ke)
          continue;
        Ie = Ke + "/" + Ie, Fe = Ke.charAt(0) === "/";
      }
      return Ie = z(D(Ie.split("/"), function(ot) {
        return !!ot;
      }), !Fe).join("/"), (Fe ? "/" : "") + Ie || ".";
    }
    function D(Ie, Fe) {
      if (Ie.filter)
        return Ie.filter(Fe);
      for (var je = [], Ke = 0; Ke < Ie.length; Ke++)
        Fe(Ie[Ke], Ke, Ie) && je.push(Ie[Ke]);
      return je;
    }
    var F = function(Ie) {
      function Fe() {
        var Ke = this || self;
        return delete Ie.prototype.__magic__, Ke;
      }
      if (typeof globalThis == "object")
        return globalThis;
      if (this)
        return Fe();
      Ie.defineProperty(Ie.prototype, "__magic__", {
        configurable: !0,
        get: Fe
      });
      var je = __magic__;
      return je;
    }(Object), ae = (
      /** @type {formatImport}*/
      X
    ), ge = (
      /** @type {parseImport}*/
      B
    ), xe = (
      /** @type {resolveImport}*/
      H
    ), ye = (
      /** @type {UrlImport}*/
      Q
    ), oe = F.URL, fe = F.URLSearchParams, $e = /%/g, Be = /\\/g, be = /\n/g, ve = /\r/g, qe = /\t/g, De = 47;
    function Ye(Ie) {
      var Fe = (
        /** @type {URL|null} */
        Ie ?? null
      );
      return !!(Fe !== null && (Fe != null && Fe.href) && (Fe != null && Fe.origin));
    }
    function he(Ie) {
      if (Ie.hostname !== "")
        throw new TypeError('File URL host must be "localhost" or empty on browser');
      for (var Fe = Ie.pathname, je = 0; je < Fe.length; je++)
        if (Fe[je] === "%") {
          var Ke = Fe.codePointAt(je + 2) | 32;
          if (Fe[je + 1] === "2" && Ke === 102)
            throw new TypeError("File URL path must not include encoded / characters");
        }
      return decodeURIComponent(Fe);
    }
    function ue(Ie) {
      return Ie.includes("%") && (Ie = Ie.replace($e, "%25")), Ie.includes("\\") && (Ie = Ie.replace(Be, "%5C")), Ie.includes(`
`) && (Ie = Ie.replace(be, "%0A")), Ie.includes("\r") && (Ie = Ie.replace(ve, "%0D")), Ie.includes("	") && (Ie = Ie.replace(qe, "%09")), Ie;
    }
    var de = (
      /**
       * @type {domainToASCII}
       */
      function(Fe) {
        if (typeof Fe > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new oe("http://" + Fe).hostname;
      }
    ), _e = (
      /**
       * @type {domainToUnicode}
       */
      function(Fe) {
        if (typeof Fe > "u")
          throw new TypeError('The "domain" argument must be specified');
        return new oe("http://" + Fe).hostname;
      }
    ), Pe = (
      /**
       * @type {(url: string) => URL}
       */
      function(Fe) {
        var je = new oe("file://"), Ke = G(Fe), ot = Fe.charCodeAt(Fe.length - 1);
        return ot === De && Ke[Ke.length - 1] !== "/" && (Ke += "/"), je.pathname = ue(Ke), je;
      }
    ), He = (
      /**
       * @type {fileURLToPath & ((path: string | URL) => string)}
       */
      function(Fe) {
        if (!Ye(Fe) && typeof Fe != "string")
          throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof Fe + " (" + Fe + ")");
        var je = new oe(Fe);
        if (je.protocol !== "file:")
          throw new TypeError("The URL must be of scheme file");
        return he(je);
      }
    ), Ve = (
      /**
       * @type {(
       *   ((urlObject: URL, options?: URLFormatOptions) => string) &
       *   ((urlObject: UrlObject | string, options?: never) => string)
       * )}
       */
      function(Fe, je) {
        var Ke, ot, ut;
        if (je === void 0 && (je = {}), !(Fe instanceof oe))
          return ae(Fe);
        if (typeof je != "object" || je === null)
          throw new TypeError('The "options" argument must be of type object.');
        var pt = (Ke = je.auth) != null ? Ke : !0, ke = (ot = je.fragment) != null ? ot : !0, Xe = (ut = je.search) != null ? ut : !0, at = new oe(Fe.toString());
        return pt || (at.username = "", at.password = ""), ke || (at.hash = ""), Xe || (at.search = ""), at.toString();
      }
    ), nt = {
      format: Ve,
      parse: ge,
      resolve: xe,
      resolveObject: V,
      Url: ye,
      URL: oe,
      URLSearchParams: fe,
      domainToASCII: de,
      domainToUnicode: _e,
      pathToFileURL: Pe,
      fileURLToPath: He
    };
    o.URL = oe, o.URLSearchParams = fe, o.Url = ye, o.default = nt, o.domainToASCII = de, o.domainToUnicode = _e, o.fileURLToPath = He, o.format = Ve, o.parse = ge, o.pathToFileURL = Pe, o.resolve = xe, o.resolveObject = V, o = e.exports = nt;
  }(url, url.exports)), url.exports;
}
var hasRequiredStreamHttp;
function requireStreamHttp() {
  return hasRequiredStreamHttp || (hasRequiredStreamHttp = 1, function(e) {
    var o = requireRequest(), S = requireResponse(), g = requireImmutable(), U = requireBrowser$b(), h = requireUrl(), q = e;
    q.request = function(A, P) {
      typeof A == "string" ? A = h.parse(A) : A = g(A);
      var I = commonjsGlobal$1.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", B = A.protocol || I, H = A.hostname || A.host, V = A.port, X = A.path || "/";
      H && H.indexOf(":") !== -1 && (H = "[" + H + "]"), A.url = (H ? B + "//" + H : "") + (V ? ":" + V : "") + X, A.method = (A.method || "GET").toUpperCase(), A.headers = A.headers || {};
      var Q = new o(A);
      return P && Q.on("response", P), Q;
    }, q.get = function(P, I) {
      var B = q.request(P, I);
      return B.end(), B;
    }, q.ClientRequest = o, q.IncomingMessage = S.IncomingMessage, q.Agent = function() {
    }, q.Agent.defaultMaxSockets = 4, q.globalAgent = new q.Agent(), q.STATUS_CODES = U, q.METHODS = [
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REPORT",
      "SEARCH",
      "SUBSCRIBE",
      "TRACE",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
  }(streamHttp)), streamHttp;
}
var httpsBrowserify = { exports: {} }, hasRequiredHttpsBrowserify;
function requireHttpsBrowserify() {
  return hasRequiredHttpsBrowserify || (hasRequiredHttpsBrowserify = 1, function(e) {
    var o = requireStreamHttp(), S = requireUrl(), g = e.exports;
    for (var U in o)
      o.hasOwnProperty(U) && (g[U] = o[U]);
    g.request = function(q, A) {
      return q = h(q), o.request.call(this, q, A);
    }, g.get = function(q, A) {
      return q = h(q), o.get.call(this, q, A);
    };
    function h(q) {
      if (typeof q == "string" && (q = S.parse(q)), q.protocol || (q.protocol = "https:"), q.protocol !== "https:")
        throw new Error('Protocol "' + q.protocol + '" not supported. Expected "https:"');
      return q;
    }
  }(httpsBrowserify)), httpsBrowserify.exports;
}
var lib$1 = {}, streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify)
    return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = S;
  var e = eventsExports.EventEmitter, o = requireInherits_browser();
  o(S, e), S.Readable = require_stream_readable$1(), S.Writable = require_stream_writable$1(), S.Duplex = require_stream_duplex$1(), S.Transform = require_stream_transform$1(), S.PassThrough = require_stream_passthrough$1(), S.finished = requireEndOfStream(), S.pipeline = requirePipeline(), S.Stream = S;
  function S() {
    e.call(this);
  }
  return S.prototype.pipe = function(g, U) {
    var h = this;
    function q(X) {
      g.writable && g.write(X) === !1 && h.pause && h.pause();
    }
    h.on("data", q);
    function A() {
      h.readable && h.resume && h.resume();
    }
    g.on("drain", A), !g._isStdio && (!U || U.end !== !1) && (h.on("end", I), h.on("close", B));
    var P = !1;
    function I() {
      P || (P = !0, g.end());
    }
    function B() {
      P || (P = !0, typeof g.destroy == "function" && g.destroy());
    }
    function H(X) {
      if (V(), e.listenerCount(this, "error") === 0)
        throw X;
    }
    h.on("error", H), g.on("error", H);
    function V() {
      h.removeListener("data", q), g.removeListener("drain", A), h.removeListener("end", I), h.removeListener("close", B), h.removeListener("error", H), g.removeListener("error", H), h.removeListener("end", V), h.removeListener("close", V), g.removeListener("close", V);
    }
    return h.on("end", V), h.on("close", V), g.on("close", V), g.emit("pipe", h), g;
  }, streamBrowserify;
}
var binding = {}, assert = { exports: {} }, errors = {}, hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors)
    return errors;
  hasRequiredErrors = 1;
  function e(pe) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
      return typeof me;
    } : function(me) {
      return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
    }, e(pe);
  }
  function o(pe, me) {
    for (var Me = 0; Me < me.length; Me++) {
      var Ee = me[Me];
      Ee.enumerable = Ee.enumerable || !1, Ee.configurable = !0, "value" in Ee && (Ee.writable = !0), Object.defineProperty(pe, g(Ee.key), Ee);
    }
  }
  function S(pe, me, Me) {
    return me && o(pe.prototype, me), Me && o(pe, Me), Object.defineProperty(pe, "prototype", { writable: !1 }), pe;
  }
  function g(pe) {
    var me = U(pe, "string");
    return e(me) === "symbol" ? me : String(me);
  }
  function U(pe, me) {
    if (e(pe) !== "object" || pe === null)
      return pe;
    var Me = pe[Symbol.toPrimitive];
    if (Me !== void 0) {
      var Ee = Me.call(pe, me || "default");
      if (e(Ee) !== "object")
        return Ee;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (me === "string" ? String : Number)(pe);
  }
  function h(pe, me) {
    if (!(pe instanceof me))
      throw new TypeError("Cannot call a class as a function");
  }
  function q(pe, me) {
    if (typeof me != "function" && me !== null)
      throw new TypeError("Super expression must either be null or a function");
    pe.prototype = Object.create(me && me.prototype, { constructor: { value: pe, writable: !0, configurable: !0 } }), Object.defineProperty(pe, "prototype", { writable: !1 }), me && A(pe, me);
  }
  function A(pe, me) {
    return A = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(Ee, Re) {
      return Ee.__proto__ = Re, Ee;
    }, A(pe, me);
  }
  function P(pe) {
    var me = H();
    return function() {
      var Ee = V(pe), Re;
      if (me) {
        var Ne = V(this).constructor;
        Re = Reflect.construct(Ee, arguments, Ne);
      } else
        Re = Ee.apply(this, arguments);
      return I(this, Re);
    };
  }
  function I(pe, me) {
    if (me && (e(me) === "object" || typeof me == "function"))
      return me;
    if (me !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return B(pe);
  }
  function B(pe) {
    if (pe === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return pe;
  }
  function H() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function V(pe) {
    return V = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Me) {
      return Me.__proto__ || Object.getPrototypeOf(Me);
    }, V(pe);
  }
  var X = {}, Q, ee;
  function ie(pe, me, Me) {
    Me || (Me = Error);
    function Ee(Ne, ne, Y) {
      return typeof me == "string" ? me : me(Ne, ne, Y);
    }
    var Re = /* @__PURE__ */ function(Ne) {
      q(Y, Ne);
      var ne = P(Y);
      function Y(M, $, O) {
        var J;
        return h(this, Y), J = ne.call(this, Ee(M, $, O)), J.code = pe, J;
      }
      return S(Y);
    }(Me);
    X[pe] = Re;
  }
  function te(pe, me) {
    if (Array.isArray(pe)) {
      var Me = pe.length;
      return pe = pe.map(function(Ee) {
        return String(Ee);
      }), Me > 2 ? "one of ".concat(me, " ").concat(pe.slice(0, Me - 1).join(", "), ", or ") + pe[Me - 1] : Me === 2 ? "one of ".concat(me, " ").concat(pe[0], " or ").concat(pe[1]) : "of ".concat(me, " ").concat(pe[0]);
    } else
      return "of ".concat(me, " ").concat(String(pe));
  }
  function se(pe, me, Me) {
    return pe.substr(!Me || Me < 0 ? 0 : +Me, me.length) === me;
  }
  function le(pe, me, Me) {
    return (Me === void 0 || Me > pe.length) && (Me = pe.length), pe.substring(Me - me.length, Me) === me;
  }
  function ce(pe, me, Me) {
    return typeof Me != "number" && (Me = 0), Me + me.length > pe.length ? !1 : pe.indexOf(me, Me) !== -1;
  }
  return ie("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), ie("ERR_INVALID_ARG_TYPE", function(pe, me, Me) {
    Q === void 0 && (Q = requireAssert()), Q(typeof pe == "string", "'name' must be a string");
    var Ee;
    typeof me == "string" && se(me, "not ") ? (Ee = "must not be", me = me.replace(/^not /, "")) : Ee = "must be";
    var Re;
    if (le(pe, " argument"))
      Re = "The ".concat(pe, " ").concat(Ee, " ").concat(te(me, "type"));
    else {
      var Ne = ce(pe, ".") ? "property" : "argument";
      Re = 'The "'.concat(pe, '" ').concat(Ne, " ").concat(Ee, " ").concat(te(me, "type"));
    }
    return Re += ". Received type ".concat(e(Me)), Re;
  }, TypeError), ie("ERR_INVALID_ARG_VALUE", function(pe, me) {
    var Me = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    ee === void 0 && (ee = requireUtil$1());
    var Ee = ee.inspect(me);
    return Ee.length > 128 && (Ee = "".concat(Ee.slice(0, 128), "...")), "The argument '".concat(pe, "' ").concat(Me, ". Received ").concat(Ee);
  }, TypeError), ie("ERR_INVALID_RETURN_VALUE", function(pe, me, Me) {
    var Ee;
    return Me && Me.constructor && Me.constructor.name ? Ee = "instance of ".concat(Me.constructor.name) : Ee = "type ".concat(e(Me)), "Expected ".concat(pe, ' to be returned from the "').concat(me, '"') + " function but got ".concat(Ee, ".");
  }, TypeError), ie("ERR_MISSING_ARGS", function() {
    for (var pe = arguments.length, me = new Array(pe), Me = 0; Me < pe; Me++)
      me[Me] = arguments[Me];
    Q === void 0 && (Q = requireAssert()), Q(me.length > 0, "At least one arg needs to be specified");
    var Ee = "The ", Re = me.length;
    switch (me = me.map(function(Ne) {
      return '"'.concat(Ne, '"');
    }), Re) {
      case 1:
        Ee += "".concat(me[0], " argument");
        break;
      case 2:
        Ee += "".concat(me[0], " and ").concat(me[1], " arguments");
        break;
      default:
        Ee += me.slice(0, Re - 1).join(", "), Ee += ", and ".concat(me[Re - 1], " arguments");
        break;
    }
    return "".concat(Ee, " must be specified");
  }, TypeError), errors.codes = X, errors;
}
var assertion_error, hasRequiredAssertion_error;
function requireAssertion_error() {
  if (hasRequiredAssertion_error)
    return assertion_error;
  hasRequiredAssertion_error = 1;
  function e(z, G) {
    var D = Object.keys(z);
    if (Object.getOwnPropertySymbols) {
      var F = Object.getOwnPropertySymbols(z);
      G && (F = F.filter(function(ae) {
        return Object.getOwnPropertyDescriptor(z, ae).enumerable;
      })), D.push.apply(D, F);
    }
    return D;
  }
  function o(z) {
    for (var G = 1; G < arguments.length; G++) {
      var D = arguments[G] != null ? arguments[G] : {};
      G % 2 ? e(Object(D), !0).forEach(function(F) {
        S(z, F, D[F]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(z, Object.getOwnPropertyDescriptors(D)) : e(Object(D)).forEach(function(F) {
        Object.defineProperty(z, F, Object.getOwnPropertyDescriptor(D, F));
      });
    }
    return z;
  }
  function S(z, G, D) {
    return G = q(G), G in z ? Object.defineProperty(z, G, { value: D, enumerable: !0, configurable: !0, writable: !0 }) : z[G] = D, z;
  }
  function g(z, G) {
    if (!(z instanceof G))
      throw new TypeError("Cannot call a class as a function");
  }
  function U(z, G) {
    for (var D = 0; D < G.length; D++) {
      var F = G[D];
      F.enumerable = F.enumerable || !1, F.configurable = !0, "value" in F && (F.writable = !0), Object.defineProperty(z, q(F.key), F);
    }
  }
  function h(z, G, D) {
    return G && U(z.prototype, G), D && U(z, D), Object.defineProperty(z, "prototype", { writable: !1 }), z;
  }
  function q(z) {
    var G = A(z, "string");
    return se(G) === "symbol" ? G : String(G);
  }
  function A(z, G) {
    if (se(z) !== "object" || z === null)
      return z;
    var D = z[Symbol.toPrimitive];
    if (D !== void 0) {
      var F = D.call(z, G || "default");
      if (se(F) !== "object")
        return F;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (G === "string" ? String : Number)(z);
  }
  function P(z, G) {
    if (typeof G != "function" && G !== null)
      throw new TypeError("Super expression must either be null or a function");
    z.prototype = Object.create(G && G.prototype, { constructor: { value: z, writable: !0, configurable: !0 } }), Object.defineProperty(z, "prototype", { writable: !1 }), G && ie(z, G);
  }
  function I(z) {
    var G = Q();
    return function() {
      var F = te(z), ae;
      if (G) {
        var ge = te(this).constructor;
        ae = Reflect.construct(F, arguments, ge);
      } else
        ae = F.apply(this, arguments);
      return B(this, ae);
    };
  }
  function B(z, G) {
    if (G && (se(G) === "object" || typeof G == "function"))
      return G;
    if (G !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return H(z);
  }
  function H(z) {
    if (z === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return z;
  }
  function V(z) {
    var G = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return V = function(F) {
      if (F === null || !ee(F))
        return F;
      if (typeof F != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof G < "u") {
        if (G.has(F))
          return G.get(F);
        G.set(F, ae);
      }
      function ae() {
        return X(F, arguments, te(this).constructor);
      }
      return ae.prototype = Object.create(F.prototype, { constructor: { value: ae, enumerable: !1, writable: !0, configurable: !0 } }), ie(ae, F);
    }, V(z);
  }
  function X(z, G, D) {
    return Q() ? X = Reflect.construct.bind() : X = function(ae, ge, xe) {
      var ye = [null];
      ye.push.apply(ye, ge);
      var oe = Function.bind.apply(ae, ye), fe = new oe();
      return xe && ie(fe, xe.prototype), fe;
    }, X.apply(null, arguments);
  }
  function Q() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function ee(z) {
    return Function.toString.call(z).indexOf("[native code]") !== -1;
  }
  function ie(z, G) {
    return ie = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(F, ae) {
      return F.__proto__ = ae, F;
    }, ie(z, G);
  }
  function te(z) {
    return te = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(D) {
      return D.__proto__ || Object.getPrototypeOf(D);
    }, te(z);
  }
  function se(z) {
    "@babel/helpers - typeof";
    return se = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(G) {
      return typeof G;
    } : function(G) {
      return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G;
    }, se(z);
  }
  var le = requireUtil$1(), ce = le.inspect, pe = requireErrors(), me = pe.codes.ERR_INVALID_ARG_TYPE;
  function Me(z, G, D) {
    return (D === void 0 || D > z.length) && (D = z.length), z.substring(D - G.length, D) === G;
  }
  function Ee(z, G) {
    if (G = Math.floor(G), z.length == 0 || G == 0)
      return "";
    var D = z.length * G;
    for (G = Math.floor(Math.log(G) / Math.log(2)); G; )
      z += z, G--;
    return z += z.substring(0, D - z.length), z;
  }
  var Re = "", Ne = "", ne = "", Y = "", M = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, $ = 10;
  function O(z) {
    var G = Object.keys(z), D = Object.create(Object.getPrototypeOf(z));
    return G.forEach(function(F) {
      D[F] = z[F];
    }), Object.defineProperty(D, "message", {
      value: z.message
    }), D;
  }
  function J(z) {
    return ce(z, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function Z(z, G, D) {
    var F = "", ae = "", ge = 0, xe = "", ye = !1, oe = J(z), fe = oe.split(`
`), $e = J(G).split(`
`), Be = 0, be = "";
    if (D === "strictEqual" && se(z) === "object" && se(G) === "object" && z !== null && G !== null && (D = "strictEqualObject"), fe.length === 1 && $e.length === 1 && fe[0] !== $e[0]) {
      var ve = fe[0].length + $e[0].length;
      if (ve <= $) {
        if ((se(z) !== "object" || z === null) && (se(G) !== "object" || G === null) && (z !== 0 || G !== 0))
          return "".concat(M[D], `

`) + "".concat(fe[0], " !== ").concat($e[0], `
`);
      } else if (D !== "strictEqualObject") {
        var qe = process$3.stderr && process$3.stderr.isTTY ? process$3.stderr.columns : 80;
        if (ve < qe) {
          for (; fe[0][Be] === $e[0][Be]; )
            Be++;
          Be > 2 && (be = `
  `.concat(Ee(" ", Be), "^"), Be = 0);
        }
      }
    }
    for (var De = fe[fe.length - 1], Ye = $e[$e.length - 1]; De === Ye && (Be++ < 2 ? xe = `
  `.concat(De).concat(xe) : F = De, fe.pop(), $e.pop(), !(fe.length === 0 || $e.length === 0)); )
      De = fe[fe.length - 1], Ye = $e[$e.length - 1];
    var he = Math.max(fe.length, $e.length);
    if (he === 0) {
      var ue = oe.split(`
`);
      if (ue.length > 30)
        for (ue[26] = "".concat(Re, "...").concat(Y); ue.length > 27; )
          ue.pop();
      return "".concat(M.notIdentical, `

`).concat(ue.join(`
`), `
`);
    }
    Be > 3 && (xe = `
`.concat(Re, "...").concat(Y).concat(xe), ye = !0), F !== "" && (xe = `
  `.concat(F).concat(xe), F = "");
    var de = 0, _e = M[D] + `
`.concat(Ne, "+ actual").concat(Y, " ").concat(ne, "- expected").concat(Y), Pe = " ".concat(Re, "...").concat(Y, " Lines skipped");
    for (Be = 0; Be < he; Be++) {
      var He = Be - ge;
      if (fe.length < Be + 1)
        He > 1 && Be > 2 && (He > 4 ? (ae += `
`.concat(Re, "...").concat(Y), ye = !0) : He > 3 && (ae += `
  `.concat($e[Be - 2]), de++), ae += `
  `.concat($e[Be - 1]), de++), ge = Be, F += `
`.concat(ne, "-").concat(Y, " ").concat($e[Be]), de++;
      else if ($e.length < Be + 1)
        He > 1 && Be > 2 && (He > 4 ? (ae += `
`.concat(Re, "...").concat(Y), ye = !0) : He > 3 && (ae += `
  `.concat(fe[Be - 2]), de++), ae += `
  `.concat(fe[Be - 1]), de++), ge = Be, ae += `
`.concat(Ne, "+").concat(Y, " ").concat(fe[Be]), de++;
      else {
        var Ve = $e[Be], nt = fe[Be], Ie = nt !== Ve && (!Me(nt, ",") || nt.slice(0, -1) !== Ve);
        Ie && Me(Ve, ",") && Ve.slice(0, -1) === nt && (Ie = !1, nt += ","), Ie ? (He > 1 && Be > 2 && (He > 4 ? (ae += `
`.concat(Re, "...").concat(Y), ye = !0) : He > 3 && (ae += `
  `.concat(fe[Be - 2]), de++), ae += `
  `.concat(fe[Be - 1]), de++), ge = Be, ae += `
`.concat(Ne, "+").concat(Y, " ").concat(nt), F += `
`.concat(ne, "-").concat(Y, " ").concat(Ve), de += 2) : (ae += F, F = "", (He === 1 || Be === 0) && (ae += `
  `.concat(nt), de++));
      }
      if (de > 20 && Be < he - 2)
        return "".concat(_e).concat(Pe, `
`).concat(ae, `
`).concat(Re, "...").concat(Y).concat(F, `
`) + "".concat(Re, "...").concat(Y);
    }
    return "".concat(_e).concat(ye ? Pe : "", `
`).concat(ae).concat(F).concat(xe).concat(be);
  }
  var K = /* @__PURE__ */ function(z, G) {
    P(F, z);
    var D = I(F);
    function F(ae) {
      var ge;
      if (g(this, F), se(ae) !== "object" || ae === null)
        throw new me("options", "Object", ae);
      var xe = ae.message, ye = ae.operator, oe = ae.stackStartFn, fe = ae.actual, $e = ae.expected, Be = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, xe != null)
        ge = D.call(this, String(xe));
      else if (process$3.stderr && process$3.stderr.isTTY && (process$3.stderr && process$3.stderr.getColorDepth && process$3.stderr.getColorDepth() !== 1 ? (Re = "\x1B[34m", Ne = "\x1B[32m", Y = "\x1B[39m", ne = "\x1B[31m") : (Re = "", Ne = "", Y = "", ne = "")), se(fe) === "object" && fe !== null && se($e) === "object" && $e !== null && "stack" in fe && fe instanceof Error && "stack" in $e && $e instanceof Error && (fe = O(fe), $e = O($e)), ye === "deepStrictEqual" || ye === "strictEqual")
        ge = D.call(this, Z(fe, $e, ye));
      else if (ye === "notDeepStrictEqual" || ye === "notStrictEqual") {
        var be = M[ye], ve = J(fe).split(`
`);
        if (ye === "notStrictEqual" && se(fe) === "object" && fe !== null && (be = M.notStrictEqualObject), ve.length > 30)
          for (ve[26] = "".concat(Re, "...").concat(Y); ve.length > 27; )
            ve.pop();
        ve.length === 1 ? ge = D.call(this, "".concat(be, " ").concat(ve[0])) : ge = D.call(this, "".concat(be, `

`).concat(ve.join(`
`), `
`));
      } else {
        var qe = J(fe), De = "", Ye = M[ye];
        ye === "notDeepEqual" || ye === "notEqual" ? (qe = "".concat(M[ye], `

`).concat(qe), qe.length > 1024 && (qe = "".concat(qe.slice(0, 1021), "..."))) : (De = "".concat(J($e)), qe.length > 512 && (qe = "".concat(qe.slice(0, 509), "...")), De.length > 512 && (De = "".concat(De.slice(0, 509), "...")), ye === "deepEqual" || ye === "equal" ? qe = "".concat(Ye, `

`).concat(qe, `

should equal

`) : De = " ".concat(ye, " ").concat(De)), ge = D.call(this, "".concat(qe).concat(De));
      }
      return Error.stackTraceLimit = Be, ge.generatedMessage = !xe, Object.defineProperty(H(ge), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), ge.code = "ERR_ASSERTION", ge.actual = fe, ge.expected = $e, ge.operator = ye, Error.captureStackTrace && Error.captureStackTrace(H(ge), oe), ge.stack, ge.name = "AssertionError", B(ge);
    }
    return h(F, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: G,
      value: function(ge, xe) {
        return ce(this, o(o({}, xe), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), F;
  }(/* @__PURE__ */ V(Error), ce.custom);
  return assertion_error = K, assertion_error;
}
var implementation$2, hasRequiredImplementation$2;
function requireImplementation$2() {
  if (hasRequiredImplementation$2)
    return implementation$2;
  hasRequiredImplementation$2 = 1;
  var e = objectKeys$1, o = shams$1(), S = callBound$1, g = Object, U = S("Array.prototype.push"), h = S("Object.prototype.propertyIsEnumerable"), q = o ? Object.getOwnPropertySymbols : null;
  return implementation$2 = function(P, I) {
    if (P == null)
      throw new TypeError("target must be an object");
    var B = g(P);
    if (arguments.length === 1)
      return B;
    for (var H = 1; H < arguments.length; ++H) {
      var V = g(arguments[H]), X = e(V), Q = o && (Object.getOwnPropertySymbols || q);
      if (Q)
        for (var ee = Q(V), ie = 0; ie < ee.length; ++ie) {
          var te = ee[ie];
          h(V, te) && U(X, te);
        }
      for (var se = 0; se < X.length; ++se) {
        var le = X[se];
        if (h(V, le)) {
          var ce = V[le];
          B[le] = ce;
        }
      }
    }
    return B;
  }, implementation$2;
}
var polyfill$2, hasRequiredPolyfill$2;
function requirePolyfill$2() {
  if (hasRequiredPolyfill$2)
    return polyfill$2;
  hasRequiredPolyfill$2 = 1;
  var e = requireImplementation$2(), o = function() {
    if (!Object.assign)
      return !1;
    for (var g = "abcdefghijklmnopqrst", U = g.split(""), h = {}, q = 0; q < U.length; ++q)
      h[U[q]] = U[q];
    var A = Object.assign({}, h), P = "";
    for (var I in A)
      P += I;
    return g !== P;
  }, S = function() {
    if (!Object.assign || !Object.preventExtensions)
      return !1;
    var g = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(g, "xy");
    } catch {
      return g[1] === "y";
    }
    return !1;
  };
  return polyfill$2 = function() {
    return !Object.assign || o() || S() ? e : Object.assign;
  }, polyfill$2;
}
var implementation$1, hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1)
    return implementation$1;
  hasRequiredImplementation$1 = 1;
  var e = function(o) {
    return o !== o;
  };
  return implementation$1 = function(S, g) {
    return S === 0 && g === 0 ? 1 / S === 1 / g : !!(S === g || e(S) && e(g));
  }, implementation$1;
}
var polyfill$1, hasRequiredPolyfill$1;
function requirePolyfill$1() {
  if (hasRequiredPolyfill$1)
    return polyfill$1;
  hasRequiredPolyfill$1 = 1;
  var e = requireImplementation$1();
  return polyfill$1 = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, polyfill$1;
}
var defineProperties_1, hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties)
    return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var e = objectKeys$1, o = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", S = Object.prototype.toString, g = Array.prototype.concat, U = defineDataProperty, h = function(I) {
    return typeof I == "function" && S.call(I) === "[object Function]";
  }, q = hasPropertyDescriptors_1(), A = function(I, B, H, V) {
    if (B in I) {
      if (V === !0) {
        if (I[B] === H)
          return;
      } else if (!h(V) || !V())
        return;
    }
    q ? U(I, B, H, !0) : U(I, B, H);
  }, P = function(I, B) {
    var H = arguments.length > 2 ? arguments[2] : {}, V = e(B);
    o && (V = g.call(V, Object.getOwnPropertySymbols(B)));
    for (var X = 0; X < V.length; X += 1)
      A(I, V[X], B[V[X]], H[V[X]]);
  };
  return P.supportsDescriptors = !!q, defineProperties_1 = P, defineProperties_1;
}
var shim$1, hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1)
    return shim$1;
  hasRequiredShim$1 = 1;
  var e = requirePolyfill$1(), o = requireDefineProperties();
  return shim$1 = function() {
    var g = e();
    return o(Object, { is: g }, {
      is: function() {
        return Object.is !== g;
      }
    }), g;
  }, shim$1;
}
var objectIs, hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs)
    return objectIs;
  hasRequiredObjectIs = 1;
  var e = requireDefineProperties(), o = callBindExports, S = requireImplementation$1(), g = requirePolyfill$1(), U = requireShim$1(), h = o(g(), Object);
  return e(h, {
    getPolyfill: g,
    implementation: S,
    shim: U
  }), objectIs = h, objectIs;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  return hasRequiredImplementation || (hasRequiredImplementation = 1, implementation = function(o) {
    return o !== o;
  }), implementation;
}
var polyfill, hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill)
    return polyfill;
  hasRequiredPolyfill = 1;
  var e = requireImplementation();
  return polyfill = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, polyfill;
}
var shim, hasRequiredShim;
function requireShim() {
  if (hasRequiredShim)
    return shim;
  hasRequiredShim = 1;
  var e = requireDefineProperties(), o = requirePolyfill();
  return shim = function() {
    var g = o();
    return e(Number, { isNaN: g }, {
      isNaN: function() {
        return Number.isNaN !== g;
      }
    }), g;
  }, shim;
}
var isNan, hasRequiredIsNan;
function requireIsNan() {
  if (hasRequiredIsNan)
    return isNan;
  hasRequiredIsNan = 1;
  var e = callBindExports, o = requireDefineProperties(), S = requireImplementation(), g = requirePolyfill(), U = requireShim(), h = e(g(), Number);
  return o(h, {
    getPolyfill: g,
    implementation: S,
    shim: U
  }), isNan = h, isNan;
}
var comparisons, hasRequiredComparisons;
function requireComparisons() {
  if (hasRequiredComparisons)
    return comparisons;
  hasRequiredComparisons = 1;
  function e(Ie, Fe) {
    return h(Ie) || U(Ie, Fe) || S(Ie, Fe) || o();
  }
  function o() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function S(Ie, Fe) {
    if (Ie) {
      if (typeof Ie == "string")
        return g(Ie, Fe);
      var je = Object.prototype.toString.call(Ie).slice(8, -1);
      if (je === "Object" && Ie.constructor && (je = Ie.constructor.name), je === "Map" || je === "Set")
        return Array.from(Ie);
      if (je === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(je))
        return g(Ie, Fe);
    }
  }
  function g(Ie, Fe) {
    (Fe == null || Fe > Ie.length) && (Fe = Ie.length);
    for (var je = 0, Ke = new Array(Fe); je < Fe; je++)
      Ke[je] = Ie[je];
    return Ke;
  }
  function U(Ie, Fe) {
    var je = Ie == null ? null : typeof Symbol < "u" && Ie[Symbol.iterator] || Ie["@@iterator"];
    if (je != null) {
      var Ke, ot, ut, pt, ke = [], Xe = !0, at = !1;
      try {
        if (ut = (je = je.call(Ie)).next, Fe === 0) {
          if (Object(je) !== je)
            return;
          Xe = !1;
        } else
          for (; !(Xe = (Ke = ut.call(je)).done) && (ke.push(Ke.value), ke.length !== Fe); Xe = !0)
            ;
      } catch (ht) {
        at = !0, ot = ht;
      } finally {
        try {
          if (!Xe && je.return != null && (pt = je.return(), Object(pt) !== pt))
            return;
        } finally {
          if (at)
            throw ot;
        }
      }
      return ke;
    }
  }
  function h(Ie) {
    if (Array.isArray(Ie))
      return Ie;
  }
  function q(Ie) {
    "@babel/helpers - typeof";
    return q = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Fe) {
      return typeof Fe;
    } : function(Fe) {
      return Fe && typeof Symbol == "function" && Fe.constructor === Symbol && Fe !== Symbol.prototype ? "symbol" : typeof Fe;
    }, q(Ie);
  }
  var A = /a/g.flags !== void 0, P = function(Fe) {
    var je = [];
    return Fe.forEach(function(Ke) {
      return je.push(Ke);
    }), je;
  }, I = function(Fe) {
    var je = [];
    return Fe.forEach(function(Ke, ot) {
      return je.push([ot, Ke]);
    }), je;
  }, B = Object.is ? Object.is : requireObjectIs(), H = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, V = Number.isNaN ? Number.isNaN : requireIsNan();
  function X(Ie) {
    return Ie.call.bind(Ie);
  }
  var Q = X(Object.prototype.hasOwnProperty), ee = X(Object.prototype.propertyIsEnumerable), ie = X(Object.prototype.toString), te = requireUtil$1().types, se = te.isAnyArrayBuffer, le = te.isArrayBufferView, ce = te.isDate, pe = te.isMap, me = te.isRegExp, Me = te.isSet, Ee = te.isNativeError, Re = te.isBoxedPrimitive, Ne = te.isNumberObject, ne = te.isStringObject, Y = te.isBooleanObject, M = te.isBigIntObject, $ = te.isSymbolObject, O = te.isFloat32Array, J = te.isFloat64Array;
  function Z(Ie) {
    if (Ie.length === 0 || Ie.length > 10)
      return !0;
    for (var Fe = 0; Fe < Ie.length; Fe++) {
      var je = Ie.charCodeAt(Fe);
      if (je < 48 || je > 57)
        return !0;
    }
    return Ie.length === 10 && Ie >= Math.pow(2, 32);
  }
  function K(Ie) {
    return Object.keys(Ie).filter(Z).concat(H(Ie).filter(Object.prototype.propertyIsEnumerable.bind(Ie)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function z(Ie, Fe) {
    if (Ie === Fe)
      return 0;
    for (var je = Ie.length, Ke = Fe.length, ot = 0, ut = Math.min(je, Ke); ot < ut; ++ot)
      if (Ie[ot] !== Fe[ot]) {
        je = Ie[ot], Ke = Fe[ot];
        break;
      }
    return je < Ke ? -1 : Ke < je ? 1 : 0;
  }
  var G = !0, D = !1, F = 0, ae = 1, ge = 2, xe = 3;
  function ye(Ie, Fe) {
    return A ? Ie.source === Fe.source && Ie.flags === Fe.flags : RegExp.prototype.toString.call(Ie) === RegExp.prototype.toString.call(Fe);
  }
  function oe(Ie, Fe) {
    if (Ie.byteLength !== Fe.byteLength)
      return !1;
    for (var je = 0; je < Ie.byteLength; je++)
      if (Ie[je] !== Fe[je])
        return !1;
    return !0;
  }
  function fe(Ie, Fe) {
    return Ie.byteLength !== Fe.byteLength ? !1 : z(new Uint8Array(Ie.buffer, Ie.byteOffset, Ie.byteLength), new Uint8Array(Fe.buffer, Fe.byteOffset, Fe.byteLength)) === 0;
  }
  function $e(Ie, Fe) {
    return Ie.byteLength === Fe.byteLength && z(new Uint8Array(Ie), new Uint8Array(Fe)) === 0;
  }
  function Be(Ie, Fe) {
    return Ne(Ie) ? Ne(Fe) && B(Number.prototype.valueOf.call(Ie), Number.prototype.valueOf.call(Fe)) : ne(Ie) ? ne(Fe) && String.prototype.valueOf.call(Ie) === String.prototype.valueOf.call(Fe) : Y(Ie) ? Y(Fe) && Boolean.prototype.valueOf.call(Ie) === Boolean.prototype.valueOf.call(Fe) : M(Ie) ? M(Fe) && BigInt.prototype.valueOf.call(Ie) === BigInt.prototype.valueOf.call(Fe) : $(Fe) && Symbol.prototype.valueOf.call(Ie) === Symbol.prototype.valueOf.call(Fe);
  }
  function be(Ie, Fe, je, Ke) {
    if (Ie === Fe)
      return Ie !== 0 ? !0 : je ? B(Ie, Fe) : !0;
    if (je) {
      if (q(Ie) !== "object")
        return typeof Ie == "number" && V(Ie) && V(Fe);
      if (q(Fe) !== "object" || Ie === null || Fe === null || Object.getPrototypeOf(Ie) !== Object.getPrototypeOf(Fe))
        return !1;
    } else {
      if (Ie === null || q(Ie) !== "object")
        return Fe === null || q(Fe) !== "object" ? Ie == Fe : !1;
      if (Fe === null || q(Fe) !== "object")
        return !1;
    }
    var ot = ie(Ie), ut = ie(Fe);
    if (ot !== ut)
      return !1;
    if (Array.isArray(Ie)) {
      if (Ie.length !== Fe.length)
        return !1;
      var pt = K(Ie), ke = K(Fe);
      return pt.length !== ke.length ? !1 : qe(Ie, Fe, je, Ke, ae, pt);
    }
    if (ot === "[object Object]" && (!pe(Ie) && pe(Fe) || !Me(Ie) && Me(Fe)))
      return !1;
    if (ce(Ie)) {
      if (!ce(Fe) || Date.prototype.getTime.call(Ie) !== Date.prototype.getTime.call(Fe))
        return !1;
    } else if (me(Ie)) {
      if (!me(Fe) || !ye(Ie, Fe))
        return !1;
    } else if (Ee(Ie) || Ie instanceof Error) {
      if (Ie.message !== Fe.message || Ie.name !== Fe.name)
        return !1;
    } else if (le(Ie)) {
      if (!je && (O(Ie) || J(Ie))) {
        if (!oe(Ie, Fe))
          return !1;
      } else if (!fe(Ie, Fe))
        return !1;
      var Xe = K(Ie), at = K(Fe);
      return Xe.length !== at.length ? !1 : qe(Ie, Fe, je, Ke, F, Xe);
    } else {
      if (Me(Ie))
        return !Me(Fe) || Ie.size !== Fe.size ? !1 : qe(Ie, Fe, je, Ke, ge);
      if (pe(Ie))
        return !pe(Fe) || Ie.size !== Fe.size ? !1 : qe(Ie, Fe, je, Ke, xe);
      if (se(Ie)) {
        if (!$e(Ie, Fe))
          return !1;
      } else if (Re(Ie) && !Be(Ie, Fe))
        return !1;
    }
    return qe(Ie, Fe, je, Ke, F);
  }
  function ve(Ie, Fe) {
    return Fe.filter(function(je) {
      return ee(Ie, je);
    });
  }
  function qe(Ie, Fe, je, Ke, ot, ut) {
    if (arguments.length === 5) {
      ut = Object.keys(Ie);
      var pt = Object.keys(Fe);
      if (ut.length !== pt.length)
        return !1;
    }
    for (var ke = 0; ke < ut.length; ke++)
      if (!Q(Fe, ut[ke]))
        return !1;
    if (je && arguments.length === 5) {
      var Xe = H(Ie);
      if (Xe.length !== 0) {
        var at = 0;
        for (ke = 0; ke < Xe.length; ke++) {
          var ht = Xe[ke];
          if (ee(Ie, ht)) {
            if (!ee(Fe, ht))
              return !1;
            ut.push(ht), at++;
          } else if (ee(Fe, ht))
            return !1;
        }
        var We = H(Fe);
        if (Xe.length !== We.length && ve(Fe, We).length !== at)
          return !1;
      } else {
        var tt = H(Fe);
        if (tt.length !== 0 && ve(Fe, tt).length !== 0)
          return !1;
      }
    }
    if (ut.length === 0 && (ot === F || ot === ae && Ie.length === 0 || Ie.size === 0))
      return !0;
    if (Ke === void 0)
      Ke = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var Te = Ke.val1.get(Ie);
      if (Te !== void 0) {
        var rt = Ke.val2.get(Fe);
        if (rt !== void 0)
          return Te === rt;
      }
      Ke.position++;
    }
    Ke.val1.set(Ie, Ke.position), Ke.val2.set(Fe, Ke.position);
    var mt = He(Ie, Fe, je, ut, Ke, ot);
    return Ke.val1.delete(Ie), Ke.val2.delete(Fe), mt;
  }
  function De(Ie, Fe, je, Ke) {
    for (var ot = P(Ie), ut = 0; ut < ot.length; ut++) {
      var pt = ot[ut];
      if (be(Fe, pt, je, Ke))
        return Ie.delete(pt), !0;
    }
    return !1;
  }
  function Ye(Ie) {
    switch (q(Ie)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        Ie = +Ie;
      case "number":
        if (V(Ie))
          return !1;
    }
    return !0;
  }
  function he(Ie, Fe, je) {
    var Ke = Ye(je);
    return Ke ?? (Fe.has(Ke) && !Ie.has(Ke));
  }
  function ue(Ie, Fe, je, Ke, ot) {
    var ut = Ye(je);
    if (ut != null)
      return ut;
    var pt = Fe.get(ut);
    return pt === void 0 && !Fe.has(ut) || !be(Ke, pt, !1, ot) ? !1 : !Ie.has(ut) && be(Ke, pt, !1, ot);
  }
  function de(Ie, Fe, je, Ke) {
    for (var ot = null, ut = P(Ie), pt = 0; pt < ut.length; pt++) {
      var ke = ut[pt];
      if (q(ke) === "object" && ke !== null)
        ot === null && (ot = /* @__PURE__ */ new Set()), ot.add(ke);
      else if (!Fe.has(ke)) {
        if (je || !he(Ie, Fe, ke))
          return !1;
        ot === null && (ot = /* @__PURE__ */ new Set()), ot.add(ke);
      }
    }
    if (ot !== null) {
      for (var Xe = P(Fe), at = 0; at < Xe.length; at++) {
        var ht = Xe[at];
        if (q(ht) === "object" && ht !== null) {
          if (!De(ot, ht, je, Ke))
            return !1;
        } else if (!je && !Ie.has(ht) && !De(ot, ht, je, Ke))
          return !1;
      }
      return ot.size === 0;
    }
    return !0;
  }
  function _e(Ie, Fe, je, Ke, ot, ut) {
    for (var pt = P(Ie), ke = 0; ke < pt.length; ke++) {
      var Xe = pt[ke];
      if (be(je, Xe, ot, ut) && be(Ke, Fe.get(Xe), ot, ut))
        return Ie.delete(Xe), !0;
    }
    return !1;
  }
  function Pe(Ie, Fe, je, Ke) {
    for (var ot = null, ut = I(Ie), pt = 0; pt < ut.length; pt++) {
      var ke = e(ut[pt], 2), Xe = ke[0], at = ke[1];
      if (q(Xe) === "object" && Xe !== null)
        ot === null && (ot = /* @__PURE__ */ new Set()), ot.add(Xe);
      else {
        var ht = Fe.get(Xe);
        if (ht === void 0 && !Fe.has(Xe) || !be(at, ht, je, Ke)) {
          if (je || !ue(Ie, Fe, Xe, at, Ke))
            return !1;
          ot === null && (ot = /* @__PURE__ */ new Set()), ot.add(Xe);
        }
      }
    }
    if (ot !== null) {
      for (var We = I(Fe), tt = 0; tt < We.length; tt++) {
        var Te = e(We[tt], 2), rt = Te[0], mt = Te[1];
        if (q(rt) === "object" && rt !== null) {
          if (!_e(ot, Ie, rt, mt, je, Ke))
            return !1;
        } else if (!je && (!Ie.has(rt) || !be(Ie.get(rt), mt, !1, Ke)) && !_e(ot, Ie, rt, mt, !1, Ke))
          return !1;
      }
      return ot.size === 0;
    }
    return !0;
  }
  function He(Ie, Fe, je, Ke, ot, ut) {
    var pt = 0;
    if (ut === ge) {
      if (!de(Ie, Fe, je, ot))
        return !1;
    } else if (ut === xe) {
      if (!Pe(Ie, Fe, je, ot))
        return !1;
    } else if (ut === ae)
      for (; pt < Ie.length; pt++)
        if (Q(Ie, pt)) {
          if (!Q(Fe, pt) || !be(Ie[pt], Fe[pt], je, ot))
            return !1;
        } else {
          if (Q(Fe, pt))
            return !1;
          for (var ke = Object.keys(Ie); pt < ke.length; pt++) {
            var Xe = ke[pt];
            if (!Q(Fe, Xe) || !be(Ie[Xe], Fe[Xe], je, ot))
              return !1;
          }
          return ke.length === Object.keys(Fe).length;
        }
    for (pt = 0; pt < Ke.length; pt++) {
      var at = Ke[pt];
      if (!be(Ie[at], Fe[at], je, ot))
        return !1;
    }
    return !0;
  }
  function Ve(Ie, Fe) {
    return be(Ie, Fe, D);
  }
  function nt(Ie, Fe) {
    return be(Ie, Fe, G);
  }
  return comparisons = {
    isDeepEqual: Ve,
    isDeepStrictEqual: nt
  }, comparisons;
}
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert)
    return assert.exports;
  hasRequiredAssert = 1;
  function e(oe) {
    "@babel/helpers - typeof";
    return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(fe) {
      return typeof fe;
    } : function(fe) {
      return fe && typeof Symbol == "function" && fe.constructor === Symbol && fe !== Symbol.prototype ? "symbol" : typeof fe;
    }, e(oe);
  }
  function o(oe, fe) {
    for (var $e = 0; $e < fe.length; $e++) {
      var Be = fe[$e];
      Be.enumerable = Be.enumerable || !1, Be.configurable = !0, "value" in Be && (Be.writable = !0), Object.defineProperty(oe, g(Be.key), Be);
    }
  }
  function S(oe, fe, $e) {
    return fe && o(oe.prototype, fe), $e && o(oe, $e), Object.defineProperty(oe, "prototype", { writable: !1 }), oe;
  }
  function g(oe) {
    var fe = U(oe, "string");
    return e(fe) === "symbol" ? fe : String(fe);
  }
  function U(oe, fe) {
    if (e(oe) !== "object" || oe === null)
      return oe;
    var $e = oe[Symbol.toPrimitive];
    if ($e !== void 0) {
      var Be = $e.call(oe, fe || "default");
      if (e(Be) !== "object")
        return Be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (fe === "string" ? String : Number)(oe);
  }
  function h(oe, fe) {
    if (!(oe instanceof fe))
      throw new TypeError("Cannot call a class as a function");
  }
  var q = requireErrors(), A = q.codes, P = A.ERR_AMBIGUOUS_ARGUMENT, I = A.ERR_INVALID_ARG_TYPE, B = A.ERR_INVALID_ARG_VALUE, H = A.ERR_INVALID_RETURN_VALUE, V = A.ERR_MISSING_ARGS, X = requireAssertion_error(), Q = requireUtil$1(), ee = Q.inspect, ie = requireUtil$1().types, te = ie.isPromise, se = ie.isRegExp, le = requirePolyfill$2()(), ce = requirePolyfill$1()(), pe = callBound$1("RegExp.prototype.test"), me, Me;
  function Ee() {
    var oe = requireComparisons();
    me = oe.isDeepEqual, Me = oe.isDeepStrictEqual;
  }
  var Re = !1, Ne = assert.exports = O, ne = {};
  function Y(oe) {
    throw oe.message instanceof Error ? oe.message : new X(oe);
  }
  function M(oe, fe, $e, Be, be) {
    var ve = arguments.length, qe;
    if (ve === 0)
      qe = "Failed";
    else if (ve === 1)
      $e = oe, oe = void 0;
    else {
      if (Re === !1) {
        Re = !0;
        var De = process$3.emitWarning ? process$3.emitWarning : console.warn.bind(console);
        De("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      ve === 2 && (Be = "!=");
    }
    if ($e instanceof Error)
      throw $e;
    var Ye = {
      actual: oe,
      expected: fe,
      operator: Be === void 0 ? "fail" : Be,
      stackStartFn: be || M
    };
    $e !== void 0 && (Ye.message = $e);
    var he = new X(Ye);
    throw qe && (he.message = qe, he.generatedMessage = !0), he;
  }
  Ne.fail = M, Ne.AssertionError = X;
  function $(oe, fe, $e, Be) {
    if (!$e) {
      var be = !1;
      if (fe === 0)
        be = !0, Be = "No value argument passed to `assert.ok()`";
      else if (Be instanceof Error)
        throw Be;
      var ve = new X({
        actual: $e,
        expected: !0,
        message: Be,
        operator: "==",
        stackStartFn: oe
      });
      throw ve.generatedMessage = be, ve;
    }
  }
  function O() {
    for (var oe = arguments.length, fe = new Array(oe), $e = 0; $e < oe; $e++)
      fe[$e] = arguments[$e];
    $.apply(void 0, [O, fe.length].concat(fe));
  }
  Ne.ok = O, Ne.equal = function oe(fe, $e, Be) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    fe != $e && Y({
      actual: fe,
      expected: $e,
      message: Be,
      operator: "==",
      stackStartFn: oe
    });
  }, Ne.notEqual = function oe(fe, $e, Be) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    fe == $e && Y({
      actual: fe,
      expected: $e,
      message: Be,
      operator: "!=",
      stackStartFn: oe
    });
  }, Ne.deepEqual = function oe(fe, $e, Be) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    me === void 0 && Ee(), me(fe, $e) || Y({
      actual: fe,
      expected: $e,
      message: Be,
      operator: "deepEqual",
      stackStartFn: oe
    });
  }, Ne.notDeepEqual = function oe(fe, $e, Be) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    me === void 0 && Ee(), me(fe, $e) && Y({
      actual: fe,
      expected: $e,
      message: Be,
      operator: "notDeepEqual",
      stackStartFn: oe
    });
  }, Ne.deepStrictEqual = function oe(fe, $e, Be) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    me === void 0 && Ee(), Me(fe, $e) || Y({
      actual: fe,
      expected: $e,
      message: Be,
      operator: "deepStrictEqual",
      stackStartFn: oe
    });
  }, Ne.notDeepStrictEqual = J;
  function J(oe, fe, $e) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    me === void 0 && Ee(), Me(oe, fe) && Y({
      actual: oe,
      expected: fe,
      message: $e,
      operator: "notDeepStrictEqual",
      stackStartFn: J
    });
  }
  Ne.strictEqual = function oe(fe, $e, Be) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    ce(fe, $e) || Y({
      actual: fe,
      expected: $e,
      message: Be,
      operator: "strictEqual",
      stackStartFn: oe
    });
  }, Ne.notStrictEqual = function oe(fe, $e, Be) {
    if (arguments.length < 2)
      throw new V("actual", "expected");
    ce(fe, $e) && Y({
      actual: fe,
      expected: $e,
      message: Be,
      operator: "notStrictEqual",
      stackStartFn: oe
    });
  };
  var Z = /* @__PURE__ */ S(function oe(fe, $e, Be) {
    var be = this;
    h(this, oe), $e.forEach(function(ve) {
      ve in fe && (Be !== void 0 && typeof Be[ve] == "string" && se(fe[ve]) && pe(fe[ve], Be[ve]) ? be[ve] = Be[ve] : be[ve] = fe[ve]);
    });
  });
  function K(oe, fe, $e, Be, be, ve) {
    if (!($e in oe) || !Me(oe[$e], fe[$e])) {
      if (!Be) {
        var qe = new Z(oe, be), De = new Z(fe, be, oe), Ye = new X({
          actual: qe,
          expected: De,
          operator: "deepStrictEqual",
          stackStartFn: ve
        });
        throw Ye.actual = oe, Ye.expected = fe, Ye.operator = ve.name, Ye;
      }
      Y({
        actual: oe,
        expected: fe,
        message: Be,
        operator: ve.name,
        stackStartFn: ve
      });
    }
  }
  function z(oe, fe, $e, Be) {
    if (typeof fe != "function") {
      if (se(fe))
        return pe(fe, oe);
      if (arguments.length === 2)
        throw new I("expected", ["Function", "RegExp"], fe);
      if (e(oe) !== "object" || oe === null) {
        var be = new X({
          actual: oe,
          expected: fe,
          message: $e,
          operator: "deepStrictEqual",
          stackStartFn: Be
        });
        throw be.operator = Be.name, be;
      }
      var ve = Object.keys(fe);
      if (fe instanceof Error)
        ve.push("name", "message");
      else if (ve.length === 0)
        throw new B("error", fe, "may not be an empty object");
      return me === void 0 && Ee(), ve.forEach(function(qe) {
        typeof oe[qe] == "string" && se(fe[qe]) && pe(fe[qe], oe[qe]) || K(oe, fe, qe, $e, ve, Be);
      }), !0;
    }
    return fe.prototype !== void 0 && oe instanceof fe ? !0 : Error.isPrototypeOf(fe) ? !1 : fe.call({}, oe) === !0;
  }
  function G(oe) {
    if (typeof oe != "function")
      throw new I("fn", "Function", oe);
    try {
      oe();
    } catch (fe) {
      return fe;
    }
    return ne;
  }
  function D(oe) {
    return te(oe) || oe !== null && e(oe) === "object" && typeof oe.then == "function" && typeof oe.catch == "function";
  }
  function F(oe) {
    return Promise.resolve().then(function() {
      var fe;
      if (typeof oe == "function") {
        if (fe = oe(), !D(fe))
          throw new H("instance of Promise", "promiseFn", fe);
      } else if (D(oe))
        fe = oe;
      else
        throw new I("promiseFn", ["Function", "Promise"], oe);
      return Promise.resolve().then(function() {
        return fe;
      }).then(function() {
        return ne;
      }).catch(function($e) {
        return $e;
      });
    });
  }
  function ae(oe, fe, $e, Be) {
    if (typeof $e == "string") {
      if (arguments.length === 4)
        throw new I("error", ["Object", "Error", "Function", "RegExp"], $e);
      if (e(fe) === "object" && fe !== null) {
        if (fe.message === $e)
          throw new P("error/message", 'The error message "'.concat(fe.message, '" is identical to the message.'));
      } else if (fe === $e)
        throw new P("error/message", 'The error "'.concat(fe, '" is identical to the message.'));
      Be = $e, $e = void 0;
    } else if ($e != null && e($e) !== "object" && typeof $e != "function")
      throw new I("error", ["Object", "Error", "Function", "RegExp"], $e);
    if (fe === ne) {
      var be = "";
      $e && $e.name && (be += " (".concat($e.name, ")")), be += Be ? ": ".concat(Be) : ".";
      var ve = oe.name === "rejects" ? "rejection" : "exception";
      Y({
        actual: void 0,
        expected: $e,
        operator: oe.name,
        message: "Missing expected ".concat(ve).concat(be),
        stackStartFn: oe
      });
    }
    if ($e && !z(fe, $e, Be, oe))
      throw fe;
  }
  function ge(oe, fe, $e, Be) {
    if (fe !== ne) {
      if (typeof $e == "string" && (Be = $e, $e = void 0), !$e || z(fe, $e)) {
        var be = Be ? ": ".concat(Be) : ".", ve = oe.name === "doesNotReject" ? "rejection" : "exception";
        Y({
          actual: fe,
          expected: $e,
          operator: oe.name,
          message: "Got unwanted ".concat(ve).concat(be, `
`) + 'Actual message: "'.concat(fe && fe.message, '"'),
          stackStartFn: oe
        });
      }
      throw fe;
    }
  }
  Ne.throws = function oe(fe) {
    for (var $e = arguments.length, Be = new Array($e > 1 ? $e - 1 : 0), be = 1; be < $e; be++)
      Be[be - 1] = arguments[be];
    ae.apply(void 0, [oe, G(fe)].concat(Be));
  }, Ne.rejects = function oe(fe) {
    for (var $e = arguments.length, Be = new Array($e > 1 ? $e - 1 : 0), be = 1; be < $e; be++)
      Be[be - 1] = arguments[be];
    return F(fe).then(function(ve) {
      return ae.apply(void 0, [oe, ve].concat(Be));
    });
  }, Ne.doesNotThrow = function oe(fe) {
    for (var $e = arguments.length, Be = new Array($e > 1 ? $e - 1 : 0), be = 1; be < $e; be++)
      Be[be - 1] = arguments[be];
    ge.apply(void 0, [oe, G(fe)].concat(Be));
  }, Ne.doesNotReject = function oe(fe) {
    for (var $e = arguments.length, Be = new Array($e > 1 ? $e - 1 : 0), be = 1; be < $e; be++)
      Be[be - 1] = arguments[be];
    return F(fe).then(function(ve) {
      return ge.apply(void 0, [oe, ve].concat(Be));
    });
  }, Ne.ifError = function oe(fe) {
    if (fe != null) {
      var $e = "ifError got unwanted exception: ";
      e(fe) === "object" && typeof fe.message == "string" ? fe.message.length === 0 && fe.constructor ? $e += fe.constructor.name : $e += fe.message : $e += ee(fe);
      var Be = new X({
        actual: fe,
        expected: null,
        operator: "ifError",
        message: $e,
        stackStartFn: oe
      }), be = fe.stack;
      if (typeof be == "string") {
        var ve = be.split(`
`);
        ve.shift();
        for (var qe = Be.stack.split(`
`), De = 0; De < ve.length; De++) {
          var Ye = qe.indexOf(ve[De]);
          if (Ye !== -1) {
            qe = qe.slice(0, Ye);
            break;
          }
        }
        Be.stack = "".concat(qe.join(`
`), `
`).concat(ve.join(`
`));
      }
      throw Be;
    }
  };
  function xe(oe, fe, $e, Be, be) {
    if (!se(fe))
      throw new I("regexp", "RegExp", fe);
    var ve = be === "match";
    if (typeof oe != "string" || pe(fe, oe) !== ve) {
      if ($e instanceof Error)
        throw $e;
      var qe = !$e;
      $e = $e || (typeof oe != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(e(oe), " (").concat(ee(oe), ")") : (ve ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(ee(fe), `. Input:

`).concat(ee(oe), `
`));
      var De = new X({
        actual: oe,
        expected: fe,
        message: $e,
        operator: be,
        stackStartFn: Be
      });
      throw De.generatedMessage = qe, De;
    }
  }
  Ne.match = function oe(fe, $e, Be) {
    xe(fe, $e, Be, oe, "match");
  }, Ne.doesNotMatch = function oe(fe, $e, Be) {
    xe(fe, $e, Be, oe, "doesNotMatch");
  };
  function ye() {
    for (var oe = arguments.length, fe = new Array(oe), $e = 0; $e < oe; $e++)
      fe[$e] = arguments[$e];
    $.apply(void 0, [ye, fe.length].concat(fe));
  }
  return Ne.strict = le(ye, Ne, {
    equal: Ne.strictEqual,
    deepEqual: Ne.deepStrictEqual,
    notEqual: Ne.notStrictEqual,
    notDeepEqual: Ne.notDeepStrictEqual
  }), Ne.strict.strict = Ne.strict, assert.exports;
}
var zstream, hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream)
    return zstream;
  hasRequiredZstream = 1;
  function e() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  return zstream = e, zstream;
}
var deflate = {}, common$2 = {}, hasRequiredCommon$2;
function requireCommon$2() {
  return hasRequiredCommon$2 || (hasRequiredCommon$2 = 1, function(e) {
    var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function S(h, q) {
      return Object.prototype.hasOwnProperty.call(h, q);
    }
    e.assign = function(h) {
      for (var q = Array.prototype.slice.call(arguments, 1); q.length; ) {
        var A = q.shift();
        if (A) {
          if (typeof A != "object")
            throw new TypeError(A + "must be non-object");
          for (var P in A)
            S(A, P) && (h[P] = A[P]);
        }
      }
      return h;
    }, e.shrinkBuf = function(h, q) {
      return h.length === q ? h : h.subarray ? h.subarray(0, q) : (h.length = q, h);
    };
    var g = {
      arraySet: function(h, q, A, P, I) {
        if (q.subarray && h.subarray) {
          h.set(q.subarray(A, A + P), I);
          return;
        }
        for (var B = 0; B < P; B++)
          h[I + B] = q[A + B];
      },
      // Join array of chunks to single array.
      flattenChunks: function(h) {
        var q, A, P, I, B, H;
        for (P = 0, q = 0, A = h.length; q < A; q++)
          P += h[q].length;
        for (H = new Uint8Array(P), I = 0, q = 0, A = h.length; q < A; q++)
          B = h[q], H.set(B, I), I += B.length;
        return H;
      }
    }, U = {
      arraySet: function(h, q, A, P, I) {
        for (var B = 0; B < P; B++)
          h[I + B] = q[A + B];
      },
      // Join array of chunks to single array.
      flattenChunks: function(h) {
        return [].concat.apply([], h);
      }
    };
    e.setTyped = function(h) {
      h ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, g)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, U));
    }, e.setTyped(o);
  }(common$2)), common$2;
}
var trees = {}, hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees)
    return trees;
  hasRequiredTrees = 1;
  var e = requireCommon$2(), o = 4, S = 0, g = 1, U = 2;
  function h(ke) {
    for (var Xe = ke.length; --Xe >= 0; )
      ke[Xe] = 0;
  }
  var q = 0, A = 1, P = 2, I = 3, B = 258, H = 29, V = 256, X = V + 1 + H, Q = 30, ee = 19, ie = 2 * X + 1, te = 15, se = 16, le = 7, ce = 256, pe = 16, me = 17, Me = 18, Ee = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  ), Re = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  ), Ne = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  ), ne = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Y = 512, M = new Array((X + 2) * 2);
  h(M);
  var $ = new Array(Q * 2);
  h($);
  var O = new Array(Y);
  h(O);
  var J = new Array(B - I + 1);
  h(J);
  var Z = new Array(H);
  h(Z);
  var K = new Array(Q);
  h(K);
  function z(ke, Xe, at, ht, We) {
    this.static_tree = ke, this.extra_bits = Xe, this.extra_base = at, this.elems = ht, this.max_length = We, this.has_stree = ke && ke.length;
  }
  var G, D, F;
  function ae(ke, Xe) {
    this.dyn_tree = ke, this.max_code = 0, this.stat_desc = Xe;
  }
  function ge(ke) {
    return ke < 256 ? O[ke] : O[256 + (ke >>> 7)];
  }
  function xe(ke, Xe) {
    ke.pending_buf[ke.pending++] = Xe & 255, ke.pending_buf[ke.pending++] = Xe >>> 8 & 255;
  }
  function ye(ke, Xe, at) {
    ke.bi_valid > se - at ? (ke.bi_buf |= Xe << ke.bi_valid & 65535, xe(ke, ke.bi_buf), ke.bi_buf = Xe >> se - ke.bi_valid, ke.bi_valid += at - se) : (ke.bi_buf |= Xe << ke.bi_valid & 65535, ke.bi_valid += at);
  }
  function oe(ke, Xe, at) {
    ye(
      ke,
      at[Xe * 2],
      at[Xe * 2 + 1]
      /*.Len*/
    );
  }
  function fe(ke, Xe) {
    var at = 0;
    do
      at |= ke & 1, ke >>>= 1, at <<= 1;
    while (--Xe > 0);
    return at >>> 1;
  }
  function $e(ke) {
    ke.bi_valid === 16 ? (xe(ke, ke.bi_buf), ke.bi_buf = 0, ke.bi_valid = 0) : ke.bi_valid >= 8 && (ke.pending_buf[ke.pending++] = ke.bi_buf & 255, ke.bi_buf >>= 8, ke.bi_valid -= 8);
  }
  function Be(ke, Xe) {
    var at = Xe.dyn_tree, ht = Xe.max_code, We = Xe.stat_desc.static_tree, tt = Xe.stat_desc.has_stree, Te = Xe.stat_desc.extra_bits, rt = Xe.stat_desc.extra_base, mt = Xe.stat_desc.max_length, Se, et, Ze, Le, ze, Qe, _t = 0;
    for (Le = 0; Le <= te; Le++)
      ke.bl_count[Le] = 0;
    for (at[ke.heap[ke.heap_max] * 2 + 1] = 0, Se = ke.heap_max + 1; Se < ie; Se++)
      et = ke.heap[Se], Le = at[at[et * 2 + 1] * 2 + 1] + 1, Le > mt && (Le = mt, _t++), at[et * 2 + 1] = Le, !(et > ht) && (ke.bl_count[Le]++, ze = 0, et >= rt && (ze = Te[et - rt]), Qe = at[et * 2], ke.opt_len += Qe * (Le + ze), tt && (ke.static_len += Qe * (We[et * 2 + 1] + ze)));
    if (_t !== 0) {
      do {
        for (Le = mt - 1; ke.bl_count[Le] === 0; )
          Le--;
        ke.bl_count[Le]--, ke.bl_count[Le + 1] += 2, ke.bl_count[mt]--, _t -= 2;
      } while (_t > 0);
      for (Le = mt; Le !== 0; Le--)
        for (et = ke.bl_count[Le]; et !== 0; )
          Ze = ke.heap[--Se], !(Ze > ht) && (at[Ze * 2 + 1] !== Le && (ke.opt_len += (Le - at[Ze * 2 + 1]) * at[Ze * 2], at[Ze * 2 + 1] = Le), et--);
    }
  }
  function be(ke, Xe, at) {
    var ht = new Array(te + 1), We = 0, tt, Te;
    for (tt = 1; tt <= te; tt++)
      ht[tt] = We = We + at[tt - 1] << 1;
    for (Te = 0; Te <= Xe; Te++) {
      var rt = ke[Te * 2 + 1];
      rt !== 0 && (ke[Te * 2] = fe(ht[rt]++, rt));
    }
  }
  function ve() {
    var ke, Xe, at, ht, We, tt = new Array(te + 1);
    for (at = 0, ht = 0; ht < H - 1; ht++)
      for (Z[ht] = at, ke = 0; ke < 1 << Ee[ht]; ke++)
        J[at++] = ht;
    for (J[at - 1] = ht, We = 0, ht = 0; ht < 16; ht++)
      for (K[ht] = We, ke = 0; ke < 1 << Re[ht]; ke++)
        O[We++] = ht;
    for (We >>= 7; ht < Q; ht++)
      for (K[ht] = We << 7, ke = 0; ke < 1 << Re[ht] - 7; ke++)
        O[256 + We++] = ht;
    for (Xe = 0; Xe <= te; Xe++)
      tt[Xe] = 0;
    for (ke = 0; ke <= 143; )
      M[ke * 2 + 1] = 8, ke++, tt[8]++;
    for (; ke <= 255; )
      M[ke * 2 + 1] = 9, ke++, tt[9]++;
    for (; ke <= 279; )
      M[ke * 2 + 1] = 7, ke++, tt[7]++;
    for (; ke <= 287; )
      M[ke * 2 + 1] = 8, ke++, tt[8]++;
    for (be(M, X + 1, tt), ke = 0; ke < Q; ke++)
      $[ke * 2 + 1] = 5, $[ke * 2] = fe(ke, 5);
    G = new z(M, Ee, V + 1, X, te), D = new z($, Re, 0, Q, te), F = new z(new Array(0), Ne, 0, ee, le);
  }
  function qe(ke) {
    var Xe;
    for (Xe = 0; Xe < X; Xe++)
      ke.dyn_ltree[Xe * 2] = 0;
    for (Xe = 0; Xe < Q; Xe++)
      ke.dyn_dtree[Xe * 2] = 0;
    for (Xe = 0; Xe < ee; Xe++)
      ke.bl_tree[Xe * 2] = 0;
    ke.dyn_ltree[ce * 2] = 1, ke.opt_len = ke.static_len = 0, ke.last_lit = ke.matches = 0;
  }
  function De(ke) {
    ke.bi_valid > 8 ? xe(ke, ke.bi_buf) : ke.bi_valid > 0 && (ke.pending_buf[ke.pending++] = ke.bi_buf), ke.bi_buf = 0, ke.bi_valid = 0;
  }
  function Ye(ke, Xe, at, ht) {
    De(ke), ht && (xe(ke, at), xe(ke, ~at)), e.arraySet(ke.pending_buf, ke.window, Xe, at, ke.pending), ke.pending += at;
  }
  function he(ke, Xe, at, ht) {
    var We = Xe * 2, tt = at * 2;
    return ke[We] < ke[tt] || ke[We] === ke[tt] && ht[Xe] <= ht[at];
  }
  function ue(ke, Xe, at) {
    for (var ht = ke.heap[at], We = at << 1; We <= ke.heap_len && (We < ke.heap_len && he(Xe, ke.heap[We + 1], ke.heap[We], ke.depth) && We++, !he(Xe, ht, ke.heap[We], ke.depth)); )
      ke.heap[at] = ke.heap[We], at = We, We <<= 1;
    ke.heap[at] = ht;
  }
  function de(ke, Xe, at) {
    var ht, We, tt = 0, Te, rt;
    if (ke.last_lit !== 0)
      do
        ht = ke.pending_buf[ke.d_buf + tt * 2] << 8 | ke.pending_buf[ke.d_buf + tt * 2 + 1], We = ke.pending_buf[ke.l_buf + tt], tt++, ht === 0 ? oe(ke, We, Xe) : (Te = J[We], oe(ke, Te + V + 1, Xe), rt = Ee[Te], rt !== 0 && (We -= Z[Te], ye(ke, We, rt)), ht--, Te = ge(ht), oe(ke, Te, at), rt = Re[Te], rt !== 0 && (ht -= K[Te], ye(ke, ht, rt)));
      while (tt < ke.last_lit);
    oe(ke, ce, Xe);
  }
  function _e(ke, Xe) {
    var at = Xe.dyn_tree, ht = Xe.stat_desc.static_tree, We = Xe.stat_desc.has_stree, tt = Xe.stat_desc.elems, Te, rt, mt = -1, Se;
    for (ke.heap_len = 0, ke.heap_max = ie, Te = 0; Te < tt; Te++)
      at[Te * 2] !== 0 ? (ke.heap[++ke.heap_len] = mt = Te, ke.depth[Te] = 0) : at[Te * 2 + 1] = 0;
    for (; ke.heap_len < 2; )
      Se = ke.heap[++ke.heap_len] = mt < 2 ? ++mt : 0, at[Se * 2] = 1, ke.depth[Se] = 0, ke.opt_len--, We && (ke.static_len -= ht[Se * 2 + 1]);
    for (Xe.max_code = mt, Te = ke.heap_len >> 1; Te >= 1; Te--)
      ue(ke, at, Te);
    Se = tt;
    do
      Te = ke.heap[
        1
        /*SMALLEST*/
      ], ke.heap[
        1
        /*SMALLEST*/
      ] = ke.heap[ke.heap_len--], ue(
        ke,
        at,
        1
        /*SMALLEST*/
      ), rt = ke.heap[
        1
        /*SMALLEST*/
      ], ke.heap[--ke.heap_max] = Te, ke.heap[--ke.heap_max] = rt, at[Se * 2] = at[Te * 2] + at[rt * 2], ke.depth[Se] = (ke.depth[Te] >= ke.depth[rt] ? ke.depth[Te] : ke.depth[rt]) + 1, at[Te * 2 + 1] = at[rt * 2 + 1] = Se, ke.heap[
        1
        /*SMALLEST*/
      ] = Se++, ue(
        ke,
        at,
        1
        /*SMALLEST*/
      );
    while (ke.heap_len >= 2);
    ke.heap[--ke.heap_max] = ke.heap[
      1
      /*SMALLEST*/
    ], Be(ke, Xe), be(at, mt, ke.bl_count);
  }
  function Pe(ke, Xe, at) {
    var ht, We = -1, tt, Te = Xe[0 * 2 + 1], rt = 0, mt = 7, Se = 4;
    for (Te === 0 && (mt = 138, Se = 3), Xe[(at + 1) * 2 + 1] = 65535, ht = 0; ht <= at; ht++)
      tt = Te, Te = Xe[(ht + 1) * 2 + 1], !(++rt < mt && tt === Te) && (rt < Se ? ke.bl_tree[tt * 2] += rt : tt !== 0 ? (tt !== We && ke.bl_tree[tt * 2]++, ke.bl_tree[pe * 2]++) : rt <= 10 ? ke.bl_tree[me * 2]++ : ke.bl_tree[Me * 2]++, rt = 0, We = tt, Te === 0 ? (mt = 138, Se = 3) : tt === Te ? (mt = 6, Se = 3) : (mt = 7, Se = 4));
  }
  function He(ke, Xe, at) {
    var ht, We = -1, tt, Te = Xe[0 * 2 + 1], rt = 0, mt = 7, Se = 4;
    for (Te === 0 && (mt = 138, Se = 3), ht = 0; ht <= at; ht++)
      if (tt = Te, Te = Xe[(ht + 1) * 2 + 1], !(++rt < mt && tt === Te)) {
        if (rt < Se)
          do
            oe(ke, tt, ke.bl_tree);
          while (--rt !== 0);
        else
          tt !== 0 ? (tt !== We && (oe(ke, tt, ke.bl_tree), rt--), oe(ke, pe, ke.bl_tree), ye(ke, rt - 3, 2)) : rt <= 10 ? (oe(ke, me, ke.bl_tree), ye(ke, rt - 3, 3)) : (oe(ke, Me, ke.bl_tree), ye(ke, rt - 11, 7));
        rt = 0, We = tt, Te === 0 ? (mt = 138, Se = 3) : tt === Te ? (mt = 6, Se = 3) : (mt = 7, Se = 4);
      }
  }
  function Ve(ke) {
    var Xe;
    for (Pe(ke, ke.dyn_ltree, ke.l_desc.max_code), Pe(ke, ke.dyn_dtree, ke.d_desc.max_code), _e(ke, ke.bl_desc), Xe = ee - 1; Xe >= 3 && ke.bl_tree[ne[Xe] * 2 + 1] === 0; Xe--)
      ;
    return ke.opt_len += 3 * (Xe + 1) + 5 + 5 + 4, Xe;
  }
  function nt(ke, Xe, at, ht) {
    var We;
    for (ye(ke, Xe - 257, 5), ye(ke, at - 1, 5), ye(ke, ht - 4, 4), We = 0; We < ht; We++)
      ye(ke, ke.bl_tree[ne[We] * 2 + 1], 3);
    He(ke, ke.dyn_ltree, Xe - 1), He(ke, ke.dyn_dtree, at - 1);
  }
  function Ie(ke) {
    var Xe = 4093624447, at;
    for (at = 0; at <= 31; at++, Xe >>>= 1)
      if (Xe & 1 && ke.dyn_ltree[at * 2] !== 0)
        return S;
    if (ke.dyn_ltree[9 * 2] !== 0 || ke.dyn_ltree[10 * 2] !== 0 || ke.dyn_ltree[13 * 2] !== 0)
      return g;
    for (at = 32; at < V; at++)
      if (ke.dyn_ltree[at * 2] !== 0)
        return g;
    return S;
  }
  var Fe = !1;
  function je(ke) {
    Fe || (ve(), Fe = !0), ke.l_desc = new ae(ke.dyn_ltree, G), ke.d_desc = new ae(ke.dyn_dtree, D), ke.bl_desc = new ae(ke.bl_tree, F), ke.bi_buf = 0, ke.bi_valid = 0, qe(ke);
  }
  function Ke(ke, Xe, at, ht) {
    ye(ke, (q << 1) + (ht ? 1 : 0), 3), Ye(ke, Xe, at, !0);
  }
  function ot(ke) {
    ye(ke, A << 1, 3), oe(ke, ce, M), $e(ke);
  }
  function ut(ke, Xe, at, ht) {
    var We, tt, Te = 0;
    ke.level > 0 ? (ke.strm.data_type === U && (ke.strm.data_type = Ie(ke)), _e(ke, ke.l_desc), _e(ke, ke.d_desc), Te = Ve(ke), We = ke.opt_len + 3 + 7 >>> 3, tt = ke.static_len + 3 + 7 >>> 3, tt <= We && (We = tt)) : We = tt = at + 5, at + 4 <= We && Xe !== -1 ? Ke(ke, Xe, at, ht) : ke.strategy === o || tt === We ? (ye(ke, (A << 1) + (ht ? 1 : 0), 3), de(ke, M, $)) : (ye(ke, (P << 1) + (ht ? 1 : 0), 3), nt(ke, ke.l_desc.max_code + 1, ke.d_desc.max_code + 1, Te + 1), de(ke, ke.dyn_ltree, ke.dyn_dtree)), qe(ke), ht && De(ke);
  }
  function pt(ke, Xe, at) {
    return ke.pending_buf[ke.d_buf + ke.last_lit * 2] = Xe >>> 8 & 255, ke.pending_buf[ke.d_buf + ke.last_lit * 2 + 1] = Xe & 255, ke.pending_buf[ke.l_buf + ke.last_lit] = at & 255, ke.last_lit++, Xe === 0 ? ke.dyn_ltree[at * 2]++ : (ke.matches++, Xe--, ke.dyn_ltree[(J[at] + V + 1) * 2]++, ke.dyn_dtree[ge(Xe) * 2]++), ke.last_lit === ke.lit_bufsize - 1;
  }
  return trees._tr_init = je, trees._tr_stored_block = Ke, trees._tr_flush_block = ut, trees._tr_tally = pt, trees._tr_align = ot, trees;
}
var adler32_1, hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32)
    return adler32_1;
  hasRequiredAdler32 = 1;
  function e(o, S, g, U) {
    for (var h = o & 65535 | 0, q = o >>> 16 & 65535 | 0, A = 0; g !== 0; ) {
      A = g > 2e3 ? 2e3 : g, g -= A;
      do
        h = h + S[U++] | 0, q = q + h | 0;
      while (--A);
      h %= 65521, q %= 65521;
    }
    return h | q << 16 | 0;
  }
  return adler32_1 = e, adler32_1;
}
var crc32_1, hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32)
    return crc32_1;
  hasRequiredCrc32 = 1;
  function e() {
    for (var g, U = [], h = 0; h < 256; h++) {
      g = h;
      for (var q = 0; q < 8; q++)
        g = g & 1 ? 3988292384 ^ g >>> 1 : g >>> 1;
      U[h] = g;
    }
    return U;
  }
  var o = e();
  function S(g, U, h, q) {
    var A = o, P = q + h;
    g ^= -1;
    for (var I = q; I < P; I++)
      g = g >>> 8 ^ A[(g ^ U[I]) & 255];
    return g ^ -1;
  }
  return crc32_1 = S, crc32_1;
}
var messages, hasRequiredMessages;
function requireMessages() {
  return hasRequiredMessages || (hasRequiredMessages = 1, messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  }), messages;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate)
    return deflate;
  hasRequiredDeflate = 1;
  var e = requireCommon$2(), o = requireTrees(), S = requireAdler32(), g = requireCrc32(), U = requireMessages(), h = 0, q = 1, A = 3, P = 4, I = 5, B = 0, H = 1, V = -2, X = -3, Q = -5, ee = -1, ie = 1, te = 2, se = 3, le = 4, ce = 0, pe = 2, me = 8, Me = 9, Ee = 15, Re = 8, Ne = 29, ne = 256, Y = ne + 1 + Ne, M = 30, $ = 19, O = 2 * Y + 1, J = 15, Z = 3, K = 258, z = K + Z + 1, G = 32, D = 42, F = 69, ae = 73, ge = 91, xe = 103, ye = 113, oe = 666, fe = 1, $e = 2, Be = 3, be = 4, ve = 3;
  function qe(Se, et) {
    return Se.msg = U[et], et;
  }
  function De(Se) {
    return (Se << 1) - (Se > 4 ? 9 : 0);
  }
  function Ye(Se) {
    for (var et = Se.length; --et >= 0; )
      Se[et] = 0;
  }
  function he(Se) {
    var et = Se.state, Ze = et.pending;
    Ze > Se.avail_out && (Ze = Se.avail_out), Ze !== 0 && (e.arraySet(Se.output, et.pending_buf, et.pending_out, Ze, Se.next_out), Se.next_out += Ze, et.pending_out += Ze, Se.total_out += Ze, Se.avail_out -= Ze, et.pending -= Ze, et.pending === 0 && (et.pending_out = 0));
  }
  function ue(Se, et) {
    o._tr_flush_block(Se, Se.block_start >= 0 ? Se.block_start : -1, Se.strstart - Se.block_start, et), Se.block_start = Se.strstart, he(Se.strm);
  }
  function de(Se, et) {
    Se.pending_buf[Se.pending++] = et;
  }
  function _e(Se, et) {
    Se.pending_buf[Se.pending++] = et >>> 8 & 255, Se.pending_buf[Se.pending++] = et & 255;
  }
  function Pe(Se, et, Ze, Le) {
    var ze = Se.avail_in;
    return ze > Le && (ze = Le), ze === 0 ? 0 : (Se.avail_in -= ze, e.arraySet(et, Se.input, Se.next_in, ze, Ze), Se.state.wrap === 1 ? Se.adler = S(Se.adler, et, ze, Ze) : Se.state.wrap === 2 && (Se.adler = g(Se.adler, et, ze, Ze)), Se.next_in += ze, Se.total_in += ze, ze);
  }
  function He(Se, et) {
    var Ze = Se.max_chain_length, Le = Se.strstart, ze, Qe, _t = Se.prev_length, ft = Se.nice_match, dt = Se.strstart > Se.w_size - z ? Se.strstart - (Se.w_size - z) : 0, Mt = Se.window, St = Se.w_mask, $t = Se.prev, At = Se.strstart + K, Ae = Mt[Le + _t - 1], Ce = Mt[Le + _t];
    Se.prev_length >= Se.good_match && (Ze >>= 2), ft > Se.lookahead && (ft = Se.lookahead);
    do
      if (ze = et, !(Mt[ze + _t] !== Ce || Mt[ze + _t - 1] !== Ae || Mt[ze] !== Mt[Le] || Mt[++ze] !== Mt[Le + 1])) {
        Le += 2, ze++;
        do
          ;
        while (Mt[++Le] === Mt[++ze] && Mt[++Le] === Mt[++ze] && Mt[++Le] === Mt[++ze] && Mt[++Le] === Mt[++ze] && Mt[++Le] === Mt[++ze] && Mt[++Le] === Mt[++ze] && Mt[++Le] === Mt[++ze] && Mt[++Le] === Mt[++ze] && Le < At);
        if (Qe = K - (At - Le), Le = At - K, Qe > _t) {
          if (Se.match_start = et, _t = Qe, Qe >= ft)
            break;
          Ae = Mt[Le + _t - 1], Ce = Mt[Le + _t];
        }
      }
    while ((et = $t[et & St]) > dt && --Ze !== 0);
    return _t <= Se.lookahead ? _t : Se.lookahead;
  }
  function Ve(Se) {
    var et = Se.w_size, Ze, Le, ze, Qe, _t;
    do {
      if (Qe = Se.window_size - Se.lookahead - Se.strstart, Se.strstart >= et + (et - z)) {
        e.arraySet(Se.window, Se.window, et, et, 0), Se.match_start -= et, Se.strstart -= et, Se.block_start -= et, Le = Se.hash_size, Ze = Le;
        do
          ze = Se.head[--Ze], Se.head[Ze] = ze >= et ? ze - et : 0;
        while (--Le);
        Le = et, Ze = Le;
        do
          ze = Se.prev[--Ze], Se.prev[Ze] = ze >= et ? ze - et : 0;
        while (--Le);
        Qe += et;
      }
      if (Se.strm.avail_in === 0)
        break;
      if (Le = Pe(Se.strm, Se.window, Se.strstart + Se.lookahead, Qe), Se.lookahead += Le, Se.lookahead + Se.insert >= Z)
        for (_t = Se.strstart - Se.insert, Se.ins_h = Se.window[_t], Se.ins_h = (Se.ins_h << Se.hash_shift ^ Se.window[_t + 1]) & Se.hash_mask; Se.insert && (Se.ins_h = (Se.ins_h << Se.hash_shift ^ Se.window[_t + Z - 1]) & Se.hash_mask, Se.prev[_t & Se.w_mask] = Se.head[Se.ins_h], Se.head[Se.ins_h] = _t, _t++, Se.insert--, !(Se.lookahead + Se.insert < Z)); )
          ;
    } while (Se.lookahead < z && Se.strm.avail_in !== 0);
  }
  function nt(Se, et) {
    var Ze = 65535;
    for (Ze > Se.pending_buf_size - 5 && (Ze = Se.pending_buf_size - 5); ; ) {
      if (Se.lookahead <= 1) {
        if (Ve(Se), Se.lookahead === 0 && et === h)
          return fe;
        if (Se.lookahead === 0)
          break;
      }
      Se.strstart += Se.lookahead, Se.lookahead = 0;
      var Le = Se.block_start + Ze;
      if ((Se.strstart === 0 || Se.strstart >= Le) && (Se.lookahead = Se.strstart - Le, Se.strstart = Le, ue(Se, !1), Se.strm.avail_out === 0) || Se.strstart - Se.block_start >= Se.w_size - z && (ue(Se, !1), Se.strm.avail_out === 0))
        return fe;
    }
    return Se.insert = 0, et === P ? (ue(Se, !0), Se.strm.avail_out === 0 ? Be : be) : (Se.strstart > Se.block_start && (ue(Se, !1), Se.strm.avail_out === 0), fe);
  }
  function Ie(Se, et) {
    for (var Ze, Le; ; ) {
      if (Se.lookahead < z) {
        if (Ve(Se), Se.lookahead < z && et === h)
          return fe;
        if (Se.lookahead === 0)
          break;
      }
      if (Ze = 0, Se.lookahead >= Z && (Se.ins_h = (Se.ins_h << Se.hash_shift ^ Se.window[Se.strstart + Z - 1]) & Se.hash_mask, Ze = Se.prev[Se.strstart & Se.w_mask] = Se.head[Se.ins_h], Se.head[Se.ins_h] = Se.strstart), Ze !== 0 && Se.strstart - Ze <= Se.w_size - z && (Se.match_length = He(Se, Ze)), Se.match_length >= Z)
        if (Le = o._tr_tally(Se, Se.strstart - Se.match_start, Se.match_length - Z), Se.lookahead -= Se.match_length, Se.match_length <= Se.max_lazy_match && Se.lookahead >= Z) {
          Se.match_length--;
          do
            Se.strstart++, Se.ins_h = (Se.ins_h << Se.hash_shift ^ Se.window[Se.strstart + Z - 1]) & Se.hash_mask, Ze = Se.prev[Se.strstart & Se.w_mask] = Se.head[Se.ins_h], Se.head[Se.ins_h] = Se.strstart;
          while (--Se.match_length !== 0);
          Se.strstart++;
        } else
          Se.strstart += Se.match_length, Se.match_length = 0, Se.ins_h = Se.window[Se.strstart], Se.ins_h = (Se.ins_h << Se.hash_shift ^ Se.window[Se.strstart + 1]) & Se.hash_mask;
      else
        Le = o._tr_tally(Se, 0, Se.window[Se.strstart]), Se.lookahead--, Se.strstart++;
      if (Le && (ue(Se, !1), Se.strm.avail_out === 0))
        return fe;
    }
    return Se.insert = Se.strstart < Z - 1 ? Se.strstart : Z - 1, et === P ? (ue(Se, !0), Se.strm.avail_out === 0 ? Be : be) : Se.last_lit && (ue(Se, !1), Se.strm.avail_out === 0) ? fe : $e;
  }
  function Fe(Se, et) {
    for (var Ze, Le, ze; ; ) {
      if (Se.lookahead < z) {
        if (Ve(Se), Se.lookahead < z && et === h)
          return fe;
        if (Se.lookahead === 0)
          break;
      }
      if (Ze = 0, Se.lookahead >= Z && (Se.ins_h = (Se.ins_h << Se.hash_shift ^ Se.window[Se.strstart + Z - 1]) & Se.hash_mask, Ze = Se.prev[Se.strstart & Se.w_mask] = Se.head[Se.ins_h], Se.head[Se.ins_h] = Se.strstart), Se.prev_length = Se.match_length, Se.prev_match = Se.match_start, Se.match_length = Z - 1, Ze !== 0 && Se.prev_length < Se.max_lazy_match && Se.strstart - Ze <= Se.w_size - z && (Se.match_length = He(Se, Ze), Se.match_length <= 5 && (Se.strategy === ie || Se.match_length === Z && Se.strstart - Se.match_start > 4096) && (Se.match_length = Z - 1)), Se.prev_length >= Z && Se.match_length <= Se.prev_length) {
        ze = Se.strstart + Se.lookahead - Z, Le = o._tr_tally(Se, Se.strstart - 1 - Se.prev_match, Se.prev_length - Z), Se.lookahead -= Se.prev_length - 1, Se.prev_length -= 2;
        do
          ++Se.strstart <= ze && (Se.ins_h = (Se.ins_h << Se.hash_shift ^ Se.window[Se.strstart + Z - 1]) & Se.hash_mask, Ze = Se.prev[Se.strstart & Se.w_mask] = Se.head[Se.ins_h], Se.head[Se.ins_h] = Se.strstart);
        while (--Se.prev_length !== 0);
        if (Se.match_available = 0, Se.match_length = Z - 1, Se.strstart++, Le && (ue(Se, !1), Se.strm.avail_out === 0))
          return fe;
      } else if (Se.match_available) {
        if (Le = o._tr_tally(Se, 0, Se.window[Se.strstart - 1]), Le && ue(Se, !1), Se.strstart++, Se.lookahead--, Se.strm.avail_out === 0)
          return fe;
      } else
        Se.match_available = 1, Se.strstart++, Se.lookahead--;
    }
    return Se.match_available && (Le = o._tr_tally(Se, 0, Se.window[Se.strstart - 1]), Se.match_available = 0), Se.insert = Se.strstart < Z - 1 ? Se.strstart : Z - 1, et === P ? (ue(Se, !0), Se.strm.avail_out === 0 ? Be : be) : Se.last_lit && (ue(Se, !1), Se.strm.avail_out === 0) ? fe : $e;
  }
  function je(Se, et) {
    for (var Ze, Le, ze, Qe, _t = Se.window; ; ) {
      if (Se.lookahead <= K) {
        if (Ve(Se), Se.lookahead <= K && et === h)
          return fe;
        if (Se.lookahead === 0)
          break;
      }
      if (Se.match_length = 0, Se.lookahead >= Z && Se.strstart > 0 && (ze = Se.strstart - 1, Le = _t[ze], Le === _t[++ze] && Le === _t[++ze] && Le === _t[++ze])) {
        Qe = Se.strstart + K;
        do
          ;
        while (Le === _t[++ze] && Le === _t[++ze] && Le === _t[++ze] && Le === _t[++ze] && Le === _t[++ze] && Le === _t[++ze] && Le === _t[++ze] && Le === _t[++ze] && ze < Qe);
        Se.match_length = K - (Qe - ze), Se.match_length > Se.lookahead && (Se.match_length = Se.lookahead);
      }
      if (Se.match_length >= Z ? (Ze = o._tr_tally(Se, 1, Se.match_length - Z), Se.lookahead -= Se.match_length, Se.strstart += Se.match_length, Se.match_length = 0) : (Ze = o._tr_tally(Se, 0, Se.window[Se.strstart]), Se.lookahead--, Se.strstart++), Ze && (ue(Se, !1), Se.strm.avail_out === 0))
        return fe;
    }
    return Se.insert = 0, et === P ? (ue(Se, !0), Se.strm.avail_out === 0 ? Be : be) : Se.last_lit && (ue(Se, !1), Se.strm.avail_out === 0) ? fe : $e;
  }
  function Ke(Se, et) {
    for (var Ze; ; ) {
      if (Se.lookahead === 0 && (Ve(Se), Se.lookahead === 0)) {
        if (et === h)
          return fe;
        break;
      }
      if (Se.match_length = 0, Ze = o._tr_tally(Se, 0, Se.window[Se.strstart]), Se.lookahead--, Se.strstart++, Ze && (ue(Se, !1), Se.strm.avail_out === 0))
        return fe;
    }
    return Se.insert = 0, et === P ? (ue(Se, !0), Se.strm.avail_out === 0 ? Be : be) : Se.last_lit && (ue(Se, !1), Se.strm.avail_out === 0) ? fe : $e;
  }
  function ot(Se, et, Ze, Le, ze) {
    this.good_length = Se, this.max_lazy = et, this.nice_length = Ze, this.max_chain = Le, this.func = ze;
  }
  var ut;
  ut = [
    /*      good lazy nice chain */
    new ot(0, 0, 0, 0, nt),
    /* 0 store only */
    new ot(4, 4, 8, 4, Ie),
    /* 1 max speed, no lazy matches */
    new ot(4, 5, 16, 8, Ie),
    /* 2 */
    new ot(4, 6, 32, 32, Ie),
    /* 3 */
    new ot(4, 4, 16, 16, Fe),
    /* 4 lazy matches */
    new ot(8, 16, 32, 32, Fe),
    /* 5 */
    new ot(8, 16, 128, 128, Fe),
    /* 6 */
    new ot(8, 32, 128, 256, Fe),
    /* 7 */
    new ot(32, 128, 258, 1024, Fe),
    /* 8 */
    new ot(32, 258, 258, 4096, Fe)
    /* 9 max compression */
  ];
  function pt(Se) {
    Se.window_size = 2 * Se.w_size, Ye(Se.head), Se.max_lazy_match = ut[Se.level].max_lazy, Se.good_match = ut[Se.level].good_length, Se.nice_match = ut[Se.level].nice_length, Se.max_chain_length = ut[Se.level].max_chain, Se.strstart = 0, Se.block_start = 0, Se.lookahead = 0, Se.insert = 0, Se.match_length = Se.prev_length = Z - 1, Se.match_available = 0, Se.ins_h = 0;
  }
  function ke() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = me, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new e.Buf16(O * 2), this.dyn_dtree = new e.Buf16((2 * M + 1) * 2), this.bl_tree = new e.Buf16((2 * $ + 1) * 2), Ye(this.dyn_ltree), Ye(this.dyn_dtree), Ye(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new e.Buf16(J + 1), this.heap = new e.Buf16(2 * Y + 1), Ye(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new e.Buf16(2 * Y + 1), Ye(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function Xe(Se) {
    var et;
    return !Se || !Se.state ? qe(Se, V) : (Se.total_in = Se.total_out = 0, Se.data_type = pe, et = Se.state, et.pending = 0, et.pending_out = 0, et.wrap < 0 && (et.wrap = -et.wrap), et.status = et.wrap ? D : ye, Se.adler = et.wrap === 2 ? 0 : 1, et.last_flush = h, o._tr_init(et), B);
  }
  function at(Se) {
    var et = Xe(Se);
    return et === B && pt(Se.state), et;
  }
  function ht(Se, et) {
    return !Se || !Se.state || Se.state.wrap !== 2 ? V : (Se.state.gzhead = et, B);
  }
  function We(Se, et, Ze, Le, ze, Qe) {
    if (!Se)
      return V;
    var _t = 1;
    if (et === ee && (et = 6), Le < 0 ? (_t = 0, Le = -Le) : Le > 15 && (_t = 2, Le -= 16), ze < 1 || ze > Me || Ze !== me || Le < 8 || Le > 15 || et < 0 || et > 9 || Qe < 0 || Qe > le)
      return qe(Se, V);
    Le === 8 && (Le = 9);
    var ft = new ke();
    return Se.state = ft, ft.strm = Se, ft.wrap = _t, ft.gzhead = null, ft.w_bits = Le, ft.w_size = 1 << ft.w_bits, ft.w_mask = ft.w_size - 1, ft.hash_bits = ze + 7, ft.hash_size = 1 << ft.hash_bits, ft.hash_mask = ft.hash_size - 1, ft.hash_shift = ~~((ft.hash_bits + Z - 1) / Z), ft.window = new e.Buf8(ft.w_size * 2), ft.head = new e.Buf16(ft.hash_size), ft.prev = new e.Buf16(ft.w_size), ft.lit_bufsize = 1 << ze + 6, ft.pending_buf_size = ft.lit_bufsize * 4, ft.pending_buf = new e.Buf8(ft.pending_buf_size), ft.d_buf = 1 * ft.lit_bufsize, ft.l_buf = 3 * ft.lit_bufsize, ft.level = et, ft.strategy = Qe, ft.method = Ze, at(Se);
  }
  function tt(Se, et) {
    return We(Se, et, me, Ee, Re, ce);
  }
  function Te(Se, et) {
    var Ze, Le, ze, Qe;
    if (!Se || !Se.state || et > I || et < 0)
      return Se ? qe(Se, V) : V;
    if (Le = Se.state, !Se.output || !Se.input && Se.avail_in !== 0 || Le.status === oe && et !== P)
      return qe(Se, Se.avail_out === 0 ? Q : V);
    if (Le.strm = Se, Ze = Le.last_flush, Le.last_flush = et, Le.status === D)
      if (Le.wrap === 2)
        Se.adler = 0, de(Le, 31), de(Le, 139), de(Le, 8), Le.gzhead ? (de(
          Le,
          (Le.gzhead.text ? 1 : 0) + (Le.gzhead.hcrc ? 2 : 0) + (Le.gzhead.extra ? 4 : 0) + (Le.gzhead.name ? 8 : 0) + (Le.gzhead.comment ? 16 : 0)
        ), de(Le, Le.gzhead.time & 255), de(Le, Le.gzhead.time >> 8 & 255), de(Le, Le.gzhead.time >> 16 & 255), de(Le, Le.gzhead.time >> 24 & 255), de(Le, Le.level === 9 ? 2 : Le.strategy >= te || Le.level < 2 ? 4 : 0), de(Le, Le.gzhead.os & 255), Le.gzhead.extra && Le.gzhead.extra.length && (de(Le, Le.gzhead.extra.length & 255), de(Le, Le.gzhead.extra.length >> 8 & 255)), Le.gzhead.hcrc && (Se.adler = g(Se.adler, Le.pending_buf, Le.pending, 0)), Le.gzindex = 0, Le.status = F) : (de(Le, 0), de(Le, 0), de(Le, 0), de(Le, 0), de(Le, 0), de(Le, Le.level === 9 ? 2 : Le.strategy >= te || Le.level < 2 ? 4 : 0), de(Le, ve), Le.status = ye);
      else {
        var _t = me + (Le.w_bits - 8 << 4) << 8, ft = -1;
        Le.strategy >= te || Le.level < 2 ? ft = 0 : Le.level < 6 ? ft = 1 : Le.level === 6 ? ft = 2 : ft = 3, _t |= ft << 6, Le.strstart !== 0 && (_t |= G), _t += 31 - _t % 31, Le.status = ye, _e(Le, _t), Le.strstart !== 0 && (_e(Le, Se.adler >>> 16), _e(Le, Se.adler & 65535)), Se.adler = 1;
      }
    if (Le.status === F)
      if (Le.gzhead.extra) {
        for (ze = Le.pending; Le.gzindex < (Le.gzhead.extra.length & 65535) && !(Le.pending === Le.pending_buf_size && (Le.gzhead.hcrc && Le.pending > ze && (Se.adler = g(Se.adler, Le.pending_buf, Le.pending - ze, ze)), he(Se), ze = Le.pending, Le.pending === Le.pending_buf_size)); )
          de(Le, Le.gzhead.extra[Le.gzindex] & 255), Le.gzindex++;
        Le.gzhead.hcrc && Le.pending > ze && (Se.adler = g(Se.adler, Le.pending_buf, Le.pending - ze, ze)), Le.gzindex === Le.gzhead.extra.length && (Le.gzindex = 0, Le.status = ae);
      } else
        Le.status = ae;
    if (Le.status === ae)
      if (Le.gzhead.name) {
        ze = Le.pending;
        do {
          if (Le.pending === Le.pending_buf_size && (Le.gzhead.hcrc && Le.pending > ze && (Se.adler = g(Se.adler, Le.pending_buf, Le.pending - ze, ze)), he(Se), ze = Le.pending, Le.pending === Le.pending_buf_size)) {
            Qe = 1;
            break;
          }
          Le.gzindex < Le.gzhead.name.length ? Qe = Le.gzhead.name.charCodeAt(Le.gzindex++) & 255 : Qe = 0, de(Le, Qe);
        } while (Qe !== 0);
        Le.gzhead.hcrc && Le.pending > ze && (Se.adler = g(Se.adler, Le.pending_buf, Le.pending - ze, ze)), Qe === 0 && (Le.gzindex = 0, Le.status = ge);
      } else
        Le.status = ge;
    if (Le.status === ge)
      if (Le.gzhead.comment) {
        ze = Le.pending;
        do {
          if (Le.pending === Le.pending_buf_size && (Le.gzhead.hcrc && Le.pending > ze && (Se.adler = g(Se.adler, Le.pending_buf, Le.pending - ze, ze)), he(Se), ze = Le.pending, Le.pending === Le.pending_buf_size)) {
            Qe = 1;
            break;
          }
          Le.gzindex < Le.gzhead.comment.length ? Qe = Le.gzhead.comment.charCodeAt(Le.gzindex++) & 255 : Qe = 0, de(Le, Qe);
        } while (Qe !== 0);
        Le.gzhead.hcrc && Le.pending > ze && (Se.adler = g(Se.adler, Le.pending_buf, Le.pending - ze, ze)), Qe === 0 && (Le.status = xe);
      } else
        Le.status = xe;
    if (Le.status === xe && (Le.gzhead.hcrc ? (Le.pending + 2 > Le.pending_buf_size && he(Se), Le.pending + 2 <= Le.pending_buf_size && (de(Le, Se.adler & 255), de(Le, Se.adler >> 8 & 255), Se.adler = 0, Le.status = ye)) : Le.status = ye), Le.pending !== 0) {
      if (he(Se), Se.avail_out === 0)
        return Le.last_flush = -1, B;
    } else if (Se.avail_in === 0 && De(et) <= De(Ze) && et !== P)
      return qe(Se, Q);
    if (Le.status === oe && Se.avail_in !== 0)
      return qe(Se, Q);
    if (Se.avail_in !== 0 || Le.lookahead !== 0 || et !== h && Le.status !== oe) {
      var dt = Le.strategy === te ? Ke(Le, et) : Le.strategy === se ? je(Le, et) : ut[Le.level].func(Le, et);
      if ((dt === Be || dt === be) && (Le.status = oe), dt === fe || dt === Be)
        return Se.avail_out === 0 && (Le.last_flush = -1), B;
      if (dt === $e && (et === q ? o._tr_align(Le) : et !== I && (o._tr_stored_block(Le, 0, 0, !1), et === A && (Ye(Le.head), Le.lookahead === 0 && (Le.strstart = 0, Le.block_start = 0, Le.insert = 0))), he(Se), Se.avail_out === 0))
        return Le.last_flush = -1, B;
    }
    return et !== P ? B : Le.wrap <= 0 ? H : (Le.wrap === 2 ? (de(Le, Se.adler & 255), de(Le, Se.adler >> 8 & 255), de(Le, Se.adler >> 16 & 255), de(Le, Se.adler >> 24 & 255), de(Le, Se.total_in & 255), de(Le, Se.total_in >> 8 & 255), de(Le, Se.total_in >> 16 & 255), de(Le, Se.total_in >> 24 & 255)) : (_e(Le, Se.adler >>> 16), _e(Le, Se.adler & 65535)), he(Se), Le.wrap > 0 && (Le.wrap = -Le.wrap), Le.pending !== 0 ? B : H);
  }
  function rt(Se) {
    var et;
    return !Se || !Se.state ? V : (et = Se.state.status, et !== D && et !== F && et !== ae && et !== ge && et !== xe && et !== ye && et !== oe ? qe(Se, V) : (Se.state = null, et === ye ? qe(Se, X) : B));
  }
  function mt(Se, et) {
    var Ze = et.length, Le, ze, Qe, _t, ft, dt, Mt, St;
    if (!Se || !Se.state || (Le = Se.state, _t = Le.wrap, _t === 2 || _t === 1 && Le.status !== D || Le.lookahead))
      return V;
    for (_t === 1 && (Se.adler = S(Se.adler, et, Ze, 0)), Le.wrap = 0, Ze >= Le.w_size && (_t === 0 && (Ye(Le.head), Le.strstart = 0, Le.block_start = 0, Le.insert = 0), St = new e.Buf8(Le.w_size), e.arraySet(St, et, Ze - Le.w_size, Le.w_size, 0), et = St, Ze = Le.w_size), ft = Se.avail_in, dt = Se.next_in, Mt = Se.input, Se.avail_in = Ze, Se.next_in = 0, Se.input = et, Ve(Le); Le.lookahead >= Z; ) {
      ze = Le.strstart, Qe = Le.lookahead - (Z - 1);
      do
        Le.ins_h = (Le.ins_h << Le.hash_shift ^ Le.window[ze + Z - 1]) & Le.hash_mask, Le.prev[ze & Le.w_mask] = Le.head[Le.ins_h], Le.head[Le.ins_h] = ze, ze++;
      while (--Qe);
      Le.strstart = ze, Le.lookahead = Z - 1, Ve(Le);
    }
    return Le.strstart += Le.lookahead, Le.block_start = Le.strstart, Le.insert = Le.lookahead, Le.lookahead = 0, Le.match_length = Le.prev_length = Z - 1, Le.match_available = 0, Se.next_in = dt, Se.input = Mt, Se.avail_in = ft, Le.wrap = _t, B;
  }
  return deflate.deflateInit = tt, deflate.deflateInit2 = We, deflate.deflateReset = at, deflate.deflateResetKeep = Xe, deflate.deflateSetHeader = ht, deflate.deflate = Te, deflate.deflateEnd = rt, deflate.deflateSetDictionary = mt, deflate.deflateInfo = "pako deflate (from Nodeca project)", deflate;
}
var inflate = {}, inffast, hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast)
    return inffast;
  hasRequiredInffast = 1;
  var e = 30, o = 12;
  return inffast = function(g, U) {
    var h, q, A, P, I, B, H, V, X, Q, ee, ie, te, se, le, ce, pe, me, Me, Ee, Re, Ne, ne, Y, M;
    h = g.state, q = g.next_in, Y = g.input, A = q + (g.avail_in - 5), P = g.next_out, M = g.output, I = P - (U - g.avail_out), B = P + (g.avail_out - 257), H = h.dmax, V = h.wsize, X = h.whave, Q = h.wnext, ee = h.window, ie = h.hold, te = h.bits, se = h.lencode, le = h.distcode, ce = (1 << h.lenbits) - 1, pe = (1 << h.distbits) - 1;
    e:
      do {
        te < 15 && (ie += Y[q++] << te, te += 8, ie += Y[q++] << te, te += 8), me = se[ie & ce];
        t:
          for (; ; ) {
            if (Me = me >>> 24, ie >>>= Me, te -= Me, Me = me >>> 16 & 255, Me === 0)
              M[P++] = me & 65535;
            else if (Me & 16) {
              Ee = me & 65535, Me &= 15, Me && (te < Me && (ie += Y[q++] << te, te += 8), Ee += ie & (1 << Me) - 1, ie >>>= Me, te -= Me), te < 15 && (ie += Y[q++] << te, te += 8, ie += Y[q++] << te, te += 8), me = le[ie & pe];
              r:
                for (; ; ) {
                  if (Me = me >>> 24, ie >>>= Me, te -= Me, Me = me >>> 16 & 255, Me & 16) {
                    if (Re = me & 65535, Me &= 15, te < Me && (ie += Y[q++] << te, te += 8, te < Me && (ie += Y[q++] << te, te += 8)), Re += ie & (1 << Me) - 1, Re > H) {
                      g.msg = "invalid distance too far back", h.mode = e;
                      break e;
                    }
                    if (ie >>>= Me, te -= Me, Me = P - I, Re > Me) {
                      if (Me = Re - Me, Me > X && h.sane) {
                        g.msg = "invalid distance too far back", h.mode = e;
                        break e;
                      }
                      if (Ne = 0, ne = ee, Q === 0) {
                        if (Ne += V - Me, Me < Ee) {
                          Ee -= Me;
                          do
                            M[P++] = ee[Ne++];
                          while (--Me);
                          Ne = P - Re, ne = M;
                        }
                      } else if (Q < Me) {
                        if (Ne += V + Q - Me, Me -= Q, Me < Ee) {
                          Ee -= Me;
                          do
                            M[P++] = ee[Ne++];
                          while (--Me);
                          if (Ne = 0, Q < Ee) {
                            Me = Q, Ee -= Me;
                            do
                              M[P++] = ee[Ne++];
                            while (--Me);
                            Ne = P - Re, ne = M;
                          }
                        }
                      } else if (Ne += Q - Me, Me < Ee) {
                        Ee -= Me;
                        do
                          M[P++] = ee[Ne++];
                        while (--Me);
                        Ne = P - Re, ne = M;
                      }
                      for (; Ee > 2; )
                        M[P++] = ne[Ne++], M[P++] = ne[Ne++], M[P++] = ne[Ne++], Ee -= 3;
                      Ee && (M[P++] = ne[Ne++], Ee > 1 && (M[P++] = ne[Ne++]));
                    } else {
                      Ne = P - Re;
                      do
                        M[P++] = M[Ne++], M[P++] = M[Ne++], M[P++] = M[Ne++], Ee -= 3;
                      while (Ee > 2);
                      Ee && (M[P++] = M[Ne++], Ee > 1 && (M[P++] = M[Ne++]));
                    }
                  } else if (Me & 64) {
                    g.msg = "invalid distance code", h.mode = e;
                    break e;
                  } else {
                    me = le[(me & 65535) + (ie & (1 << Me) - 1)];
                    continue r;
                  }
                  break;
                }
            } else if (Me & 64)
              if (Me & 32) {
                h.mode = o;
                break e;
              } else {
                g.msg = "invalid literal/length code", h.mode = e;
                break e;
              }
            else {
              me = se[(me & 65535) + (ie & (1 << Me) - 1)];
              continue t;
            }
            break;
          }
      } while (q < A && P < B);
    Ee = te >> 3, q -= Ee, te -= Ee << 3, ie &= (1 << te) - 1, g.next_in = q, g.next_out = P, g.avail_in = q < A ? 5 + (A - q) : 5 - (q - A), g.avail_out = P < B ? 257 + (B - P) : 257 - (P - B), h.hold = ie, h.bits = te;
  }, inffast;
}
var inftrees, hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees)
    return inftrees;
  hasRequiredInftrees = 1;
  var e = requireCommon$2(), o = 15, S = 852, g = 592, U = 0, h = 1, q = 2, A = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ], P = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ], I = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ], B = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  return inftrees = function(V, X, Q, ee, ie, te, se, le) {
    var ce = le.bits, pe = 0, me = 0, Me = 0, Ee = 0, Re = 0, Ne = 0, ne = 0, Y = 0, M = 0, $ = 0, O, J, Z, K, z, G = null, D = 0, F, ae = new e.Buf16(o + 1), ge = new e.Buf16(o + 1), xe = null, ye = 0, oe, fe, $e;
    for (pe = 0; pe <= o; pe++)
      ae[pe] = 0;
    for (me = 0; me < ee; me++)
      ae[X[Q + me]]++;
    for (Re = ce, Ee = o; Ee >= 1 && ae[Ee] === 0; Ee--)
      ;
    if (Re > Ee && (Re = Ee), Ee === 0)
      return ie[te++] = 1 << 24 | 64 << 16 | 0, ie[te++] = 1 << 24 | 64 << 16 | 0, le.bits = 1, 0;
    for (Me = 1; Me < Ee && ae[Me] === 0; Me++)
      ;
    for (Re < Me && (Re = Me), Y = 1, pe = 1; pe <= o; pe++)
      if (Y <<= 1, Y -= ae[pe], Y < 0)
        return -1;
    if (Y > 0 && (V === U || Ee !== 1))
      return -1;
    for (ge[1] = 0, pe = 1; pe < o; pe++)
      ge[pe + 1] = ge[pe] + ae[pe];
    for (me = 0; me < ee; me++)
      X[Q + me] !== 0 && (se[ge[X[Q + me]]++] = me);
    if (V === U ? (G = xe = se, F = 19) : V === h ? (G = A, D -= 257, xe = P, ye -= 257, F = 256) : (G = I, xe = B, F = -1), $ = 0, me = 0, pe = Me, z = te, Ne = Re, ne = 0, Z = -1, M = 1 << Re, K = M - 1, V === h && M > S || V === q && M > g)
      return 1;
    for (; ; ) {
      oe = pe - ne, se[me] < F ? (fe = 0, $e = se[me]) : se[me] > F ? (fe = xe[ye + se[me]], $e = G[D + se[me]]) : (fe = 96, $e = 0), O = 1 << pe - ne, J = 1 << Ne, Me = J;
      do
        J -= O, ie[z + ($ >> ne) + J] = oe << 24 | fe << 16 | $e | 0;
      while (J !== 0);
      for (O = 1 << pe - 1; $ & O; )
        O >>= 1;
      if (O !== 0 ? ($ &= O - 1, $ += O) : $ = 0, me++, --ae[pe] === 0) {
        if (pe === Ee)
          break;
        pe = X[Q + se[me]];
      }
      if (pe > Re && ($ & K) !== Z) {
        for (ne === 0 && (ne = Re), z += Me, Ne = pe - ne, Y = 1 << Ne; Ne + ne < Ee && (Y -= ae[Ne + ne], !(Y <= 0)); )
          Ne++, Y <<= 1;
        if (M += 1 << Ne, V === h && M > S || V === q && M > g)
          return 1;
        Z = $ & K, ie[Z] = Re << 24 | Ne << 16 | z - te | 0;
      }
    }
    return $ !== 0 && (ie[z + $] = pe - ne << 24 | 64 << 16 | 0), le.bits = Re, 0;
  }, inftrees;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate)
    return inflate;
  hasRequiredInflate = 1;
  var e = requireCommon$2(), o = requireAdler32(), S = requireCrc32(), g = requireInffast(), U = requireInftrees(), h = 0, q = 1, A = 2, P = 4, I = 5, B = 6, H = 0, V = 1, X = 2, Q = -2, ee = -3, ie = -4, te = -5, se = 8, le = 1, ce = 2, pe = 3, me = 4, Me = 5, Ee = 6, Re = 7, Ne = 8, ne = 9, Y = 10, M = 11, $ = 12, O = 13, J = 14, Z = 15, K = 16, z = 17, G = 18, D = 19, F = 20, ae = 21, ge = 22, xe = 23, ye = 24, oe = 25, fe = 26, $e = 27, Be = 28, be = 29, ve = 30, qe = 31, De = 32, Ye = 852, he = 592, ue = 15, de = ue;
  function _e(We) {
    return (We >>> 24 & 255) + (We >>> 8 & 65280) + ((We & 65280) << 8) + ((We & 255) << 24);
  }
  function Pe() {
    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function He(We) {
    var tt;
    return !We || !We.state ? Q : (tt = We.state, We.total_in = We.total_out = tt.total = 0, We.msg = "", tt.wrap && (We.adler = tt.wrap & 1), tt.mode = le, tt.last = 0, tt.havedict = 0, tt.dmax = 32768, tt.head = null, tt.hold = 0, tt.bits = 0, tt.lencode = tt.lendyn = new e.Buf32(Ye), tt.distcode = tt.distdyn = new e.Buf32(he), tt.sane = 1, tt.back = -1, H);
  }
  function Ve(We) {
    var tt;
    return !We || !We.state ? Q : (tt = We.state, tt.wsize = 0, tt.whave = 0, tt.wnext = 0, He(We));
  }
  function nt(We, tt) {
    var Te, rt;
    return !We || !We.state || (rt = We.state, tt < 0 ? (Te = 0, tt = -tt) : (Te = (tt >> 4) + 1, tt < 48 && (tt &= 15)), tt && (tt < 8 || tt > 15)) ? Q : (rt.window !== null && rt.wbits !== tt && (rt.window = null), rt.wrap = Te, rt.wbits = tt, Ve(We));
  }
  function Ie(We, tt) {
    var Te, rt;
    return We ? (rt = new Pe(), We.state = rt, rt.window = null, Te = nt(We, tt), Te !== H && (We.state = null), Te) : Q;
  }
  function Fe(We) {
    return Ie(We, de);
  }
  var je = !0, Ke, ot;
  function ut(We) {
    if (je) {
      var tt;
      for (Ke = new e.Buf32(512), ot = new e.Buf32(32), tt = 0; tt < 144; )
        We.lens[tt++] = 8;
      for (; tt < 256; )
        We.lens[tt++] = 9;
      for (; tt < 280; )
        We.lens[tt++] = 7;
      for (; tt < 288; )
        We.lens[tt++] = 8;
      for (U(q, We.lens, 0, 288, Ke, 0, We.work, { bits: 9 }), tt = 0; tt < 32; )
        We.lens[tt++] = 5;
      U(A, We.lens, 0, 32, ot, 0, We.work, { bits: 5 }), je = !1;
    }
    We.lencode = Ke, We.lenbits = 9, We.distcode = ot, We.distbits = 5;
  }
  function pt(We, tt, Te, rt) {
    var mt, Se = We.state;
    return Se.window === null && (Se.wsize = 1 << Se.wbits, Se.wnext = 0, Se.whave = 0, Se.window = new e.Buf8(Se.wsize)), rt >= Se.wsize ? (e.arraySet(Se.window, tt, Te - Se.wsize, Se.wsize, 0), Se.wnext = 0, Se.whave = Se.wsize) : (mt = Se.wsize - Se.wnext, mt > rt && (mt = rt), e.arraySet(Se.window, tt, Te - rt, mt, Se.wnext), rt -= mt, rt ? (e.arraySet(Se.window, tt, Te - rt, rt, 0), Se.wnext = rt, Se.whave = Se.wsize) : (Se.wnext += mt, Se.wnext === Se.wsize && (Se.wnext = 0), Se.whave < Se.wsize && (Se.whave += mt))), 0;
  }
  function ke(We, tt) {
    var Te, rt, mt, Se, et, Ze, Le, ze, Qe, _t, ft, dt, Mt, St, $t = 0, At, Ae, Ce, Oe, we, Ue, Je, Ge, st = new e.Buf8(4), ct, bt, wt = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!We || !We.state || !We.output || !We.input && We.avail_in !== 0)
      return Q;
    Te = We.state, Te.mode === $ && (Te.mode = O), et = We.next_out, mt = We.output, Le = We.avail_out, Se = We.next_in, rt = We.input, Ze = We.avail_in, ze = Te.hold, Qe = Te.bits, _t = Ze, ft = Le, Ge = H;
    e:
      for (; ; )
        switch (Te.mode) {
          case le:
            if (Te.wrap === 0) {
              Te.mode = O;
              break;
            }
            for (; Qe < 16; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            if (Te.wrap & 2 && ze === 35615) {
              Te.check = 0, st[0] = ze & 255, st[1] = ze >>> 8 & 255, Te.check = S(Te.check, st, 2, 0), ze = 0, Qe = 0, Te.mode = ce;
              break;
            }
            if (Te.flags = 0, Te.head && (Te.head.done = !1), !(Te.wrap & 1) || /* check if zlib header allowed */
            (((ze & 255) << 8) + (ze >> 8)) % 31) {
              We.msg = "incorrect header check", Te.mode = ve;
              break;
            }
            if ((ze & 15) !== se) {
              We.msg = "unknown compression method", Te.mode = ve;
              break;
            }
            if (ze >>>= 4, Qe -= 4, Je = (ze & 15) + 8, Te.wbits === 0)
              Te.wbits = Je;
            else if (Je > Te.wbits) {
              We.msg = "invalid window size", Te.mode = ve;
              break;
            }
            Te.dmax = 1 << Je, We.adler = Te.check = 1, Te.mode = ze & 512 ? Y : $, ze = 0, Qe = 0;
            break;
          case ce:
            for (; Qe < 16; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            if (Te.flags = ze, (Te.flags & 255) !== se) {
              We.msg = "unknown compression method", Te.mode = ve;
              break;
            }
            if (Te.flags & 57344) {
              We.msg = "unknown header flags set", Te.mode = ve;
              break;
            }
            Te.head && (Te.head.text = ze >> 8 & 1), Te.flags & 512 && (st[0] = ze & 255, st[1] = ze >>> 8 & 255, Te.check = S(Te.check, st, 2, 0)), ze = 0, Qe = 0, Te.mode = pe;
          case pe:
            for (; Qe < 32; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            Te.head && (Te.head.time = ze), Te.flags & 512 && (st[0] = ze & 255, st[1] = ze >>> 8 & 255, st[2] = ze >>> 16 & 255, st[3] = ze >>> 24 & 255, Te.check = S(Te.check, st, 4, 0)), ze = 0, Qe = 0, Te.mode = me;
          case me:
            for (; Qe < 16; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            Te.head && (Te.head.xflags = ze & 255, Te.head.os = ze >> 8), Te.flags & 512 && (st[0] = ze & 255, st[1] = ze >>> 8 & 255, Te.check = S(Te.check, st, 2, 0)), ze = 0, Qe = 0, Te.mode = Me;
          case Me:
            if (Te.flags & 1024) {
              for (; Qe < 16; ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              Te.length = ze, Te.head && (Te.head.extra_len = ze), Te.flags & 512 && (st[0] = ze & 255, st[1] = ze >>> 8 & 255, Te.check = S(Te.check, st, 2, 0)), ze = 0, Qe = 0;
            } else
              Te.head && (Te.head.extra = null);
            Te.mode = Ee;
          case Ee:
            if (Te.flags & 1024 && (dt = Te.length, dt > Ze && (dt = Ze), dt && (Te.head && (Je = Te.head.extra_len - Te.length, Te.head.extra || (Te.head.extra = new Array(Te.head.extra_len)), e.arraySet(
              Te.head.extra,
              rt,
              Se,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              dt,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              Je
            )), Te.flags & 512 && (Te.check = S(Te.check, rt, dt, Se)), Ze -= dt, Se += dt, Te.length -= dt), Te.length))
              break e;
            Te.length = 0, Te.mode = Re;
          case Re:
            if (Te.flags & 2048) {
              if (Ze === 0)
                break e;
              dt = 0;
              do
                Je = rt[Se + dt++], Te.head && Je && Te.length < 65536 && (Te.head.name += String.fromCharCode(Je));
              while (Je && dt < Ze);
              if (Te.flags & 512 && (Te.check = S(Te.check, rt, dt, Se)), Ze -= dt, Se += dt, Je)
                break e;
            } else
              Te.head && (Te.head.name = null);
            Te.length = 0, Te.mode = Ne;
          case Ne:
            if (Te.flags & 4096) {
              if (Ze === 0)
                break e;
              dt = 0;
              do
                Je = rt[Se + dt++], Te.head && Je && Te.length < 65536 && (Te.head.comment += String.fromCharCode(Je));
              while (Je && dt < Ze);
              if (Te.flags & 512 && (Te.check = S(Te.check, rt, dt, Se)), Ze -= dt, Se += dt, Je)
                break e;
            } else
              Te.head && (Te.head.comment = null);
            Te.mode = ne;
          case ne:
            if (Te.flags & 512) {
              for (; Qe < 16; ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              if (ze !== (Te.check & 65535)) {
                We.msg = "header crc mismatch", Te.mode = ve;
                break;
              }
              ze = 0, Qe = 0;
            }
            Te.head && (Te.head.hcrc = Te.flags >> 9 & 1, Te.head.done = !0), We.adler = Te.check = 0, Te.mode = $;
            break;
          case Y:
            for (; Qe < 32; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            We.adler = Te.check = _e(ze), ze = 0, Qe = 0, Te.mode = M;
          case M:
            if (Te.havedict === 0)
              return We.next_out = et, We.avail_out = Le, We.next_in = Se, We.avail_in = Ze, Te.hold = ze, Te.bits = Qe, X;
            We.adler = Te.check = 1, Te.mode = $;
          case $:
            if (tt === I || tt === B)
              break e;
          case O:
            if (Te.last) {
              ze >>>= Qe & 7, Qe -= Qe & 7, Te.mode = $e;
              break;
            }
            for (; Qe < 3; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            switch (Te.last = ze & 1, ze >>>= 1, Qe -= 1, ze & 3) {
              case 0:
                Te.mode = J;
                break;
              case 1:
                if (ut(Te), Te.mode = F, tt === B) {
                  ze >>>= 2, Qe -= 2;
                  break e;
                }
                break;
              case 2:
                Te.mode = z;
                break;
              case 3:
                We.msg = "invalid block type", Te.mode = ve;
            }
            ze >>>= 2, Qe -= 2;
            break;
          case J:
            for (ze >>>= Qe & 7, Qe -= Qe & 7; Qe < 32; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            if ((ze & 65535) !== (ze >>> 16 ^ 65535)) {
              We.msg = "invalid stored block lengths", Te.mode = ve;
              break;
            }
            if (Te.length = ze & 65535, ze = 0, Qe = 0, Te.mode = Z, tt === B)
              break e;
          case Z:
            Te.mode = K;
          case K:
            if (dt = Te.length, dt) {
              if (dt > Ze && (dt = Ze), dt > Le && (dt = Le), dt === 0)
                break e;
              e.arraySet(mt, rt, Se, dt, et), Ze -= dt, Se += dt, Le -= dt, et += dt, Te.length -= dt;
              break;
            }
            Te.mode = $;
            break;
          case z:
            for (; Qe < 14; ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            if (Te.nlen = (ze & 31) + 257, ze >>>= 5, Qe -= 5, Te.ndist = (ze & 31) + 1, ze >>>= 5, Qe -= 5, Te.ncode = (ze & 15) + 4, ze >>>= 4, Qe -= 4, Te.nlen > 286 || Te.ndist > 30) {
              We.msg = "too many length or distance symbols", Te.mode = ve;
              break;
            }
            Te.have = 0, Te.mode = G;
          case G:
            for (; Te.have < Te.ncode; ) {
              for (; Qe < 3; ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              Te.lens[wt[Te.have++]] = ze & 7, ze >>>= 3, Qe -= 3;
            }
            for (; Te.have < 19; )
              Te.lens[wt[Te.have++]] = 0;
            if (Te.lencode = Te.lendyn, Te.lenbits = 7, ct = { bits: Te.lenbits }, Ge = U(h, Te.lens, 0, 19, Te.lencode, 0, Te.work, ct), Te.lenbits = ct.bits, Ge) {
              We.msg = "invalid code lengths set", Te.mode = ve;
              break;
            }
            Te.have = 0, Te.mode = D;
          case D:
            for (; Te.have < Te.nlen + Te.ndist; ) {
              for (; $t = Te.lencode[ze & (1 << Te.lenbits) - 1], At = $t >>> 24, Ae = $t >>> 16 & 255, Ce = $t & 65535, !(At <= Qe); ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              if (Ce < 16)
                ze >>>= At, Qe -= At, Te.lens[Te.have++] = Ce;
              else {
                if (Ce === 16) {
                  for (bt = At + 2; Qe < bt; ) {
                    if (Ze === 0)
                      break e;
                    Ze--, ze += rt[Se++] << Qe, Qe += 8;
                  }
                  if (ze >>>= At, Qe -= At, Te.have === 0) {
                    We.msg = "invalid bit length repeat", Te.mode = ve;
                    break;
                  }
                  Je = Te.lens[Te.have - 1], dt = 3 + (ze & 3), ze >>>= 2, Qe -= 2;
                } else if (Ce === 17) {
                  for (bt = At + 3; Qe < bt; ) {
                    if (Ze === 0)
                      break e;
                    Ze--, ze += rt[Se++] << Qe, Qe += 8;
                  }
                  ze >>>= At, Qe -= At, Je = 0, dt = 3 + (ze & 7), ze >>>= 3, Qe -= 3;
                } else {
                  for (bt = At + 7; Qe < bt; ) {
                    if (Ze === 0)
                      break e;
                    Ze--, ze += rt[Se++] << Qe, Qe += 8;
                  }
                  ze >>>= At, Qe -= At, Je = 0, dt = 11 + (ze & 127), ze >>>= 7, Qe -= 7;
                }
                if (Te.have + dt > Te.nlen + Te.ndist) {
                  We.msg = "invalid bit length repeat", Te.mode = ve;
                  break;
                }
                for (; dt--; )
                  Te.lens[Te.have++] = Je;
              }
            }
            if (Te.mode === ve)
              break;
            if (Te.lens[256] === 0) {
              We.msg = "invalid code -- missing end-of-block", Te.mode = ve;
              break;
            }
            if (Te.lenbits = 9, ct = { bits: Te.lenbits }, Ge = U(q, Te.lens, 0, Te.nlen, Te.lencode, 0, Te.work, ct), Te.lenbits = ct.bits, Ge) {
              We.msg = "invalid literal/lengths set", Te.mode = ve;
              break;
            }
            if (Te.distbits = 6, Te.distcode = Te.distdyn, ct = { bits: Te.distbits }, Ge = U(A, Te.lens, Te.nlen, Te.ndist, Te.distcode, 0, Te.work, ct), Te.distbits = ct.bits, Ge) {
              We.msg = "invalid distances set", Te.mode = ve;
              break;
            }
            if (Te.mode = F, tt === B)
              break e;
          case F:
            Te.mode = ae;
          case ae:
            if (Ze >= 6 && Le >= 258) {
              We.next_out = et, We.avail_out = Le, We.next_in = Se, We.avail_in = Ze, Te.hold = ze, Te.bits = Qe, g(We, ft), et = We.next_out, mt = We.output, Le = We.avail_out, Se = We.next_in, rt = We.input, Ze = We.avail_in, ze = Te.hold, Qe = Te.bits, Te.mode === $ && (Te.back = -1);
              break;
            }
            for (Te.back = 0; $t = Te.lencode[ze & (1 << Te.lenbits) - 1], At = $t >>> 24, Ae = $t >>> 16 & 255, Ce = $t & 65535, !(At <= Qe); ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            if (Ae && !(Ae & 240)) {
              for (Oe = At, we = Ae, Ue = Ce; $t = Te.lencode[Ue + ((ze & (1 << Oe + we) - 1) >> Oe)], At = $t >>> 24, Ae = $t >>> 16 & 255, Ce = $t & 65535, !(Oe + At <= Qe); ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              ze >>>= Oe, Qe -= Oe, Te.back += Oe;
            }
            if (ze >>>= At, Qe -= At, Te.back += At, Te.length = Ce, Ae === 0) {
              Te.mode = fe;
              break;
            }
            if (Ae & 32) {
              Te.back = -1, Te.mode = $;
              break;
            }
            if (Ae & 64) {
              We.msg = "invalid literal/length code", Te.mode = ve;
              break;
            }
            Te.extra = Ae & 15, Te.mode = ge;
          case ge:
            if (Te.extra) {
              for (bt = Te.extra; Qe < bt; ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              Te.length += ze & (1 << Te.extra) - 1, ze >>>= Te.extra, Qe -= Te.extra, Te.back += Te.extra;
            }
            Te.was = Te.length, Te.mode = xe;
          case xe:
            for (; $t = Te.distcode[ze & (1 << Te.distbits) - 1], At = $t >>> 24, Ae = $t >>> 16 & 255, Ce = $t & 65535, !(At <= Qe); ) {
              if (Ze === 0)
                break e;
              Ze--, ze += rt[Se++] << Qe, Qe += 8;
            }
            if (!(Ae & 240)) {
              for (Oe = At, we = Ae, Ue = Ce; $t = Te.distcode[Ue + ((ze & (1 << Oe + we) - 1) >> Oe)], At = $t >>> 24, Ae = $t >>> 16 & 255, Ce = $t & 65535, !(Oe + At <= Qe); ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              ze >>>= Oe, Qe -= Oe, Te.back += Oe;
            }
            if (ze >>>= At, Qe -= At, Te.back += At, Ae & 64) {
              We.msg = "invalid distance code", Te.mode = ve;
              break;
            }
            Te.offset = Ce, Te.extra = Ae & 15, Te.mode = ye;
          case ye:
            if (Te.extra) {
              for (bt = Te.extra; Qe < bt; ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              Te.offset += ze & (1 << Te.extra) - 1, ze >>>= Te.extra, Qe -= Te.extra, Te.back += Te.extra;
            }
            if (Te.offset > Te.dmax) {
              We.msg = "invalid distance too far back", Te.mode = ve;
              break;
            }
            Te.mode = oe;
          case oe:
            if (Le === 0)
              break e;
            if (dt = ft - Le, Te.offset > dt) {
              if (dt = Te.offset - dt, dt > Te.whave && Te.sane) {
                We.msg = "invalid distance too far back", Te.mode = ve;
                break;
              }
              dt > Te.wnext ? (dt -= Te.wnext, Mt = Te.wsize - dt) : Mt = Te.wnext - dt, dt > Te.length && (dt = Te.length), St = Te.window;
            } else
              St = mt, Mt = et - Te.offset, dt = Te.length;
            dt > Le && (dt = Le), Le -= dt, Te.length -= dt;
            do
              mt[et++] = St[Mt++];
            while (--dt);
            Te.length === 0 && (Te.mode = ae);
            break;
          case fe:
            if (Le === 0)
              break e;
            mt[et++] = Te.length, Le--, Te.mode = ae;
            break;
          case $e:
            if (Te.wrap) {
              for (; Qe < 32; ) {
                if (Ze === 0)
                  break e;
                Ze--, ze |= rt[Se++] << Qe, Qe += 8;
              }
              if (ft -= Le, We.total_out += ft, Te.total += ft, ft && (We.adler = Te.check = /*UPDATE(state.check, put - _out, _out);*/
              Te.flags ? S(Te.check, mt, ft, et - ft) : o(Te.check, mt, ft, et - ft)), ft = Le, (Te.flags ? ze : _e(ze)) !== Te.check) {
                We.msg = "incorrect data check", Te.mode = ve;
                break;
              }
              ze = 0, Qe = 0;
            }
            Te.mode = Be;
          case Be:
            if (Te.wrap && Te.flags) {
              for (; Qe < 32; ) {
                if (Ze === 0)
                  break e;
                Ze--, ze += rt[Se++] << Qe, Qe += 8;
              }
              if (ze !== (Te.total & 4294967295)) {
                We.msg = "incorrect length check", Te.mode = ve;
                break;
              }
              ze = 0, Qe = 0;
            }
            Te.mode = be;
          case be:
            Ge = V;
            break e;
          case ve:
            Ge = ee;
            break e;
          case qe:
            return ie;
          case De:
          default:
            return Q;
        }
    return We.next_out = et, We.avail_out = Le, We.next_in = Se, We.avail_in = Ze, Te.hold = ze, Te.bits = Qe, (Te.wsize || ft !== We.avail_out && Te.mode < ve && (Te.mode < $e || tt !== P)) && pt(We, We.output, We.next_out, ft - We.avail_out), _t -= We.avail_in, ft -= We.avail_out, We.total_in += _t, We.total_out += ft, Te.total += ft, Te.wrap && ft && (We.adler = Te.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    Te.flags ? S(Te.check, mt, ft, We.next_out - ft) : o(Te.check, mt, ft, We.next_out - ft)), We.data_type = Te.bits + (Te.last ? 64 : 0) + (Te.mode === $ ? 128 : 0) + (Te.mode === F || Te.mode === Z ? 256 : 0), (_t === 0 && ft === 0 || tt === P) && Ge === H && (Ge = te), Ge;
  }
  function Xe(We) {
    if (!We || !We.state)
      return Q;
    var tt = We.state;
    return tt.window && (tt.window = null), We.state = null, H;
  }
  function at(We, tt) {
    var Te;
    return !We || !We.state || (Te = We.state, !(Te.wrap & 2)) ? Q : (Te.head = tt, tt.done = !1, H);
  }
  function ht(We, tt) {
    var Te = tt.length, rt, mt, Se;
    return !We || !We.state || (rt = We.state, rt.wrap !== 0 && rt.mode !== M) ? Q : rt.mode === M && (mt = 1, mt = o(mt, tt, Te, 0), mt !== rt.check) ? ee : (Se = pt(We, tt, Te, Te), Se ? (rt.mode = qe, ie) : (rt.havedict = 1, H));
  }
  return inflate.inflateReset = Ve, inflate.inflateReset2 = nt, inflate.inflateResetKeep = He, inflate.inflateInit = Fe, inflate.inflateInit2 = Ie, inflate.inflate = ke, inflate.inflateEnd = Xe, inflate.inflateGetHeader = at, inflate.inflateSetDictionary = ht, inflate.inflateInfo = "pako inflate (from Nodeca project)", inflate;
}
var constants$1, hasRequiredConstants$1;
function requireConstants$1() {
  return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, constants$1 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  }), constants$1;
}
var hasRequiredBinding;
function requireBinding() {
  return hasRequiredBinding || (hasRequiredBinding = 1, function(e) {
    var o = requireAssert(), S = requireZstream(), g = requireDeflate(), U = requireInflate(), h = requireConstants$1();
    for (var q in h)
      e[q] = h[q];
    e.NONE = 0, e.DEFLATE = 1, e.INFLATE = 2, e.GZIP = 3, e.GUNZIP = 4, e.DEFLATERAW = 5, e.INFLATERAW = 6, e.UNZIP = 7;
    var A = 31, P = 139;
    function I(B) {
      if (typeof B != "number" || B < e.DEFLATE || B > e.UNZIP)
        throw new TypeError("Bad argument");
      this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = B, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
    }
    I.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = !0;
        return;
      }
      this.pending_close = !1, o(this.init_done, "close before init"), o(this.mode <= e.UNZIP), this.mode === e.DEFLATE || this.mode === e.GZIP || this.mode === e.DEFLATERAW ? g.deflateEnd(this.strm) : (this.mode === e.INFLATE || this.mode === e.GUNZIP || this.mode === e.INFLATERAW || this.mode === e.UNZIP) && U.inflateEnd(this.strm), this.mode = e.NONE, this.dictionary = null;
    }, I.prototype.write = function(B, H, V, X, Q, ee, ie) {
      return this._write(!0, B, H, V, X, Q, ee, ie);
    }, I.prototype.writeSync = function(B, H, V, X, Q, ee, ie) {
      return this._write(!1, B, H, V, X, Q, ee, ie);
    }, I.prototype._write = function(B, H, V, X, Q, ee, ie, te) {
      if (o.equal(arguments.length, 8), o(this.init_done, "write before init"), o(this.mode !== e.NONE, "already finalized"), o.equal(!1, this.write_in_progress, "write already in progress"), o.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, o.equal(!1, H === void 0, "must provide flush value"), this.write_in_progress = !0, H !== e.Z_NO_FLUSH && H !== e.Z_PARTIAL_FLUSH && H !== e.Z_SYNC_FLUSH && H !== e.Z_FULL_FLUSH && H !== e.Z_FINISH && H !== e.Z_BLOCK)
        throw new Error("Invalid flush value");
      if (V == null && (V = buffer$3.Buffer.alloc(0), Q = 0, X = 0), this.strm.avail_in = Q, this.strm.input = V, this.strm.next_in = X, this.strm.avail_out = te, this.strm.output = ee, this.strm.next_out = ie, this.flush = H, !B)
        return this._process(), this._checkError() ? this._afterSync() : void 0;
      var se = this;
      return process$3.nextTick(function() {
        se._process(), se._after();
      }), this;
    }, I.prototype._afterSync = function() {
      var B = this.strm.avail_out, H = this.strm.avail_in;
      return this.write_in_progress = !1, [H, B];
    }, I.prototype._process = function() {
      var B = null;
      switch (this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = g.deflate(this.strm, this.flush);
          break;
        case e.UNZIP:
          switch (this.strm.avail_in > 0 && (B = this.strm.next_in), this.gzip_id_bytes_read) {
            case 0:
              if (B === null)
                break;
              if (this.strm.input[B] === A) {
                if (this.gzip_id_bytes_read = 1, B++, this.strm.avail_in === 1)
                  break;
              } else {
                this.mode = e.INFLATE;
                break;
              }
            case 1:
              if (B === null)
                break;
              this.strm.input[B] === P ? (this.gzip_id_bytes_read = 2, this.mode = e.GUNZIP) : this.mode = e.INFLATE;
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
          for (this.err = U.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          ), this.err === e.Z_NEED_DICT && this.dictionary && (this.err = U.inflateSetDictionary(this.strm, this.dictionary), this.err === e.Z_OK ? this.err = U.inflate(this.strm, this.flush) : this.err === e.Z_DATA_ERROR && (this.err = e.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === e.GUNZIP && this.err === e.Z_STREAM_END && this.strm.next_in[0] !== 0; )
            this.reset(), this.err = U.inflate(this.strm, this.flush);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    }, I.prototype._checkError = function() {
      switch (this.err) {
        case e.Z_OK:
        case e.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === e.Z_FINISH)
            return this._error("unexpected end of file"), !1;
          break;
        case e.Z_STREAM_END:
          break;
        case e.Z_NEED_DICT:
          return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
        default:
          return this._error("Zlib error"), !1;
      }
      return !0;
    }, I.prototype._after = function() {
      if (this._checkError()) {
        var B = this.strm.avail_out, H = this.strm.avail_in;
        this.write_in_progress = !1, this.callback(H, B), this.pending_close && this.close();
      }
    }, I.prototype._error = function(B) {
      this.strm.msg && (B = this.strm.msg), this.onerror(
        B,
        this.err
        // no hope of rescue.
      ), this.write_in_progress = !1, this.pending_close && this.close();
    }, I.prototype.init = function(B, H, V, X, Q) {
      o(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), o(B >= 8 && B <= 15, "invalid windowBits"), o(H >= -1 && H <= 9, "invalid compression level"), o(V >= 1 && V <= 9, "invalid memlevel"), o(X === e.Z_FILTERED || X === e.Z_HUFFMAN_ONLY || X === e.Z_RLE || X === e.Z_FIXED || X === e.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(H, B, V, X, Q), this._setDictionary();
    }, I.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    }, I.prototype.reset = function() {
      this._reset(), this._setDictionary();
    }, I.prototype._init = function(B, H, V, X, Q) {
      switch (this.level = B, this.windowBits = H, this.memLevel = V, this.strategy = X, this.flush = e.Z_NO_FLUSH, this.err = e.Z_OK, (this.mode === e.GZIP || this.mode === e.GUNZIP) && (this.windowBits += 16), this.mode === e.UNZIP && (this.windowBits += 32), (this.mode === e.DEFLATERAW || this.mode === e.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new S(), this.mode) {
        case e.DEFLATE:
        case e.GZIP:
        case e.DEFLATERAW:
          this.err = g.deflateInit2(this.strm, this.level, e.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case e.INFLATE:
        case e.GUNZIP:
        case e.INFLATERAW:
        case e.UNZIP:
          this.err = U.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      this.err !== e.Z_OK && this._error("Init error"), this.dictionary = Q, this.write_in_progress = !1, this.init_done = !0;
    }, I.prototype._setDictionary = function() {
      if (this.dictionary != null) {
        switch (this.err = e.Z_OK, this.mode) {
          case e.DEFLATE:
          case e.DEFLATERAW:
            this.err = g.deflateSetDictionary(this.strm, this.dictionary);
            break;
        }
        this.err !== e.Z_OK && this._error("Failed to set dictionary");
      }
    }, I.prototype._reset = function() {
      switch (this.err = e.Z_OK, this.mode) {
        case e.DEFLATE:
        case e.DEFLATERAW:
        case e.GZIP:
          this.err = g.deflateReset(this.strm);
          break;
        case e.INFLATE:
        case e.INFLATERAW:
        case e.GUNZIP:
          this.err = U.inflateReset(this.strm);
          break;
      }
      this.err !== e.Z_OK && this._error("Failed to reset stream");
    }, e.Zlib = I;
  }(binding)), binding;
}
var hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, function(e) {
    var o = buffer$3.Buffer, S = requireStreamBrowserify().Transform, g = requireBinding(), U = requireUtil$1(), h = requireAssert().ok, q = buffer$3.kMaxLength, A = "Cannot create final Buffer. It would be larger than 0x" + q.toString(16) + " bytes";
    g.Z_MIN_WINDOWBITS = 8, g.Z_MAX_WINDOWBITS = 15, g.Z_DEFAULT_WINDOWBITS = 15, g.Z_MIN_CHUNK = 64, g.Z_MAX_CHUNK = 1 / 0, g.Z_DEFAULT_CHUNK = 16 * 1024, g.Z_MIN_MEMLEVEL = 1, g.Z_MAX_MEMLEVEL = 9, g.Z_DEFAULT_MEMLEVEL = 8, g.Z_MIN_LEVEL = -1, g.Z_MAX_LEVEL = 9, g.Z_DEFAULT_LEVEL = g.Z_DEFAULT_COMPRESSION;
    for (var P = Object.keys(g), I = 0; I < P.length; I++) {
      var B = P[I];
      B.match(/^Z/) && Object.defineProperty(e, B, {
        enumerable: !0,
        value: g[B],
        writable: !1
      });
    }
    for (var H = {
      Z_OK: g.Z_OK,
      Z_STREAM_END: g.Z_STREAM_END,
      Z_NEED_DICT: g.Z_NEED_DICT,
      Z_ERRNO: g.Z_ERRNO,
      Z_STREAM_ERROR: g.Z_STREAM_ERROR,
      Z_DATA_ERROR: g.Z_DATA_ERROR,
      Z_MEM_ERROR: g.Z_MEM_ERROR,
      Z_BUF_ERROR: g.Z_BUF_ERROR,
      Z_VERSION_ERROR: g.Z_VERSION_ERROR
    }, V = Object.keys(H), X = 0; X < V.length; X++) {
      var Q = V[X];
      H[H[Q]] = Q;
    }
    Object.defineProperty(e, "codes", {
      enumerable: !0,
      value: Object.freeze(H),
      writable: !1
    }), e.Deflate = te, e.Inflate = se, e.Gzip = le, e.Gunzip = ce, e.DeflateRaw = pe, e.InflateRaw = me, e.Unzip = Me, e.createDeflate = function(Y) {
      return new te(Y);
    }, e.createInflate = function(Y) {
      return new se(Y);
    }, e.createDeflateRaw = function(Y) {
      return new pe(Y);
    }, e.createInflateRaw = function(Y) {
      return new me(Y);
    }, e.createGzip = function(Y) {
      return new le(Y);
    }, e.createGunzip = function(Y) {
      return new ce(Y);
    }, e.createUnzip = function(Y) {
      return new Me(Y);
    }, e.deflate = function(Y, M, $) {
      return typeof M == "function" && ($ = M, M = {}), ee(new te(M), Y, $);
    }, e.deflateSync = function(Y, M) {
      return ie(new te(M), Y);
    }, e.gzip = function(Y, M, $) {
      return typeof M == "function" && ($ = M, M = {}), ee(new le(M), Y, $);
    }, e.gzipSync = function(Y, M) {
      return ie(new le(M), Y);
    }, e.deflateRaw = function(Y, M, $) {
      return typeof M == "function" && ($ = M, M = {}), ee(new pe(M), Y, $);
    }, e.deflateRawSync = function(Y, M) {
      return ie(new pe(M), Y);
    }, e.unzip = function(Y, M, $) {
      return typeof M == "function" && ($ = M, M = {}), ee(new Me(M), Y, $);
    }, e.unzipSync = function(Y, M) {
      return ie(new Me(M), Y);
    }, e.inflate = function(Y, M, $) {
      return typeof M == "function" && ($ = M, M = {}), ee(new se(M), Y, $);
    }, e.inflateSync = function(Y, M) {
      return ie(new se(M), Y);
    }, e.gunzip = function(Y, M, $) {
      return typeof M == "function" && ($ = M, M = {}), ee(new ce(M), Y, $);
    }, e.gunzipSync = function(Y, M) {
      return ie(new ce(M), Y);
    }, e.inflateRaw = function(Y, M, $) {
      return typeof M == "function" && ($ = M, M = {}), ee(new me(M), Y, $);
    }, e.inflateRawSync = function(Y, M) {
      return ie(new me(M), Y);
    };
    function ee(Y, M, $) {
      var O = [], J = 0;
      Y.on("error", K), Y.on("end", z), Y.end(M), Z();
      function Z() {
        for (var G; (G = Y.read()) !== null; )
          O.push(G), J += G.length;
        Y.once("readable", Z);
      }
      function K(G) {
        Y.removeListener("end", z), Y.removeListener("readable", Z), $(G);
      }
      function z() {
        var G, D = null;
        J >= q ? D = new RangeError(A) : G = o.concat(O, J), O = [], Y.close(), $(D, G);
      }
    }
    function ie(Y, M) {
      if (typeof M == "string" && (M = o.from(M)), !o.isBuffer(M))
        throw new TypeError("Not a string or buffer");
      var $ = Y._finishFlushFlag;
      return Y._processChunk(M, $);
    }
    function te(Y) {
      if (!(this instanceof te))
        return new te(Y);
      Re.call(this, Y, g.DEFLATE);
    }
    function se(Y) {
      if (!(this instanceof se))
        return new se(Y);
      Re.call(this, Y, g.INFLATE);
    }
    function le(Y) {
      if (!(this instanceof le))
        return new le(Y);
      Re.call(this, Y, g.GZIP);
    }
    function ce(Y) {
      if (!(this instanceof ce))
        return new ce(Y);
      Re.call(this, Y, g.GUNZIP);
    }
    function pe(Y) {
      if (!(this instanceof pe))
        return new pe(Y);
      Re.call(this, Y, g.DEFLATERAW);
    }
    function me(Y) {
      if (!(this instanceof me))
        return new me(Y);
      Re.call(this, Y, g.INFLATERAW);
    }
    function Me(Y) {
      if (!(this instanceof Me))
        return new Me(Y);
      Re.call(this, Y, g.UNZIP);
    }
    function Ee(Y) {
      return Y === g.Z_NO_FLUSH || Y === g.Z_PARTIAL_FLUSH || Y === g.Z_SYNC_FLUSH || Y === g.Z_FULL_FLUSH || Y === g.Z_FINISH || Y === g.Z_BLOCK;
    }
    function Re(Y, M) {
      var $ = this;
      if (this._opts = Y = Y || {}, this._chunkSize = Y.chunkSize || e.Z_DEFAULT_CHUNK, S.call(this, Y), Y.flush && !Ee(Y.flush))
        throw new Error("Invalid flush flag: " + Y.flush);
      if (Y.finishFlush && !Ee(Y.finishFlush))
        throw new Error("Invalid flush flag: " + Y.finishFlush);
      if (this._flushFlag = Y.flush || g.Z_NO_FLUSH, this._finishFlushFlag = typeof Y.finishFlush < "u" ? Y.finishFlush : g.Z_FINISH, Y.chunkSize && (Y.chunkSize < e.Z_MIN_CHUNK || Y.chunkSize > e.Z_MAX_CHUNK))
        throw new Error("Invalid chunk size: " + Y.chunkSize);
      if (Y.windowBits && (Y.windowBits < e.Z_MIN_WINDOWBITS || Y.windowBits > e.Z_MAX_WINDOWBITS))
        throw new Error("Invalid windowBits: " + Y.windowBits);
      if (Y.level && (Y.level < e.Z_MIN_LEVEL || Y.level > e.Z_MAX_LEVEL))
        throw new Error("Invalid compression level: " + Y.level);
      if (Y.memLevel && (Y.memLevel < e.Z_MIN_MEMLEVEL || Y.memLevel > e.Z_MAX_MEMLEVEL))
        throw new Error("Invalid memLevel: " + Y.memLevel);
      if (Y.strategy && Y.strategy != e.Z_FILTERED && Y.strategy != e.Z_HUFFMAN_ONLY && Y.strategy != e.Z_RLE && Y.strategy != e.Z_FIXED && Y.strategy != e.Z_DEFAULT_STRATEGY)
        throw new Error("Invalid strategy: " + Y.strategy);
      if (Y.dictionary && !o.isBuffer(Y.dictionary))
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      this._handle = new g.Zlib(M);
      var O = this;
      this._hadError = !1, this._handle.onerror = function(K, z) {
        Ne(O), O._hadError = !0;
        var G = new Error(K);
        G.errno = z, G.code = e.codes[z], O.emit("error", G);
      };
      var J = e.Z_DEFAULT_COMPRESSION;
      typeof Y.level == "number" && (J = Y.level);
      var Z = e.Z_DEFAULT_STRATEGY;
      typeof Y.strategy == "number" && (Z = Y.strategy), this._handle.init(Y.windowBits || e.Z_DEFAULT_WINDOWBITS, J, Y.memLevel || e.Z_DEFAULT_MEMLEVEL, Z, Y.dictionary), this._buffer = o.allocUnsafe(this._chunkSize), this._offset = 0, this._level = J, this._strategy = Z, this.once("end", this.close), Object.defineProperty(this, "_closed", {
        get: function() {
          return !$._handle;
        },
        configurable: !0,
        enumerable: !0
      });
    }
    U.inherits(Re, S), Re.prototype.params = function(Y, M, $) {
      if (Y < e.Z_MIN_LEVEL || Y > e.Z_MAX_LEVEL)
        throw new RangeError("Invalid compression level: " + Y);
      if (M != e.Z_FILTERED && M != e.Z_HUFFMAN_ONLY && M != e.Z_RLE && M != e.Z_FIXED && M != e.Z_DEFAULT_STRATEGY)
        throw new TypeError("Invalid strategy: " + M);
      if (this._level !== Y || this._strategy !== M) {
        var O = this;
        this.flush(g.Z_SYNC_FLUSH, function() {
          h(O._handle, "zlib binding closed"), O._handle.params(Y, M), O._hadError || (O._level = Y, O._strategy = M, $ && $());
        });
      } else
        process$3.nextTick($);
    }, Re.prototype.reset = function() {
      return h(this._handle, "zlib binding closed"), this._handle.reset();
    }, Re.prototype._flush = function(Y) {
      this._transform(o.alloc(0), "", Y);
    }, Re.prototype.flush = function(Y, M) {
      var $ = this, O = this._writableState;
      (typeof Y == "function" || Y === void 0 && !M) && (M = Y, Y = g.Z_FULL_FLUSH), O.ended ? M && process$3.nextTick(M) : O.ending ? M && this.once("end", M) : O.needDrain ? M && this.once("drain", function() {
        return $.flush(Y, M);
      }) : (this._flushFlag = Y, this.write(o.alloc(0), "", M));
    }, Re.prototype.close = function(Y) {
      Ne(this, Y), process$3.nextTick(ne, this);
    };
    function Ne(Y, M) {
      M && process$3.nextTick(M), Y._handle && (Y._handle.close(), Y._handle = null);
    }
    function ne(Y) {
      Y.emit("close");
    }
    Re.prototype._transform = function(Y, M, $) {
      var O, J = this._writableState, Z = J.ending || J.ended, K = Z && (!Y || J.length === Y.length);
      if (Y !== null && !o.isBuffer(Y))
        return $(new Error("invalid input"));
      if (!this._handle)
        return $(new Error("zlib binding closed"));
      K ? O = this._finishFlushFlag : (O = this._flushFlag, Y.length >= J.length && (this._flushFlag = this._opts.flush || g.Z_NO_FLUSH)), this._processChunk(Y, O, $);
    }, Re.prototype._processChunk = function(Y, M, $) {
      var O = Y && Y.length, J = this._chunkSize - this._offset, Z = 0, K = this, z = typeof $ == "function";
      if (!z) {
        var G = [], D = 0, F;
        this.on("error", function(oe) {
          F = oe;
        }), h(this._handle, "zlib binding closed");
        do
          var ae = this._handle.writeSync(
            M,
            Y,
            // in
            Z,
            // in_off
            O,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            J
          );
        while (!this._hadError && ye(ae[0], ae[1]));
        if (this._hadError)
          throw F;
        if (D >= q)
          throw Ne(this), new RangeError(A);
        var ge = o.concat(G, D);
        return Ne(this), ge;
      }
      h(this._handle, "zlib binding closed");
      var xe = this._handle.write(
        M,
        Y,
        // in
        Z,
        // in_off
        O,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        J
      );
      xe.buffer = Y, xe.callback = ye;
      function ye(oe, fe) {
        if (this && (this.buffer = null, this.callback = null), !K._hadError) {
          var $e = J - fe;
          if (h($e >= 0, "have should not go down"), $e > 0) {
            var Be = K._buffer.slice(K._offset, K._offset + $e);
            K._offset += $e, z ? K.push(Be) : (G.push(Be), D += Be.length);
          }
          if ((fe === 0 || K._offset >= K._chunkSize) && (J = K._chunkSize, K._offset = 0, K._buffer = o.allocUnsafe(K._chunkSize)), fe === 0) {
            if (Z += O - oe, O = oe, !z)
              return !0;
            var be = K._handle.write(M, Y, Z, O, K._buffer, K._offset, K._chunkSize);
            be.callback = ye, be.buffer = Y;
            return;
          }
          if (!z)
            return !1;
          $();
        }
      }
    }, U.inherits(te, Re), U.inherits(se, Re), U.inherits(le, Re), U.inherits(ce, Re), U.inherits(pe, Re), U.inherits(me, Re), U.inherits(Me, Re);
  }(lib$1)), lib$1;
}
Object.defineProperty(microFtch, "__esModule", { value: !0 });
microFtch.InvalidStatusCodeError = microFtch.InvalidCertError = void 0;
const DEFAULT_OPT = Object.freeze({
  redirect: !0,
  expectStatusCode: 200,
  headers: {},
  full: !1,
  keepAlive: !0,
  cors: !1,
  referrer: !1,
  sslAllowSelfSigned: !1,
  _redirectCount: 0
});
class InvalidCertError extends Error {
  constructor(o, S) {
    super(o), this.fingerprint256 = S;
  }
}
microFtch.InvalidCertError = InvalidCertError;
class InvalidStatusCodeError extends Error {
  constructor(o) {
    super(`Request Failed. Status Code: ${o}`), this.statusCode = o;
  }
}
microFtch.InvalidStatusCodeError = InvalidStatusCodeError;
function detectType(e, o) {
  if (!o || o === "text" || o === "json")
    try {
      let S = new TextDecoder("utf8", { fatal: !0 }).decode(e);
      if (o === "text")
        return S;
      try {
        return JSON.parse(S);
      } catch (g) {
        if (o === "json")
          throw g;
        return S;
      }
    } catch (S) {
      if (o === "text" || o === "json")
        throw S;
    }
  return e;
}
let agents = {};
function fetchNode(e, o) {
  var V;
  let S = { ...DEFAULT_OPT, ...o };
  const g = requireStreamHttp(), U = requireHttpsBrowserify(), h = requireLib(), { promisify: q } = requireUtil$1(), { resolve: A } = requireUrl(), P = !!/^https/.test(e);
  let I = {
    method: S.method || "GET",
    headers: { "Accept-Encoding": "gzip, deflate, br" }
  };
  const B = (X) => X.replace(/:| /g, "").toLowerCase();
  if (S.keepAlive) {
    const X = {
      keepAlive: !0,
      keepAliveMsecs: 3e4,
      maxFreeSockets: 1024,
      maxCachedSessions: 1024
    }, Q = [
      P,
      P && ((V = S.sslPinnedCertificates) == null ? void 0 : V.map((ee) => B(ee)).sort())
    ].join();
    I.agent = agents[Q] || (agents[Q] = new (P ? U : g).Agent(X));
  }
  S.type === "json" && (I.headers["Content-Type"] = "application/json"), S.data && (S.method || (I.method = "POST"), I.body = S.type === "json" ? JSON.stringify(S.data) : S.data), I.headers = { ...I.headers, ...S.headers }, S.sslAllowSelfSigned && (I.rejectUnauthorized = !1);
  const H = async (X) => {
    const Q = X.statusCode;
    if (S.redirect && 300 <= Q && Q < 400 && X.headers.location) {
      if (S._redirectCount == 10)
        throw new Error("Request failed. Too much redirects.");
      return S._redirectCount += 1, await fetchNode(A(e, X.headers.location), S);
    }
    if (S.expectStatusCode && Q !== S.expectStatusCode)
      throw X.resume(), new InvalidStatusCodeError(Q);
    let ee = [];
    for await (const le of X)
      ee.push(le);
    let ie = buffer$3.Buffer.concat(ee);
    const te = X.headers["content-encoding"];
    te === "br" && (ie = await q(h.brotliDecompress)(ie)), (te === "gzip" || te === "deflate") && (ie = await q(h.unzip)(ie));
    const se = detectType(ie, S.type);
    return S.full ? { headers: X.headers, status: Q, body: se } : se;
  };
  return new Promise((X, Q) => {
    var le;
    const ee = async (ce) => {
      if (ce && ce.code === "DEPTH_ZERO_SELF_SIGNED_CERT")
        try {
          await fetchNode(e, { ...S, sslAllowSelfSigned: !0, sslPinnedCertificates: [] });
        } catch (pe) {
          pe && pe.fingerprint256 && (ce = new InvalidCertError(`Self-signed SSL certificate: ${pe.fingerprint256}`, pe.fingerprint256));
        }
      Q(ce);
    }, ie = (P ? U : g).request(e, I, (ce) => {
      ce.on("error", ee), (async () => {
        try {
          X(await H(ce));
        } catch (pe) {
          Q(pe);
        }
      })();
    });
    ie.on("error", ee);
    const te = (le = S.sslPinnedCertificates) == null ? void 0 : le.map((ce) => B(ce)), se = (ce) => {
      var me;
      const pe = B(((me = ce.getPeerCertificate()) == null ? void 0 : me.fingerprint256) || "");
      if (!(!pe && ce.isSessionReused()) && !te.includes(pe))
        return ie.emit("error", new InvalidCertError(`Invalid SSL certificate: ${pe} Expected: ${te}`, pe)), ie.abort();
    };
    S.sslPinnedCertificates && ie.on("socket", (ce) => {
      ce.listeners("secureConnect").map((me) => (me.name || "").replace("bound ", "")).includes("mfetchSecureConnect") || ce.on("secureConnect", se.bind(null, ce));
    }), S.keepAlive && ie.setNoDelay(!0), I.body && ie.write(I.body), ie.end();
  });
}
const SAFE_HEADERS = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((e) => e.toLowerCase())), FORBIDDEN_HEADERS = new Set([
  "Accept-Charset",
  "Accept-Encoding",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Connection",
  "Content-Length",
  "Cookie",
  "Cookie2",
  "Date",
  "DNT",
  "Expect",
  "Host",
  "Keep-Alive",
  "Origin",
  "Referer",
  "TE",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Via"
].map((e) => e.toLowerCase()));
async function fetchBrowser(e, o) {
  let S = { ...DEFAULT_OPT, ...o };
  const g = new Headers();
  S.type === "json" && g.set("Content-Type", "application/json");
  let U = new URL(e);
  if (U.username) {
    const P = btoa(`${U.username}:${U.password}`);
    g.set("Authorization", `Basic ${P}`), U.username = "", U.password = "";
  }
  e = "" + U;
  for (let P in S.headers) {
    const I = P.toLowerCase();
    (SAFE_HEADERS.has(I) || S.cors && !FORBIDDEN_HEADERS.has(I)) && g.set(P, S.headers[P]);
  }
  let h = { headers: g, redirect: S.redirect ? "follow" : "manual" };
  S.referrer || (h.referrerPolicy = "no-referrer"), S.cors && (h.mode = "cors"), S.data && (S.method || (h.method = "POST"), h.body = S.type === "json" ? JSON.stringify(S.data) : S.data);
  const q = await fetch(e, h);
  if (S.expectStatusCode && q.status !== S.expectStatusCode)
    throw new InvalidStatusCodeError(q.status);
  const A = detectType(new Uint8Array(await q.arrayBuffer()), S.type);
  return S.full ? { headers: Object.fromEntries(q.headers.entries()), status: q.status, body: A } : A;
}
const IS_NODE = !!(typeof process$3 == "object" && process$3.versions && process$3.versions.node && process$3.versions.v8);
function fetchUrl(e, o) {
  return (IS_NODE ? fetchNode : fetchBrowser)(e, o);
}
microFtch.default = fetchUrl;
Object.defineProperty(provider, "__esModule", { value: !0 });
provider.getProvider = provider.fetchFromProvider = void 0;
const micro_ftch_1 = microFtch, fetchFromProvider = async (e, o) => (await (0, micro_ftch_1.default)(e, {
  headers: {
    "content-type": "application/json"
  },
  type: "json",
  data: {
    method: o.method,
    params: o.params,
    jsonrpc: "2.0",
    id: 1
  }
})).result;
provider.fetchFromProvider = fetchFromProvider;
const getProvider = (e) => {
  var o;
  if (typeof e == "string")
    return e;
  if (((o = e == null ? void 0 : e.connection) == null ? void 0 : o.url) !== void 0)
    return e.connection.url;
  throw new Error("Must provide valid provider URL or Web3Provider");
};
provider.getProvider = getProvider;
(function(e) {
  var o = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(U, h, q, A) {
    A === void 0 && (A = q);
    var P = Object.getOwnPropertyDescriptor(h, q);
    (!P || ("get" in P ? !h.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
      return h[q];
    } }), Object.defineProperty(U, A, P);
  } : function(U, h, q, A) {
    A === void 0 && (A = q), U[A] = h[q];
  }), S = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(U, h) {
    for (var q in U)
      q !== "default" && !Object.prototype.hasOwnProperty.call(h, q) && o(h, U, q);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.toAscii = e.stripHexPrefix = e.padToEven = e.isHexString = e.isHexPrefixed = e.getKeys = e.getBinarySize = e.fromUtf8 = e.fromAscii = e.arrayContainsArray = void 0, S(constants$2, e), S(units, e), S(account, e), S(address, e), S(withdrawal, e), S(signature$2, e), S(bytes, e), S(types$2, e), S(encoding, e), S(asyncEventEmitter, e);
  var g = internal;
  Object.defineProperty(e, "arrayContainsArray", { enumerable: !0, get: function() {
    return g.arrayContainsArray;
  } }), Object.defineProperty(e, "fromAscii", { enumerable: !0, get: function() {
    return g.fromAscii;
  } }), Object.defineProperty(e, "fromUtf8", { enumerable: !0, get: function() {
    return g.fromUtf8;
  } }), Object.defineProperty(e, "getBinarySize", { enumerable: !0, get: function() {
    return g.getBinarySize;
  } }), Object.defineProperty(e, "getKeys", { enumerable: !0, get: function() {
    return g.getKeys;
  } }), Object.defineProperty(e, "isHexPrefixed", { enumerable: !0, get: function() {
    return g.isHexPrefixed;
  } }), Object.defineProperty(e, "isHexString", { enumerable: !0, get: function() {
    return g.isHexString;
  } }), Object.defineProperty(e, "padToEven", { enumerable: !0, get: function() {
    return g.padToEven;
  } }), Object.defineProperty(e, "stripHexPrefix", { enumerable: !0, get: function() {
    return g.stripHexPrefix;
  } }), Object.defineProperty(e, "toAscii", { enumerable: !0, get: function() {
    return g.toAscii;
  } }), S(lock, e), S(provider, e);
})(dist$1);
var utils$4 = {}, src$1 = function e(o) {
  if (typeof o != "string")
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof o + ", while checking isHexPrefixed.");
  return o.slice(0, 2) === "0x";
}, isHexPrefixed$1 = src$1, src = function e(o) {
  return typeof o != "string" ? o : isHexPrefixed$1(o) ? o.slice(2) : o;
}, isHexPrefixed = src$1, stripHexPrefix = src;
function padToEven(e) {
  var o = e;
  if (typeof o != "string")
    throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof o + ", while padToEven.");
  return o.length % 2 && (o = "0" + o), o;
}
function intToHex(e) {
  var o = e.toString(16);
  return "0x" + o;
}
function intToBuffer(e) {
  var o = intToHex(e);
  return new buffer$3.Buffer(padToEven(o.slice(2)), "hex");
}
function getBinarySize(e) {
  if (typeof e != "string")
    throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof e + "'.");
  return buffer$3.Buffer.byteLength(e, "utf8");
}
function arrayContainsArray(e, o, S) {
  if (Array.isArray(e) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof e + "'");
  if (Array.isArray(o) !== !0)
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof o + "'");
  return o[!!S && "some" || "every"](function(g) {
    return e.indexOf(g) >= 0;
  });
}
function toUtf8(e) {
  var o = new buffer$3.Buffer(padToEven(stripHexPrefix(e).replace(/^0+|0+$/g, "")), "hex");
  return o.toString("utf8");
}
function toAscii(e) {
  var o = "", S = 0, g = e.length;
  for (e.substring(0, 2) === "0x" && (S = 2); S < g; S += 2) {
    var U = parseInt(e.substr(S, 2), 16);
    o += String.fromCharCode(U);
  }
  return o;
}
function fromUtf8(e) {
  var o = new buffer$3.Buffer(e, "utf8");
  return "0x" + padToEven(o.toString("hex")).replace(/^0+|0+$/g, "");
}
function fromAscii(e) {
  for (var o = "", S = 0; S < e.length; S++) {
    var g = e.charCodeAt(S), U = g.toString(16);
    o += U.length < 2 ? "0" + U : U;
  }
  return "0x" + o;
}
function getKeys(e, o, S) {
  if (!Array.isArray(e))
    throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof e + "'");
  if (typeof o != "string")
    throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof o + "'.");
  for (var g = [], U = 0; U < e.length; U++) {
    var h = e[U][o];
    if (S && !h)
      h = "";
    else if (typeof h != "string")
      throw new Error("invalid abi");
    g.push(h);
  }
  return g;
}
function isHexString(e, o) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || o && e.length !== 2 + 2 * o);
}
var lib = {
  arrayContainsArray,
  intToBuffer,
  getBinarySize,
  isHexPrefixed,
  stripHexPrefix,
  padToEven,
  intToHex,
  fromAscii,
  fromUtf8,
  toAscii,
  toUtf8,
  getKeys,
  isHexString
};
Object.defineProperty(utils$4, "__esModule", { value: !0 });
utils$4.numberToBuffer = utils$4.normalize = utils$4.recoverPublicKey = utils$4.concatSig = utils$4.legacyToBuffer = utils$4.isNullish = utils$4.padWithZeroes = void 0;
const util_1$2 = dist$1, ethjs_util_1$1 = lib;
function padWithZeroes(e, o) {
  if (e !== "" && !/^[a-f0-9]+$/iu.test(e))
    throw new Error(`Expected an unprefixed hex string. Received: ${e}`);
  if (o < 0)
    throw new Error(`Expected a non-negative integer target length. Received: ${o}`);
  return String.prototype.padStart.call(e, o, "0");
}
utils$4.padWithZeroes = padWithZeroes;
function isNullish(e) {
  return e == null;
}
utils$4.isNullish = isNullish;
function legacyToBuffer(e) {
  return typeof e == "string" && !(0, ethjs_util_1$1.isHexString)(e) ? buffer$3.Buffer.from(e) : (0, util_1$2.toBuffer)(e);
}
utils$4.legacyToBuffer = legacyToBuffer;
function concatSig(e, o, S) {
  const g = (0, util_1$2.fromSigned)(o), U = (0, util_1$2.fromSigned)(S), h = (0, util_1$2.bufferToInt)(e), q = padWithZeroes((0, util_1$2.toUnsigned)(g).toString("hex"), 64), A = padWithZeroes((0, util_1$2.toUnsigned)(U).toString("hex"), 64), P = (0, ethjs_util_1$1.stripHexPrefix)((0, ethjs_util_1$1.intToHex)(h));
  return (0, util_1$2.addHexPrefix)(q.concat(A, P));
}
utils$4.concatSig = concatSig;
function recoverPublicKey(e, o) {
  const S = (0, util_1$2.fromRpcSig)(o);
  return (0, util_1$2.ecrecover)(e, S.v, S.r, S.s);
}
utils$4.recoverPublicKey = recoverPublicKey;
function normalize(e) {
  if (e) {
    if (typeof e == "number") {
      if (e < 0)
        return "0x";
      const o = (0, util_1$2.toBuffer)(e);
      e = (0, util_1$2.bufferToHex)(o);
    }
    if (typeof e != "string") {
      let o = "eth-sig-util.normalize() requires hex string or integer input.";
      throw o += ` received ${typeof e}: ${e}`, new Error(o);
    }
    return (0, util_1$2.addHexPrefix)(e.toLowerCase());
  }
}
utils$4.normalize = normalize;
function numberToBuffer(e) {
  const o = e.toString(16), S = o.length % 2 ? "0" : "";
  return buffer$3.Buffer.from(S + o, "hex");
}
utils$4.numberToBuffer = numberToBuffer;
Object.defineProperty(personalSign$1, "__esModule", { value: !0 });
personalSign$1.extractPublicKey = personalSign$1.recoverPersonalSignature = personalSign$1.personalSign = void 0;
const util_1$1 = dist$1, utils_1$2 = utils$4;
function personalSign({ privateKey: e, data: o }) {
  if ((0, utils_1$2.isNullish)(o))
    throw new Error("Missing data parameter");
  if ((0, utils_1$2.isNullish)(e))
    throw new Error("Missing privateKey parameter");
  const S = (0, utils_1$2.legacyToBuffer)(o), g = (0, util_1$1.hashPersonalMessage)(S), U = (0, util_1$1.ecsign)(g, e);
  return (0, utils_1$2.concatSig)((0, util_1$1.toBuffer)(U.v), U.r, U.s);
}
personalSign$1.personalSign = personalSign;
function recoverPersonalSignature({ data: e, signature: o }) {
  if ((0, utils_1$2.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, utils_1$2.isNullish)(o))
    throw new Error("Missing signature parameter");
  const S = getPublicKeyFor(e, o), g = (0, util_1$1.publicToAddress)(S);
  return (0, util_1$1.bufferToHex)(g);
}
personalSign$1.recoverPersonalSignature = recoverPersonalSignature;
function extractPublicKey({ data: e, signature: o }) {
  if ((0, utils_1$2.isNullish)(e))
    throw new Error("Missing data parameter");
  if ((0, utils_1$2.isNullish)(o))
    throw new Error("Missing signature parameter");
  return `0x${getPublicKeyFor(e, o).toString("hex")}`;
}
personalSign$1.extractPublicKey = extractPublicKey;
function getPublicKeyFor(e, o) {
  const S = (0, util_1$1.hashPersonalMessage)((0, utils_1$2.legacyToBuffer)(e));
  return (0, utils_1$2.recoverPublicKey)(S, o);
}
var signTypedData$1 = {}, ethereumjsAbiUtils = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(e) {
  (function(o, S) {
    function g(ne, Y) {
      if (!ne)
        throw new Error(Y || "Assertion failed");
    }
    function U(ne, Y) {
      ne.super_ = Y;
      var M = function() {
      };
      M.prototype = Y.prototype, ne.prototype = new M(), ne.prototype.constructor = ne;
    }
    function h(ne, Y, M) {
      if (h.isBN(ne))
        return ne;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, ne !== null && ((Y === "le" || Y === "be") && (M = Y, Y = 10), this._init(ne || 0, Y || 10, M || "be"));
    }
    typeof o == "object" ? o.exports = h : S.BN = h, h.BN = h, h.wordSize = 26;
    var q;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? q = window.Buffer : q = buffer$3.Buffer;
    } catch {
    }
    h.isBN = function(Y) {
      return Y instanceof h ? !0 : Y !== null && typeof Y == "object" && Y.constructor.wordSize === h.wordSize && Array.isArray(Y.words);
    }, h.max = function(Y, M) {
      return Y.cmp(M) > 0 ? Y : M;
    }, h.min = function(Y, M) {
      return Y.cmp(M) < 0 ? Y : M;
    }, h.prototype._init = function(Y, M, $) {
      if (typeof Y == "number")
        return this._initNumber(Y, M, $);
      if (typeof Y == "object")
        return this._initArray(Y, M, $);
      M === "hex" && (M = 16), g(M === (M | 0) && M >= 2 && M <= 36), Y = Y.toString().replace(/\s+/g, "");
      var O = 0;
      Y[0] === "-" && (O++, this.negative = 1), O < Y.length && (M === 16 ? this._parseHex(Y, O, $) : (this._parseBase(Y, M, O), $ === "le" && this._initArray(this.toArray(), M, $)));
    }, h.prototype._initNumber = function(Y, M, $) {
      Y < 0 && (this.negative = 1, Y = -Y), Y < 67108864 ? (this.words = [Y & 67108863], this.length = 1) : Y < 4503599627370496 ? (this.words = [
        Y & 67108863,
        Y / 67108864 & 67108863
      ], this.length = 2) : (g(Y < 9007199254740992), this.words = [
        Y & 67108863,
        Y / 67108864 & 67108863,
        1
      ], this.length = 3), $ === "le" && this._initArray(this.toArray(), M, $);
    }, h.prototype._initArray = function(Y, M, $) {
      if (g(typeof Y.length == "number"), Y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Y.length / 3), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var J, Z, K = 0;
      if ($ === "be")
        for (O = Y.length - 1, J = 0; O >= 0; O -= 3)
          Z = Y[O] | Y[O - 1] << 8 | Y[O - 2] << 16, this.words[J] |= Z << K & 67108863, this.words[J + 1] = Z >>> 26 - K & 67108863, K += 24, K >= 26 && (K -= 26, J++);
      else if ($ === "le")
        for (O = 0, J = 0; O < Y.length; O += 3)
          Z = Y[O] | Y[O + 1] << 8 | Y[O + 2] << 16, this.words[J] |= Z << K & 67108863, this.words[J + 1] = Z >>> 26 - K & 67108863, K += 24, K >= 26 && (K -= 26, J++);
      return this.strip();
    };
    function A(ne, Y) {
      var M = ne.charCodeAt(Y);
      return M >= 65 && M <= 70 ? M - 55 : M >= 97 && M <= 102 ? M - 87 : M - 48 & 15;
    }
    function P(ne, Y, M) {
      var $ = A(ne, M);
      return M - 1 >= Y && ($ |= A(ne, M - 1) << 4), $;
    }
    h.prototype._parseHex = function(Y, M, $) {
      this.length = Math.ceil((Y.length - M) / 6), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var J = 0, Z = 0, K;
      if ($ === "be")
        for (O = Y.length - 1; O >= M; O -= 2)
          K = P(Y, M, O) << J, this.words[Z] |= K & 67108863, J >= 18 ? (J -= 18, Z += 1, this.words[Z] |= K >>> 26) : J += 8;
      else {
        var z = Y.length - M;
        for (O = z % 2 === 0 ? M + 1 : M; O < Y.length; O += 2)
          K = P(Y, M, O) << J, this.words[Z] |= K & 67108863, J >= 18 ? (J -= 18, Z += 1, this.words[Z] |= K >>> 26) : J += 8;
      }
      this.strip();
    };
    function I(ne, Y, M, $) {
      for (var O = 0, J = Math.min(ne.length, M), Z = Y; Z < J; Z++) {
        var K = ne.charCodeAt(Z) - 48;
        O *= $, K >= 49 ? O += K - 49 + 10 : K >= 17 ? O += K - 17 + 10 : O += K;
      }
      return O;
    }
    h.prototype._parseBase = function(Y, M, $) {
      this.words = [0], this.length = 1;
      for (var O = 0, J = 1; J <= 67108863; J *= M)
        O++;
      O--, J = J / M | 0;
      for (var Z = Y.length - $, K = Z % O, z = Math.min(Z, Z - K) + $, G = 0, D = $; D < z; D += O)
        G = I(Y, D, D + O, M), this.imuln(J), this.words[0] + G < 67108864 ? this.words[0] += G : this._iaddn(G);
      if (K !== 0) {
        var F = 1;
        for (G = I(Y, D, Y.length, M), D = 0; D < K; D++)
          F *= M;
        this.imuln(F), this.words[0] + G < 67108864 ? this.words[0] += G : this._iaddn(G);
      }
      this.strip();
    }, h.prototype.copy = function(Y) {
      Y.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        Y.words[M] = this.words[M];
      Y.length = this.length, Y.negative = this.negative, Y.red = this.red;
    }, h.prototype.clone = function() {
      var Y = new h(null);
      return this.copy(Y), Y;
    }, h.prototype._expand = function(Y) {
      for (; this.length < Y; )
        this.words[this.length++] = 0;
      return this;
    }, h.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, h.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, h.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var B = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], V = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    h.prototype.toString = function(Y, M) {
      Y = Y || 10, M = M | 0 || 1;
      var $;
      if (Y === 16 || Y === "hex") {
        $ = "";
        for (var O = 0, J = 0, Z = 0; Z < this.length; Z++) {
          var K = this.words[Z], z = ((K << O | J) & 16777215).toString(16);
          J = K >>> 24 - O & 16777215, J !== 0 || Z !== this.length - 1 ? $ = B[6 - z.length] + z + $ : $ = z + $, O += 2, O >= 26 && (O -= 26, Z--);
        }
        for (J !== 0 && ($ = J.toString(16) + $); $.length % M !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      if (Y === (Y | 0) && Y >= 2 && Y <= 36) {
        var G = H[Y], D = V[Y];
        $ = "";
        var F = this.clone();
        for (F.negative = 0; !F.isZero(); ) {
          var ae = F.modn(D).toString(Y);
          F = F.idivn(D), F.isZero() ? $ = ae + $ : $ = B[G - ae.length] + ae + $;
        }
        for (this.isZero() && ($ = "0" + $); $.length % M !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      g(!1, "Base should be between 2 and 36");
    }, h.prototype.toNumber = function() {
      var Y = this.words[0];
      return this.length === 2 ? Y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && g(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Y : Y;
    }, h.prototype.toJSON = function() {
      return this.toString(16);
    }, h.prototype.toBuffer = function(Y, M) {
      return g(typeof q < "u"), this.toArrayLike(q, Y, M);
    }, h.prototype.toArray = function(Y, M) {
      return this.toArrayLike(Array, Y, M);
    }, h.prototype.toArrayLike = function(Y, M, $) {
      var O = this.byteLength(), J = $ || Math.max(1, O);
      g(O <= J, "byte array longer than desired length"), g(J > 0, "Requested array length <= 0"), this.strip();
      var Z = M === "le", K = new Y(J), z, G, D = this.clone();
      if (Z) {
        for (G = 0; !D.isZero(); G++)
          z = D.andln(255), D.iushrn(8), K[G] = z;
        for (; G < J; G++)
          K[G] = 0;
      } else {
        for (G = 0; G < J - O; G++)
          K[G] = 0;
        for (G = 0; !D.isZero(); G++)
          z = D.andln(255), D.iushrn(8), K[J - G - 1] = z;
      }
      return K;
    }, Math.clz32 ? h.prototype._countBits = function(Y) {
      return 32 - Math.clz32(Y);
    } : h.prototype._countBits = function(Y) {
      var M = Y, $ = 0;
      return M >= 4096 && ($ += 13, M >>>= 13), M >= 64 && ($ += 7, M >>>= 7), M >= 8 && ($ += 4, M >>>= 4), M >= 2 && ($ += 2, M >>>= 2), $ + M;
    }, h.prototype._zeroBits = function(Y) {
      if (Y === 0)
        return 26;
      var M = Y, $ = 0;
      return M & 8191 || ($ += 13, M >>>= 13), M & 127 || ($ += 7, M >>>= 7), M & 15 || ($ += 4, M >>>= 4), M & 3 || ($ += 2, M >>>= 2), M & 1 || $++, $;
    }, h.prototype.bitLength = function() {
      var Y = this.words[this.length - 1], M = this._countBits(Y);
      return (this.length - 1) * 26 + M;
    };
    function X(ne) {
      for (var Y = new Array(ne.bitLength()), M = 0; M < Y.length; M++) {
        var $ = M / 26 | 0, O = M % 26;
        Y[M] = (ne.words[$] & 1 << O) >>> O;
      }
      return Y;
    }
    h.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var Y = 0, M = 0; M < this.length; M++) {
        var $ = this._zeroBits(this.words[M]);
        if (Y += $, $ !== 26)
          break;
      }
      return Y;
    }, h.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, h.prototype.toTwos = function(Y) {
      return this.negative !== 0 ? this.abs().inotn(Y).iaddn(1) : this.clone();
    }, h.prototype.fromTwos = function(Y) {
      return this.testn(Y - 1) ? this.notn(Y).iaddn(1).ineg() : this.clone();
    }, h.prototype.isNeg = function() {
      return this.negative !== 0;
    }, h.prototype.neg = function() {
      return this.clone().ineg();
    }, h.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, h.prototype.iuor = function(Y) {
      for (; this.length < Y.length; )
        this.words[this.length++] = 0;
      for (var M = 0; M < Y.length; M++)
        this.words[M] = this.words[M] | Y.words[M];
      return this.strip();
    }, h.prototype.ior = function(Y) {
      return g((this.negative | Y.negative) === 0), this.iuor(Y);
    }, h.prototype.or = function(Y) {
      return this.length > Y.length ? this.clone().ior(Y) : Y.clone().ior(this);
    }, h.prototype.uor = function(Y) {
      return this.length > Y.length ? this.clone().iuor(Y) : Y.clone().iuor(this);
    }, h.prototype.iuand = function(Y) {
      var M;
      this.length > Y.length ? M = Y : M = this;
      for (var $ = 0; $ < M.length; $++)
        this.words[$] = this.words[$] & Y.words[$];
      return this.length = M.length, this.strip();
    }, h.prototype.iand = function(Y) {
      return g((this.negative | Y.negative) === 0), this.iuand(Y);
    }, h.prototype.and = function(Y) {
      return this.length > Y.length ? this.clone().iand(Y) : Y.clone().iand(this);
    }, h.prototype.uand = function(Y) {
      return this.length > Y.length ? this.clone().iuand(Y) : Y.clone().iuand(this);
    }, h.prototype.iuxor = function(Y) {
      var M, $;
      this.length > Y.length ? (M = this, $ = Y) : (M = Y, $ = this);
      for (var O = 0; O < $.length; O++)
        this.words[O] = M.words[O] ^ $.words[O];
      if (this !== M)
        for (; O < M.length; O++)
          this.words[O] = M.words[O];
      return this.length = M.length, this.strip();
    }, h.prototype.ixor = function(Y) {
      return g((this.negative | Y.negative) === 0), this.iuxor(Y);
    }, h.prototype.xor = function(Y) {
      return this.length > Y.length ? this.clone().ixor(Y) : Y.clone().ixor(this);
    }, h.prototype.uxor = function(Y) {
      return this.length > Y.length ? this.clone().iuxor(Y) : Y.clone().iuxor(this);
    }, h.prototype.inotn = function(Y) {
      g(typeof Y == "number" && Y >= 0);
      var M = Math.ceil(Y / 26) | 0, $ = Y % 26;
      this._expand(M), $ > 0 && M--;
      for (var O = 0; O < M; O++)
        this.words[O] = ~this.words[O] & 67108863;
      return $ > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - $), this.strip();
    }, h.prototype.notn = function(Y) {
      return this.clone().inotn(Y);
    }, h.prototype.setn = function(Y, M) {
      g(typeof Y == "number" && Y >= 0);
      var $ = Y / 26 | 0, O = Y % 26;
      return this._expand($ + 1), M ? this.words[$] = this.words[$] | 1 << O : this.words[$] = this.words[$] & ~(1 << O), this.strip();
    }, h.prototype.iadd = function(Y) {
      var M;
      if (this.negative !== 0 && Y.negative === 0)
        return this.negative = 0, M = this.isub(Y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Y.negative !== 0)
        return Y.negative = 0, M = this.isub(Y), Y.negative = 1, M._normSign();
      var $, O;
      this.length > Y.length ? ($ = this, O = Y) : ($ = Y, O = this);
      for (var J = 0, Z = 0; Z < O.length; Z++)
        M = ($.words[Z] | 0) + (O.words[Z] | 0) + J, this.words[Z] = M & 67108863, J = M >>> 26;
      for (; J !== 0 && Z < $.length; Z++)
        M = ($.words[Z] | 0) + J, this.words[Z] = M & 67108863, J = M >>> 26;
      if (this.length = $.length, J !== 0)
        this.words[this.length] = J, this.length++;
      else if ($ !== this)
        for (; Z < $.length; Z++)
          this.words[Z] = $.words[Z];
      return this;
    }, h.prototype.add = function(Y) {
      var M;
      return Y.negative !== 0 && this.negative === 0 ? (Y.negative = 0, M = this.sub(Y), Y.negative ^= 1, M) : Y.negative === 0 && this.negative !== 0 ? (this.negative = 0, M = Y.sub(this), this.negative = 1, M) : this.length > Y.length ? this.clone().iadd(Y) : Y.clone().iadd(this);
    }, h.prototype.isub = function(Y) {
      if (Y.negative !== 0) {
        Y.negative = 0;
        var M = this.iadd(Y);
        return Y.negative = 1, M._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Y), this.negative = 1, this._normSign();
      var $ = this.cmp(Y);
      if ($ === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var O, J;
      $ > 0 ? (O = this, J = Y) : (O = Y, J = this);
      for (var Z = 0, K = 0; K < J.length; K++)
        M = (O.words[K] | 0) - (J.words[K] | 0) + Z, Z = M >> 26, this.words[K] = M & 67108863;
      for (; Z !== 0 && K < O.length; K++)
        M = (O.words[K] | 0) + Z, Z = M >> 26, this.words[K] = M & 67108863;
      if (Z === 0 && K < O.length && O !== this)
        for (; K < O.length; K++)
          this.words[K] = O.words[K];
      return this.length = Math.max(this.length, K), O !== this && (this.negative = 1), this.strip();
    }, h.prototype.sub = function(Y) {
      return this.clone().isub(Y);
    };
    function Q(ne, Y, M) {
      M.negative = Y.negative ^ ne.negative;
      var $ = ne.length + Y.length | 0;
      M.length = $, $ = $ - 1 | 0;
      var O = ne.words[0] | 0, J = Y.words[0] | 0, Z = O * J, K = Z & 67108863, z = Z / 67108864 | 0;
      M.words[0] = K;
      for (var G = 1; G < $; G++) {
        for (var D = z >>> 26, F = z & 67108863, ae = Math.min(G, Y.length - 1), ge = Math.max(0, G - ne.length + 1); ge <= ae; ge++) {
          var xe = G - ge | 0;
          O = ne.words[xe] | 0, J = Y.words[ge] | 0, Z = O * J + F, D += Z / 67108864 | 0, F = Z & 67108863;
        }
        M.words[G] = F | 0, z = D | 0;
      }
      return z !== 0 ? M.words[G] = z | 0 : M.length--, M.strip();
    }
    var ee = function(Y, M, $) {
      var O = Y.words, J = M.words, Z = $.words, K = 0, z, G, D, F = O[0] | 0, ae = F & 8191, ge = F >>> 13, xe = O[1] | 0, ye = xe & 8191, oe = xe >>> 13, fe = O[2] | 0, $e = fe & 8191, Be = fe >>> 13, be = O[3] | 0, ve = be & 8191, qe = be >>> 13, De = O[4] | 0, Ye = De & 8191, he = De >>> 13, ue = O[5] | 0, de = ue & 8191, _e = ue >>> 13, Pe = O[6] | 0, He = Pe & 8191, Ve = Pe >>> 13, nt = O[7] | 0, Ie = nt & 8191, Fe = nt >>> 13, je = O[8] | 0, Ke = je & 8191, ot = je >>> 13, ut = O[9] | 0, pt = ut & 8191, ke = ut >>> 13, Xe = J[0] | 0, at = Xe & 8191, ht = Xe >>> 13, We = J[1] | 0, tt = We & 8191, Te = We >>> 13, rt = J[2] | 0, mt = rt & 8191, Se = rt >>> 13, et = J[3] | 0, Ze = et & 8191, Le = et >>> 13, ze = J[4] | 0, Qe = ze & 8191, _t = ze >>> 13, ft = J[5] | 0, dt = ft & 8191, Mt = ft >>> 13, St = J[6] | 0, $t = St & 8191, At = St >>> 13, Ae = J[7] | 0, Ce = Ae & 8191, Oe = Ae >>> 13, we = J[8] | 0, Ue = we & 8191, Je = we >>> 13, Ge = J[9] | 0, st = Ge & 8191, ct = Ge >>> 13;
      $.negative = Y.negative ^ M.negative, $.length = 19, z = Math.imul(ae, at), G = Math.imul(ae, ht), G = G + Math.imul(ge, at) | 0, D = Math.imul(ge, ht);
      var bt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, z = Math.imul(ye, at), G = Math.imul(ye, ht), G = G + Math.imul(oe, at) | 0, D = Math.imul(oe, ht), z = z + Math.imul(ae, tt) | 0, G = G + Math.imul(ae, Te) | 0, G = G + Math.imul(ge, tt) | 0, D = D + Math.imul(ge, Te) | 0;
      var wt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, z = Math.imul($e, at), G = Math.imul($e, ht), G = G + Math.imul(Be, at) | 0, D = Math.imul(Be, ht), z = z + Math.imul(ye, tt) | 0, G = G + Math.imul(ye, Te) | 0, G = G + Math.imul(oe, tt) | 0, D = D + Math.imul(oe, Te) | 0, z = z + Math.imul(ae, mt) | 0, G = G + Math.imul(ae, Se) | 0, G = G + Math.imul(ge, mt) | 0, D = D + Math.imul(ge, Se) | 0;
      var zt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, z = Math.imul(ve, at), G = Math.imul(ve, ht), G = G + Math.imul(qe, at) | 0, D = Math.imul(qe, ht), z = z + Math.imul($e, tt) | 0, G = G + Math.imul($e, Te) | 0, G = G + Math.imul(Be, tt) | 0, D = D + Math.imul(Be, Te) | 0, z = z + Math.imul(ye, mt) | 0, G = G + Math.imul(ye, Se) | 0, G = G + Math.imul(oe, mt) | 0, D = D + Math.imul(oe, Se) | 0, z = z + Math.imul(ae, Ze) | 0, G = G + Math.imul(ae, Le) | 0, G = G + Math.imul(ge, Ze) | 0, D = D + Math.imul(ge, Le) | 0;
      var Tt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, z = Math.imul(Ye, at), G = Math.imul(Ye, ht), G = G + Math.imul(he, at) | 0, D = Math.imul(he, ht), z = z + Math.imul(ve, tt) | 0, G = G + Math.imul(ve, Te) | 0, G = G + Math.imul(qe, tt) | 0, D = D + Math.imul(qe, Te) | 0, z = z + Math.imul($e, mt) | 0, G = G + Math.imul($e, Se) | 0, G = G + Math.imul(Be, mt) | 0, D = D + Math.imul(Be, Se) | 0, z = z + Math.imul(ye, Ze) | 0, G = G + Math.imul(ye, Le) | 0, G = G + Math.imul(oe, Ze) | 0, D = D + Math.imul(oe, Le) | 0, z = z + Math.imul(ae, Qe) | 0, G = G + Math.imul(ae, _t) | 0, G = G + Math.imul(ge, Qe) | 0, D = D + Math.imul(ge, _t) | 0;
      var Lt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, z = Math.imul(de, at), G = Math.imul(de, ht), G = G + Math.imul(_e, at) | 0, D = Math.imul(_e, ht), z = z + Math.imul(Ye, tt) | 0, G = G + Math.imul(Ye, Te) | 0, G = G + Math.imul(he, tt) | 0, D = D + Math.imul(he, Te) | 0, z = z + Math.imul(ve, mt) | 0, G = G + Math.imul(ve, Se) | 0, G = G + Math.imul(qe, mt) | 0, D = D + Math.imul(qe, Se) | 0, z = z + Math.imul($e, Ze) | 0, G = G + Math.imul($e, Le) | 0, G = G + Math.imul(Be, Ze) | 0, D = D + Math.imul(Be, Le) | 0, z = z + Math.imul(ye, Qe) | 0, G = G + Math.imul(ye, _t) | 0, G = G + Math.imul(oe, Qe) | 0, D = D + Math.imul(oe, _t) | 0, z = z + Math.imul(ae, dt) | 0, G = G + Math.imul(ae, Mt) | 0, G = G + Math.imul(ge, dt) | 0, D = D + Math.imul(ge, Mt) | 0;
      var jt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, z = Math.imul(He, at), G = Math.imul(He, ht), G = G + Math.imul(Ve, at) | 0, D = Math.imul(Ve, ht), z = z + Math.imul(de, tt) | 0, G = G + Math.imul(de, Te) | 0, G = G + Math.imul(_e, tt) | 0, D = D + Math.imul(_e, Te) | 0, z = z + Math.imul(Ye, mt) | 0, G = G + Math.imul(Ye, Se) | 0, G = G + Math.imul(he, mt) | 0, D = D + Math.imul(he, Se) | 0, z = z + Math.imul(ve, Ze) | 0, G = G + Math.imul(ve, Le) | 0, G = G + Math.imul(qe, Ze) | 0, D = D + Math.imul(qe, Le) | 0, z = z + Math.imul($e, Qe) | 0, G = G + Math.imul($e, _t) | 0, G = G + Math.imul(Be, Qe) | 0, D = D + Math.imul(Be, _t) | 0, z = z + Math.imul(ye, dt) | 0, G = G + Math.imul(ye, Mt) | 0, G = G + Math.imul(oe, dt) | 0, D = D + Math.imul(oe, Mt) | 0, z = z + Math.imul(ae, $t) | 0, G = G + Math.imul(ae, At) | 0, G = G + Math.imul(ge, $t) | 0, D = D + Math.imul(ge, At) | 0;
      var Ht = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, z = Math.imul(Ie, at), G = Math.imul(Ie, ht), G = G + Math.imul(Fe, at) | 0, D = Math.imul(Fe, ht), z = z + Math.imul(He, tt) | 0, G = G + Math.imul(He, Te) | 0, G = G + Math.imul(Ve, tt) | 0, D = D + Math.imul(Ve, Te) | 0, z = z + Math.imul(de, mt) | 0, G = G + Math.imul(de, Se) | 0, G = G + Math.imul(_e, mt) | 0, D = D + Math.imul(_e, Se) | 0, z = z + Math.imul(Ye, Ze) | 0, G = G + Math.imul(Ye, Le) | 0, G = G + Math.imul(he, Ze) | 0, D = D + Math.imul(he, Le) | 0, z = z + Math.imul(ve, Qe) | 0, G = G + Math.imul(ve, _t) | 0, G = G + Math.imul(qe, Qe) | 0, D = D + Math.imul(qe, _t) | 0, z = z + Math.imul($e, dt) | 0, G = G + Math.imul($e, Mt) | 0, G = G + Math.imul(Be, dt) | 0, D = D + Math.imul(Be, Mt) | 0, z = z + Math.imul(ye, $t) | 0, G = G + Math.imul(ye, At) | 0, G = G + Math.imul(oe, $t) | 0, D = D + Math.imul(oe, At) | 0, z = z + Math.imul(ae, Ce) | 0, G = G + Math.imul(ae, Oe) | 0, G = G + Math.imul(ge, Ce) | 0, D = D + Math.imul(ge, Oe) | 0;
      var Ft = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, z = Math.imul(Ke, at), G = Math.imul(Ke, ht), G = G + Math.imul(ot, at) | 0, D = Math.imul(ot, ht), z = z + Math.imul(Ie, tt) | 0, G = G + Math.imul(Ie, Te) | 0, G = G + Math.imul(Fe, tt) | 0, D = D + Math.imul(Fe, Te) | 0, z = z + Math.imul(He, mt) | 0, G = G + Math.imul(He, Se) | 0, G = G + Math.imul(Ve, mt) | 0, D = D + Math.imul(Ve, Se) | 0, z = z + Math.imul(de, Ze) | 0, G = G + Math.imul(de, Le) | 0, G = G + Math.imul(_e, Ze) | 0, D = D + Math.imul(_e, Le) | 0, z = z + Math.imul(Ye, Qe) | 0, G = G + Math.imul(Ye, _t) | 0, G = G + Math.imul(he, Qe) | 0, D = D + Math.imul(he, _t) | 0, z = z + Math.imul(ve, dt) | 0, G = G + Math.imul(ve, Mt) | 0, G = G + Math.imul(qe, dt) | 0, D = D + Math.imul(qe, Mt) | 0, z = z + Math.imul($e, $t) | 0, G = G + Math.imul($e, At) | 0, G = G + Math.imul(Be, $t) | 0, D = D + Math.imul(Be, At) | 0, z = z + Math.imul(ye, Ce) | 0, G = G + Math.imul(ye, Oe) | 0, G = G + Math.imul(oe, Ce) | 0, D = D + Math.imul(oe, Oe) | 0, z = z + Math.imul(ae, Ue) | 0, G = G + Math.imul(ae, Je) | 0, G = G + Math.imul(ge, Ue) | 0, D = D + Math.imul(ge, Je) | 0;
      var Nt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, z = Math.imul(pt, at), G = Math.imul(pt, ht), G = G + Math.imul(ke, at) | 0, D = Math.imul(ke, ht), z = z + Math.imul(Ke, tt) | 0, G = G + Math.imul(Ke, Te) | 0, G = G + Math.imul(ot, tt) | 0, D = D + Math.imul(ot, Te) | 0, z = z + Math.imul(Ie, mt) | 0, G = G + Math.imul(Ie, Se) | 0, G = G + Math.imul(Fe, mt) | 0, D = D + Math.imul(Fe, Se) | 0, z = z + Math.imul(He, Ze) | 0, G = G + Math.imul(He, Le) | 0, G = G + Math.imul(Ve, Ze) | 0, D = D + Math.imul(Ve, Le) | 0, z = z + Math.imul(de, Qe) | 0, G = G + Math.imul(de, _t) | 0, G = G + Math.imul(_e, Qe) | 0, D = D + Math.imul(_e, _t) | 0, z = z + Math.imul(Ye, dt) | 0, G = G + Math.imul(Ye, Mt) | 0, G = G + Math.imul(he, dt) | 0, D = D + Math.imul(he, Mt) | 0, z = z + Math.imul(ve, $t) | 0, G = G + Math.imul(ve, At) | 0, G = G + Math.imul(qe, $t) | 0, D = D + Math.imul(qe, At) | 0, z = z + Math.imul($e, Ce) | 0, G = G + Math.imul($e, Oe) | 0, G = G + Math.imul(Be, Ce) | 0, D = D + Math.imul(Be, Oe) | 0, z = z + Math.imul(ye, Ue) | 0, G = G + Math.imul(ye, Je) | 0, G = G + Math.imul(oe, Ue) | 0, D = D + Math.imul(oe, Je) | 0, z = z + Math.imul(ae, st) | 0, G = G + Math.imul(ae, ct) | 0, G = G + Math.imul(ge, st) | 0, D = D + Math.imul(ge, ct) | 0;
      var Dt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, z = Math.imul(pt, tt), G = Math.imul(pt, Te), G = G + Math.imul(ke, tt) | 0, D = Math.imul(ke, Te), z = z + Math.imul(Ke, mt) | 0, G = G + Math.imul(Ke, Se) | 0, G = G + Math.imul(ot, mt) | 0, D = D + Math.imul(ot, Se) | 0, z = z + Math.imul(Ie, Ze) | 0, G = G + Math.imul(Ie, Le) | 0, G = G + Math.imul(Fe, Ze) | 0, D = D + Math.imul(Fe, Le) | 0, z = z + Math.imul(He, Qe) | 0, G = G + Math.imul(He, _t) | 0, G = G + Math.imul(Ve, Qe) | 0, D = D + Math.imul(Ve, _t) | 0, z = z + Math.imul(de, dt) | 0, G = G + Math.imul(de, Mt) | 0, G = G + Math.imul(_e, dt) | 0, D = D + Math.imul(_e, Mt) | 0, z = z + Math.imul(Ye, $t) | 0, G = G + Math.imul(Ye, At) | 0, G = G + Math.imul(he, $t) | 0, D = D + Math.imul(he, At) | 0, z = z + Math.imul(ve, Ce) | 0, G = G + Math.imul(ve, Oe) | 0, G = G + Math.imul(qe, Ce) | 0, D = D + Math.imul(qe, Oe) | 0, z = z + Math.imul($e, Ue) | 0, G = G + Math.imul($e, Je) | 0, G = G + Math.imul(Be, Ue) | 0, D = D + Math.imul(Be, Je) | 0, z = z + Math.imul(ye, st) | 0, G = G + Math.imul(ye, ct) | 0, G = G + Math.imul(oe, st) | 0, D = D + Math.imul(oe, ct) | 0;
      var Ut = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, z = Math.imul(pt, mt), G = Math.imul(pt, Se), G = G + Math.imul(ke, mt) | 0, D = Math.imul(ke, Se), z = z + Math.imul(Ke, Ze) | 0, G = G + Math.imul(Ke, Le) | 0, G = G + Math.imul(ot, Ze) | 0, D = D + Math.imul(ot, Le) | 0, z = z + Math.imul(Ie, Qe) | 0, G = G + Math.imul(Ie, _t) | 0, G = G + Math.imul(Fe, Qe) | 0, D = D + Math.imul(Fe, _t) | 0, z = z + Math.imul(He, dt) | 0, G = G + Math.imul(He, Mt) | 0, G = G + Math.imul(Ve, dt) | 0, D = D + Math.imul(Ve, Mt) | 0, z = z + Math.imul(de, $t) | 0, G = G + Math.imul(de, At) | 0, G = G + Math.imul(_e, $t) | 0, D = D + Math.imul(_e, At) | 0, z = z + Math.imul(Ye, Ce) | 0, G = G + Math.imul(Ye, Oe) | 0, G = G + Math.imul(he, Ce) | 0, D = D + Math.imul(he, Oe) | 0, z = z + Math.imul(ve, Ue) | 0, G = G + Math.imul(ve, Je) | 0, G = G + Math.imul(qe, Ue) | 0, D = D + Math.imul(qe, Je) | 0, z = z + Math.imul($e, st) | 0, G = G + Math.imul($e, ct) | 0, G = G + Math.imul(Be, st) | 0, D = D + Math.imul(Be, ct) | 0;
      var kt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, z = Math.imul(pt, Ze), G = Math.imul(pt, Le), G = G + Math.imul(ke, Ze) | 0, D = Math.imul(ke, Le), z = z + Math.imul(Ke, Qe) | 0, G = G + Math.imul(Ke, _t) | 0, G = G + Math.imul(ot, Qe) | 0, D = D + Math.imul(ot, _t) | 0, z = z + Math.imul(Ie, dt) | 0, G = G + Math.imul(Ie, Mt) | 0, G = G + Math.imul(Fe, dt) | 0, D = D + Math.imul(Fe, Mt) | 0, z = z + Math.imul(He, $t) | 0, G = G + Math.imul(He, At) | 0, G = G + Math.imul(Ve, $t) | 0, D = D + Math.imul(Ve, At) | 0, z = z + Math.imul(de, Ce) | 0, G = G + Math.imul(de, Oe) | 0, G = G + Math.imul(_e, Ce) | 0, D = D + Math.imul(_e, Oe) | 0, z = z + Math.imul(Ye, Ue) | 0, G = G + Math.imul(Ye, Je) | 0, G = G + Math.imul(he, Ue) | 0, D = D + Math.imul(he, Je) | 0, z = z + Math.imul(ve, st) | 0, G = G + Math.imul(ve, ct) | 0, G = G + Math.imul(qe, st) | 0, D = D + Math.imul(qe, ct) | 0;
      var Ot = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, z = Math.imul(pt, Qe), G = Math.imul(pt, _t), G = G + Math.imul(ke, Qe) | 0, D = Math.imul(ke, _t), z = z + Math.imul(Ke, dt) | 0, G = G + Math.imul(Ke, Mt) | 0, G = G + Math.imul(ot, dt) | 0, D = D + Math.imul(ot, Mt) | 0, z = z + Math.imul(Ie, $t) | 0, G = G + Math.imul(Ie, At) | 0, G = G + Math.imul(Fe, $t) | 0, D = D + Math.imul(Fe, At) | 0, z = z + Math.imul(He, Ce) | 0, G = G + Math.imul(He, Oe) | 0, G = G + Math.imul(Ve, Ce) | 0, D = D + Math.imul(Ve, Oe) | 0, z = z + Math.imul(de, Ue) | 0, G = G + Math.imul(de, Je) | 0, G = G + Math.imul(_e, Ue) | 0, D = D + Math.imul(_e, Je) | 0, z = z + Math.imul(Ye, st) | 0, G = G + Math.imul(Ye, ct) | 0, G = G + Math.imul(he, st) | 0, D = D + Math.imul(he, ct) | 0;
      var It = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, z = Math.imul(pt, dt), G = Math.imul(pt, Mt), G = G + Math.imul(ke, dt) | 0, D = Math.imul(ke, Mt), z = z + Math.imul(Ke, $t) | 0, G = G + Math.imul(Ke, At) | 0, G = G + Math.imul(ot, $t) | 0, D = D + Math.imul(ot, At) | 0, z = z + Math.imul(Ie, Ce) | 0, G = G + Math.imul(Ie, Oe) | 0, G = G + Math.imul(Fe, Ce) | 0, D = D + Math.imul(Fe, Oe) | 0, z = z + Math.imul(He, Ue) | 0, G = G + Math.imul(He, Je) | 0, G = G + Math.imul(Ve, Ue) | 0, D = D + Math.imul(Ve, Je) | 0, z = z + Math.imul(de, st) | 0, G = G + Math.imul(de, ct) | 0, G = G + Math.imul(_e, st) | 0, D = D + Math.imul(_e, ct) | 0;
      var Pt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, z = Math.imul(pt, $t), G = Math.imul(pt, At), G = G + Math.imul(ke, $t) | 0, D = Math.imul(ke, At), z = z + Math.imul(Ke, Ce) | 0, G = G + Math.imul(Ke, Oe) | 0, G = G + Math.imul(ot, Ce) | 0, D = D + Math.imul(ot, Oe) | 0, z = z + Math.imul(Ie, Ue) | 0, G = G + Math.imul(Ie, Je) | 0, G = G + Math.imul(Fe, Ue) | 0, D = D + Math.imul(Fe, Je) | 0, z = z + Math.imul(He, st) | 0, G = G + Math.imul(He, ct) | 0, G = G + Math.imul(Ve, st) | 0, D = D + Math.imul(Ve, ct) | 0;
      var Ct = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, z = Math.imul(pt, Ce), G = Math.imul(pt, Oe), G = G + Math.imul(ke, Ce) | 0, D = Math.imul(ke, Oe), z = z + Math.imul(Ke, Ue) | 0, G = G + Math.imul(Ke, Je) | 0, G = G + Math.imul(ot, Ue) | 0, D = D + Math.imul(ot, Je) | 0, z = z + Math.imul(Ie, st) | 0, G = G + Math.imul(Ie, ct) | 0, G = G + Math.imul(Fe, st) | 0, D = D + Math.imul(Fe, ct) | 0;
      var Bt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, z = Math.imul(pt, Ue), G = Math.imul(pt, Je), G = G + Math.imul(ke, Ue) | 0, D = Math.imul(ke, Je), z = z + Math.imul(Ke, st) | 0, G = G + Math.imul(Ke, ct) | 0, G = G + Math.imul(ot, st) | 0, D = D + Math.imul(ot, ct) | 0;
      var vt = (K + z | 0) + ((G & 8191) << 13) | 0;
      K = (D + (G >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, z = Math.imul(pt, st), G = Math.imul(pt, ct), G = G + Math.imul(ke, st) | 0, D = Math.imul(ke, ct);
      var yt = (K + z | 0) + ((G & 8191) << 13) | 0;
      return K = (D + (G >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, Z[0] = bt, Z[1] = wt, Z[2] = zt, Z[3] = Tt, Z[4] = Lt, Z[5] = jt, Z[6] = Ht, Z[7] = Ft, Z[8] = Nt, Z[9] = Dt, Z[10] = Ut, Z[11] = kt, Z[12] = Ot, Z[13] = It, Z[14] = Pt, Z[15] = Ct, Z[16] = Bt, Z[17] = vt, Z[18] = yt, K !== 0 && (Z[19] = K, $.length++), $;
    };
    Math.imul || (ee = Q);
    function ie(ne, Y, M) {
      M.negative = Y.negative ^ ne.negative, M.length = ne.length + Y.length;
      for (var $ = 0, O = 0, J = 0; J < M.length - 1; J++) {
        var Z = O;
        O = 0;
        for (var K = $ & 67108863, z = Math.min(J, Y.length - 1), G = Math.max(0, J - ne.length + 1); G <= z; G++) {
          var D = J - G, F = ne.words[D] | 0, ae = Y.words[G] | 0, ge = F * ae, xe = ge & 67108863;
          Z = Z + (ge / 67108864 | 0) | 0, xe = xe + K | 0, K = xe & 67108863, Z = Z + (xe >>> 26) | 0, O += Z >>> 26, Z &= 67108863;
        }
        M.words[J] = K, $ = Z, Z = O;
      }
      return $ !== 0 ? M.words[J] = $ : M.length--, M.strip();
    }
    function te(ne, Y, M) {
      var $ = new se();
      return $.mulp(ne, Y, M);
    }
    h.prototype.mulTo = function(Y, M) {
      var $, O = this.length + Y.length;
      return this.length === 10 && Y.length === 10 ? $ = ee(this, Y, M) : O < 63 ? $ = Q(this, Y, M) : O < 1024 ? $ = ie(this, Y, M) : $ = te(this, Y, M), $;
    };
    function se(ne, Y) {
      this.x = ne, this.y = Y;
    }
    se.prototype.makeRBT = function(Y) {
      for (var M = new Array(Y), $ = h.prototype._countBits(Y) - 1, O = 0; O < Y; O++)
        M[O] = this.revBin(O, $, Y);
      return M;
    }, se.prototype.revBin = function(Y, M, $) {
      if (Y === 0 || Y === $ - 1)
        return Y;
      for (var O = 0, J = 0; J < M; J++)
        O |= (Y & 1) << M - J - 1, Y >>= 1;
      return O;
    }, se.prototype.permute = function(Y, M, $, O, J, Z) {
      for (var K = 0; K < Z; K++)
        O[K] = M[Y[K]], J[K] = $[Y[K]];
    }, se.prototype.transform = function(Y, M, $, O, J, Z) {
      this.permute(Z, Y, M, $, O, J);
      for (var K = 1; K < J; K <<= 1)
        for (var z = K << 1, G = Math.cos(2 * Math.PI / z), D = Math.sin(2 * Math.PI / z), F = 0; F < J; F += z)
          for (var ae = G, ge = D, xe = 0; xe < K; xe++) {
            var ye = $[F + xe], oe = O[F + xe], fe = $[F + xe + K], $e = O[F + xe + K], Be = ae * fe - ge * $e;
            $e = ae * $e + ge * fe, fe = Be, $[F + xe] = ye + fe, O[F + xe] = oe + $e, $[F + xe + K] = ye - fe, O[F + xe + K] = oe - $e, xe !== z && (Be = G * ae - D * ge, ge = G * ge + D * ae, ae = Be);
          }
    }, se.prototype.guessLen13b = function(Y, M) {
      var $ = Math.max(M, Y) | 1, O = $ & 1, J = 0;
      for ($ = $ / 2 | 0; $; $ = $ >>> 1)
        J++;
      return 1 << J + 1 + O;
    }, se.prototype.conjugate = function(Y, M, $) {
      if (!($ <= 1))
        for (var O = 0; O < $ / 2; O++) {
          var J = Y[O];
          Y[O] = Y[$ - O - 1], Y[$ - O - 1] = J, J = M[O], M[O] = -M[$ - O - 1], M[$ - O - 1] = -J;
        }
    }, se.prototype.normalize13b = function(Y, M) {
      for (var $ = 0, O = 0; O < M / 2; O++) {
        var J = Math.round(Y[2 * O + 1] / M) * 8192 + Math.round(Y[2 * O] / M) + $;
        Y[O] = J & 67108863, J < 67108864 ? $ = 0 : $ = J / 67108864 | 0;
      }
      return Y;
    }, se.prototype.convert13b = function(Y, M, $, O) {
      for (var J = 0, Z = 0; Z < M; Z++)
        J = J + (Y[Z] | 0), $[2 * Z] = J & 8191, J = J >>> 13, $[2 * Z + 1] = J & 8191, J = J >>> 13;
      for (Z = 2 * M; Z < O; ++Z)
        $[Z] = 0;
      g(J === 0), g((J & -8192) === 0);
    }, se.prototype.stub = function(Y) {
      for (var M = new Array(Y), $ = 0; $ < Y; $++)
        M[$] = 0;
      return M;
    }, se.prototype.mulp = function(Y, M, $) {
      var O = 2 * this.guessLen13b(Y.length, M.length), J = this.makeRBT(O), Z = this.stub(O), K = new Array(O), z = new Array(O), G = new Array(O), D = new Array(O), F = new Array(O), ae = new Array(O), ge = $.words;
      ge.length = O, this.convert13b(Y.words, Y.length, K, O), this.convert13b(M.words, M.length, D, O), this.transform(K, Z, z, G, O, J), this.transform(D, Z, F, ae, O, J);
      for (var xe = 0; xe < O; xe++) {
        var ye = z[xe] * F[xe] - G[xe] * ae[xe];
        G[xe] = z[xe] * ae[xe] + G[xe] * F[xe], z[xe] = ye;
      }
      return this.conjugate(z, G, O), this.transform(z, G, ge, Z, O, J), this.conjugate(ge, Z, O), this.normalize13b(ge, O), $.negative = Y.negative ^ M.negative, $.length = Y.length + M.length, $.strip();
    }, h.prototype.mul = function(Y) {
      var M = new h(null);
      return M.words = new Array(this.length + Y.length), this.mulTo(Y, M);
    }, h.prototype.mulf = function(Y) {
      var M = new h(null);
      return M.words = new Array(this.length + Y.length), te(this, Y, M);
    }, h.prototype.imul = function(Y) {
      return this.clone().mulTo(Y, this);
    }, h.prototype.imuln = function(Y) {
      g(typeof Y == "number"), g(Y < 67108864);
      for (var M = 0, $ = 0; $ < this.length; $++) {
        var O = (this.words[$] | 0) * Y, J = (O & 67108863) + (M & 67108863);
        M >>= 26, M += O / 67108864 | 0, M += J >>> 26, this.words[$] = J & 67108863;
      }
      return M !== 0 && (this.words[$] = M, this.length++), this;
    }, h.prototype.muln = function(Y) {
      return this.clone().imuln(Y);
    }, h.prototype.sqr = function() {
      return this.mul(this);
    }, h.prototype.isqr = function() {
      return this.imul(this.clone());
    }, h.prototype.pow = function(Y) {
      var M = X(Y);
      if (M.length === 0)
        return new h(1);
      for (var $ = this, O = 0; O < M.length && M[O] === 0; O++, $ = $.sqr())
        ;
      if (++O < M.length)
        for (var J = $.sqr(); O < M.length; O++, J = J.sqr())
          M[O] !== 0 && ($ = $.mul(J));
      return $;
    }, h.prototype.iushln = function(Y) {
      g(typeof Y == "number" && Y >= 0);
      var M = Y % 26, $ = (Y - M) / 26, O = 67108863 >>> 26 - M << 26 - M, J;
      if (M !== 0) {
        var Z = 0;
        for (J = 0; J < this.length; J++) {
          var K = this.words[J] & O, z = (this.words[J] | 0) - K << M;
          this.words[J] = z | Z, Z = K >>> 26 - M;
        }
        Z && (this.words[J] = Z, this.length++);
      }
      if ($ !== 0) {
        for (J = this.length - 1; J >= 0; J--)
          this.words[J + $] = this.words[J];
        for (J = 0; J < $; J++)
          this.words[J] = 0;
        this.length += $;
      }
      return this.strip();
    }, h.prototype.ishln = function(Y) {
      return g(this.negative === 0), this.iushln(Y);
    }, h.prototype.iushrn = function(Y, M, $) {
      g(typeof Y == "number" && Y >= 0);
      var O;
      M ? O = (M - M % 26) / 26 : O = 0;
      var J = Y % 26, Z = Math.min((Y - J) / 26, this.length), K = 67108863 ^ 67108863 >>> J << J, z = $;
      if (O -= Z, O = Math.max(0, O), z) {
        for (var G = 0; G < Z; G++)
          z.words[G] = this.words[G];
        z.length = Z;
      }
      if (Z !== 0)
        if (this.length > Z)
          for (this.length -= Z, G = 0; G < this.length; G++)
            this.words[G] = this.words[G + Z];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (G = this.length - 1; G >= 0 && (D !== 0 || G >= O); G--) {
        var F = this.words[G] | 0;
        this.words[G] = D << 26 - J | F >>> J, D = F & K;
      }
      return z && D !== 0 && (z.words[z.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, h.prototype.ishrn = function(Y, M, $) {
      return g(this.negative === 0), this.iushrn(Y, M, $);
    }, h.prototype.shln = function(Y) {
      return this.clone().ishln(Y);
    }, h.prototype.ushln = function(Y) {
      return this.clone().iushln(Y);
    }, h.prototype.shrn = function(Y) {
      return this.clone().ishrn(Y);
    }, h.prototype.ushrn = function(Y) {
      return this.clone().iushrn(Y);
    }, h.prototype.testn = function(Y) {
      g(typeof Y == "number" && Y >= 0);
      var M = Y % 26, $ = (Y - M) / 26, O = 1 << M;
      if (this.length <= $)
        return !1;
      var J = this.words[$];
      return !!(J & O);
    }, h.prototype.imaskn = function(Y) {
      g(typeof Y == "number" && Y >= 0);
      var M = Y % 26, $ = (Y - M) / 26;
      if (g(this.negative === 0, "imaskn works only with positive numbers"), this.length <= $)
        return this;
      if (M !== 0 && $++, this.length = Math.min($, this.length), M !== 0) {
        var O = 67108863 ^ 67108863 >>> M << M;
        this.words[this.length - 1] &= O;
      }
      return this.strip();
    }, h.prototype.maskn = function(Y) {
      return this.clone().imaskn(Y);
    }, h.prototype.iaddn = function(Y) {
      return g(typeof Y == "number"), g(Y < 67108864), Y < 0 ? this.isubn(-Y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Y ? (this.words[0] = Y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Y), this.negative = 1, this) : this._iaddn(Y);
    }, h.prototype._iaddn = function(Y) {
      this.words[0] += Y;
      for (var M = 0; M < this.length && this.words[M] >= 67108864; M++)
        this.words[M] -= 67108864, M === this.length - 1 ? this.words[M + 1] = 1 : this.words[M + 1]++;
      return this.length = Math.max(this.length, M + 1), this;
    }, h.prototype.isubn = function(Y) {
      if (g(typeof Y == "number"), g(Y < 67108864), Y < 0)
        return this.iaddn(-Y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Y), this.negative = 1, this;
      if (this.words[0] -= Y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var M = 0; M < this.length && this.words[M] < 0; M++)
          this.words[M] += 67108864, this.words[M + 1] -= 1;
      return this.strip();
    }, h.prototype.addn = function(Y) {
      return this.clone().iaddn(Y);
    }, h.prototype.subn = function(Y) {
      return this.clone().isubn(Y);
    }, h.prototype.iabs = function() {
      return this.negative = 0, this;
    }, h.prototype.abs = function() {
      return this.clone().iabs();
    }, h.prototype._ishlnsubmul = function(Y, M, $) {
      var O = Y.length + $, J;
      this._expand(O);
      var Z, K = 0;
      for (J = 0; J < Y.length; J++) {
        Z = (this.words[J + $] | 0) + K;
        var z = (Y.words[J] | 0) * M;
        Z -= z & 67108863, K = (Z >> 26) - (z / 67108864 | 0), this.words[J + $] = Z & 67108863;
      }
      for (; J < this.length - $; J++)
        Z = (this.words[J + $] | 0) + K, K = Z >> 26, this.words[J + $] = Z & 67108863;
      if (K === 0)
        return this.strip();
      for (g(K === -1), K = 0, J = 0; J < this.length; J++)
        Z = -(this.words[J] | 0) + K, K = Z >> 26, this.words[J] = Z & 67108863;
      return this.negative = 1, this.strip();
    }, h.prototype._wordDiv = function(Y, M) {
      var $ = this.length - Y.length, O = this.clone(), J = Y, Z = J.words[J.length - 1] | 0, K = this._countBits(Z);
      $ = 26 - K, $ !== 0 && (J = J.ushln($), O.iushln($), Z = J.words[J.length - 1] | 0);
      var z = O.length - J.length, G;
      if (M !== "mod") {
        G = new h(null), G.length = z + 1, G.words = new Array(G.length);
        for (var D = 0; D < G.length; D++)
          G.words[D] = 0;
      }
      var F = O.clone()._ishlnsubmul(J, 1, z);
      F.negative === 0 && (O = F, G && (G.words[z] = 1));
      for (var ae = z - 1; ae >= 0; ae--) {
        var ge = (O.words[J.length + ae] | 0) * 67108864 + (O.words[J.length + ae - 1] | 0);
        for (ge = Math.min(ge / Z | 0, 67108863), O._ishlnsubmul(J, ge, ae); O.negative !== 0; )
          ge--, O.negative = 0, O._ishlnsubmul(J, 1, ae), O.isZero() || (O.negative ^= 1);
        G && (G.words[ae] = ge);
      }
      return G && G.strip(), O.strip(), M !== "div" && $ !== 0 && O.iushrn($), {
        div: G || null,
        mod: O
      };
    }, h.prototype.divmod = function(Y, M, $) {
      if (g(!Y.isZero()), this.isZero())
        return {
          div: new h(0),
          mod: new h(0)
        };
      var O, J, Z;
      return this.negative !== 0 && Y.negative === 0 ? (Z = this.neg().divmod(Y, M), M !== "mod" && (O = Z.div.neg()), M !== "div" && (J = Z.mod.neg(), $ && J.negative !== 0 && J.iadd(Y)), {
        div: O,
        mod: J
      }) : this.negative === 0 && Y.negative !== 0 ? (Z = this.divmod(Y.neg(), M), M !== "mod" && (O = Z.div.neg()), {
        div: O,
        mod: Z.mod
      }) : this.negative & Y.negative ? (Z = this.neg().divmod(Y.neg(), M), M !== "div" && (J = Z.mod.neg(), $ && J.negative !== 0 && J.isub(Y)), {
        div: Z.div,
        mod: J
      }) : Y.length > this.length || this.cmp(Y) < 0 ? {
        div: new h(0),
        mod: this
      } : Y.length === 1 ? M === "div" ? {
        div: this.divn(Y.words[0]),
        mod: null
      } : M === "mod" ? {
        div: null,
        mod: new h(this.modn(Y.words[0]))
      } : {
        div: this.divn(Y.words[0]),
        mod: new h(this.modn(Y.words[0]))
      } : this._wordDiv(Y, M);
    }, h.prototype.div = function(Y) {
      return this.divmod(Y, "div", !1).div;
    }, h.prototype.mod = function(Y) {
      return this.divmod(Y, "mod", !1).mod;
    }, h.prototype.umod = function(Y) {
      return this.divmod(Y, "mod", !0).mod;
    }, h.prototype.divRound = function(Y) {
      var M = this.divmod(Y);
      if (M.mod.isZero())
        return M.div;
      var $ = M.div.negative !== 0 ? M.mod.isub(Y) : M.mod, O = Y.ushrn(1), J = Y.andln(1), Z = $.cmp(O);
      return Z < 0 || J === 1 && Z === 0 ? M.div : M.div.negative !== 0 ? M.div.isubn(1) : M.div.iaddn(1);
    }, h.prototype.modn = function(Y) {
      g(Y <= 67108863);
      for (var M = (1 << 26) % Y, $ = 0, O = this.length - 1; O >= 0; O--)
        $ = (M * $ + (this.words[O] | 0)) % Y;
      return $;
    }, h.prototype.idivn = function(Y) {
      g(Y <= 67108863);
      for (var M = 0, $ = this.length - 1; $ >= 0; $--) {
        var O = (this.words[$] | 0) + M * 67108864;
        this.words[$] = O / Y | 0, M = O % Y;
      }
      return this.strip();
    }, h.prototype.divn = function(Y) {
      return this.clone().idivn(Y);
    }, h.prototype.egcd = function(Y) {
      g(Y.negative === 0), g(!Y.isZero());
      var M = this, $ = Y.clone();
      M.negative !== 0 ? M = M.umod(Y) : M = M.clone();
      for (var O = new h(1), J = new h(0), Z = new h(0), K = new h(1), z = 0; M.isEven() && $.isEven(); )
        M.iushrn(1), $.iushrn(1), ++z;
      for (var G = $.clone(), D = M.clone(); !M.isZero(); ) {
        for (var F = 0, ae = 1; !(M.words[0] & ae) && F < 26; ++F, ae <<= 1)
          ;
        if (F > 0)
          for (M.iushrn(F); F-- > 0; )
            (O.isOdd() || J.isOdd()) && (O.iadd(G), J.isub(D)), O.iushrn(1), J.iushrn(1);
        for (var ge = 0, xe = 1; !($.words[0] & xe) && ge < 26; ++ge, xe <<= 1)
          ;
        if (ge > 0)
          for ($.iushrn(ge); ge-- > 0; )
            (Z.isOdd() || K.isOdd()) && (Z.iadd(G), K.isub(D)), Z.iushrn(1), K.iushrn(1);
        M.cmp($) >= 0 ? (M.isub($), O.isub(Z), J.isub(K)) : ($.isub(M), Z.isub(O), K.isub(J));
      }
      return {
        a: Z,
        b: K,
        gcd: $.iushln(z)
      };
    }, h.prototype._invmp = function(Y) {
      g(Y.negative === 0), g(!Y.isZero());
      var M = this, $ = Y.clone();
      M.negative !== 0 ? M = M.umod(Y) : M = M.clone();
      for (var O = new h(1), J = new h(0), Z = $.clone(); M.cmpn(1) > 0 && $.cmpn(1) > 0; ) {
        for (var K = 0, z = 1; !(M.words[0] & z) && K < 26; ++K, z <<= 1)
          ;
        if (K > 0)
          for (M.iushrn(K); K-- > 0; )
            O.isOdd() && O.iadd(Z), O.iushrn(1);
        for (var G = 0, D = 1; !($.words[0] & D) && G < 26; ++G, D <<= 1)
          ;
        if (G > 0)
          for ($.iushrn(G); G-- > 0; )
            J.isOdd() && J.iadd(Z), J.iushrn(1);
        M.cmp($) >= 0 ? (M.isub($), O.isub(J)) : ($.isub(M), J.isub(O));
      }
      var F;
      return M.cmpn(1) === 0 ? F = O : F = J, F.cmpn(0) < 0 && F.iadd(Y), F;
    }, h.prototype.gcd = function(Y) {
      if (this.isZero())
        return Y.abs();
      if (Y.isZero())
        return this.abs();
      var M = this.clone(), $ = Y.clone();
      M.negative = 0, $.negative = 0;
      for (var O = 0; M.isEven() && $.isEven(); O++)
        M.iushrn(1), $.iushrn(1);
      do {
        for (; M.isEven(); )
          M.iushrn(1);
        for (; $.isEven(); )
          $.iushrn(1);
        var J = M.cmp($);
        if (J < 0) {
          var Z = M;
          M = $, $ = Z;
        } else if (J === 0 || $.cmpn(1) === 0)
          break;
        M.isub($);
      } while (!0);
      return $.iushln(O);
    }, h.prototype.invm = function(Y) {
      return this.egcd(Y).a.umod(Y);
    }, h.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, h.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, h.prototype.andln = function(Y) {
      return this.words[0] & Y;
    }, h.prototype.bincn = function(Y) {
      g(typeof Y == "number");
      var M = Y % 26, $ = (Y - M) / 26, O = 1 << M;
      if (this.length <= $)
        return this._expand($ + 1), this.words[$] |= O, this;
      for (var J = O, Z = $; J !== 0 && Z < this.length; Z++) {
        var K = this.words[Z] | 0;
        K += J, J = K >>> 26, K &= 67108863, this.words[Z] = K;
      }
      return J !== 0 && (this.words[Z] = J, this.length++), this;
    }, h.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, h.prototype.cmpn = function(Y) {
      var M = Y < 0;
      if (this.negative !== 0 && !M)
        return -1;
      if (this.negative === 0 && M)
        return 1;
      this.strip();
      var $;
      if (this.length > 1)
        $ = 1;
      else {
        M && (Y = -Y), g(Y <= 67108863, "Number is too big");
        var O = this.words[0] | 0;
        $ = O === Y ? 0 : O < Y ? -1 : 1;
      }
      return this.negative !== 0 ? -$ | 0 : $;
    }, h.prototype.cmp = function(Y) {
      if (this.negative !== 0 && Y.negative === 0)
        return -1;
      if (this.negative === 0 && Y.negative !== 0)
        return 1;
      var M = this.ucmp(Y);
      return this.negative !== 0 ? -M | 0 : M;
    }, h.prototype.ucmp = function(Y) {
      if (this.length > Y.length)
        return 1;
      if (this.length < Y.length)
        return -1;
      for (var M = 0, $ = this.length - 1; $ >= 0; $--) {
        var O = this.words[$] | 0, J = Y.words[$] | 0;
        if (O !== J) {
          O < J ? M = -1 : O > J && (M = 1);
          break;
        }
      }
      return M;
    }, h.prototype.gtn = function(Y) {
      return this.cmpn(Y) === 1;
    }, h.prototype.gt = function(Y) {
      return this.cmp(Y) === 1;
    }, h.prototype.gten = function(Y) {
      return this.cmpn(Y) >= 0;
    }, h.prototype.gte = function(Y) {
      return this.cmp(Y) >= 0;
    }, h.prototype.ltn = function(Y) {
      return this.cmpn(Y) === -1;
    }, h.prototype.lt = function(Y) {
      return this.cmp(Y) === -1;
    }, h.prototype.lten = function(Y) {
      return this.cmpn(Y) <= 0;
    }, h.prototype.lte = function(Y) {
      return this.cmp(Y) <= 0;
    }, h.prototype.eqn = function(Y) {
      return this.cmpn(Y) === 0;
    }, h.prototype.eq = function(Y) {
      return this.cmp(Y) === 0;
    }, h.red = function(Y) {
      return new Re(Y);
    }, h.prototype.toRed = function(Y) {
      return g(!this.red, "Already a number in reduction context"), g(this.negative === 0, "red works only with positives"), Y.convertTo(this)._forceRed(Y);
    }, h.prototype.fromRed = function() {
      return g(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, h.prototype._forceRed = function(Y) {
      return this.red = Y, this;
    }, h.prototype.forceRed = function(Y) {
      return g(!this.red, "Already a number in reduction context"), this._forceRed(Y);
    }, h.prototype.redAdd = function(Y) {
      return g(this.red, "redAdd works only with red numbers"), this.red.add(this, Y);
    }, h.prototype.redIAdd = function(Y) {
      return g(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Y);
    }, h.prototype.redSub = function(Y) {
      return g(this.red, "redSub works only with red numbers"), this.red.sub(this, Y);
    }, h.prototype.redISub = function(Y) {
      return g(this.red, "redISub works only with red numbers"), this.red.isub(this, Y);
    }, h.prototype.redShl = function(Y) {
      return g(this.red, "redShl works only with red numbers"), this.red.shl(this, Y);
    }, h.prototype.redMul = function(Y) {
      return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, Y), this.red.mul(this, Y);
    }, h.prototype.redIMul = function(Y) {
      return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, Y), this.red.imul(this, Y);
    }, h.prototype.redSqr = function() {
      return g(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, h.prototype.redISqr = function() {
      return g(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, h.prototype.redSqrt = function() {
      return g(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, h.prototype.redInvm = function() {
      return g(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, h.prototype.redNeg = function() {
      return g(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, h.prototype.redPow = function(Y) {
      return g(this.red && !Y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Y);
    };
    var le = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ce(ne, Y) {
      this.name = ne, this.p = new h(Y, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ce.prototype._tmp = function() {
      var Y = new h(null);
      return Y.words = new Array(Math.ceil(this.n / 13)), Y;
    }, ce.prototype.ireduce = function(Y) {
      var M = Y, $;
      do
        this.split(M, this.tmp), M = this.imulK(M), M = M.iadd(this.tmp), $ = M.bitLength();
      while ($ > this.n);
      var O = $ < this.n ? -1 : M.ucmp(this.p);
      return O === 0 ? (M.words[0] = 0, M.length = 1) : O > 0 ? M.isub(this.p) : M.strip !== void 0 ? M.strip() : M._strip(), M;
    }, ce.prototype.split = function(Y, M) {
      Y.iushrn(this.n, 0, M);
    }, ce.prototype.imulK = function(Y) {
      return Y.imul(this.k);
    };
    function pe() {
      ce.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    U(pe, ce), pe.prototype.split = function(Y, M) {
      for (var $ = 4194303, O = Math.min(Y.length, 9), J = 0; J < O; J++)
        M.words[J] = Y.words[J];
      if (M.length = O, Y.length <= 9) {
        Y.words[0] = 0, Y.length = 1;
        return;
      }
      var Z = Y.words[9];
      for (M.words[M.length++] = Z & $, J = 10; J < Y.length; J++) {
        var K = Y.words[J] | 0;
        Y.words[J - 10] = (K & $) << 4 | Z >>> 22, Z = K;
      }
      Z >>>= 22, Y.words[J - 10] = Z, Z === 0 && Y.length > 10 ? Y.length -= 10 : Y.length -= 9;
    }, pe.prototype.imulK = function(Y) {
      Y.words[Y.length] = 0, Y.words[Y.length + 1] = 0, Y.length += 2;
      for (var M = 0, $ = 0; $ < Y.length; $++) {
        var O = Y.words[$] | 0;
        M += O * 977, Y.words[$] = M & 67108863, M = O * 64 + (M / 67108864 | 0);
      }
      return Y.words[Y.length - 1] === 0 && (Y.length--, Y.words[Y.length - 1] === 0 && Y.length--), Y;
    };
    function me() {
      ce.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    U(me, ce);
    function Me() {
      ce.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    U(Me, ce);
    function Ee() {
      ce.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    U(Ee, ce), Ee.prototype.imulK = function(Y) {
      for (var M = 0, $ = 0; $ < Y.length; $++) {
        var O = (Y.words[$] | 0) * 19 + M, J = O & 67108863;
        O >>>= 26, Y.words[$] = J, M = O;
      }
      return M !== 0 && (Y.words[Y.length++] = M), Y;
    }, h._prime = function(Y) {
      if (le[Y])
        return le[Y];
      var M;
      if (Y === "k256")
        M = new pe();
      else if (Y === "p224")
        M = new me();
      else if (Y === "p192")
        M = new Me();
      else if (Y === "p25519")
        M = new Ee();
      else
        throw new Error("Unknown prime " + Y);
      return le[Y] = M, M;
    };
    function Re(ne) {
      if (typeof ne == "string") {
        var Y = h._prime(ne);
        this.m = Y.p, this.prime = Y;
      } else
        g(ne.gtn(1), "modulus must be greater than 1"), this.m = ne, this.prime = null;
    }
    Re.prototype._verify1 = function(Y) {
      g(Y.negative === 0, "red works only with positives"), g(Y.red, "red works only with red numbers");
    }, Re.prototype._verify2 = function(Y, M) {
      g((Y.negative | M.negative) === 0, "red works only with positives"), g(
        Y.red && Y.red === M.red,
        "red works only with red numbers"
      );
    }, Re.prototype.imod = function(Y) {
      return this.prime ? this.prime.ireduce(Y)._forceRed(this) : Y.umod(this.m)._forceRed(this);
    }, Re.prototype.neg = function(Y) {
      return Y.isZero() ? Y.clone() : this.m.sub(Y)._forceRed(this);
    }, Re.prototype.add = function(Y, M) {
      this._verify2(Y, M);
      var $ = Y.add(M);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $._forceRed(this);
    }, Re.prototype.iadd = function(Y, M) {
      this._verify2(Y, M);
      var $ = Y.iadd(M);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $;
    }, Re.prototype.sub = function(Y, M) {
      this._verify2(Y, M);
      var $ = Y.sub(M);
      return $.cmpn(0) < 0 && $.iadd(this.m), $._forceRed(this);
    }, Re.prototype.isub = function(Y, M) {
      this._verify2(Y, M);
      var $ = Y.isub(M);
      return $.cmpn(0) < 0 && $.iadd(this.m), $;
    }, Re.prototype.shl = function(Y, M) {
      return this._verify1(Y), this.imod(Y.ushln(M));
    }, Re.prototype.imul = function(Y, M) {
      return this._verify2(Y, M), this.imod(Y.imul(M));
    }, Re.prototype.mul = function(Y, M) {
      return this._verify2(Y, M), this.imod(Y.mul(M));
    }, Re.prototype.isqr = function(Y) {
      return this.imul(Y, Y.clone());
    }, Re.prototype.sqr = function(Y) {
      return this.mul(Y, Y);
    }, Re.prototype.sqrt = function(Y) {
      if (Y.isZero())
        return Y.clone();
      var M = this.m.andln(3);
      if (g(M % 2 === 1), M === 3) {
        var $ = this.m.add(new h(1)).iushrn(2);
        return this.pow(Y, $);
      }
      for (var O = this.m.subn(1), J = 0; !O.isZero() && O.andln(1) === 0; )
        J++, O.iushrn(1);
      g(!O.isZero());
      var Z = new h(1).toRed(this), K = Z.redNeg(), z = this.m.subn(1).iushrn(1), G = this.m.bitLength();
      for (G = new h(2 * G * G).toRed(this); this.pow(G, z).cmp(K) !== 0; )
        G.redIAdd(K);
      for (var D = this.pow(G, O), F = this.pow(Y, O.addn(1).iushrn(1)), ae = this.pow(Y, O), ge = J; ae.cmp(Z) !== 0; ) {
        for (var xe = ae, ye = 0; xe.cmp(Z) !== 0; ye++)
          xe = xe.redSqr();
        g(ye < ge);
        var oe = this.pow(D, new h(1).iushln(ge - ye - 1));
        F = F.redMul(oe), D = oe.redSqr(), ae = ae.redMul(D), ge = ye;
      }
      return F;
    }, Re.prototype.invm = function(Y) {
      var M = Y._invmp(this.m);
      return M.negative !== 0 ? (M.negative = 0, this.imod(M).redNeg()) : this.imod(M);
    }, Re.prototype.pow = function(Y, M) {
      if (M.isZero())
        return new h(1).toRed(this);
      if (M.cmpn(1) === 0)
        return Y.clone();
      var $ = 4, O = new Array(1 << $);
      O[0] = new h(1).toRed(this), O[1] = Y;
      for (var J = 2; J < O.length; J++)
        O[J] = this.mul(O[J - 1], Y);
      var Z = O[0], K = 0, z = 0, G = M.bitLength() % 26;
      for (G === 0 && (G = 26), J = M.length - 1; J >= 0; J--) {
        for (var D = M.words[J], F = G - 1; F >= 0; F--) {
          var ae = D >> F & 1;
          if (Z !== O[0] && (Z = this.sqr(Z)), ae === 0 && K === 0) {
            z = 0;
            continue;
          }
          K <<= 1, K |= ae, z++, !(z !== $ && (J !== 0 || F !== 0)) && (Z = this.mul(Z, O[K]), z = 0, K = 0);
        }
        G = 26;
      }
      return Z;
    }, Re.prototype.convertTo = function(Y) {
      var M = Y.umod(this.m);
      return M === Y ? M.clone() : M;
    }, Re.prototype.convertFrom = function(Y) {
      var M = Y.clone();
      return M.red = null, M;
    }, h.mont = function(Y) {
      return new Ne(Y);
    };
    function Ne(ne) {
      Re.call(this, ne), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    U(Ne, Re), Ne.prototype.convertTo = function(Y) {
      return this.imod(Y.ushln(this.shift));
    }, Ne.prototype.convertFrom = function(Y) {
      var M = this.imod(Y.mul(this.rinv));
      return M.red = null, M;
    }, Ne.prototype.imul = function(Y, M) {
      if (Y.isZero() || M.isZero())
        return Y.words[0] = 0, Y.length = 1, Y;
      var $ = Y.imul(M), O = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), J = $.isub(O).iushrn(this.shift), Z = J;
      return J.cmp(this.m) >= 0 ? Z = J.isub(this.m) : J.cmpn(0) < 0 && (Z = J.iadd(this.m)), Z._forceRed(this);
    }, Ne.prototype.mul = function(Y, M) {
      if (Y.isZero() || M.isZero())
        return new h(0)._forceRed(this);
      var $ = Y.mul(M), O = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), J = $.isub(O).iushrn(this.shift), Z = J;
      return J.cmp(this.m) >= 0 ? Z = J.isub(this.m) : J.cmpn(0) < 0 && (Z = J.iadd(this.m)), Z._forceRed(this);
    }, Ne.prototype.invm = function(Y) {
      var M = this.imod(Y._invmp(this.m).mul(this.r2));
      return M._forceRed(this);
    };
  })(e, commonjsGlobal$1);
})(bn$2);
var bnExports = bn$2.exports, __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ethereumjsAbiUtils, "__esModule", { value: !0 });
ethereumjsAbiUtils.rawEncode = ethereumjsAbiUtils.parseNumber = ethereumjsAbiUtils.solidityPack = void 0;
const util_1 = dist$1, bn_js_1 = __importDefault(bnExports), ethjs_util_1 = lib, utils_1$1 = utils$4;
function solidityPack(e, o) {
  if (e.length !== o.length)
    throw new Error("Number of types are not matching the values");
  const S = [];
  for (let g = 0; g < e.length; g++) {
    const U = elementaryName(e[g]), h = o[g];
    S.push(solidityHexValue(U, h, null));
  }
  return buffer$3.Buffer.concat(S);
}
ethereumjsAbiUtils.solidityPack = solidityPack;
function isArray(e) {
  return e.endsWith("]");
}
function parseTypeArray(e) {
  const o = e.match(/(.*)\[(.*?)\]$/u);
  return o ? o[2] === "" ? "dynamic" : parseInt(o[2], 10) : null;
}
function parseTypeN(e) {
  const o = /^\D+(\d+)$/u.exec(e);
  if (o === null)
    throw new Error(`Invalid parseTypeN input "${e}".`);
  return parseInt(o[1], 10);
}
function parseNumber(e) {
  const o = typeof e;
  if (o === "string")
    return (0, util_1.isHexPrefixed)(e) ? new bn_js_1.default((0, ethjs_util_1.stripHexPrefix)(e), 16) : new bn_js_1.default(e, 10);
  if (o === "number")
    return new bn_js_1.default(e);
  if (e && Object.prototype.hasOwnProperty.call(e, "toArray") || bn_js_1.default.isBN(e))
    return e;
  throw new Error("Argument is not a number");
}
ethereumjsAbiUtils.parseNumber = parseNumber;
function solidityHexValue(e, o, S) {
  if (isArray(e)) {
    const g = e.replace(/\[.*?\]/u, "");
    if (!isArray(g)) {
      const h = parseTypeArray(e);
      if (h !== "dynamic" && h !== 0 && h !== null && o.length > h)
        throw new Error(`Elements exceed array size: ${h}`);
    }
    const U = o.map((h) => solidityHexValue(g, h, 256));
    return buffer$3.Buffer.concat(U);
  } else {
    if (e === "bytes")
      return o;
    if (e === "string")
      return buffer$3.Buffer.from(o, "utf8");
    if (e === "bool") {
      S = S || 8;
      const g = Array(S / 4).join("0");
      return buffer$3.Buffer.from(o ? `${g}1` : `${g}0`, "hex");
    } else if (e === "address") {
      let g = 20;
      return S && (g = S / 8), (0, util_1.setLengthLeft)((0, util_1.toBuffer)(o), g);
    } else if (e.startsWith("bytes")) {
      const g = parseTypeN(e);
      if (g < 1 || g > 32)
        throw new Error(`Invalid bytes<N> width: ${g}`);
      return typeof o == "number" && (o = (0, utils_1$1.normalize)(o)), (0, util_1.setLengthRight)((0, util_1.toBuffer)(o), g);
    } else if (e.startsWith("uint")) {
      const g = parseTypeN(e);
      if (g % 8 || g < 8 || g > 256)
        throw new Error(`Invalid uint<N> width: ${g}`);
      const U = parseNumber(o);
      if (U.bitLength() > g)
        throw new Error(`Supplied uint exceeds width: ${g} vs ${U.bitLength()}`);
      return S = S || g, U.toArrayLike(buffer$3.Buffer, "be", S / 8);
    } else if (e.startsWith("int")) {
      const g = parseTypeN(e);
      if (g % 8 || g < 8 || g > 256)
        throw new Error(`Invalid int<N> width: ${g}`);
      const U = parseNumber(o);
      if (U.bitLength() > g)
        throw new Error(`Supplied int exceeds width: ${g} vs ${U.bitLength()}`);
      return S = S || g, U.toTwos(g).toArrayLike(buffer$3.Buffer, "be", S / 8);
    }
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function elementaryName(e) {
  return e.startsWith("int[") ? `int256${e.slice(3)}` : e === "int" ? "int256" : e.startsWith("uint[") ? `uint256${e.slice(4)}` : e === "uint" ? "uint256" : e.startsWith("fixed[") ? `fixed128x128${e.slice(5)}` : e === "fixed" ? "fixed128x128" : e.startsWith("ufixed[") ? `ufixed128x128${e.slice(6)}` : e === "ufixed" ? "ufixed128x128" : e;
}
function rawEncode(e, o) {
  const S = [], g = [];
  let U = 0;
  e.forEach((h) => {
    if (isArray(h)) {
      const q = parseTypeArray(h);
      q !== "dynamic" && q !== null ? U += 32 * q : U += 32;
    } else
      U += 32;
  });
  for (let h = 0; h < e.length; h++) {
    const q = elementaryName(e[h]), A = o[h], P = encodeSingle(q, A);
    isDynamic(q) ? (S.push(encodeSingle("uint256", U)), g.push(P), U += P.length) : S.push(P);
  }
  return buffer$3.Buffer.concat(S.concat(g));
}
ethereumjsAbiUtils.rawEncode = rawEncode;
function encodeSingle(e, o) {
  if (e === "address")
    return encodeSingle("uint160", parseNumber(o));
  if (e === "bool")
    return encodeSingle("uint8", o ? 1 : 0);
  if (e === "string")
    return encodeSingle("bytes", buffer$3.Buffer.from(o, "utf8"));
  if (isArray(e)) {
    if (typeof o.length > "u")
      throw new Error("Not an array?");
    const S = parseTypeArray(e);
    if (S !== "dynamic" && S !== 0 && S !== null && o.length > S)
      throw new Error(`Elements exceed array size: ${S}`);
    const g = [];
    e = e.slice(0, e.lastIndexOf("[")), typeof o == "string" && (o = JSON.parse(o));
    for (const U in o)
      Object.prototype.hasOwnProperty.call(o, U) && g.push(encodeSingle(e, o[U]));
    if (S === "dynamic") {
      const U = encodeSingle("uint256", o.length);
      g.unshift(U);
    }
    return buffer$3.Buffer.concat(g);
  } else if (e === "bytes") {
    o = buffer$3.Buffer.from(o);
    let S = buffer$3.Buffer.concat([encodeSingle("uint256", o.length), o]);
    return o.length % 32 !== 0 && (S = buffer$3.Buffer.concat([S, (0, util_1.zeros)(32 - o.length % 32)])), S;
  } else if (e.startsWith("bytes")) {
    const S = parseTypeN(e);
    if (S < 1 || S > 32)
      throw new Error(`Invalid bytes<N> width: ${S}`);
    const g = typeof o == "number" ? (0, utils_1$1.normalize)(o) : o;
    return (0, util_1.setLengthRight)((0, util_1.toBuffer)(g), 32);
  } else if (e.startsWith("uint")) {
    const S = parseTypeN(e);
    if (S % 8 || S < 8 || S > 256)
      throw new Error(`Invalid uint<N> width: ${S}`);
    const g = parseNumber(o);
    if (g.bitLength() > S)
      throw new Error(`Supplied uint exceeds width: ${S} vs ${g.bitLength()}`);
    if (g.isNeg())
      throw new Error("Supplied uint is negative");
    return g.toArrayLike(buffer$3.Buffer, "be", 32);
  } else if (e.startsWith("int")) {
    const S = parseTypeN(e);
    if (S % 8 || S < 8 || S > 256)
      throw new Error(`Invalid int<N> width: ${S}`);
    const g = parseNumber(o);
    if (g.bitLength() > S)
      throw new Error(`Supplied int exceeds width: ${S} vs ${g.bitLength()}`);
    return g.toTwos(256).toArrayLike(buffer$3.Buffer, "be", 32);
  } else if (e.startsWith("ufixed")) {
    const S = parseTypeNxM(e), g = parseNumber(o);
    if (g.isNeg())
      throw new Error("Supplied ufixed is negative");
    return encodeSingle("uint256", g.mul(new bn_js_1.default(2).pow(new bn_js_1.default(S[1]))));
  } else if (e.startsWith("fixed")) {
    const S = parseTypeNxM(e);
    return encodeSingle("int256", parseNumber(o).mul(new bn_js_1.default(2).pow(new bn_js_1.default(S[1]))));
  }
  throw new Error(`Unsupported or invalid type: ${JSON.stringify(e)}`);
}
function isDynamic(e) {
  return e === "string" || e === "bytes" || parseTypeArray(e) === "dynamic";
}
function parseTypeNxM(e) {
  const o = /^\D+(\d+)x(\d+)$/u.exec(e);
  if (o === null || o.length < 1)
    throw new Error(`Invalid parseTypeNxM input "${e}".`);
  return [parseInt(o[1], 10), parseInt(o[2], 10)];
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.recoverTypedSignature = e.signTypedData = e.typedSignatureHash = e.TypedDataUtils = e.TYPED_MESSAGE_SCHEMA = e.SignTypedDataVersion = void 0;
  const o = dist$1, S = keccak, g = lib, U = ethereumjsAbiUtils, h = utils$4;
  var q;
  (function(pe) {
    pe.V1 = "V1", pe.V3 = "V3", pe.V4 = "V4";
  })(q = e.SignTypedDataVersion || (e.SignTypedDataVersion = {})), e.TYPED_MESSAGE_SCHEMA = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              type: { type: "string" }
            },
            required: ["name", "type"]
          }
        }
      },
      primaryType: { type: "string" },
      domain: { type: "object" },
      message: { type: "object" }
    },
    required: ["types", "primaryType", "domain", "message"]
  };
  function A(pe, me) {
    if (Object.keys(q).includes(pe)) {
      if (me && !me.includes(pe))
        throw new Error(`SignTypedDataVersion not allowed: '${pe}'. Allowed versions are: ${me.join(", ")}`);
    } else
      throw new Error(`Invalid version: '${pe}'`);
  }
  function P(pe, me, Me, Ee, Re) {
    if (A(Re, [q.V3, q.V4]), pe[Me] !== void 0)
      return [
        "bytes32",
        // TODO: return Buffer, remove string from return type
        Re === q.V4 && Ee == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, o.arrToBufArr)((0, S.keccak256)(I(Me, Ee, pe, Re)))
      ];
    if (Ee === void 0)
      throw new Error(`missing value for field ${me} of type ${Me}`);
    if (Me === "bytes") {
      if (typeof Ee == "number")
        Ee = (0, h.numberToBuffer)(Ee);
      else if ((0, g.isHexString)(Ee)) {
        const Ne = Ee.length % 2 ? "0" : "";
        Ee = buffer$3.Buffer.from(Ne + Ee.slice(2), "hex");
      } else
        Ee = buffer$3.Buffer.from(Ee, "utf8");
      return ["bytes32", (0, o.arrToBufArr)((0, S.keccak256)(Ee))];
    }
    if (Me === "string")
      return typeof Ee == "number" ? Ee = (0, h.numberToBuffer)(Ee) : Ee = buffer$3.Buffer.from(Ee ?? "", "utf8"), ["bytes32", (0, o.arrToBufArr)((0, S.keccak256)(Ee))];
    if (Me.endsWith("]")) {
      if (Re === q.V3)
        throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
      const Ne = Me.slice(0, Me.lastIndexOf("[")), ne = Ee.map((Y) => P(pe, me, Ne, Y, Re));
      return [
        "bytes32",
        (0, o.arrToBufArr)((0, S.keccak256)((0, U.rawEncode)(ne.map(([Y]) => Y), ne.map(([, Y]) => Y))))
      ];
    }
    return [Me, Ee];
  }
  function I(pe, me, Me, Ee) {
    A(Ee, [q.V3, q.V4]);
    const Re = ["bytes32"], Ne = [X(pe, Me)];
    for (const ne of Me[pe]) {
      if (Ee === q.V3 && me[ne.name] === void 0)
        continue;
      const [Y, M] = P(Me, ne.name, ne.type, me[ne.name], Ee);
      Re.push(Y), Ne.push(M);
    }
    return (0, U.rawEncode)(Re, Ne);
  }
  function B(pe, me) {
    let Me = "";
    const Ee = H(pe, me);
    Ee.delete(pe);
    const Re = [pe, ...Array.from(Ee).sort()];
    for (const Ne of Re) {
      if (!me[Ne])
        throw new Error(`No type definition specified: ${Ne}`);
      Me += `${Ne}(${me[Ne].map(({ name: Y, type: M }) => `${M} ${Y}`).join(",")})`;
    }
    return Me;
  }
  function H(pe, me, Me = /* @__PURE__ */ new Set()) {
    if (typeof pe != "string")
      throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(pe)}`);
    if ([pe] = pe.match(/^\w*/u), Me.has(pe) || me[pe] === void 0)
      return Me;
    Me.add(pe);
    for (const Re of me[pe])
      H(Re.type, me, Me);
    return Me;
  }
  function V(pe, me, Me, Ee) {
    A(Ee, [q.V3, q.V4]);
    const Re = I(pe, me, Me, Ee), Ne = (0, S.keccak256)(Re);
    return (0, o.arrToBufArr)(Ne);
  }
  function X(pe, me) {
    const Me = buffer$3.Buffer.from(B(pe, me), "utf-8");
    return (0, o.arrToBufArr)((0, S.keccak256)(Me));
  }
  function Q(pe) {
    const me = {};
    for (const Me in e.TYPED_MESSAGE_SCHEMA.properties)
      pe[Me] && (me[Me] = pe[Me]);
    return "types" in me && (me.types = Object.assign({ EIP712Domain: [] }, me.types)), me;
  }
  function ee(pe, me) {
    A(me, [q.V3, q.V4]);
    const Me = Q(pe), { domain: Ee } = Me, Re = { EIP712Domain: Me.types.EIP712Domain };
    return V("EIP712Domain", Ee, Re, me);
  }
  function ie(pe, me) {
    A(me, [q.V3, q.V4]);
    const Me = Q(pe), Ee = [buffer$3.Buffer.from("1901", "hex")];
    return Ee.push(ee(pe, me)), Me.primaryType !== "EIP712Domain" && Ee.push(V(
      // TODO: Validate that this is a string, so this type cast can be removed.
      Me.primaryType,
      Me.message,
      Me.types,
      me
    )), (0, o.arrToBufArr)((0, S.keccak256)(buffer$3.Buffer.concat(Ee)));
  }
  e.TypedDataUtils = {
    encodeData: I,
    encodeType: B,
    findTypeDependencies: H,
    hashStruct: V,
    hashType: X,
    sanitizeData: Q,
    eip712Hash: ie,
    eip712DomainHash: ee
  };
  function te(pe) {
    const me = se(pe);
    return (0, o.bufferToHex)(me);
  }
  e.typedSignatureHash = te;
  function se(pe) {
    const me = new Error("Expect argument to be non-empty array");
    if (typeof pe != "object" || !("length" in pe) || !pe.length)
      throw me;
    const Me = pe.map(function(Ne) {
      return Ne.type !== "bytes" ? Ne.value : (0, h.legacyToBuffer)(Ne.value);
    }), Ee = pe.map(function(Ne) {
      return Ne.type;
    }), Re = pe.map(function(Ne) {
      if (!Ne.name)
        throw me;
      return `${Ne.type} ${Ne.name}`;
    });
    return (0, o.arrToBufArr)((0, S.keccak256)((0, U.solidityPack)(["bytes32", "bytes32"], [
      (0, S.keccak256)((0, U.solidityPack)(new Array(pe.length).fill("string"), Re)),
      (0, S.keccak256)((0, U.solidityPack)(Ee, Me))
    ])));
  }
  function le({ privateKey: pe, data: me, version: Me }) {
    if (A(Me), (0, h.isNullish)(me))
      throw new Error("Missing data parameter");
    if ((0, h.isNullish)(pe))
      throw new Error("Missing private key parameter");
    const Ee = Me === q.V1 ? se(me) : e.TypedDataUtils.eip712Hash(me, Me), Re = (0, o.ecsign)(Ee, pe);
    return (0, h.concatSig)((0, o.toBuffer)(Re.v), Re.r, Re.s);
  }
  e.signTypedData = le;
  function ce({ data: pe, signature: me, version: Me }) {
    if (A(Me), (0, h.isNullish)(pe))
      throw new Error("Missing data parameter");
    if ((0, h.isNullish)(me))
      throw new Error("Missing signature parameter");
    const Ee = Me === q.V1 ? se(pe) : e.TypedDataUtils.eip712Hash(pe, Me), Re = (0, h.recoverPublicKey)(Ee, me), Ne = (0, o.publicToAddress)(Re);
    return (0, o.bufferToHex)(Ne);
  }
  e.recoverTypedSignature = ce;
})(signTypedData$1);
var encryption = {}, naclFast = { exports: {} }, cryptoBrowserify = {}, browser$a = { exports: {} }, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a)
    return browser$a.exports;
  hasRequiredBrowser$a = 1;
  var e = 65536, o = 4294967295;
  function S() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var g = requireSafeBuffer$1().Buffer, U = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto;
  U && U.getRandomValues ? browser$a.exports = h : browser$a.exports = S;
  function h(q, A) {
    if (q > o)
      throw new RangeError("requested too many random bytes");
    var P = g.allocUnsafe(q);
    if (q > 0)
      if (q > e)
        for (var I = 0; I < q; I += e)
          U.getRandomValues(P.slice(I, I + e));
      else
        U.getRandomValues(P);
    return typeof A == "function" ? process$3.nextTick(function() {
      A(null, P);
    }) : P;
  }
  return browser$a.exports;
}
var hashBase$1, hasRequiredHashBase$1;
function requireHashBase$1() {
  if (hasRequiredHashBase$1)
    return hashBase$1;
  hasRequiredHashBase$1 = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireReadableBrowser$1().Transform, S = requireInherits_browser();
  function g(h, q) {
    if (!e.isBuffer(h) && typeof h != "string")
      throw new TypeError(q + " must be a string or a buffer");
  }
  function U(h) {
    o.call(this), this._block = e.allocUnsafe(h), this._blockSize = h, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return S(U, o), U.prototype._transform = function(h, q, A) {
    var P = null;
    try {
      this.update(h, q);
    } catch (I) {
      P = I;
    }
    A(P);
  }, U.prototype._flush = function(h) {
    var q = null;
    try {
      this.push(this.digest());
    } catch (A) {
      q = A;
    }
    h(q);
  }, U.prototype.update = function(h, q) {
    if (g(h, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(h) || (h = e.from(h, q));
    for (var A = this._block, P = 0; this._blockOffset + h.length - P >= this._blockSize; ) {
      for (var I = this._blockOffset; I < this._blockSize; )
        A[I++] = h[P++];
      this._update(), this._blockOffset = 0;
    }
    for (; P < h.length; )
      A[this._blockOffset++] = h[P++];
    for (var B = 0, H = h.length * 8; H > 0; ++B)
      this._length[B] += H, H = this._length[B] / 4294967296 | 0, H > 0 && (this._length[B] -= 4294967296 * H);
    return this;
  }, U.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, U.prototype.digest = function(h) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var q = this._digest();
    h !== void 0 && (q = q.toString(h)), this._block.fill(0), this._blockOffset = 0;
    for (var A = 0; A < 4; ++A)
      this._length[A] = 0;
    return q;
  }, U.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase$1 = U, hashBase$1;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js)
    return md5_js;
  hasRequiredMd5_js = 1;
  var e = requireInherits_browser(), o = requireHashBase$1(), S = requireSafeBuffer$1().Buffer, g = new Array(16);
  function U() {
    o.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(U, o), U.prototype._update = function() {
    for (var B = g, H = 0; H < 16; ++H)
      B[H] = this._block.readInt32LE(H * 4);
    var V = this._a, X = this._b, Q = this._c, ee = this._d;
    V = q(V, X, Q, ee, B[0], 3614090360, 7), ee = q(ee, V, X, Q, B[1], 3905402710, 12), Q = q(Q, ee, V, X, B[2], 606105819, 17), X = q(X, Q, ee, V, B[3], 3250441966, 22), V = q(V, X, Q, ee, B[4], 4118548399, 7), ee = q(ee, V, X, Q, B[5], 1200080426, 12), Q = q(Q, ee, V, X, B[6], 2821735955, 17), X = q(X, Q, ee, V, B[7], 4249261313, 22), V = q(V, X, Q, ee, B[8], 1770035416, 7), ee = q(ee, V, X, Q, B[9], 2336552879, 12), Q = q(Q, ee, V, X, B[10], 4294925233, 17), X = q(X, Q, ee, V, B[11], 2304563134, 22), V = q(V, X, Q, ee, B[12], 1804603682, 7), ee = q(ee, V, X, Q, B[13], 4254626195, 12), Q = q(Q, ee, V, X, B[14], 2792965006, 17), X = q(X, Q, ee, V, B[15], 1236535329, 22), V = A(V, X, Q, ee, B[1], 4129170786, 5), ee = A(ee, V, X, Q, B[6], 3225465664, 9), Q = A(Q, ee, V, X, B[11], 643717713, 14), X = A(X, Q, ee, V, B[0], 3921069994, 20), V = A(V, X, Q, ee, B[5], 3593408605, 5), ee = A(ee, V, X, Q, B[10], 38016083, 9), Q = A(Q, ee, V, X, B[15], 3634488961, 14), X = A(X, Q, ee, V, B[4], 3889429448, 20), V = A(V, X, Q, ee, B[9], 568446438, 5), ee = A(ee, V, X, Q, B[14], 3275163606, 9), Q = A(Q, ee, V, X, B[3], 4107603335, 14), X = A(X, Q, ee, V, B[8], 1163531501, 20), V = A(V, X, Q, ee, B[13], 2850285829, 5), ee = A(ee, V, X, Q, B[2], 4243563512, 9), Q = A(Q, ee, V, X, B[7], 1735328473, 14), X = A(X, Q, ee, V, B[12], 2368359562, 20), V = P(V, X, Q, ee, B[5], 4294588738, 4), ee = P(ee, V, X, Q, B[8], 2272392833, 11), Q = P(Q, ee, V, X, B[11], 1839030562, 16), X = P(X, Q, ee, V, B[14], 4259657740, 23), V = P(V, X, Q, ee, B[1], 2763975236, 4), ee = P(ee, V, X, Q, B[4], 1272893353, 11), Q = P(Q, ee, V, X, B[7], 4139469664, 16), X = P(X, Q, ee, V, B[10], 3200236656, 23), V = P(V, X, Q, ee, B[13], 681279174, 4), ee = P(ee, V, X, Q, B[0], 3936430074, 11), Q = P(Q, ee, V, X, B[3], 3572445317, 16), X = P(X, Q, ee, V, B[6], 76029189, 23), V = P(V, X, Q, ee, B[9], 3654602809, 4), ee = P(ee, V, X, Q, B[12], 3873151461, 11), Q = P(Q, ee, V, X, B[15], 530742520, 16), X = P(X, Q, ee, V, B[2], 3299628645, 23), V = I(V, X, Q, ee, B[0], 4096336452, 6), ee = I(ee, V, X, Q, B[7], 1126891415, 10), Q = I(Q, ee, V, X, B[14], 2878612391, 15), X = I(X, Q, ee, V, B[5], 4237533241, 21), V = I(V, X, Q, ee, B[12], 1700485571, 6), ee = I(ee, V, X, Q, B[3], 2399980690, 10), Q = I(Q, ee, V, X, B[10], 4293915773, 15), X = I(X, Q, ee, V, B[1], 2240044497, 21), V = I(V, X, Q, ee, B[8], 1873313359, 6), ee = I(ee, V, X, Q, B[15], 4264355552, 10), Q = I(Q, ee, V, X, B[6], 2734768916, 15), X = I(X, Q, ee, V, B[13], 1309151649, 21), V = I(V, X, Q, ee, B[4], 4149444226, 6), ee = I(ee, V, X, Q, B[11], 3174756917, 10), Q = I(Q, ee, V, X, B[2], 718787259, 15), X = I(X, Q, ee, V, B[9], 3951481745, 21), this._a = this._a + V | 0, this._b = this._b + X | 0, this._c = this._c + Q | 0, this._d = this._d + ee | 0;
  }, U.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var B = S.allocUnsafe(16);
    return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B;
  };
  function h(B, H) {
    return B << H | B >>> 32 - H;
  }
  function q(B, H, V, X, Q, ee, ie) {
    return h(B + (H & V | ~H & X) + Q + ee | 0, ie) + H | 0;
  }
  function A(B, H, V, X, Q, ee, ie) {
    return h(B + (H & X | V & ~X) + Q + ee | 0, ie) + H | 0;
  }
  function P(B, H, V, X, Q, ee, ie) {
    return h(B + (H ^ V ^ X) + Q + ee | 0, ie) + H | 0;
  }
  function I(B, H, V, X, Q, ee, ie) {
    return h(B + (V ^ (H | ~X)) + Q + ee | 0, ie) + H | 0;
  }
  return md5_js = U, md5_js;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase)
    return hashBase;
  hasRequiredHashBase = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireReadableBrowser$1().Transform, S = requireInherits_browser();
  function g(h, q) {
    if (!e.isBuffer(h) && typeof h != "string")
      throw new TypeError(q + " must be a string or a buffer");
  }
  function U(h) {
    o.call(this), this._block = e.allocUnsafe(h), this._blockSize = h, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return S(U, o), U.prototype._transform = function(h, q, A) {
    var P = null;
    try {
      this.update(h, q);
    } catch (I) {
      P = I;
    }
    A(P);
  }, U.prototype._flush = function(h) {
    var q = null;
    try {
      this.push(this.digest());
    } catch (A) {
      q = A;
    }
    h(q);
  }, U.prototype.update = function(h, q) {
    if (g(h, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(h) || (h = e.from(h, q));
    for (var A = this._block, P = 0; this._blockOffset + h.length - P >= this._blockSize; ) {
      for (var I = this._blockOffset; I < this._blockSize; )
        A[I++] = h[P++];
      this._update(), this._blockOffset = 0;
    }
    for (; P < h.length; )
      A[this._blockOffset++] = h[P++];
    for (var B = 0, H = h.length * 8; H > 0; ++B)
      this._length[B] += H, H = this._length[B] / 4294967296 | 0, H > 0 && (this._length[B] -= 4294967296 * H);
    return this;
  }, U.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, U.prototype.digest = function(h) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var q = this._digest();
    h !== void 0 && (q = q.toString(h)), this._block.fill(0), this._blockOffset = 0;
    for (var A = 0; A < 4; ++A)
      this._length[A] = 0;
    return q;
  }, U.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = U, hashBase;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160)
    return ripemd160;
  hasRequiredRipemd160 = 1;
  var e = buffer$3.Buffer, o = requireInherits_browser(), S = requireHashBase(), g = new Array(16), U = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], h = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], q = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], A = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], P = [0, 1518500249, 1859775393, 2400959708, 2840853838], I = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function B() {
    S.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  o(B, S), B.prototype._update = function() {
    for (var te = g, se = 0; se < 16; ++se)
      te[se] = this._block.readInt32LE(se * 4);
    for (var le = this._a | 0, ce = this._b | 0, pe = this._c | 0, me = this._d | 0, Me = this._e | 0, Ee = this._a | 0, Re = this._b | 0, Ne = this._c | 0, ne = this._d | 0, Y = this._e | 0, M = 0; M < 80; M += 1) {
      var $, O;
      M < 16 ? ($ = V(le, ce, pe, me, Me, te[U[M]], P[0], q[M]), O = ie(Ee, Re, Ne, ne, Y, te[h[M]], I[0], A[M])) : M < 32 ? ($ = X(le, ce, pe, me, Me, te[U[M]], P[1], q[M]), O = ee(Ee, Re, Ne, ne, Y, te[h[M]], I[1], A[M])) : M < 48 ? ($ = Q(le, ce, pe, me, Me, te[U[M]], P[2], q[M]), O = Q(Ee, Re, Ne, ne, Y, te[h[M]], I[2], A[M])) : M < 64 ? ($ = ee(le, ce, pe, me, Me, te[U[M]], P[3], q[M]), O = X(Ee, Re, Ne, ne, Y, te[h[M]], I[3], A[M])) : ($ = ie(le, ce, pe, me, Me, te[U[M]], P[4], q[M]), O = V(Ee, Re, Ne, ne, Y, te[h[M]], I[4], A[M])), le = Me, Me = me, me = H(pe, 10), pe = ce, ce = $, Ee = Y, Y = ne, ne = H(Ne, 10), Ne = Re, Re = O;
    }
    var J = this._b + pe + ne | 0;
    this._b = this._c + me + Y | 0, this._c = this._d + Me + Ee | 0, this._d = this._e + le + Re | 0, this._e = this._a + ce + Ne | 0, this._a = J;
  }, B.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var te = e.alloc ? e.alloc(20) : new e(20);
    return te.writeInt32LE(this._a, 0), te.writeInt32LE(this._b, 4), te.writeInt32LE(this._c, 8), te.writeInt32LE(this._d, 12), te.writeInt32LE(this._e, 16), te;
  };
  function H(te, se) {
    return te << se | te >>> 32 - se;
  }
  function V(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se ^ le ^ ce) + me + Me | 0, Ee) + pe | 0;
  }
  function X(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se & le | ~se & ce) + me + Me | 0, Ee) + pe | 0;
  }
  function Q(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + ((se | ~le) ^ ce) + me + Me | 0, Ee) + pe | 0;
  }
  function ee(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se & ce | le & ~ce) + me + Me | 0, Ee) + pe | 0;
  }
  function ie(te, se, le, ce, pe, me, Me, Ee) {
    return H(te + (se ^ (le | ~ce)) + me + Me | 0, Ee) + pe | 0;
  }
  return ripemd160 = B, ripemd160;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1)
    return hash$1;
  hasRequiredHash$1 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function o(S, g) {
    this._block = e.alloc(S), this._finalSize = g, this._blockSize = S, this._len = 0;
  }
  return o.prototype.update = function(S, g) {
    typeof S == "string" && (g = g || "utf8", S = e.from(S, g));
    for (var U = this._block, h = this._blockSize, q = S.length, A = this._len, P = 0; P < q; ) {
      for (var I = A % h, B = Math.min(q - P, h - I), H = 0; H < B; H++)
        U[I + H] = S[P + H];
      A += B, P += B, A % h === 0 && this._update(U);
    }
    return this._len += q, this;
  }, o.prototype.digest = function(S) {
    var g = this._len % this._blockSize;
    this._block[g] = 128, this._block.fill(0, g + 1), g >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var U = this._len * 8;
    if (U <= 4294967295)
      this._block.writeUInt32BE(U, this._blockSize - 4);
    else {
      var h = (U & 4294967295) >>> 0, q = (U - h) / 4294967296;
      this._block.writeUInt32BE(q, this._blockSize - 8), this._block.writeUInt32BE(h, this._blockSize - 4);
    }
    this._update(this._block);
    var A = this._hash();
    return S ? A.toString(S) : A;
  }, o.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = o, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1)
    return sha$1;
  hasRequiredSha$1 = 1;
  var e = requireInherits_browser(), o = requireHash$1(), S = requireSafeBuffer$1().Buffer, g = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], U = new Array(80);
  function h() {
    this.init(), this._w = U, o.call(this, 64, 56);
  }
  e(h, o), h.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function q(I) {
    return I << 5 | I >>> 27;
  }
  function A(I) {
    return I << 30 | I >>> 2;
  }
  function P(I, B, H, V) {
    return I === 0 ? B & H | ~B & V : I === 2 ? B & H | B & V | H & V : B ^ H ^ V;
  }
  return h.prototype._update = function(I) {
    for (var B = this._w, H = this._a | 0, V = this._b | 0, X = this._c | 0, Q = this._d | 0, ee = this._e | 0, ie = 0; ie < 16; ++ie)
      B[ie] = I.readInt32BE(ie * 4);
    for (; ie < 80; ++ie)
      B[ie] = B[ie - 3] ^ B[ie - 8] ^ B[ie - 14] ^ B[ie - 16];
    for (var te = 0; te < 80; ++te) {
      var se = ~~(te / 20), le = q(H) + P(se, V, X, Q) + ee + B[te] + g[se] | 0;
      ee = Q, Q = X, X = A(V), V = H, H = le;
    }
    this._a = H + this._a | 0, this._b = V + this._b | 0, this._c = X + this._c | 0, this._d = Q + this._d | 0, this._e = ee + this._e | 0;
  }, h.prototype._hash = function() {
    var I = S.allocUnsafe(20);
    return I.writeInt32BE(this._a | 0, 0), I.writeInt32BE(this._b | 0, 4), I.writeInt32BE(this._c | 0, 8), I.writeInt32BE(this._d | 0, 12), I.writeInt32BE(this._e | 0, 16), I;
  }, sha$1 = h, sha$1;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1)
    return sha1;
  hasRequiredSha1 = 1;
  var e = requireInherits_browser(), o = requireHash$1(), S = requireSafeBuffer$1().Buffer, g = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], U = new Array(80);
  function h() {
    this.init(), this._w = U, o.call(this, 64, 56);
  }
  e(h, o), h.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function q(B) {
    return B << 1 | B >>> 31;
  }
  function A(B) {
    return B << 5 | B >>> 27;
  }
  function P(B) {
    return B << 30 | B >>> 2;
  }
  function I(B, H, V, X) {
    return B === 0 ? H & V | ~H & X : B === 2 ? H & V | H & X | V & X : H ^ V ^ X;
  }
  return h.prototype._update = function(B) {
    for (var H = this._w, V = this._a | 0, X = this._b | 0, Q = this._c | 0, ee = this._d | 0, ie = this._e | 0, te = 0; te < 16; ++te)
      H[te] = B.readInt32BE(te * 4);
    for (; te < 80; ++te)
      H[te] = q(H[te - 3] ^ H[te - 8] ^ H[te - 14] ^ H[te - 16]);
    for (var se = 0; se < 80; ++se) {
      var le = ~~(se / 20), ce = A(V) + I(le, X, Q, ee) + ie + H[se] + g[le] | 0;
      ie = ee, ee = Q, Q = P(X), X = V, V = ce;
    }
    this._a = V + this._a | 0, this._b = X + this._b | 0, this._c = Q + this._c | 0, this._d = ee + this._d | 0, this._e = ie + this._e | 0;
  }, h.prototype._hash = function() {
    var B = S.allocUnsafe(20);
    return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
  }, sha1 = h, sha1;
}
var sha256$1, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256)
    return sha256$1;
  hasRequiredSha256 = 1;
  var e = requireInherits_browser(), o = requireHash$1(), S = requireSafeBuffer$1().Buffer, g = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], U = new Array(64);
  function h() {
    this.init(), this._w = U, o.call(this, 64, 56);
  }
  e(h, o), h.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function q(V, X, Q) {
    return Q ^ V & (X ^ Q);
  }
  function A(V, X, Q) {
    return V & X | Q & (V | X);
  }
  function P(V) {
    return (V >>> 2 | V << 30) ^ (V >>> 13 | V << 19) ^ (V >>> 22 | V << 10);
  }
  function I(V) {
    return (V >>> 6 | V << 26) ^ (V >>> 11 | V << 21) ^ (V >>> 25 | V << 7);
  }
  function B(V) {
    return (V >>> 7 | V << 25) ^ (V >>> 18 | V << 14) ^ V >>> 3;
  }
  function H(V) {
    return (V >>> 17 | V << 15) ^ (V >>> 19 | V << 13) ^ V >>> 10;
  }
  return h.prototype._update = function(V) {
    for (var X = this._w, Q = this._a | 0, ee = this._b | 0, ie = this._c | 0, te = this._d | 0, se = this._e | 0, le = this._f | 0, ce = this._g | 0, pe = this._h | 0, me = 0; me < 16; ++me)
      X[me] = V.readInt32BE(me * 4);
    for (; me < 64; ++me)
      X[me] = H(X[me - 2]) + X[me - 7] + B(X[me - 15]) + X[me - 16] | 0;
    for (var Me = 0; Me < 64; ++Me) {
      var Ee = pe + I(se) + q(se, le, ce) + g[Me] + X[Me] | 0, Re = P(Q) + A(Q, ee, ie) | 0;
      pe = ce, ce = le, le = se, se = te + Ee | 0, te = ie, ie = ee, ee = Q, Q = Ee + Re | 0;
    }
    this._a = Q + this._a | 0, this._b = ee + this._b | 0, this._c = ie + this._c | 0, this._d = te + this._d | 0, this._e = se + this._e | 0, this._f = le + this._f | 0, this._g = ce + this._g | 0, this._h = pe + this._h | 0;
  }, h.prototype._hash = function() {
    var V = S.allocUnsafe(32);
    return V.writeInt32BE(this._a, 0), V.writeInt32BE(this._b, 4), V.writeInt32BE(this._c, 8), V.writeInt32BE(this._d, 12), V.writeInt32BE(this._e, 16), V.writeInt32BE(this._f, 20), V.writeInt32BE(this._g, 24), V.writeInt32BE(this._h, 28), V;
  }, sha256$1 = h, sha256$1;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224)
    return sha224$1;
  hasRequiredSha224 = 1;
  var e = requireInherits_browser(), o = requireSha256(), S = requireHash$1(), g = requireSafeBuffer$1().Buffer, U = new Array(64);
  function h() {
    this.init(), this._w = U, S.call(this, 64, 56);
  }
  return e(h, o), h.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, h.prototype._hash = function() {
    var q = g.allocUnsafe(28);
    return q.writeInt32BE(this._a, 0), q.writeInt32BE(this._b, 4), q.writeInt32BE(this._c, 8), q.writeInt32BE(this._d, 12), q.writeInt32BE(this._e, 16), q.writeInt32BE(this._f, 20), q.writeInt32BE(this._g, 24), q;
  }, sha224$1 = h, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512)
    return sha512$1;
  hasRequiredSha512 = 1;
  var e = requireInherits_browser(), o = requireHash$1(), S = requireSafeBuffer$1().Buffer, g = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], U = new Array(160);
  function h() {
    this.init(), this._w = U, o.call(this, 128, 112);
  }
  e(h, o), h.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function q(ee, ie, te) {
    return te ^ ee & (ie ^ te);
  }
  function A(ee, ie, te) {
    return ee & ie | te & (ee | ie);
  }
  function P(ee, ie) {
    return (ee >>> 28 | ie << 4) ^ (ie >>> 2 | ee << 30) ^ (ie >>> 7 | ee << 25);
  }
  function I(ee, ie) {
    return (ee >>> 14 | ie << 18) ^ (ee >>> 18 | ie << 14) ^ (ie >>> 9 | ee << 23);
  }
  function B(ee, ie) {
    return (ee >>> 1 | ie << 31) ^ (ee >>> 8 | ie << 24) ^ ee >>> 7;
  }
  function H(ee, ie) {
    return (ee >>> 1 | ie << 31) ^ (ee >>> 8 | ie << 24) ^ (ee >>> 7 | ie << 25);
  }
  function V(ee, ie) {
    return (ee >>> 19 | ie << 13) ^ (ie >>> 29 | ee << 3) ^ ee >>> 6;
  }
  function X(ee, ie) {
    return (ee >>> 19 | ie << 13) ^ (ie >>> 29 | ee << 3) ^ (ee >>> 6 | ie << 26);
  }
  function Q(ee, ie) {
    return ee >>> 0 < ie >>> 0 ? 1 : 0;
  }
  return h.prototype._update = function(ee) {
    for (var ie = this._w, te = this._ah | 0, se = this._bh | 0, le = this._ch | 0, ce = this._dh | 0, pe = this._eh | 0, me = this._fh | 0, Me = this._gh | 0, Ee = this._hh | 0, Re = this._al | 0, Ne = this._bl | 0, ne = this._cl | 0, Y = this._dl | 0, M = this._el | 0, $ = this._fl | 0, O = this._gl | 0, J = this._hl | 0, Z = 0; Z < 32; Z += 2)
      ie[Z] = ee.readInt32BE(Z * 4), ie[Z + 1] = ee.readInt32BE(Z * 4 + 4);
    for (; Z < 160; Z += 2) {
      var K = ie[Z - 30], z = ie[Z - 15 * 2 + 1], G = B(K, z), D = H(z, K);
      K = ie[Z - 2 * 2], z = ie[Z - 2 * 2 + 1];
      var F = V(K, z), ae = X(z, K), ge = ie[Z - 7 * 2], xe = ie[Z - 7 * 2 + 1], ye = ie[Z - 16 * 2], oe = ie[Z - 16 * 2 + 1], fe = D + xe | 0, $e = G + ge + Q(fe, D) | 0;
      fe = fe + ae | 0, $e = $e + F + Q(fe, ae) | 0, fe = fe + oe | 0, $e = $e + ye + Q(fe, oe) | 0, ie[Z] = $e, ie[Z + 1] = fe;
    }
    for (var Be = 0; Be < 160; Be += 2) {
      $e = ie[Be], fe = ie[Be + 1];
      var be = A(te, se, le), ve = A(Re, Ne, ne), qe = P(te, Re), De = P(Re, te), Ye = I(pe, M), he = I(M, pe), ue = g[Be], de = g[Be + 1], _e = q(pe, me, Me), Pe = q(M, $, O), He = J + he | 0, Ve = Ee + Ye + Q(He, J) | 0;
      He = He + Pe | 0, Ve = Ve + _e + Q(He, Pe) | 0, He = He + de | 0, Ve = Ve + ue + Q(He, de) | 0, He = He + fe | 0, Ve = Ve + $e + Q(He, fe) | 0;
      var nt = De + ve | 0, Ie = qe + be + Q(nt, De) | 0;
      Ee = Me, J = O, Me = me, O = $, me = pe, $ = M, M = Y + He | 0, pe = ce + Ve + Q(M, Y) | 0, ce = le, Y = ne, le = se, ne = Ne, se = te, Ne = Re, Re = He + nt | 0, te = Ve + Ie + Q(Re, He) | 0;
    }
    this._al = this._al + Re | 0, this._bl = this._bl + Ne | 0, this._cl = this._cl + ne | 0, this._dl = this._dl + Y | 0, this._el = this._el + M | 0, this._fl = this._fl + $ | 0, this._gl = this._gl + O | 0, this._hl = this._hl + J | 0, this._ah = this._ah + te + Q(this._al, Re) | 0, this._bh = this._bh + se + Q(this._bl, Ne) | 0, this._ch = this._ch + le + Q(this._cl, ne) | 0, this._dh = this._dh + ce + Q(this._dl, Y) | 0, this._eh = this._eh + pe + Q(this._el, M) | 0, this._fh = this._fh + me + Q(this._fl, $) | 0, this._gh = this._gh + Me + Q(this._gl, O) | 0, this._hh = this._hh + Ee + Q(this._hl, J) | 0;
  }, h.prototype._hash = function() {
    var ee = S.allocUnsafe(64);
    function ie(te, se, le) {
      ee.writeInt32BE(te, le), ee.writeInt32BE(se, le + 4);
    }
    return ie(this._ah, this._al, 0), ie(this._bh, this._bl, 8), ie(this._ch, this._cl, 16), ie(this._dh, this._dl, 24), ie(this._eh, this._el, 32), ie(this._fh, this._fl, 40), ie(this._gh, this._gl, 48), ie(this._hh, this._hl, 56), ee;
  }, sha512$1 = h, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384)
    return sha384$1;
  hasRequiredSha384 = 1;
  var e = requireInherits_browser(), o = requireSha512(), S = requireHash$1(), g = requireSafeBuffer$1().Buffer, U = new Array(160);
  function h() {
    this.init(), this._w = U, S.call(this, 128, 112);
  }
  return e(h, o), h.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, h.prototype._hash = function() {
    var q = g.allocUnsafe(48);
    function A(P, I, B) {
      q.writeInt32BE(P, B), q.writeInt32BE(I, B + 4);
    }
    return A(this._ah, this._al, 0), A(this._bh, this._bl, 8), A(this._ch, this._cl, 16), A(this._dh, this._dl, 24), A(this._eh, this._el, 32), A(this._fh, this._fl, 40), q;
  }, sha384$1 = h, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js)
    return sha_js.exports;
  hasRequiredSha_js = 1;
  var e = sha_js.exports = function(S) {
    S = S.toLowerCase();
    var g = e[S];
    if (!g)
      throw new Error(S + " is not supported (we accept pull requests)");
    return new g();
  };
  return e.sha = requireSha$1(), e.sha1 = requireSha1(), e.sha224 = requireSha224(), e.sha256 = requireSha256(), e.sha384 = requireSha384(), e.sha512 = requireSha512(), sha_js.exports;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase)
    return cipherBase;
  hasRequiredCipherBase = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireStreamBrowserify().Transform, S = requireString_decoder().StringDecoder, g = requireInherits_browser();
  function U(h) {
    o.call(this), this.hashMode = typeof h == "string", this.hashMode ? this[h] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return g(U, o), U.prototype.update = function(h, q, A) {
    typeof h == "string" && (h = e.from(h, q));
    var P = this._update(h);
    return this.hashMode ? this : (A && (P = this._toString(P, A)), P);
  }, U.prototype.setAutoPadding = function() {
  }, U.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, U.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, U.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, U.prototype._transform = function(h, q, A) {
    var P;
    try {
      this.hashMode ? this._update(h) : this.push(this._update(h));
    } catch (I) {
      P = I;
    } finally {
      A(P);
    }
  }, U.prototype._flush = function(h) {
    var q;
    try {
      this.push(this.__final());
    } catch (A) {
      q = A;
    }
    h(q);
  }, U.prototype._finalOrDigest = function(h) {
    var q = this.__final() || e.alloc(0);
    return h && (q = this._toString(q, h, !0)), q;
  }, U.prototype._toString = function(h, q, A) {
    if (this._decoder || (this._decoder = new S(q), this._encoding = q), this._encoding !== q)
      throw new Error("can't switch encodings");
    var P = this._decoder.write(h);
    return A && (P += this._decoder.end()), P;
  }, cipherBase = U, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9)
    return browser$9;
  hasRequiredBrowser$9 = 1;
  var e = requireInherits_browser(), o = requireMd5_js(), S = requireRipemd160(), g = requireSha_js(), U = requireCipherBase();
  function h(q) {
    U.call(this, "digest"), this._hash = q;
  }
  return e(h, U), h.prototype._update = function(q) {
    this._hash.update(q);
  }, h.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(A) {
    return A = A.toLowerCase(), A === "md5" ? new o() : A === "rmd160" || A === "ripemd160" ? new S() : new h(g(A));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy)
    return legacy;
  hasRequiredLegacy = 1;
  var e = requireInherits_browser(), o = requireSafeBuffer$1().Buffer, S = requireCipherBase(), g = o.alloc(128), U = 64;
  function h(q, A) {
    S.call(this, "digest"), typeof A == "string" && (A = o.from(A)), this._alg = q, this._key = A, A.length > U ? A = q(A) : A.length < U && (A = o.concat([A, g], U));
    for (var P = this._ipad = o.allocUnsafe(U), I = this._opad = o.allocUnsafe(U), B = 0; B < U; B++)
      P[B] = A[B] ^ 54, I[B] = A[B] ^ 92;
    this._hash = [P];
  }
  return e(h, S), h.prototype._update = function(q) {
    this._hash.push(q);
  }, h.prototype._final = function() {
    var q = this._alg(o.concat(this._hash));
    return this._alg(o.concat([this._opad, q]));
  }, legacy = h, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5)
    return md5;
  hasRequiredMd5 = 1;
  var e = requireMd5_js();
  return md5 = function(o) {
    return new e().update(o).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8)
    return browser$8;
  hasRequiredBrowser$8 = 1;
  var e = requireInherits_browser(), o = requireLegacy(), S = requireCipherBase(), g = requireSafeBuffer$1().Buffer, U = requireMd5(), h = requireRipemd160(), q = requireSha_js(), A = g.alloc(128);
  function P(I, B) {
    S.call(this, "digest"), typeof B == "string" && (B = g.from(B));
    var H = I === "sha512" || I === "sha384" ? 128 : 64;
    if (this._alg = I, this._key = B, B.length > H) {
      var V = I === "rmd160" ? new h() : q(I);
      B = V.update(B).digest();
    } else
      B.length < H && (B = g.concat([B, A], H));
    for (var X = this._ipad = g.allocUnsafe(H), Q = this._opad = g.allocUnsafe(H), ee = 0; ee < H; ee++)
      X[ee] = B[ee] ^ 54, Q[ee] = B[ee] ^ 92;
    this._hash = I === "rmd160" ? new h() : q(I), this._hash.update(X);
  }
  return e(P, S), P.prototype._update = function(I) {
    this._hash.update(I);
  }, P.prototype._final = function() {
    var I = this._hash.digest(), B = this._alg === "rmd160" ? new h() : q(this._alg);
    return B.update(this._opad).update(I).digest();
  }, browser$8 = function(B, H) {
    return B = B.toLowerCase(), B === "rmd160" || B === "ripemd160" ? new P("rmd160", H) : B === "md5" ? new o(U, H) : new P(B, H);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition)
    return precondition;
  hasRequiredPrecondition = 1;
  var e = Math.pow(2, 30) - 1;
  return precondition = function(o, S) {
    if (typeof o != "number")
      throw new TypeError("Iterations not a number");
    if (o < 0)
      throw new TypeError("Bad iterations");
    if (typeof S != "number")
      throw new TypeError("Key length not a number");
    if (S < 0 || S > e || S !== S)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding)
    return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var e;
  if (commonjsGlobal$1.process && commonjsGlobal$1.process.browser)
    e = "utf-8";
  else if (commonjsGlobal$1.process && commonjsGlobal$1.process.version) {
    var o = parseInt(process$3.version.split(".")[0].slice(1), 10);
    e = o >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return defaultEncoding_1 = e, defaultEncoding_1;
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer)
    return toBuffer;
  hasRequiredToBuffer = 1;
  var e = requireSafeBuffer$1().Buffer;
  return toBuffer = function(o, S, g) {
    if (e.isBuffer(o))
      return o;
    if (typeof o == "string")
      return e.from(o, S);
    if (ArrayBuffer.isView(o))
      return e.from(o.buffer);
    throw new TypeError(g + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser)
    return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var e = requireMd5(), o = requireRipemd160(), S = requireSha_js(), g = requireSafeBuffer$1().Buffer, U = requirePrecondition(), h = requireDefaultEncoding(), q = requireToBuffer(), A = g.alloc(128), P = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function I(V, X, Q) {
    var ee = B(V), ie = V === "sha512" || V === "sha384" ? 128 : 64;
    X.length > ie ? X = ee(X) : X.length < ie && (X = g.concat([X, A], ie));
    for (var te = g.allocUnsafe(ie + P[V]), se = g.allocUnsafe(ie + P[V]), le = 0; le < ie; le++)
      te[le] = X[le] ^ 54, se[le] = X[le] ^ 92;
    var ce = g.allocUnsafe(ie + Q + 4);
    te.copy(ce, 0, 0, ie), this.ipad1 = ce, this.ipad2 = te, this.opad = se, this.alg = V, this.blocksize = ie, this.hash = ee, this.size = P[V];
  }
  I.prototype.run = function(V, X) {
    V.copy(X, this.blocksize);
    var Q = this.hash(X);
    return Q.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function B(V) {
    function X(ee) {
      return S(V).update(ee).digest();
    }
    function Q(ee) {
      return new o().update(ee).digest();
    }
    return V === "rmd160" || V === "ripemd160" ? Q : V === "md5" ? e : X;
  }
  function H(V, X, Q, ee, ie) {
    U(Q, ee), V = q(V, h, "Password"), X = q(X, h, "Salt"), ie = ie || "sha1";
    var te = new I(ie, V, X.length), se = g.allocUnsafe(ee), le = g.allocUnsafe(X.length + 4);
    X.copy(le, 0, 0, X.length);
    for (var ce = 0, pe = P[ie], me = Math.ceil(ee / pe), Me = 1; Me <= me; Me++) {
      le.writeUInt32BE(Me, X.length);
      for (var Ee = te.run(le, te.ipad1), Re = Ee, Ne = 1; Ne < Q; Ne++) {
        Re = te.run(Re, te.ipad2);
        for (var ne = 0; ne < pe; ne++)
          Ee[ne] ^= Re[ne];
      }
      Ee.copy(se, ce), ce += pe;
    }
    return se;
  }
  return syncBrowser = H, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync)
    return async;
  hasRequiredAsync = 1;
  var e = requireSafeBuffer$1().Buffer, o = requirePrecondition(), S = requireDefaultEncoding(), g = requireSyncBrowser(), U = requireToBuffer(), h, q = commonjsGlobal$1.crypto && commonjsGlobal$1.crypto.subtle, A = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, P = [];
  function I(Q) {
    if (commonjsGlobal$1.process && !commonjsGlobal$1.process.browser || !q || !q.importKey || !q.deriveBits)
      return Promise.resolve(!1);
    if (P[Q] !== void 0)
      return P[Q];
    h = h || e.alloc(8);
    var ee = V(h, h, 10, 128, Q).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return P[Q] = ee, ee;
  }
  var B;
  function H() {
    return B || (commonjsGlobal$1.process && commonjsGlobal$1.process.nextTick ? B = commonjsGlobal$1.process.nextTick : commonjsGlobal$1.queueMicrotask ? B = commonjsGlobal$1.queueMicrotask : commonjsGlobal$1.setImmediate ? B = commonjsGlobal$1.setImmediate : B = commonjsGlobal$1.setTimeout, B);
  }
  function V(Q, ee, ie, te, se) {
    return q.importKey(
      "raw",
      Q,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(le) {
      return q.deriveBits({
        name: "PBKDF2",
        salt: ee,
        iterations: ie,
        hash: {
          name: se
        }
      }, le, te << 3);
    }).then(function(le) {
      return e.from(le);
    });
  }
  function X(Q, ee) {
    Q.then(function(ie) {
      H()(function() {
        ee(null, ie);
      });
    }, function(ie) {
      H()(function() {
        ee(ie);
      });
    });
  }
  return async = function(Q, ee, ie, te, se, le) {
    typeof se == "function" && (le = se, se = void 0), se = se || "sha1";
    var ce = A[se.toLowerCase()];
    if (!ce || typeof commonjsGlobal$1.Promise != "function") {
      H()(function() {
        var pe;
        try {
          pe = g(Q, ee, ie, te, se);
        } catch (me) {
          return le(me);
        }
        le(null, pe);
      });
      return;
    }
    if (o(ie, te), Q = U(Q, S, "Password"), ee = U(ee, S, "Salt"), typeof le != "function")
      throw new Error("No callback provided to pbkdf2");
    X(I(ce).then(function(pe) {
      return pe ? V(Q, ee, ie, te, ce) : g(Q, ee, ie, te, se);
    }), le);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$3 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3)
    return utils$3;
  hasRequiredUtils$3 = 1, utils$3.readUInt32BE = function(U, h) {
    var q = U[0 + h] << 24 | U[1 + h] << 16 | U[2 + h] << 8 | U[3 + h];
    return q >>> 0;
  }, utils$3.writeUInt32BE = function(U, h, q) {
    U[0 + q] = h >>> 24, U[1 + q] = h >>> 16 & 255, U[2 + q] = h >>> 8 & 255, U[3 + q] = h & 255;
  }, utils$3.ip = function(U, h, q, A) {
    for (var P = 0, I = 0, B = 6; B >= 0; B -= 2) {
      for (var H = 0; H <= 24; H += 8)
        P <<= 1, P |= h >>> H + B & 1;
      for (var H = 0; H <= 24; H += 8)
        P <<= 1, P |= U >>> H + B & 1;
    }
    for (var B = 6; B >= 0; B -= 2) {
      for (var H = 1; H <= 25; H += 8)
        I <<= 1, I |= h >>> H + B & 1;
      for (var H = 1; H <= 25; H += 8)
        I <<= 1, I |= U >>> H + B & 1;
    }
    q[A + 0] = P >>> 0, q[A + 1] = I >>> 0;
  }, utils$3.rip = function(U, h, q, A) {
    for (var P = 0, I = 0, B = 0; B < 4; B++)
      for (var H = 24; H >= 0; H -= 8)
        P <<= 1, P |= h >>> H + B & 1, P <<= 1, P |= U >>> H + B & 1;
    for (var B = 4; B < 8; B++)
      for (var H = 24; H >= 0; H -= 8)
        I <<= 1, I |= h >>> H + B & 1, I <<= 1, I |= U >>> H + B & 1;
    q[A + 0] = P >>> 0, q[A + 1] = I >>> 0;
  }, utils$3.pc1 = function(U, h, q, A) {
    for (var P = 0, I = 0, B = 7; B >= 5; B--) {
      for (var H = 0; H <= 24; H += 8)
        P <<= 1, P |= h >> H + B & 1;
      for (var H = 0; H <= 24; H += 8)
        P <<= 1, P |= U >> H + B & 1;
    }
    for (var H = 0; H <= 24; H += 8)
      P <<= 1, P |= h >> H + B & 1;
    for (var B = 1; B <= 3; B++) {
      for (var H = 0; H <= 24; H += 8)
        I <<= 1, I |= h >> H + B & 1;
      for (var H = 0; H <= 24; H += 8)
        I <<= 1, I |= U >> H + B & 1;
    }
    for (var H = 0; H <= 24; H += 8)
      I <<= 1, I |= U >> H + B & 1;
    q[A + 0] = P >>> 0, q[A + 1] = I >>> 0;
  }, utils$3.r28shl = function(U, h) {
    return U << h & 268435455 | U >>> 28 - h;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$3.pc2 = function(U, h, q, A) {
    for (var P = 0, I = 0, B = e.length >>> 1, H = 0; H < B; H++)
      P <<= 1, P |= U >>> e[H] & 1;
    for (var H = B; H < e.length; H++)
      I <<= 1, I |= h >>> e[H] & 1;
    q[A + 0] = P >>> 0, q[A + 1] = I >>> 0;
  }, utils$3.expand = function(U, h, q) {
    var A = 0, P = 0;
    A = (U & 1) << 5 | U >>> 27;
    for (var I = 23; I >= 15; I -= 4)
      A <<= 6, A |= U >>> I & 63;
    for (var I = 11; I >= 3; I -= 4)
      P |= U >>> I & 63, P <<= 6;
    P |= (U & 31) << 1 | U >>> 31, h[q + 0] = A >>> 0, h[q + 1] = P >>> 0;
  };
  var o = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$3.substitute = function(U, h) {
    for (var q = 0, A = 0; A < 4; A++) {
      var P = U >>> 18 - A * 6 & 63, I = o[A * 64 + P];
      q <<= 4, q |= I;
    }
    for (var A = 0; A < 4; A++) {
      var P = h >>> 18 - A * 6 & 63, I = o[4 * 64 + A * 64 + P];
      q <<= 4, q |= I;
    }
    return q >>> 0;
  };
  var S = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$3.permute = function(U) {
    for (var h = 0, q = 0; q < S.length; q++)
      h <<= 1, h |= U >>> S[q] & 1;
    return h >>> 0;
  }, utils$3.padSplit = function(U, h, q) {
    for (var A = U.toString(2); A.length < h; )
      A = "0" + A;
    for (var P = [], I = 0; I < h; I += q)
      P.push(A.slice(I, I + q));
    return P.join(" ");
  }, utils$3;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert)
    return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = e;
  function e(o, S) {
    if (!o)
      throw new Error(S || "Assertion failed");
  }
  return e.equal = function(S, g, U) {
    if (S != g)
      throw new Error(U || "Assertion failed: " + S + " != " + g);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher)
    return cipher;
  hasRequiredCipher = 1;
  var e = requireMinimalisticAssert();
  function o(S) {
    this.options = S, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = S.padding !== !1;
  }
  return cipher = o, o.prototype._init = function() {
  }, o.prototype.update = function(g) {
    return g.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(g) : this._updateEncrypt(g);
  }, o.prototype._buffer = function(g, U) {
    for (var h = Math.min(this.buffer.length - this.bufferOff, g.length - U), q = 0; q < h; q++)
      this.buffer[this.bufferOff + q] = g[U + q];
    return this.bufferOff += h, h;
  }, o.prototype._flushBuffer = function(g, U) {
    return this._update(this.buffer, 0, g, U), this.bufferOff = 0, this.blockSize;
  }, o.prototype._updateEncrypt = function(g) {
    var U = 0, h = 0, q = (this.bufferOff + g.length) / this.blockSize | 0, A = new Array(q * this.blockSize);
    this.bufferOff !== 0 && (U += this._buffer(g, U), this.bufferOff === this.buffer.length && (h += this._flushBuffer(A, h)));
    for (var P = g.length - (g.length - U) % this.blockSize; U < P; U += this.blockSize)
      this._update(g, U, A, h), h += this.blockSize;
    for (; U < g.length; U++, this.bufferOff++)
      this.buffer[this.bufferOff] = g[U];
    return A;
  }, o.prototype._updateDecrypt = function(g) {
    for (var U = 0, h = 0, q = Math.ceil((this.bufferOff + g.length) / this.blockSize) - 1, A = new Array(q * this.blockSize); q > 0; q--)
      U += this._buffer(g, U), h += this._flushBuffer(A, h);
    return U += this._buffer(g, U), A;
  }, o.prototype.final = function(g) {
    var U;
    g && (U = this.update(g));
    var h;
    return this.type === "encrypt" ? h = this._finalEncrypt() : h = this._finalDecrypt(), U ? U.concat(h) : h;
  }, o.prototype._pad = function(g, U) {
    if (U === 0)
      return !1;
    for (; U < g.length; )
      g[U++] = 0;
    return !0;
  }, o.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var g = new Array(this.blockSize);
    return this._update(this.buffer, 0, g, 0), g;
  }, o.prototype._unpad = function(g) {
    return g;
  }, o.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var g = new Array(this.blockSize);
    return this._flushBuffer(g, 0), this._unpad(g);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1)
    return des;
  hasRequiredDes$1 = 1;
  var e = requireMinimalisticAssert(), o = requireInherits_browser(), S = requireUtils$3(), g = requireCipher();
  function U() {
    this.tmp = new Array(2), this.keys = null;
  }
  function h(A) {
    g.call(this, A);
    var P = new U();
    this._desState = P, this.deriveKeys(P, A.key);
  }
  o(h, g), des = h, h.create = function(P) {
    return new h(P);
  };
  var q = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return h.prototype.deriveKeys = function(P, I) {
    P.keys = new Array(16 * 2), e.equal(I.length, this.blockSize, "Invalid key length");
    var B = S.readUInt32BE(I, 0), H = S.readUInt32BE(I, 4);
    S.pc1(B, H, P.tmp, 0), B = P.tmp[0], H = P.tmp[1];
    for (var V = 0; V < P.keys.length; V += 2) {
      var X = q[V >>> 1];
      B = S.r28shl(B, X), H = S.r28shl(H, X), S.pc2(B, H, P.keys, V);
    }
  }, h.prototype._update = function(P, I, B, H) {
    var V = this._desState, X = S.readUInt32BE(P, I), Q = S.readUInt32BE(P, I + 4);
    S.ip(X, Q, V.tmp, 0), X = V.tmp[0], Q = V.tmp[1], this.type === "encrypt" ? this._encrypt(V, X, Q, V.tmp, 0) : this._decrypt(V, X, Q, V.tmp, 0), X = V.tmp[0], Q = V.tmp[1], S.writeUInt32BE(B, X, H), S.writeUInt32BE(B, Q, H + 4);
  }, h.prototype._pad = function(P, I) {
    if (this.padding === !1)
      return !1;
    for (var B = P.length - I, H = I; H < P.length; H++)
      P[H] = B;
    return !0;
  }, h.prototype._unpad = function(P) {
    if (this.padding === !1)
      return P;
    for (var I = P[P.length - 1], B = P.length - I; B < P.length; B++)
      e.equal(P[B], I);
    return P.slice(0, P.length - I);
  }, h.prototype._encrypt = function(P, I, B, H, V) {
    for (var X = I, Q = B, ee = 0; ee < P.keys.length; ee += 2) {
      var ie = P.keys[ee], te = P.keys[ee + 1];
      S.expand(Q, P.tmp, 0), ie ^= P.tmp[0], te ^= P.tmp[1];
      var se = S.substitute(ie, te), le = S.permute(se), ce = Q;
      Q = (X ^ le) >>> 0, X = ce;
    }
    S.rip(Q, X, H, V);
  }, h.prototype._decrypt = function(P, I, B, H, V) {
    for (var X = B, Q = I, ee = P.keys.length - 2; ee >= 0; ee -= 2) {
      var ie = P.keys[ee], te = P.keys[ee + 1];
      S.expand(X, P.tmp, 0), ie ^= P.tmp[0], te ^= P.tmp[1];
      var se = S.substitute(ie, te), le = S.permute(se), ce = X;
      X = (Q ^ le) >>> 0, Q = ce;
    }
    S.rip(X, Q, H, V);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1)
    return cbc$1;
  hasRequiredCbc$1 = 1;
  var e = requireMinimalisticAssert(), o = requireInherits_browser(), S = {};
  function g(h) {
    e.equal(h.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var q = 0; q < this.iv.length; q++)
      this.iv[q] = h[q];
  }
  function U(h) {
    function q(B) {
      h.call(this, B), this._cbcInit();
    }
    o(q, h);
    for (var A = Object.keys(S), P = 0; P < A.length; P++) {
      var I = A[P];
      q.prototype[I] = S[I];
    }
    return q.create = function(H) {
      return new q(H);
    }, q;
  }
  return cbc$1.instantiate = U, S._cbcInit = function() {
    var q = new g(this.options.iv);
    this._cbcState = q;
  }, S._update = function(q, A, P, I) {
    var B = this._cbcState, H = this.constructor.super_.prototype, V = B.iv;
    if (this.type === "encrypt") {
      for (var X = 0; X < this.blockSize; X++)
        V[X] ^= q[A + X];
      H._update.call(this, V, 0, P, I);
      for (var X = 0; X < this.blockSize; X++)
        V[X] = P[I + X];
    } else {
      H._update.call(this, q, A, P, I);
      for (var X = 0; X < this.blockSize; X++)
        P[I + X] ^= V[X];
      for (var X = 0; X < this.blockSize; X++)
        V[X] = q[A + X];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde)
    return ede;
  hasRequiredEde = 1;
  var e = requireMinimalisticAssert(), o = requireInherits_browser(), S = requireCipher(), g = requireDes$1();
  function U(q, A) {
    e.equal(A.length, 24, "Invalid key length");
    var P = A.slice(0, 8), I = A.slice(8, 16), B = A.slice(16, 24);
    q === "encrypt" ? this.ciphers = [
      g.create({ type: "encrypt", key: P }),
      g.create({ type: "decrypt", key: I }),
      g.create({ type: "encrypt", key: B })
    ] : this.ciphers = [
      g.create({ type: "decrypt", key: B }),
      g.create({ type: "encrypt", key: I }),
      g.create({ type: "decrypt", key: P })
    ];
  }
  function h(q) {
    S.call(this, q);
    var A = new U(this.type, this.options.key);
    this._edeState = A;
  }
  return o(h, S), ede = h, h.create = function(A) {
    return new h(A);
  }, h.prototype._update = function(A, P, I, B) {
    var H = this._edeState;
    H.ciphers[0]._update(A, P, I, B), H.ciphers[1]._update(I, B, I, B), H.ciphers[2]._update(I, B, I, B);
  }, h.prototype._pad = g.prototype._pad, h.prototype._unpad = g.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes)
    return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var e = requireCipherBase(), o = requireDes(), S = requireInherits_browser(), g = requireSafeBuffer$1().Buffer, U = {
    "des-ede3-cbc": o.CBC.instantiate(o.EDE),
    "des-ede3": o.EDE,
    "des-ede-cbc": o.CBC.instantiate(o.EDE),
    "des-ede": o.EDE,
    "des-cbc": o.CBC.instantiate(o.DES),
    "des-ecb": o.DES
  };
  U.des = U["des-cbc"], U.des3 = U["des-ede3-cbc"], browserifyDes = h, S(h, e);
  function h(q) {
    e.call(this);
    var A = q.mode.toLowerCase(), P = U[A], I;
    q.decrypt ? I = "decrypt" : I = "encrypt";
    var B = q.key;
    g.isBuffer(B) || (B = g.from(B)), (A === "des-ede" || A === "des-ede-cbc") && (B = g.concat([B, B.slice(0, 8)]));
    var H = q.iv;
    g.isBuffer(H) || (H = g.from(H)), this._des = P.create({
      key: B,
      iv: H,
      type: I
    });
  }
  return h.prototype._update = function(q) {
    return g.from(this._des.update(q));
  }, h.prototype._final = function() {
    return g.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(e, o) {
    return e._cipher.encryptBlock(o);
  }, ecb.decrypt = function(e, o) {
    return e._cipher.decryptBlock(o);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(o, S) {
    for (var g = Math.min(o.length, S.length), U = new buffer$3.Buffer(g), h = 0; h < g; ++h)
      U[h] = o[h] ^ S[h];
    return U;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc)
    return cbc;
  hasRequiredCbc = 1;
  var e = requireBufferXor();
  return cbc.encrypt = function(o, S) {
    var g = e(S, o._prev);
    return o._prev = o._cipher.encryptBlock(g), o._prev;
  }, cbc.decrypt = function(o, S) {
    var g = o._prev;
    o._prev = S;
    var U = o._cipher.decryptBlock(S);
    return e(U, g);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb)
    return cfb;
  hasRequiredCfb = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireBufferXor();
  function S(g, U, h) {
    var q = U.length, A = o(U, g._cache);
    return g._cache = g._cache.slice(q), g._prev = e.concat([g._prev, h ? U : A]), A;
  }
  return cfb.encrypt = function(g, U, h) {
    for (var q = e.allocUnsafe(0), A; U.length; )
      if (g._cache.length === 0 && (g._cache = g._cipher.encryptBlock(g._prev), g._prev = e.allocUnsafe(0)), g._cache.length <= U.length)
        A = g._cache.length, q = e.concat([q, S(g, U.slice(0, A), h)]), U = U.slice(A);
      else {
        q = e.concat([q, S(g, U, h)]);
        break;
      }
    return q;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8)
    return cfb8;
  hasRequiredCfb8 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function o(S, g, U) {
    var h = S._cipher.encryptBlock(S._prev), q = h[0] ^ g;
    return S._prev = e.concat([
      S._prev.slice(1),
      e.from([U ? g : q])
    ]), q;
  }
  return cfb8.encrypt = function(S, g, U) {
    for (var h = g.length, q = e.allocUnsafe(h), A = -1; ++A < h; )
      q[A] = o(S, g[A], U);
    return q;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1)
    return cfb1;
  hasRequiredCfb1 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function o(g, U, h) {
    for (var q, A = -1, P = 8, I = 0, B, H; ++A < P; )
      q = g._cipher.encryptBlock(g._prev), B = U & 1 << 7 - A ? 128 : 0, H = q[0] ^ B, I += (H & 128) >> A % 8, g._prev = S(g._prev, h ? B : H);
    return I;
  }
  function S(g, U) {
    var h = g.length, q = -1, A = e.allocUnsafe(g.length);
    for (g = e.concat([g, e.from([U])]); ++q < h; )
      A[q] = g[q] << 1 | g[q + 1] >> 7;
    return A;
  }
  return cfb1.encrypt = function(g, U, h) {
    for (var q = U.length, A = e.allocUnsafe(q), P = -1; ++P < q; )
      A[P] = o(g, U[P], h);
    return A;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb)
    return ofb;
  hasRequiredOfb = 1;
  var e = requireBufferXor();
  function o(S) {
    return S._prev = S._cipher.encryptBlock(S._prev), S._prev;
  }
  return ofb.encrypt = function(S, g) {
    for (; S._cache.length < g.length; )
      S._cache = buffer$3.Buffer.concat([S._cache, o(S)]);
    var U = S._cache.slice(0, g.length);
    return S._cache = S._cache.slice(g.length), e(g, U);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32)
    return incr32_1;
  hasRequiredIncr32 = 1;
  function e(o) {
    for (var S = o.length, g; S--; )
      if (g = o.readUInt8(S), g === 255)
        o.writeUInt8(0, S);
      else {
        g++, o.writeUInt8(g, S);
        break;
      }
  }
  return incr32_1 = e, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr)
    return ctr;
  hasRequiredCtr = 1;
  var e = requireBufferXor(), o = requireSafeBuffer$1().Buffer, S = requireIncr32();
  function g(h) {
    var q = h._cipher.encryptBlockRaw(h._prev);
    return S(h._prev), q;
  }
  var U = 16;
  return ctr.encrypt = function(h, q) {
    var A = Math.ceil(q.length / U), P = h._cache.length;
    h._cache = o.concat([
      h._cache,
      o.allocUnsafe(A * U)
    ]);
    for (var I = 0; I < A; I++) {
      var B = g(h), H = P + I * U;
      h._cache.writeUInt32BE(B[0], H + 0), h._cache.writeUInt32BE(B[1], H + 4), h._cache.writeUInt32BE(B[2], H + 8), h._cache.writeUInt32BE(B[3], H + 12);
    }
    var V = h._cache.slice(0, q.length);
    return h._cache = h._cache.slice(q.length), e(q, V);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1)
    return modes_1;
  hasRequiredModes$1 = 1;
  var e = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, o = require$$2;
  for (var S in o)
    o[S].module = e[o[S].mode];
  return modes_1 = o, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes;
  hasRequiredAes = 1;
  var e = requireSafeBuffer$1().Buffer;
  function o(A) {
    e.isBuffer(A) || (A = e.from(A));
    for (var P = A.length / 4 | 0, I = new Array(P), B = 0; B < P; B++)
      I[B] = A.readUInt32BE(B * 4);
    return I;
  }
  function S(A) {
    for (var P = 0; P < A.length; A++)
      A[P] = 0;
  }
  function g(A, P, I, B, H) {
    for (var V = I[0], X = I[1], Q = I[2], ee = I[3], ie = A[0] ^ P[0], te = A[1] ^ P[1], se = A[2] ^ P[2], le = A[3] ^ P[3], ce, pe, me, Me, Ee = 4, Re = 1; Re < H; Re++)
      ce = V[ie >>> 24] ^ X[te >>> 16 & 255] ^ Q[se >>> 8 & 255] ^ ee[le & 255] ^ P[Ee++], pe = V[te >>> 24] ^ X[se >>> 16 & 255] ^ Q[le >>> 8 & 255] ^ ee[ie & 255] ^ P[Ee++], me = V[se >>> 24] ^ X[le >>> 16 & 255] ^ Q[ie >>> 8 & 255] ^ ee[te & 255] ^ P[Ee++], Me = V[le >>> 24] ^ X[ie >>> 16 & 255] ^ Q[te >>> 8 & 255] ^ ee[se & 255] ^ P[Ee++], ie = ce, te = pe, se = me, le = Me;
    return ce = (B[ie >>> 24] << 24 | B[te >>> 16 & 255] << 16 | B[se >>> 8 & 255] << 8 | B[le & 255]) ^ P[Ee++], pe = (B[te >>> 24] << 24 | B[se >>> 16 & 255] << 16 | B[le >>> 8 & 255] << 8 | B[ie & 255]) ^ P[Ee++], me = (B[se >>> 24] << 24 | B[le >>> 16 & 255] << 16 | B[ie >>> 8 & 255] << 8 | B[te & 255]) ^ P[Ee++], Me = (B[le >>> 24] << 24 | B[ie >>> 16 & 255] << 16 | B[te >>> 8 & 255] << 8 | B[se & 255]) ^ P[Ee++], ce = ce >>> 0, pe = pe >>> 0, me = me >>> 0, Me = Me >>> 0, [ce, pe, me, Me];
  }
  var U = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], h = function() {
    for (var A = new Array(256), P = 0; P < 256; P++)
      P < 128 ? A[P] = P << 1 : A[P] = P << 1 ^ 283;
    for (var I = [], B = [], H = [[], [], [], []], V = [[], [], [], []], X = 0, Q = 0, ee = 0; ee < 256; ++ee) {
      var ie = Q ^ Q << 1 ^ Q << 2 ^ Q << 3 ^ Q << 4;
      ie = ie >>> 8 ^ ie & 255 ^ 99, I[X] = ie, B[ie] = X;
      var te = A[X], se = A[te], le = A[se], ce = A[ie] * 257 ^ ie * 16843008;
      H[0][X] = ce << 24 | ce >>> 8, H[1][X] = ce << 16 | ce >>> 16, H[2][X] = ce << 8 | ce >>> 24, H[3][X] = ce, ce = le * 16843009 ^ se * 65537 ^ te * 257 ^ X * 16843008, V[0][ie] = ce << 24 | ce >>> 8, V[1][ie] = ce << 16 | ce >>> 16, V[2][ie] = ce << 8 | ce >>> 24, V[3][ie] = ce, X === 0 ? X = Q = 1 : (X = te ^ A[A[A[le ^ te]]], Q ^= A[A[Q]]);
    }
    return {
      SBOX: I,
      INV_SBOX: B,
      SUB_MIX: H,
      INV_SUB_MIX: V
    };
  }();
  function q(A) {
    this._key = o(A), this._reset();
  }
  return q.blockSize = 4 * 4, q.keySize = 256 / 8, q.prototype.blockSize = q.blockSize, q.prototype.keySize = q.keySize, q.prototype._reset = function() {
    for (var A = this._key, P = A.length, I = P + 6, B = (I + 1) * 4, H = [], V = 0; V < P; V++)
      H[V] = A[V];
    for (V = P; V < B; V++) {
      var X = H[V - 1];
      V % P === 0 ? (X = X << 8 | X >>> 24, X = h.SBOX[X >>> 24] << 24 | h.SBOX[X >>> 16 & 255] << 16 | h.SBOX[X >>> 8 & 255] << 8 | h.SBOX[X & 255], X ^= U[V / P | 0] << 24) : P > 6 && V % P === 4 && (X = h.SBOX[X >>> 24] << 24 | h.SBOX[X >>> 16 & 255] << 16 | h.SBOX[X >>> 8 & 255] << 8 | h.SBOX[X & 255]), H[V] = H[V - P] ^ X;
    }
    for (var Q = [], ee = 0; ee < B; ee++) {
      var ie = B - ee, te = H[ie - (ee % 4 ? 0 : 4)];
      ee < 4 || ie <= 4 ? Q[ee] = te : Q[ee] = h.INV_SUB_MIX[0][h.SBOX[te >>> 24]] ^ h.INV_SUB_MIX[1][h.SBOX[te >>> 16 & 255]] ^ h.INV_SUB_MIX[2][h.SBOX[te >>> 8 & 255]] ^ h.INV_SUB_MIX[3][h.SBOX[te & 255]];
    }
    this._nRounds = I, this._keySchedule = H, this._invKeySchedule = Q;
  }, q.prototype.encryptBlockRaw = function(A) {
    return A = o(A), g(A, this._keySchedule, h.SUB_MIX, h.SBOX, this._nRounds);
  }, q.prototype.encryptBlock = function(A) {
    var P = this.encryptBlockRaw(A), I = e.allocUnsafe(16);
    return I.writeUInt32BE(P[0], 0), I.writeUInt32BE(P[1], 4), I.writeUInt32BE(P[2], 8), I.writeUInt32BE(P[3], 12), I;
  }, q.prototype.decryptBlock = function(A) {
    A = o(A);
    var P = A[1];
    A[1] = A[3], A[3] = P;
    var I = g(A, this._invKeySchedule, h.INV_SUB_MIX, h.INV_SBOX, this._nRounds), B = e.allocUnsafe(16);
    return B.writeUInt32BE(I[0], 0), B.writeUInt32BE(I[3], 4), B.writeUInt32BE(I[2], 8), B.writeUInt32BE(I[1], 12), B;
  }, q.prototype.scrub = function() {
    S(this._keySchedule), S(this._invKeySchedule), S(this._key);
  }, aes.AES = q, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash)
    return ghash;
  hasRequiredGhash = 1;
  var e = requireSafeBuffer$1().Buffer, o = e.alloc(16, 0);
  function S(h) {
    return [
      h.readUInt32BE(0),
      h.readUInt32BE(4),
      h.readUInt32BE(8),
      h.readUInt32BE(12)
    ];
  }
  function g(h) {
    var q = e.allocUnsafe(16);
    return q.writeUInt32BE(h[0] >>> 0, 0), q.writeUInt32BE(h[1] >>> 0, 4), q.writeUInt32BE(h[2] >>> 0, 8), q.writeUInt32BE(h[3] >>> 0, 12), q;
  }
  function U(h) {
    this.h = h, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return U.prototype.ghash = function(h) {
    for (var q = -1; ++q < h.length; )
      this.state[q] ^= h[q];
    this._multiply();
  }, U.prototype._multiply = function() {
    for (var h = S(this.h), q = [0, 0, 0, 0], A, P, I, B = -1; ++B < 128; ) {
      for (P = (this.state[~~(B / 8)] & 1 << 7 - B % 8) !== 0, P && (q[0] ^= h[0], q[1] ^= h[1], q[2] ^= h[2], q[3] ^= h[3]), I = (h[3] & 1) !== 0, A = 3; A > 0; A--)
        h[A] = h[A] >>> 1 | (h[A - 1] & 1) << 31;
      h[0] = h[0] >>> 1, I && (h[0] = h[0] ^ 225 << 24);
    }
    this.state = g(q);
  }, U.prototype.update = function(h) {
    this.cache = e.concat([this.cache, h]);
    for (var q; this.cache.length >= 16; )
      q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(q);
  }, U.prototype.final = function(h, q) {
    return this.cache.length && this.ghash(e.concat([this.cache, o], 16)), this.ghash(g([0, h, 0, q])), this.state;
  }, ghash = U, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher)
    return authCipher;
  hasRequiredAuthCipher = 1;
  var e = requireAes(), o = requireSafeBuffer$1().Buffer, S = requireCipherBase(), g = requireInherits_browser(), U = requireGhash(), h = requireBufferXor(), q = requireIncr32();
  function A(B, H) {
    var V = 0;
    B.length !== H.length && V++;
    for (var X = Math.min(B.length, H.length), Q = 0; Q < X; ++Q)
      V += B[Q] ^ H[Q];
    return V;
  }
  function P(B, H, V) {
    if (H.length === 12)
      return B._finID = o.concat([H, o.from([0, 0, 0, 1])]), o.concat([H, o.from([0, 0, 0, 2])]);
    var X = new U(V), Q = H.length, ee = Q % 16;
    X.update(H), ee && (ee = 16 - ee, X.update(o.alloc(ee, 0))), X.update(o.alloc(8, 0));
    var ie = Q * 8, te = o.alloc(8);
    te.writeUIntBE(ie, 0, 8), X.update(te), B._finID = X.state;
    var se = o.from(B._finID);
    return q(se), se;
  }
  function I(B, H, V, X) {
    S.call(this);
    var Q = o.alloc(4, 0);
    this._cipher = new e.AES(H);
    var ee = this._cipher.encryptBlock(Q);
    this._ghash = new U(ee), V = P(this, V, ee), this._prev = o.from(V), this._cache = o.allocUnsafe(0), this._secCache = o.allocUnsafe(0), this._decrypt = X, this._alen = 0, this._len = 0, this._mode = B, this._authTag = null, this._called = !1;
  }
  return g(I, S), I.prototype._update = function(B) {
    if (!this._called && this._alen) {
      var H = 16 - this._alen % 16;
      H < 16 && (H = o.alloc(H, 0), this._ghash.update(H));
    }
    this._called = !0;
    var V = this._mode.encrypt(this, B);
    return this._decrypt ? this._ghash.update(B) : this._ghash.update(V), this._len += B.length, V;
  }, I.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var B = h(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && A(B, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = B, this._cipher.scrub();
  }, I.prototype.getAuthTag = function() {
    if (this._decrypt || !o.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, I.prototype.setAuthTag = function(H) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = H;
  }, I.prototype.setAAD = function(H) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(H), this._alen += H.length;
  }, authCipher = I, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher)
    return streamCipher;
  hasRequiredStreamCipher = 1;
  var e = requireAes(), o = requireSafeBuffer$1().Buffer, S = requireCipherBase(), g = requireInherits_browser();
  function U(h, q, A, P) {
    S.call(this), this._cipher = new e.AES(q), this._prev = o.from(A), this._cache = o.allocUnsafe(0), this._secCache = o.allocUnsafe(0), this._decrypt = P, this._mode = h;
  }
  return g(U, S), U.prototype._update = function(h) {
    return this._mode.encrypt(this, h, this._decrypt);
  }, U.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = U, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey)
    return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireMd5_js();
  function S(g, U, h, q) {
    if (e.isBuffer(g) || (g = e.from(g, "binary")), U && (e.isBuffer(U) || (U = e.from(U, "binary")), U.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var A = h / 8, P = e.alloc(A), I = e.alloc(q || 0), B = e.alloc(0); A > 0 || q > 0; ) {
      var H = new o();
      H.update(B), H.update(g), U && H.update(U), B = H.digest();
      var V = 0;
      if (A > 0) {
        var X = P.length - A;
        V = Math.min(A, B.length), B.copy(P, X, 0, V), A -= V;
      }
      if (V < B.length && q > 0) {
        var Q = I.length - q, ee = Math.min(q, B.length - V);
        B.copy(I, Q, V, V + ee), q -= ee;
      }
    }
    return B.fill(0), { key: P, iv: I };
  }
  return evp_bytestokey = S, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter)
    return encrypter;
  hasRequiredEncrypter = 1;
  var e = requireModes$1(), o = requireAuthCipher(), S = requireSafeBuffer$1().Buffer, g = requireStreamCipher(), U = requireCipherBase(), h = requireAes(), q = requireEvp_bytestokey(), A = requireInherits_browser();
  function P(X, Q, ee) {
    U.call(this), this._cache = new B(), this._cipher = new h.AES(Q), this._prev = S.from(ee), this._mode = X, this._autopadding = !0;
  }
  A(P, U), P.prototype._update = function(X) {
    this._cache.add(X);
    for (var Q, ee, ie = []; Q = this._cache.get(); )
      ee = this._mode.encrypt(this, Q), ie.push(ee);
    return S.concat(ie);
  };
  var I = S.alloc(16, 16);
  P.prototype._final = function() {
    var X = this._cache.flush();
    if (this._autopadding)
      return X = this._mode.encrypt(this, X), this._cipher.scrub(), X;
    if (!X.equals(I))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, P.prototype.setAutoPadding = function(X) {
    return this._autopadding = !!X, this;
  };
  function B() {
    this.cache = S.allocUnsafe(0);
  }
  B.prototype.add = function(X) {
    this.cache = S.concat([this.cache, X]);
  }, B.prototype.get = function() {
    if (this.cache.length > 15) {
      var X = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), X;
    }
    return null;
  }, B.prototype.flush = function() {
    for (var X = 16 - this.cache.length, Q = S.allocUnsafe(X), ee = -1; ++ee < X; )
      Q.writeUInt8(X, ee);
    return S.concat([this.cache, Q]);
  };
  function H(X, Q, ee) {
    var ie = e[X.toLowerCase()];
    if (!ie)
      throw new TypeError("invalid suite type");
    if (typeof Q == "string" && (Q = S.from(Q)), Q.length !== ie.key / 8)
      throw new TypeError("invalid key length " + Q.length);
    if (typeof ee == "string" && (ee = S.from(ee)), ie.mode !== "GCM" && ee.length !== ie.iv)
      throw new TypeError("invalid iv length " + ee.length);
    return ie.type === "stream" ? new g(ie.module, Q, ee) : ie.type === "auth" ? new o(ie.module, Q, ee) : new P(ie.module, Q, ee);
  }
  function V(X, Q) {
    var ee = e[X.toLowerCase()];
    if (!ee)
      throw new TypeError("invalid suite type");
    var ie = q(Q, !1, ee.key, ee.iv);
    return H(X, ie.key, ie.iv);
  }
  return encrypter.createCipheriv = H, encrypter.createCipher = V, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter)
    return decrypter;
  hasRequiredDecrypter = 1;
  var e = requireAuthCipher(), o = requireSafeBuffer$1().Buffer, S = requireModes$1(), g = requireStreamCipher(), U = requireCipherBase(), h = requireAes(), q = requireEvp_bytestokey(), A = requireInherits_browser();
  function P(X, Q, ee) {
    U.call(this), this._cache = new I(), this._last = void 0, this._cipher = new h.AES(Q), this._prev = o.from(ee), this._mode = X, this._autopadding = !0;
  }
  A(P, U), P.prototype._update = function(X) {
    this._cache.add(X);
    for (var Q, ee, ie = []; Q = this._cache.get(this._autopadding); )
      ee = this._mode.decrypt(this, Q), ie.push(ee);
    return o.concat(ie);
  }, P.prototype._final = function() {
    var X = this._cache.flush();
    if (this._autopadding)
      return B(this._mode.decrypt(this, X));
    if (X)
      throw new Error("data not multiple of block length");
  }, P.prototype.setAutoPadding = function(X) {
    return this._autopadding = !!X, this;
  };
  function I() {
    this.cache = o.allocUnsafe(0);
  }
  I.prototype.add = function(X) {
    this.cache = o.concat([this.cache, X]);
  }, I.prototype.get = function(X) {
    var Q;
    if (X) {
      if (this.cache.length > 16)
        return Q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Q;
    } else if (this.cache.length >= 16)
      return Q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Q;
    return null;
  }, I.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function B(X) {
    var Q = X[15];
    if (Q < 1 || Q > 16)
      throw new Error("unable to decrypt data");
    for (var ee = -1; ++ee < Q; )
      if (X[ee + (16 - Q)] !== Q)
        throw new Error("unable to decrypt data");
    if (Q !== 16)
      return X.slice(0, 16 - Q);
  }
  function H(X, Q, ee) {
    var ie = S[X.toLowerCase()];
    if (!ie)
      throw new TypeError("invalid suite type");
    if (typeof ee == "string" && (ee = o.from(ee)), ie.mode !== "GCM" && ee.length !== ie.iv)
      throw new TypeError("invalid iv length " + ee.length);
    if (typeof Q == "string" && (Q = o.from(Q)), Q.length !== ie.key / 8)
      throw new TypeError("invalid key length " + Q.length);
    return ie.type === "stream" ? new g(ie.module, Q, ee, !0) : ie.type === "auth" ? new e(ie.module, Q, ee, !0) : new P(ie.module, Q, ee);
  }
  function V(X, Q) {
    var ee = S[X.toLowerCase()];
    if (!ee)
      throw new TypeError("invalid suite type");
    var ie = q(Q, !1, ee.key, ee.iv);
    return H(X, ie.key, ie.iv);
  }
  return decrypter.createDecipher = V, decrypter.createDecipheriv = H, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6)
    return browser$5;
  hasRequiredBrowser$6 = 1;
  var e = requireEncrypter(), o = requireDecrypter(), S = require$$2;
  function g() {
    return Object.keys(S);
  }
  return browser$5.createCipher = browser$5.Cipher = e.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = e.createCipheriv, browser$5.createDecipher = browser$5.Decipher = o.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = o.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = g, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5)
    return browser$6;
  hasRequiredBrowser$5 = 1;
  var e = requireBrowserifyDes(), o = requireBrowser$6(), S = requireModes$1(), g = requireModes(), U = requireEvp_bytestokey();
  function h(B, H) {
    B = B.toLowerCase();
    var V, X;
    if (S[B])
      V = S[B].key, X = S[B].iv;
    else if (g[B])
      V = g[B].key * 8, X = g[B].iv;
    else
      throw new TypeError("invalid suite type");
    var Q = U(H, !1, V, X);
    return A(B, Q.key, Q.iv);
  }
  function q(B, H) {
    B = B.toLowerCase();
    var V, X;
    if (S[B])
      V = S[B].key, X = S[B].iv;
    else if (g[B])
      V = g[B].key * 8, X = g[B].iv;
    else
      throw new TypeError("invalid suite type");
    var Q = U(H, !1, V, X);
    return P(B, Q.key, Q.iv);
  }
  function A(B, H, V) {
    if (B = B.toLowerCase(), S[B])
      return o.createCipheriv(B, H, V);
    if (g[B])
      return new e({ key: H, iv: V, mode: B });
    throw new TypeError("invalid suite type");
  }
  function P(B, H, V) {
    if (B = B.toLowerCase(), S[B])
      return o.createDecipheriv(B, H, V);
    if (g[B])
      return new e({ key: H, iv: V, mode: B, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function I() {
    return Object.keys(g).concat(o.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = h, browser$6.createCipheriv = browser$6.Cipheriv = A, browser$6.createDecipher = browser$6.Decipher = q, browser$6.createDecipheriv = browser$6.Decipheriv = P, browser$6.listCiphers = browser$6.getCiphers = I, browser$6;
}
var browser$4 = {}, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var e;
  brorand.exports = function(U) {
    return e || (e = new o(null)), e.generate(U);
  };
  function o(g) {
    this.rand = g;
  }
  if (brorand.exports.Rand = o, o.prototype.generate = function(U) {
    return this._rand(U);
  }, o.prototype._rand = function(U) {
    if (this.rand.getBytes)
      return this.rand.getBytes(U);
    for (var h = new Uint8Array(U), q = 0; q < h.length; q++)
      h[q] = this.rand.getByte();
    return h;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? o.prototype._rand = function(U) {
      var h = new Uint8Array(U);
      return self.crypto.getRandomValues(h), h;
    } : self.msCrypto && self.msCrypto.getRandomValues ? o.prototype._rand = function(U) {
      var h = new Uint8Array(U);
      return self.msCrypto.getRandomValues(h), h;
    } : typeof window == "object" && (o.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var S = requireCryptoBrowserify();
      if (typeof S.randomBytes != "function")
        throw new Error("Not supported");
      o.prototype._rand = function(U) {
        return S.randomBytes(U);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var e = bnExports, o = requireBrorand();
  function S(g) {
    this.rand = g || new o.Rand();
  }
  return mr = S, S.create = function(U) {
    return new S(U);
  }, S.prototype._randbelow = function(U) {
    var h = U.bitLength(), q = Math.ceil(h / 8);
    do
      var A = new e(this.rand.generate(q));
    while (A.cmp(U) >= 0);
    return A;
  }, S.prototype._randrange = function(U, h) {
    var q = h.sub(U);
    return U.add(this._randbelow(q));
  }, S.prototype.test = function(U, h, q) {
    var A = U.bitLength(), P = e.mont(U), I = new e(1).toRed(P);
    h || (h = Math.max(1, A / 48 | 0));
    for (var B = U.subn(1), H = 0; !B.testn(H); H++)
      ;
    for (var V = U.shrn(H), X = B.toRed(P), Q = !0; h > 0; h--) {
      var ee = this._randrange(new e(2), B);
      q && q(ee);
      var ie = ee.toRed(P).redPow(V);
      if (!(ie.cmp(I) === 0 || ie.cmp(X) === 0)) {
        for (var te = 1; te < H; te++) {
          if (ie = ie.redSqr(), ie.cmp(I) === 0)
            return !1;
          if (ie.cmp(X) === 0)
            break;
        }
        if (te === H)
          return !1;
      }
    }
    return Q;
  }, S.prototype.getDivisor = function(U, h) {
    var q = U.bitLength(), A = e.mont(U), P = new e(1).toRed(A);
    h || (h = Math.max(1, q / 48 | 0));
    for (var I = U.subn(1), B = 0; !I.testn(B); B++)
      ;
    for (var H = U.shrn(B), V = I.toRed(A); h > 0; h--) {
      var X = this._randrange(new e(2), I), Q = U.gcd(X);
      if (Q.cmpn(1) !== 0)
        return Q;
      var ee = X.toRed(A).redPow(H);
      if (!(ee.cmp(P) === 0 || ee.cmp(V) === 0)) {
        for (var ie = 1; ie < B; ie++) {
          if (ee = ee.redSqr(), ee.cmp(P) === 0)
            return ee.fromRed().subn(1).gcd(U);
          if (ee.cmp(V) === 0)
            break;
        }
        if (ie === B)
          return ee = ee.redSqr(), ee.fromRed().subn(1).gcd(U);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var e = requireBrowser$a();
  generatePrime = ie, ie.simpleSieve = Q, ie.fermatTest = ee;
  var o = bnExports, S = new o(24), g = requireMr(), U = new g(), h = new o(1), q = new o(2), A = new o(5);
  new o(16), new o(8);
  var P = new o(10), I = new o(3);
  new o(7);
  var B = new o(11), H = new o(4);
  new o(12);
  var V = null;
  function X() {
    if (V !== null)
      return V;
    var te = 1048576, se = [];
    se[0] = 2;
    for (var le = 1, ce = 3; ce < te; ce += 2) {
      for (var pe = Math.ceil(Math.sqrt(ce)), me = 0; me < le && se[me] <= pe && ce % se[me] !== 0; me++)
        ;
      le !== me && se[me] <= pe || (se[le++] = ce);
    }
    return V = se, se;
  }
  function Q(te) {
    for (var se = X(), le = 0; le < se.length; le++)
      if (te.modn(se[le]) === 0)
        return te.cmpn(se[le]) === 0;
    return !0;
  }
  function ee(te) {
    var se = o.mont(te);
    return q.toRed(se).redPow(te.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ie(te, se) {
    if (te < 16)
      return se === 2 || se === 5 ? new o([140, 123]) : new o([140, 39]);
    se = new o(se);
    for (var le, ce; ; ) {
      for (le = new o(e(Math.ceil(te / 8))); le.bitLength() > te; )
        le.ishrn(1);
      if (le.isEven() && le.iadd(h), le.testn(1) || le.iadd(q), se.cmp(q)) {
        if (!se.cmp(A))
          for (; le.mod(P).cmp(I); )
            le.iadd(H);
      } else
        for (; le.mod(S).cmp(B); )
          le.iadd(H);
      if (ce = le.shrn(1), Q(ce) && Q(le) && ee(ce) && ee(le) && U.test(ce) && U.test(le))
        return le;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var e = bnExports, o = requireMr(), S = new o(), g = new e(24), U = new e(11), h = new e(10), q = new e(3), A = new e(7), P = requireGeneratePrime(), I = requireBrowser$a();
  dh = Q;
  function B(ie, te) {
    return te = te || "utf8", buffer$3.Buffer.isBuffer(ie) || (ie = new buffer$3.Buffer(ie, te)), this._pub = new e(ie), this;
  }
  function H(ie, te) {
    return te = te || "utf8", buffer$3.Buffer.isBuffer(ie) || (ie = new buffer$3.Buffer(ie, te)), this._priv = new e(ie), this;
  }
  var V = {};
  function X(ie, te) {
    var se = te.toString("hex"), le = [se, ie.toString(16)].join("_");
    if (le in V)
      return V[le];
    var ce = 0;
    if (ie.isEven() || !P.simpleSieve || !P.fermatTest(ie) || !S.test(ie))
      return ce += 1, se === "02" || se === "05" ? ce += 8 : ce += 4, V[le] = ce, ce;
    S.test(ie.shrn(1)) || (ce += 2);
    var pe;
    switch (se) {
      case "02":
        ie.mod(g).cmp(U) && (ce += 8);
        break;
      case "05":
        pe = ie.mod(h), pe.cmp(q) && pe.cmp(A) && (ce += 8);
        break;
      default:
        ce += 4;
    }
    return V[le] = ce, ce;
  }
  function Q(ie, te, se) {
    this.setGenerator(te), this.__prime = new e(ie), this._prime = e.mont(this.__prime), this._primeLen = ie.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, se ? (this.setPublicKey = B, this.setPrivateKey = H) : this._primeCode = 8;
  }
  Object.defineProperty(Q.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = X(this.__prime, this.__gen)), this._primeCode;
    }
  }), Q.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(I(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, Q.prototype.computeSecret = function(ie) {
    ie = new e(ie), ie = ie.toRed(this._prime);
    var te = ie.redPow(this._priv).fromRed(), se = new buffer$3.Buffer(te.toArray()), le = this.getPrime();
    if (se.length < le.length) {
      var ce = new buffer$3.Buffer(le.length - se.length);
      ce.fill(0), se = buffer$3.Buffer.concat([ce, se]);
    }
    return se;
  }, Q.prototype.getPublicKey = function(te) {
    return ee(this._pub, te);
  }, Q.prototype.getPrivateKey = function(te) {
    return ee(this._priv, te);
  }, Q.prototype.getPrime = function(ie) {
    return ee(this.__prime, ie);
  }, Q.prototype.getGenerator = function(ie) {
    return ee(this._gen, ie);
  }, Q.prototype.setGenerator = function(ie, te) {
    return te = te || "utf8", buffer$3.Buffer.isBuffer(ie) || (ie = new buffer$3.Buffer(ie, te)), this.__gen = ie, this._gen = new e(ie), this;
  };
  function ee(ie, te) {
    var se = new buffer$3.Buffer(ie.toArray());
    return te ? se.toString(te) : se;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4)
    return browser$4;
  hasRequiredBrowser$4 = 1;
  var e = requireGeneratePrime(), o = require$$1$1, S = requireDh();
  function g(q) {
    var A = new buffer$3.Buffer(o[q].prime, "hex"), P = new buffer$3.Buffer(o[q].gen, "hex");
    return new S(A, P);
  }
  var U = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function h(q, A, P, I) {
    return buffer$3.Buffer.isBuffer(A) || U[A] === void 0 ? h(q, "binary", A, P) : (A = A || "binary", I = I || "binary", P = P || new buffer$3.Buffer([2]), buffer$3.Buffer.isBuffer(P) || (P = new buffer$3.Buffer(P, I)), typeof q == "number" ? new S(e(q, P), P, !0) : (buffer$3.Buffer.isBuffer(q) || (q = new buffer$3.Buffer(q, A)), new S(q, P, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = g, browser$4.createDiffieHellman = browser$4.DiffieHellman = h, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs)
    return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$3 > "u" || !process$3.version || process$3.version.indexOf("v0.") === 0 || process$3.version.indexOf("v1.") === 0 && process$3.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: e } : processNextickArgs.exports = process$3;
  function e(o, S, g, U) {
    if (typeof o != "function")
      throw new TypeError('"callback" argument must be a function');
    var h = arguments.length, q, A;
    switch (h) {
      case 0:
      case 1:
        return process$3.nextTick(o);
      case 2:
        return process$3.nextTick(function() {
          o.call(null, S);
        });
      case 3:
        return process$3.nextTick(function() {
          o.call(null, S, g);
        });
      case 4:
        return process$3.nextTick(function() {
          o.call(null, S, g, U);
        });
      default:
        for (q = new Array(h - 1), A = 0; A < q.length; )
          q[A++] = arguments[A];
        return process$3.nextTick(function() {
          o.apply(null, q);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray)
    return isarray;
  hasRequiredIsarray = 1;
  var e = {}.toString;
  return isarray = Array.isArray || function(o) {
    return e.call(o) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = eventsExports.EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(e, o) {
    var S = buffer$3, g = S.Buffer;
    function U(q, A) {
      for (var P in q)
        A[P] = q[P];
    }
    g.from && g.alloc && g.allocUnsafe && g.allocUnsafeSlow ? e.exports = S : (U(S, o), o.Buffer = h);
    function h(q, A, P) {
      return g(q, A, P);
    }
    U(g, h), h.from = function(q, A, P) {
      if (typeof q == "number")
        throw new TypeError("Argument must not be a number");
      return g(q, A, P);
    }, h.alloc = function(q, A, P) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      var I = g(q);
      return A !== void 0 ? typeof P == "string" ? I.fill(A, P) : I.fill(A) : I.fill(0), I;
    }, h.allocUnsafe = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return g(q);
    }, h.allocUnsafeSlow = function(q) {
      if (typeof q != "number")
        throw new TypeError("Argument must be a number");
      return S.SlowBuffer(q);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  function e(ee) {
    return Array.isArray ? Array.isArray(ee) : Q(ee) === "[object Array]";
  }
  util.isArray = e;
  function o(ee) {
    return typeof ee == "boolean";
  }
  util.isBoolean = o;
  function S(ee) {
    return ee === null;
  }
  util.isNull = S;
  function g(ee) {
    return ee == null;
  }
  util.isNullOrUndefined = g;
  function U(ee) {
    return typeof ee == "number";
  }
  util.isNumber = U;
  function h(ee) {
    return typeof ee == "string";
  }
  util.isString = h;
  function q(ee) {
    return typeof ee == "symbol";
  }
  util.isSymbol = q;
  function A(ee) {
    return ee === void 0;
  }
  util.isUndefined = A;
  function P(ee) {
    return Q(ee) === "[object RegExp]";
  }
  util.isRegExp = P;
  function I(ee) {
    return typeof ee == "object" && ee !== null;
  }
  util.isObject = I;
  function B(ee) {
    return Q(ee) === "[object Date]";
  }
  util.isDate = B;
  function H(ee) {
    return Q(ee) === "[object Error]" || ee instanceof Error;
  }
  util.isError = H;
  function V(ee) {
    return typeof ee == "function";
  }
  util.isFunction = V;
  function X(ee) {
    return ee === null || typeof ee == "boolean" || typeof ee == "number" || typeof ee == "string" || typeof ee == "symbol" || // ES6 symbol
    typeof ee > "u";
  }
  util.isPrimitive = X, util.isBuffer = buffer$3.Buffer.isBuffer;
  function Q(ee) {
    return Object.prototype.toString.call(ee);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(e) {
    function o(h, q) {
      if (!(h instanceof q))
        throw new TypeError("Cannot call a class as a function");
    }
    var S = requireSafeBuffer().Buffer, g = requireUtil$1();
    function U(h, q, A) {
      h.copy(q, A);
    }
    e.exports = function() {
      function h() {
        o(this, h), this.head = null, this.tail = null, this.length = 0;
      }
      return h.prototype.push = function(A) {
        var P = { data: A, next: null };
        this.length > 0 ? this.tail.next = P : this.head = P, this.tail = P, ++this.length;
      }, h.prototype.unshift = function(A) {
        var P = { data: A, next: this.head };
        this.length === 0 && (this.tail = P), this.head = P, ++this.length;
      }, h.prototype.shift = function() {
        if (this.length !== 0) {
          var A = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, A;
        }
      }, h.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, h.prototype.join = function(A) {
        if (this.length === 0)
          return "";
        for (var P = this.head, I = "" + P.data; P = P.next; )
          I += A + P.data;
        return I;
      }, h.prototype.concat = function(A) {
        if (this.length === 0)
          return S.alloc(0);
        for (var P = S.allocUnsafe(A >>> 0), I = this.head, B = 0; I; )
          U(I.data, P, B), B += I.data.length, I = I.next;
        return P;
      }, h;
    }(), g && g.inspect && g.inspect.custom && (e.exports.prototype[g.inspect.custom] = function() {
      var h = g.inspect({ length: this.length });
      return this.constructor.name + " " + h;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1;
  hasRequiredDestroy = 1;
  var e = requireProcessNextickArgs();
  function o(U, h) {
    var q = this, A = this._readableState && this._readableState.destroyed, P = this._writableState && this._writableState.destroyed;
    return A || P ? (h ? h(U) : U && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(g, this, U)) : e.nextTick(g, this, U)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(U || null, function(I) {
      !h && I ? q._writableState ? q._writableState.errorEmitted || (q._writableState.errorEmitted = !0, e.nextTick(g, q, I)) : e.nextTick(g, q, I) : h && h(I);
    }), this);
  }
  function S() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function g(U, h) {
    U.emit("error", h);
  }
  return destroy_1 = {
    destroy: o,
    undestroy: S
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  var e = requireProcessNextickArgs();
  _stream_writable = ee;
  function o(Z) {
    var K = this;
    this.next = null, this.entry = null, this.finish = function() {
      J(K, Z);
    };
  }
  var S = !process$3.browser && ["v0.10", "v0.9."].indexOf(process$3.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, g;
  ee.WritableState = X;
  var U = Object.create(requireUtil());
  U.inherits = requireInherits_browser();
  var h = {
    deprecate: requireBrowser$c()
  }, q = requireStreamBrowser(), A = requireSafeBuffer().Buffer, P = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function I(Z) {
    return A.from(Z);
  }
  function B(Z) {
    return A.isBuffer(Z) || Z instanceof P;
  }
  var H = requireDestroy();
  U.inherits(ee, q);
  function V() {
  }
  function X(Z, K) {
    g = g || require_stream_duplex(), Z = Z || {};
    var z = K instanceof g;
    this.objectMode = !!Z.objectMode, z && (this.objectMode = this.objectMode || !!Z.writableObjectMode);
    var G = Z.highWaterMark, D = Z.writableHighWaterMark, F = this.objectMode ? 16 : 16 * 1024;
    G || G === 0 ? this.highWaterMark = G : z && (D || D === 0) ? this.highWaterMark = D : this.highWaterMark = F, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ae = Z.decodeStrings === !1;
    this.decodeStrings = !ae, this.defaultEncoding = Z.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ge) {
      Me(K, ge);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new o(this);
  }
  X.prototype.getBuffer = function() {
    for (var K = this.bufferedRequest, z = []; K; )
      z.push(K), K = K.next;
    return z;
  }, function() {
    try {
      Object.defineProperty(X.prototype, "buffer", {
        get: h.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Q = Function.prototype[Symbol.hasInstance], Object.defineProperty(ee, Symbol.hasInstance, {
    value: function(Z) {
      return Q.call(this, Z) ? !0 : this !== ee ? !1 : Z && Z._writableState instanceof X;
    }
  })) : Q = function(Z) {
    return Z instanceof this;
  };
  function ee(Z) {
    if (g = g || require_stream_duplex(), !Q.call(ee, this) && !(this instanceof g))
      return new ee(Z);
    this._writableState = new X(Z, this), this.writable = !0, Z && (typeof Z.write == "function" && (this._write = Z.write), typeof Z.writev == "function" && (this._writev = Z.writev), typeof Z.destroy == "function" && (this._destroy = Z.destroy), typeof Z.final == "function" && (this._final = Z.final)), q.call(this);
  }
  ee.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function ie(Z, K) {
    var z = new Error("write after end");
    Z.emit("error", z), e.nextTick(K, z);
  }
  function te(Z, K, z, G) {
    var D = !0, F = !1;
    return z === null ? F = new TypeError("May not write null values to stream") : typeof z != "string" && z !== void 0 && !K.objectMode && (F = new TypeError("Invalid non-string/buffer chunk")), F && (Z.emit("error", F), e.nextTick(G, F), D = !1), D;
  }
  ee.prototype.write = function(Z, K, z) {
    var G = this._writableState, D = !1, F = !G.objectMode && B(Z);
    return F && !A.isBuffer(Z) && (Z = I(Z)), typeof K == "function" && (z = K, K = null), F ? K = "buffer" : K || (K = G.defaultEncoding), typeof z != "function" && (z = V), G.ended ? ie(this, z) : (F || te(this, G, Z, z)) && (G.pendingcb++, D = le(this, G, F, Z, K, z)), D;
  }, ee.prototype.cork = function() {
    var Z = this._writableState;
    Z.corked++;
  }, ee.prototype.uncork = function() {
    var Z = this._writableState;
    Z.corked && (Z.corked--, !Z.writing && !Z.corked && !Z.bufferProcessing && Z.bufferedRequest && Ne(this, Z));
  }, ee.prototype.setDefaultEncoding = function(K) {
    if (typeof K == "string" && (K = K.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((K + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + K);
    return this._writableState.defaultEncoding = K, this;
  };
  function se(Z, K, z) {
    return !Z.objectMode && Z.decodeStrings !== !1 && typeof K == "string" && (K = A.from(K, z)), K;
  }
  Object.defineProperty(ee.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function le(Z, K, z, G, D, F) {
    if (!z) {
      var ae = se(K, G, D);
      G !== ae && (z = !0, D = "buffer", G = ae);
    }
    var ge = K.objectMode ? 1 : G.length;
    K.length += ge;
    var xe = K.length < K.highWaterMark;
    if (xe || (K.needDrain = !0), K.writing || K.corked) {
      var ye = K.lastBufferedRequest;
      K.lastBufferedRequest = {
        chunk: G,
        encoding: D,
        isBuf: z,
        callback: F,
        next: null
      }, ye ? ye.next = K.lastBufferedRequest : K.bufferedRequest = K.lastBufferedRequest, K.bufferedRequestCount += 1;
    } else
      ce(Z, K, !1, ge, G, D, F);
    return xe;
  }
  function ce(Z, K, z, G, D, F, ae) {
    K.writelen = G, K.writecb = ae, K.writing = !0, K.sync = !0, z ? Z._writev(D, K.onwrite) : Z._write(D, F, K.onwrite), K.sync = !1;
  }
  function pe(Z, K, z, G, D) {
    --K.pendingcb, z ? (e.nextTick(D, G), e.nextTick($, Z, K), Z._writableState.errorEmitted = !0, Z.emit("error", G)) : (D(G), Z._writableState.errorEmitted = !0, Z.emit("error", G), $(Z, K));
  }
  function me(Z) {
    Z.writing = !1, Z.writecb = null, Z.length -= Z.writelen, Z.writelen = 0;
  }
  function Me(Z, K) {
    var z = Z._writableState, G = z.sync, D = z.writecb;
    if (me(z), K)
      pe(Z, z, G, K, D);
    else {
      var F = ne(z);
      !F && !z.corked && !z.bufferProcessing && z.bufferedRequest && Ne(Z, z), G ? S(Ee, Z, z, F, D) : Ee(Z, z, F, D);
    }
  }
  function Ee(Z, K, z, G) {
    z || Re(Z, K), K.pendingcb--, G(), $(Z, K);
  }
  function Re(Z, K) {
    K.length === 0 && K.needDrain && (K.needDrain = !1, Z.emit("drain"));
  }
  function Ne(Z, K) {
    K.bufferProcessing = !0;
    var z = K.bufferedRequest;
    if (Z._writev && z && z.next) {
      var G = K.bufferedRequestCount, D = new Array(G), F = K.corkedRequestsFree;
      F.entry = z;
      for (var ae = 0, ge = !0; z; )
        D[ae] = z, z.isBuf || (ge = !1), z = z.next, ae += 1;
      D.allBuffers = ge, ce(Z, K, !0, K.length, D, "", F.finish), K.pendingcb++, K.lastBufferedRequest = null, F.next ? (K.corkedRequestsFree = F.next, F.next = null) : K.corkedRequestsFree = new o(K), K.bufferedRequestCount = 0;
    } else {
      for (; z; ) {
        var xe = z.chunk, ye = z.encoding, oe = z.callback, fe = K.objectMode ? 1 : xe.length;
        if (ce(Z, K, !1, fe, xe, ye, oe), z = z.next, K.bufferedRequestCount--, K.writing)
          break;
      }
      z === null && (K.lastBufferedRequest = null);
    }
    K.bufferedRequest = z, K.bufferProcessing = !1;
  }
  ee.prototype._write = function(Z, K, z) {
    z(new Error("_write() is not implemented"));
  }, ee.prototype._writev = null, ee.prototype.end = function(Z, K, z) {
    var G = this._writableState;
    typeof Z == "function" ? (z = Z, Z = null, K = null) : typeof K == "function" && (z = K, K = null), Z != null && this.write(Z, K), G.corked && (G.corked = 1, this.uncork()), G.ending || O(this, G, z);
  };
  function ne(Z) {
    return Z.ending && Z.length === 0 && Z.bufferedRequest === null && !Z.finished && !Z.writing;
  }
  function Y(Z, K) {
    Z._final(function(z) {
      K.pendingcb--, z && Z.emit("error", z), K.prefinished = !0, Z.emit("prefinish"), $(Z, K);
    });
  }
  function M(Z, K) {
    !K.prefinished && !K.finalCalled && (typeof Z._final == "function" ? (K.pendingcb++, K.finalCalled = !0, e.nextTick(Y, Z, K)) : (K.prefinished = !0, Z.emit("prefinish")));
  }
  function $(Z, K) {
    var z = ne(K);
    return z && (M(Z, K), K.pendingcb === 0 && (K.finished = !0, Z.emit("finish"))), z;
  }
  function O(Z, K, z) {
    K.ending = !0, $(Z, K), z && (K.finished ? e.nextTick(z) : Z.once("finish", z)), K.ended = !0, Z.writable = !1;
  }
  function J(Z, K, z) {
    var G = Z.entry;
    for (Z.entry = null; G; ) {
      var D = G.callback;
      K.pendingcb--, D(z), G = G.next;
    }
    K.corkedRequestsFree.next = Z;
  }
  return Object.defineProperty(ee.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Z) {
      this._writableState && (this._writableState.destroyed = Z);
    }
  }), ee.prototype.destroy = H.destroy, ee.prototype._undestroy = H.undestroy, ee.prototype._destroy = function(Z, K) {
    this.end(), K(Z);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var e = requireProcessNextickArgs(), o = Object.keys || function(H) {
    var V = [];
    for (var X in H)
      V.push(X);
    return V;
  };
  _stream_duplex = P;
  var S = Object.create(requireUtil());
  S.inherits = requireInherits_browser();
  var g = require_stream_readable(), U = require_stream_writable();
  S.inherits(P, g);
  for (var h = o(U.prototype), q = 0; q < h.length; q++) {
    var A = h[q];
    P.prototype[A] || (P.prototype[A] = U.prototype[A]);
  }
  function P(H) {
    if (!(this instanceof P))
      return new P(H);
    g.call(this, H), U.call(this, H), H && H.readable === !1 && (this.readable = !1), H && H.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, H && H.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", I);
  }
  Object.defineProperty(P.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function I() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(B, this);
  }
  function B(H) {
    H.end();
  }
  return Object.defineProperty(P.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(H) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = H, this._writableState.destroyed = H);
    }
  }), P.prototype._destroy = function(H, V) {
    this.push(null), this.end(), e.nextTick(V, H);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  var e = requireProcessNextickArgs();
  _stream_readable = se;
  var o = requireIsarray(), S;
  se.ReadableState = te, eventsExports.EventEmitter;
  var g = function(oe, fe) {
    return oe.listeners(fe).length;
  }, U = requireStreamBrowser(), h = requireSafeBuffer().Buffer, q = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function A(oe) {
    return h.from(oe);
  }
  function P(oe) {
    return h.isBuffer(oe) || oe instanceof q;
  }
  var I = Object.create(requireUtil());
  I.inherits = requireInherits_browser();
  var B = requireUtil$1(), H = void 0;
  B && B.debuglog ? H = B.debuglog("stream") : H = function() {
  };
  var V = requireBufferList(), X = requireDestroy(), Q;
  I.inherits(se, U);
  var ee = ["error", "close", "destroy", "pause", "resume"];
  function ie(oe, fe, $e) {
    if (typeof oe.prependListener == "function")
      return oe.prependListener(fe, $e);
    !oe._events || !oe._events[fe] ? oe.on(fe, $e) : o(oe._events[fe]) ? oe._events[fe].unshift($e) : oe._events[fe] = [$e, oe._events[fe]];
  }
  function te(oe, fe) {
    S = S || require_stream_duplex(), oe = oe || {};
    var $e = fe instanceof S;
    this.objectMode = !!oe.objectMode, $e && (this.objectMode = this.objectMode || !!oe.readableObjectMode);
    var Be = oe.highWaterMark, be = oe.readableHighWaterMark, ve = this.objectMode ? 16 : 16 * 1024;
    Be || Be === 0 ? this.highWaterMark = Be : $e && (be || be === 0) ? this.highWaterMark = be : this.highWaterMark = ve, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new V(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = oe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, oe.encoding && (Q || (Q = requireString_decoder().StringDecoder), this.decoder = new Q(oe.encoding), this.encoding = oe.encoding);
  }
  function se(oe) {
    if (S = S || require_stream_duplex(), !(this instanceof se))
      return new se(oe);
    this._readableState = new te(oe, this), this.readable = !0, oe && (typeof oe.read == "function" && (this._read = oe.read), typeof oe.destroy == "function" && (this._destroy = oe.destroy)), U.call(this);
  }
  Object.defineProperty(se.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(oe) {
      this._readableState && (this._readableState.destroyed = oe);
    }
  }), se.prototype.destroy = X.destroy, se.prototype._undestroy = X.undestroy, se.prototype._destroy = function(oe, fe) {
    this.push(null), fe(oe);
  }, se.prototype.push = function(oe, fe) {
    var $e = this._readableState, Be;
    return $e.objectMode ? Be = !0 : typeof oe == "string" && (fe = fe || $e.defaultEncoding, fe !== $e.encoding && (oe = h.from(oe, fe), fe = ""), Be = !0), le(this, oe, fe, !1, Be);
  }, se.prototype.unshift = function(oe) {
    return le(this, oe, null, !0, !1);
  };
  function le(oe, fe, $e, Be, be) {
    var ve = oe._readableState;
    if (fe === null)
      ve.reading = !1, Ne(oe, ve);
    else {
      var qe;
      be || (qe = pe(ve, fe)), qe ? oe.emit("error", qe) : ve.objectMode || fe && fe.length > 0 ? (typeof fe != "string" && !ve.objectMode && Object.getPrototypeOf(fe) !== h.prototype && (fe = A(fe)), Be ? ve.endEmitted ? oe.emit("error", new Error("stream.unshift() after end event")) : ce(oe, ve, fe, !0) : ve.ended ? oe.emit("error", new Error("stream.push() after EOF")) : (ve.reading = !1, ve.decoder && !$e ? (fe = ve.decoder.write(fe), ve.objectMode || fe.length !== 0 ? ce(oe, ve, fe, !1) : M(oe, ve)) : ce(oe, ve, fe, !1))) : Be || (ve.reading = !1);
    }
    return me(ve);
  }
  function ce(oe, fe, $e, Be) {
    fe.flowing && fe.length === 0 && !fe.sync ? (oe.emit("data", $e), oe.read(0)) : (fe.length += fe.objectMode ? 1 : $e.length, Be ? fe.buffer.unshift($e) : fe.buffer.push($e), fe.needReadable && ne(oe)), M(oe, fe);
  }
  function pe(oe, fe) {
    var $e;
    return !P(fe) && typeof fe != "string" && fe !== void 0 && !oe.objectMode && ($e = new TypeError("Invalid non-string/buffer chunk")), $e;
  }
  function me(oe) {
    return !oe.ended && (oe.needReadable || oe.length < oe.highWaterMark || oe.length === 0);
  }
  se.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, se.prototype.setEncoding = function(oe) {
    return Q || (Q = requireString_decoder().StringDecoder), this._readableState.decoder = new Q(oe), this._readableState.encoding = oe, this;
  };
  var Me = 8388608;
  function Ee(oe) {
    return oe >= Me ? oe = Me : (oe--, oe |= oe >>> 1, oe |= oe >>> 2, oe |= oe >>> 4, oe |= oe >>> 8, oe |= oe >>> 16, oe++), oe;
  }
  function Re(oe, fe) {
    return oe <= 0 || fe.length === 0 && fe.ended ? 0 : fe.objectMode ? 1 : oe !== oe ? fe.flowing && fe.length ? fe.buffer.head.data.length : fe.length : (oe > fe.highWaterMark && (fe.highWaterMark = Ee(oe)), oe <= fe.length ? oe : fe.ended ? fe.length : (fe.needReadable = !0, 0));
  }
  se.prototype.read = function(oe) {
    H("read", oe), oe = parseInt(oe, 10);
    var fe = this._readableState, $e = oe;
    if (oe !== 0 && (fe.emittedReadable = !1), oe === 0 && fe.needReadable && (fe.length >= fe.highWaterMark || fe.ended))
      return H("read: emitReadable", fe.length, fe.ended), fe.length === 0 && fe.ended ? ge(this) : ne(this), null;
    if (oe = Re(oe, fe), oe === 0 && fe.ended)
      return fe.length === 0 && ge(this), null;
    var Be = fe.needReadable;
    H("need readable", Be), (fe.length === 0 || fe.length - oe < fe.highWaterMark) && (Be = !0, H("length less than watermark", Be)), fe.ended || fe.reading ? (Be = !1, H("reading or ended", Be)) : Be && (H("do read"), fe.reading = !0, fe.sync = !0, fe.length === 0 && (fe.needReadable = !0), this._read(fe.highWaterMark), fe.sync = !1, fe.reading || (oe = Re($e, fe)));
    var be;
    return oe > 0 ? be = G(oe, fe) : be = null, be === null ? (fe.needReadable = !0, oe = 0) : fe.length -= oe, fe.length === 0 && (fe.ended || (fe.needReadable = !0), $e !== oe && fe.ended && ge(this)), be !== null && this.emit("data", be), be;
  };
  function Ne(oe, fe) {
    if (!fe.ended) {
      if (fe.decoder) {
        var $e = fe.decoder.end();
        $e && $e.length && (fe.buffer.push($e), fe.length += fe.objectMode ? 1 : $e.length);
      }
      fe.ended = !0, ne(oe);
    }
  }
  function ne(oe) {
    var fe = oe._readableState;
    fe.needReadable = !1, fe.emittedReadable || (H("emitReadable", fe.flowing), fe.emittedReadable = !0, fe.sync ? e.nextTick(Y, oe) : Y(oe));
  }
  function Y(oe) {
    H("emit readable"), oe.emit("readable"), z(oe);
  }
  function M(oe, fe) {
    fe.readingMore || (fe.readingMore = !0, e.nextTick($, oe, fe));
  }
  function $(oe, fe) {
    for (var $e = fe.length; !fe.reading && !fe.flowing && !fe.ended && fe.length < fe.highWaterMark && (H("maybeReadMore read 0"), oe.read(0), $e !== fe.length); )
      $e = fe.length;
    fe.readingMore = !1;
  }
  se.prototype._read = function(oe) {
    this.emit("error", new Error("_read() is not implemented"));
  }, se.prototype.pipe = function(oe, fe) {
    var $e = this, Be = this._readableState;
    switch (Be.pipesCount) {
      case 0:
        Be.pipes = oe;
        break;
      case 1:
        Be.pipes = [Be.pipes, oe];
        break;
      default:
        Be.pipes.push(oe);
        break;
    }
    Be.pipesCount += 1, H("pipe count=%d opts=%j", Be.pipesCount, fe);
    var be = (!fe || fe.end !== !1) && oe !== process$3.stdout && oe !== process$3.stderr, ve = be ? De : nt;
    Be.endEmitted ? e.nextTick(ve) : $e.once("end", ve), oe.on("unpipe", qe);
    function qe(Ie, Fe) {
      H("onunpipe"), Ie === $e && Fe && Fe.hasUnpiped === !1 && (Fe.hasUnpiped = !0, ue());
    }
    function De() {
      H("onend"), oe.end();
    }
    var Ye = O($e);
    oe.on("drain", Ye);
    var he = !1;
    function ue() {
      H("cleanup"), oe.removeListener("close", He), oe.removeListener("finish", Ve), oe.removeListener("drain", Ye), oe.removeListener("error", Pe), oe.removeListener("unpipe", qe), $e.removeListener("end", De), $e.removeListener("end", nt), $e.removeListener("data", _e), he = !0, Be.awaitDrain && (!oe._writableState || oe._writableState.needDrain) && Ye();
    }
    var de = !1;
    $e.on("data", _e);
    function _e(Ie) {
      H("ondata"), de = !1;
      var Fe = oe.write(Ie);
      Fe === !1 && !de && ((Be.pipesCount === 1 && Be.pipes === oe || Be.pipesCount > 1 && ye(Be.pipes, oe) !== -1) && !he && (H("false write response, pause", Be.awaitDrain), Be.awaitDrain++, de = !0), $e.pause());
    }
    function Pe(Ie) {
      H("onerror", Ie), nt(), oe.removeListener("error", Pe), g(oe, "error") === 0 && oe.emit("error", Ie);
    }
    ie(oe, "error", Pe);
    function He() {
      oe.removeListener("finish", Ve), nt();
    }
    oe.once("close", He);
    function Ve() {
      H("onfinish"), oe.removeListener("close", He), nt();
    }
    oe.once("finish", Ve);
    function nt() {
      H("unpipe"), $e.unpipe(oe);
    }
    return oe.emit("pipe", $e), Be.flowing || (H("pipe resume"), $e.resume()), oe;
  };
  function O(oe) {
    return function() {
      var fe = oe._readableState;
      H("pipeOnDrain", fe.awaitDrain), fe.awaitDrain && fe.awaitDrain--, fe.awaitDrain === 0 && g(oe, "data") && (fe.flowing = !0, z(oe));
    };
  }
  se.prototype.unpipe = function(oe) {
    var fe = this._readableState, $e = { hasUnpiped: !1 };
    if (fe.pipesCount === 0)
      return this;
    if (fe.pipesCount === 1)
      return oe && oe !== fe.pipes ? this : (oe || (oe = fe.pipes), fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1, oe && oe.emit("unpipe", this, $e), this);
    if (!oe) {
      var Be = fe.pipes, be = fe.pipesCount;
      fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1;
      for (var ve = 0; ve < be; ve++)
        Be[ve].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var qe = ye(fe.pipes, oe);
    return qe === -1 ? this : (fe.pipes.splice(qe, 1), fe.pipesCount -= 1, fe.pipesCount === 1 && (fe.pipes = fe.pipes[0]), oe.emit("unpipe", this, $e), this);
  }, se.prototype.on = function(oe, fe) {
    var $e = U.prototype.on.call(this, oe, fe);
    if (oe === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (oe === "readable") {
      var Be = this._readableState;
      !Be.endEmitted && !Be.readableListening && (Be.readableListening = Be.needReadable = !0, Be.emittedReadable = !1, Be.reading ? Be.length && ne(this) : e.nextTick(J, this));
    }
    return $e;
  }, se.prototype.addListener = se.prototype.on;
  function J(oe) {
    H("readable nexttick read 0"), oe.read(0);
  }
  se.prototype.resume = function() {
    var oe = this._readableState;
    return oe.flowing || (H("resume"), oe.flowing = !0, Z(this, oe)), this;
  };
  function Z(oe, fe) {
    fe.resumeScheduled || (fe.resumeScheduled = !0, e.nextTick(K, oe, fe));
  }
  function K(oe, fe) {
    fe.reading || (H("resume read 0"), oe.read(0)), fe.resumeScheduled = !1, fe.awaitDrain = 0, oe.emit("resume"), z(oe), fe.flowing && !fe.reading && oe.read(0);
  }
  se.prototype.pause = function() {
    return H("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (H("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function z(oe) {
    var fe = oe._readableState;
    for (H("flow", fe.flowing); fe.flowing && oe.read() !== null; )
      ;
  }
  se.prototype.wrap = function(oe) {
    var fe = this, $e = this._readableState, Be = !1;
    oe.on("end", function() {
      if (H("wrapped end"), $e.decoder && !$e.ended) {
        var qe = $e.decoder.end();
        qe && qe.length && fe.push(qe);
      }
      fe.push(null);
    }), oe.on("data", function(qe) {
      if (H("wrapped data"), $e.decoder && (qe = $e.decoder.write(qe)), !($e.objectMode && qe == null) && !(!$e.objectMode && (!qe || !qe.length))) {
        var De = fe.push(qe);
        De || (Be = !0, oe.pause());
      }
    });
    for (var be in oe)
      this[be] === void 0 && typeof oe[be] == "function" && (this[be] = /* @__PURE__ */ function(qe) {
        return function() {
          return oe[qe].apply(oe, arguments);
        };
      }(be));
    for (var ve = 0; ve < ee.length; ve++)
      oe.on(ee[ve], this.emit.bind(this, ee[ve]));
    return this._read = function(qe) {
      H("wrapped _read", qe), Be && (Be = !1, oe.resume());
    }, this;
  }, Object.defineProperty(se.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), se._fromList = G;
  function G(oe, fe) {
    if (fe.length === 0)
      return null;
    var $e;
    return fe.objectMode ? $e = fe.buffer.shift() : !oe || oe >= fe.length ? (fe.decoder ? $e = fe.buffer.join("") : fe.buffer.length === 1 ? $e = fe.buffer.head.data : $e = fe.buffer.concat(fe.length), fe.buffer.clear()) : $e = D(oe, fe.buffer, fe.decoder), $e;
  }
  function D(oe, fe, $e) {
    var Be;
    return oe < fe.head.data.length ? (Be = fe.head.data.slice(0, oe), fe.head.data = fe.head.data.slice(oe)) : oe === fe.head.data.length ? Be = fe.shift() : Be = $e ? F(oe, fe) : ae(oe, fe), Be;
  }
  function F(oe, fe) {
    var $e = fe.head, Be = 1, be = $e.data;
    for (oe -= be.length; $e = $e.next; ) {
      var ve = $e.data, qe = oe > ve.length ? ve.length : oe;
      if (qe === ve.length ? be += ve : be += ve.slice(0, oe), oe -= qe, oe === 0) {
        qe === ve.length ? (++Be, $e.next ? fe.head = $e.next : fe.head = fe.tail = null) : (fe.head = $e, $e.data = ve.slice(qe));
        break;
      }
      ++Be;
    }
    return fe.length -= Be, be;
  }
  function ae(oe, fe) {
    var $e = h.allocUnsafe(oe), Be = fe.head, be = 1;
    for (Be.data.copy($e), oe -= Be.data.length; Be = Be.next; ) {
      var ve = Be.data, qe = oe > ve.length ? ve.length : oe;
      if (ve.copy($e, $e.length - oe, 0, qe), oe -= qe, oe === 0) {
        qe === ve.length ? (++be, Be.next ? fe.head = Be.next : fe.head = fe.tail = null) : (fe.head = Be, Be.data = ve.slice(qe));
        break;
      }
      ++be;
    }
    return fe.length -= be, $e;
  }
  function ge(oe) {
    var fe = oe._readableState;
    if (fe.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    fe.endEmitted || (fe.ended = !0, e.nextTick(xe, fe, oe));
  }
  function xe(oe, fe) {
    !oe.endEmitted && oe.length === 0 && (oe.endEmitted = !0, fe.readable = !1, fe.emit("end"));
  }
  function ye(oe, fe) {
    for (var $e = 0, Be = oe.length; $e < Be; $e++)
      if (oe[$e] === fe)
        return $e;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = g;
  var e = require_stream_duplex(), o = Object.create(requireUtil());
  o.inherits = requireInherits_browser(), o.inherits(g, e);
  function S(q, A) {
    var P = this._transformState;
    P.transforming = !1;
    var I = P.writecb;
    if (!I)
      return this.emit("error", new Error("write callback called multiple times"));
    P.writechunk = null, P.writecb = null, A != null && this.push(A), I(q);
    var B = this._readableState;
    B.reading = !1, (B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark);
  }
  function g(q) {
    if (!(this instanceof g))
      return new g(q);
    e.call(this, q), this._transformState = {
      afterTransform: S.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, q && (typeof q.transform == "function" && (this._transform = q.transform), typeof q.flush == "function" && (this._flush = q.flush)), this.on("prefinish", U);
  }
  function U() {
    var q = this;
    typeof this._flush == "function" ? this._flush(function(A, P) {
      h(q, A, P);
    }) : h(this, null, null);
  }
  g.prototype.push = function(q, A) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, q, A);
  }, g.prototype._transform = function(q, A, P) {
    throw new Error("_transform() is not implemented");
  }, g.prototype._write = function(q, A, P) {
    var I = this._transformState;
    if (I.writecb = P, I.writechunk = q, I.writeencoding = A, !I.transforming) {
      var B = this._readableState;
      (I.needTransform || B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark);
    }
  }, g.prototype._read = function(q) {
    var A = this._transformState;
    A.writechunk !== null && A.writecb && !A.transforming ? (A.transforming = !0, this._transform(A.writechunk, A.writeencoding, A.afterTransform)) : A.needTransform = !0;
  }, g.prototype._destroy = function(q, A) {
    var P = this;
    e.prototype._destroy.call(this, q, function(I) {
      A(I), P.emit("close");
    });
  };
  function h(q, A, P) {
    if (A)
      return q.emit("error", A);
    if (P != null && q.push(P), q._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (q._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return q.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = S;
  var e = require_stream_transform(), o = Object.create(requireUtil());
  o.inherits = requireInherits_browser(), o.inherits(S, e);
  function S(g) {
    if (!(this instanceof S))
      return new S(g);
    e.call(this, g);
  }
  return S.prototype._transform = function(g, U, h) {
    h(null, g);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(e, o) {
    o = e.exports = require_stream_readable(), o.Stream = o, o.Readable = o, o.Writable = require_stream_writable(), o.Duplex = require_stream_duplex(), o.Transform = require_stream_transform(), o.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign$1 = { exports: {} }, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(e) {
    (function(o, S) {
      function g(M, $) {
        if (!M)
          throw new Error($ || "Assertion failed");
      }
      function U(M, $) {
        M.super_ = $;
        var O = function() {
        };
        O.prototype = $.prototype, M.prototype = new O(), M.prototype.constructor = M;
      }
      function h(M, $, O) {
        if (h.isBN(M))
          return M;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && (($ === "le" || $ === "be") && (O = $, $ = 10), this._init(M || 0, $ || 10, O || "be"));
      }
      typeof o == "object" ? o.exports = h : S.BN = h, h.BN = h, h.wordSize = 26;
      var q;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? q = window.Buffer : q = buffer$3.Buffer;
      } catch {
      }
      h.isBN = function($) {
        return $ instanceof h ? !0 : $ !== null && typeof $ == "object" && $.constructor.wordSize === h.wordSize && Array.isArray($.words);
      }, h.max = function($, O) {
        return $.cmp(O) > 0 ? $ : O;
      }, h.min = function($, O) {
        return $.cmp(O) < 0 ? $ : O;
      }, h.prototype._init = function($, O, J) {
        if (typeof $ == "number")
          return this._initNumber($, O, J);
        if (typeof $ == "object")
          return this._initArray($, O, J);
        O === "hex" && (O = 16), g(O === (O | 0) && O >= 2 && O <= 36), $ = $.toString().replace(/\s+/g, "");
        var Z = 0;
        $[0] === "-" && (Z++, this.negative = 1), Z < $.length && (O === 16 ? this._parseHex($, Z, J) : (this._parseBase($, O, Z), J === "le" && this._initArray(this.toArray(), O, J)));
      }, h.prototype._initNumber = function($, O, J) {
        $ < 0 && (this.negative = 1, $ = -$), $ < 67108864 ? (this.words = [$ & 67108863], this.length = 1) : $ < 4503599627370496 ? (this.words = [
          $ & 67108863,
          $ / 67108864 & 67108863
        ], this.length = 2) : (g($ < 9007199254740992), this.words = [
          $ & 67108863,
          $ / 67108864 & 67108863,
          1
        ], this.length = 3), J === "le" && this._initArray(this.toArray(), O, J);
      }, h.prototype._initArray = function($, O, J) {
        if (g(typeof $.length == "number"), $.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil($.length / 3), this.words = new Array(this.length);
        for (var Z = 0; Z < this.length; Z++)
          this.words[Z] = 0;
        var K, z, G = 0;
        if (J === "be")
          for (Z = $.length - 1, K = 0; Z >= 0; Z -= 3)
            z = $[Z] | $[Z - 1] << 8 | $[Z - 2] << 16, this.words[K] |= z << G & 67108863, this.words[K + 1] = z >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, K++);
        else if (J === "le")
          for (Z = 0, K = 0; Z < $.length; Z += 3)
            z = $[Z] | $[Z + 1] << 8 | $[Z + 2] << 16, this.words[K] |= z << G & 67108863, this.words[K + 1] = z >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, K++);
        return this._strip();
      };
      function A(M, $) {
        var O = M.charCodeAt($);
        if (O >= 48 && O <= 57)
          return O - 48;
        if (O >= 65 && O <= 70)
          return O - 55;
        if (O >= 97 && O <= 102)
          return O - 87;
        g(!1, "Invalid character in " + M);
      }
      function P(M, $, O) {
        var J = A(M, O);
        return O - 1 >= $ && (J |= A(M, O - 1) << 4), J;
      }
      h.prototype._parseHex = function($, O, J) {
        this.length = Math.ceil(($.length - O) / 6), this.words = new Array(this.length);
        for (var Z = 0; Z < this.length; Z++)
          this.words[Z] = 0;
        var K = 0, z = 0, G;
        if (J === "be")
          for (Z = $.length - 1; Z >= O; Z -= 2)
            G = P($, O, Z) << K, this.words[z] |= G & 67108863, K >= 18 ? (K -= 18, z += 1, this.words[z] |= G >>> 26) : K += 8;
        else {
          var D = $.length - O;
          for (Z = D % 2 === 0 ? O + 1 : O; Z < $.length; Z += 2)
            G = P($, O, Z) << K, this.words[z] |= G & 67108863, K >= 18 ? (K -= 18, z += 1, this.words[z] |= G >>> 26) : K += 8;
        }
        this._strip();
      };
      function I(M, $, O, J) {
        for (var Z = 0, K = 0, z = Math.min(M.length, O), G = $; G < z; G++) {
          var D = M.charCodeAt(G) - 48;
          Z *= J, D >= 49 ? K = D - 49 + 10 : D >= 17 ? K = D - 17 + 10 : K = D, g(D >= 0 && K < J, "Invalid character"), Z += K;
        }
        return Z;
      }
      h.prototype._parseBase = function($, O, J) {
        this.words = [0], this.length = 1;
        for (var Z = 0, K = 1; K <= 67108863; K *= O)
          Z++;
        Z--, K = K / O | 0;
        for (var z = $.length - J, G = z % Z, D = Math.min(z, z - G) + J, F = 0, ae = J; ae < D; ae += Z)
          F = I($, ae, ae + Z, O), this.imuln(K), this.words[0] + F < 67108864 ? this.words[0] += F : this._iaddn(F);
        if (G !== 0) {
          var ge = 1;
          for (F = I($, ae, $.length, O), ae = 0; ae < G; ae++)
            ge *= O;
          this.imuln(ge), this.words[0] + F < 67108864 ? this.words[0] += F : this._iaddn(F);
        }
        this._strip();
      }, h.prototype.copy = function($) {
        $.words = new Array(this.length);
        for (var O = 0; O < this.length; O++)
          $.words[O] = this.words[O];
        $.length = this.length, $.negative = this.negative, $.red = this.red;
      };
      function B(M, $) {
        M.words = $.words, M.length = $.length, M.negative = $.negative, M.red = $.red;
      }
      if (h.prototype._move = function($) {
        B($, this);
      }, h.prototype.clone = function() {
        var $ = new h(null);
        return this.copy($), $;
      }, h.prototype._expand = function($) {
        for (; this.length < $; )
          this.words[this.length++] = 0;
        return this;
      }, h.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, h.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          h.prototype[Symbol.for("nodejs.util.inspect.custom")] = H;
        } catch {
          h.prototype.inspect = H;
        }
      else
        h.prototype.inspect = H;
      function H() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var V = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], X = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Q = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      h.prototype.toString = function($, O) {
        $ = $ || 10, O = O | 0 || 1;
        var J;
        if ($ === 16 || $ === "hex") {
          J = "";
          for (var Z = 0, K = 0, z = 0; z < this.length; z++) {
            var G = this.words[z], D = ((G << Z | K) & 16777215).toString(16);
            K = G >>> 24 - Z & 16777215, Z += 2, Z >= 26 && (Z -= 26, z--), K !== 0 || z !== this.length - 1 ? J = V[6 - D.length] + D + J : J = D + J;
          }
          for (K !== 0 && (J = K.toString(16) + J); J.length % O !== 0; )
            J = "0" + J;
          return this.negative !== 0 && (J = "-" + J), J;
        }
        if ($ === ($ | 0) && $ >= 2 && $ <= 36) {
          var F = X[$], ae = Q[$];
          J = "";
          var ge = this.clone();
          for (ge.negative = 0; !ge.isZero(); ) {
            var xe = ge.modrn(ae).toString($);
            ge = ge.idivn(ae), ge.isZero() ? J = xe + J : J = V[F - xe.length] + xe + J;
          }
          for (this.isZero() && (J = "0" + J); J.length % O !== 0; )
            J = "0" + J;
          return this.negative !== 0 && (J = "-" + J), J;
        }
        g(!1, "Base should be between 2 and 36");
      }, h.prototype.toNumber = function() {
        var $ = this.words[0];
        return this.length === 2 ? $ += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? $ += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && g(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -$ : $;
      }, h.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, q && (h.prototype.toBuffer = function($, O) {
        return this.toArrayLike(q, $, O);
      }), h.prototype.toArray = function($, O) {
        return this.toArrayLike(Array, $, O);
      };
      var ee = function($, O) {
        return $.allocUnsafe ? $.allocUnsafe(O) : new $(O);
      };
      h.prototype.toArrayLike = function($, O, J) {
        this._strip();
        var Z = this.byteLength(), K = J || Math.max(1, Z);
        g(Z <= K, "byte array longer than desired length"), g(K > 0, "Requested array length <= 0");
        var z = ee($, K), G = O === "le" ? "LE" : "BE";
        return this["_toArrayLike" + G](z, Z), z;
      }, h.prototype._toArrayLikeLE = function($, O) {
        for (var J = 0, Z = 0, K = 0, z = 0; K < this.length; K++) {
          var G = this.words[K] << z | Z;
          $[J++] = G & 255, J < $.length && ($[J++] = G >> 8 & 255), J < $.length && ($[J++] = G >> 16 & 255), z === 6 ? (J < $.length && ($[J++] = G >> 24 & 255), Z = 0, z = 0) : (Z = G >>> 24, z += 2);
        }
        if (J < $.length)
          for ($[J++] = Z; J < $.length; )
            $[J++] = 0;
      }, h.prototype._toArrayLikeBE = function($, O) {
        for (var J = $.length - 1, Z = 0, K = 0, z = 0; K < this.length; K++) {
          var G = this.words[K] << z | Z;
          $[J--] = G & 255, J >= 0 && ($[J--] = G >> 8 & 255), J >= 0 && ($[J--] = G >> 16 & 255), z === 6 ? (J >= 0 && ($[J--] = G >> 24 & 255), Z = 0, z = 0) : (Z = G >>> 24, z += 2);
        }
        if (J >= 0)
          for ($[J--] = Z; J >= 0; )
            $[J--] = 0;
      }, Math.clz32 ? h.prototype._countBits = function($) {
        return 32 - Math.clz32($);
      } : h.prototype._countBits = function($) {
        var O = $, J = 0;
        return O >= 4096 && (J += 13, O >>>= 13), O >= 64 && (J += 7, O >>>= 7), O >= 8 && (J += 4, O >>>= 4), O >= 2 && (J += 2, O >>>= 2), J + O;
      }, h.prototype._zeroBits = function($) {
        if ($ === 0)
          return 26;
        var O = $, J = 0;
        return O & 8191 || (J += 13, O >>>= 13), O & 127 || (J += 7, O >>>= 7), O & 15 || (J += 4, O >>>= 4), O & 3 || (J += 2, O >>>= 2), O & 1 || J++, J;
      }, h.prototype.bitLength = function() {
        var $ = this.words[this.length - 1], O = this._countBits($);
        return (this.length - 1) * 26 + O;
      };
      function ie(M) {
        for (var $ = new Array(M.bitLength()), O = 0; O < $.length; O++) {
          var J = O / 26 | 0, Z = O % 26;
          $[O] = M.words[J] >>> Z & 1;
        }
        return $;
      }
      h.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var $ = 0, O = 0; O < this.length; O++) {
          var J = this._zeroBits(this.words[O]);
          if ($ += J, J !== 26)
            break;
        }
        return $;
      }, h.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, h.prototype.toTwos = function($) {
        return this.negative !== 0 ? this.abs().inotn($).iaddn(1) : this.clone();
      }, h.prototype.fromTwos = function($) {
        return this.testn($ - 1) ? this.notn($).iaddn(1).ineg() : this.clone();
      }, h.prototype.isNeg = function() {
        return this.negative !== 0;
      }, h.prototype.neg = function() {
        return this.clone().ineg();
      }, h.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, h.prototype.iuor = function($) {
        for (; this.length < $.length; )
          this.words[this.length++] = 0;
        for (var O = 0; O < $.length; O++)
          this.words[O] = this.words[O] | $.words[O];
        return this._strip();
      }, h.prototype.ior = function($) {
        return g((this.negative | $.negative) === 0), this.iuor($);
      }, h.prototype.or = function($) {
        return this.length > $.length ? this.clone().ior($) : $.clone().ior(this);
      }, h.prototype.uor = function($) {
        return this.length > $.length ? this.clone().iuor($) : $.clone().iuor(this);
      }, h.prototype.iuand = function($) {
        var O;
        this.length > $.length ? O = $ : O = this;
        for (var J = 0; J < O.length; J++)
          this.words[J] = this.words[J] & $.words[J];
        return this.length = O.length, this._strip();
      }, h.prototype.iand = function($) {
        return g((this.negative | $.negative) === 0), this.iuand($);
      }, h.prototype.and = function($) {
        return this.length > $.length ? this.clone().iand($) : $.clone().iand(this);
      }, h.prototype.uand = function($) {
        return this.length > $.length ? this.clone().iuand($) : $.clone().iuand(this);
      }, h.prototype.iuxor = function($) {
        var O, J;
        this.length > $.length ? (O = this, J = $) : (O = $, J = this);
        for (var Z = 0; Z < J.length; Z++)
          this.words[Z] = O.words[Z] ^ J.words[Z];
        if (this !== O)
          for (; Z < O.length; Z++)
            this.words[Z] = O.words[Z];
        return this.length = O.length, this._strip();
      }, h.prototype.ixor = function($) {
        return g((this.negative | $.negative) === 0), this.iuxor($);
      }, h.prototype.xor = function($) {
        return this.length > $.length ? this.clone().ixor($) : $.clone().ixor(this);
      }, h.prototype.uxor = function($) {
        return this.length > $.length ? this.clone().iuxor($) : $.clone().iuxor(this);
      }, h.prototype.inotn = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = Math.ceil($ / 26) | 0, J = $ % 26;
        this._expand(O), J > 0 && O--;
        for (var Z = 0; Z < O; Z++)
          this.words[Z] = ~this.words[Z] & 67108863;
        return J > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - J), this._strip();
      }, h.prototype.notn = function($) {
        return this.clone().inotn($);
      }, h.prototype.setn = function($, O) {
        g(typeof $ == "number" && $ >= 0);
        var J = $ / 26 | 0, Z = $ % 26;
        return this._expand(J + 1), O ? this.words[J] = this.words[J] | 1 << Z : this.words[J] = this.words[J] & ~(1 << Z), this._strip();
      }, h.prototype.iadd = function($) {
        var O;
        if (this.negative !== 0 && $.negative === 0)
          return this.negative = 0, O = this.isub($), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && $.negative !== 0)
          return $.negative = 0, O = this.isub($), $.negative = 1, O._normSign();
        var J, Z;
        this.length > $.length ? (J = this, Z = $) : (J = $, Z = this);
        for (var K = 0, z = 0; z < Z.length; z++)
          O = (J.words[z] | 0) + (Z.words[z] | 0) + K, this.words[z] = O & 67108863, K = O >>> 26;
        for (; K !== 0 && z < J.length; z++)
          O = (J.words[z] | 0) + K, this.words[z] = O & 67108863, K = O >>> 26;
        if (this.length = J.length, K !== 0)
          this.words[this.length] = K, this.length++;
        else if (J !== this)
          for (; z < J.length; z++)
            this.words[z] = J.words[z];
        return this;
      }, h.prototype.add = function($) {
        var O;
        return $.negative !== 0 && this.negative === 0 ? ($.negative = 0, O = this.sub($), $.negative ^= 1, O) : $.negative === 0 && this.negative !== 0 ? (this.negative = 0, O = $.sub(this), this.negative = 1, O) : this.length > $.length ? this.clone().iadd($) : $.clone().iadd(this);
      }, h.prototype.isub = function($) {
        if ($.negative !== 0) {
          $.negative = 0;
          var O = this.iadd($);
          return $.negative = 1, O._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd($), this.negative = 1, this._normSign();
        var J = this.cmp($);
        if (J === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var Z, K;
        J > 0 ? (Z = this, K = $) : (Z = $, K = this);
        for (var z = 0, G = 0; G < K.length; G++)
          O = (Z.words[G] | 0) - (K.words[G] | 0) + z, z = O >> 26, this.words[G] = O & 67108863;
        for (; z !== 0 && G < Z.length; G++)
          O = (Z.words[G] | 0) + z, z = O >> 26, this.words[G] = O & 67108863;
        if (z === 0 && G < Z.length && Z !== this)
          for (; G < Z.length; G++)
            this.words[G] = Z.words[G];
        return this.length = Math.max(this.length, G), Z !== this && (this.negative = 1), this._strip();
      }, h.prototype.sub = function($) {
        return this.clone().isub($);
      };
      function te(M, $, O) {
        O.negative = $.negative ^ M.negative;
        var J = M.length + $.length | 0;
        O.length = J, J = J - 1 | 0;
        var Z = M.words[0] | 0, K = $.words[0] | 0, z = Z * K, G = z & 67108863, D = z / 67108864 | 0;
        O.words[0] = G;
        for (var F = 1; F < J; F++) {
          for (var ae = D >>> 26, ge = D & 67108863, xe = Math.min(F, $.length - 1), ye = Math.max(0, F - M.length + 1); ye <= xe; ye++) {
            var oe = F - ye | 0;
            Z = M.words[oe] | 0, K = $.words[ye] | 0, z = Z * K + ge, ae += z / 67108864 | 0, ge = z & 67108863;
          }
          O.words[F] = ge | 0, D = ae | 0;
        }
        return D !== 0 ? O.words[F] = D | 0 : O.length--, O._strip();
      }
      var se = function($, O, J) {
        var Z = $.words, K = O.words, z = J.words, G = 0, D, F, ae, ge = Z[0] | 0, xe = ge & 8191, ye = ge >>> 13, oe = Z[1] | 0, fe = oe & 8191, $e = oe >>> 13, Be = Z[2] | 0, be = Be & 8191, ve = Be >>> 13, qe = Z[3] | 0, De = qe & 8191, Ye = qe >>> 13, he = Z[4] | 0, ue = he & 8191, de = he >>> 13, _e = Z[5] | 0, Pe = _e & 8191, He = _e >>> 13, Ve = Z[6] | 0, nt = Ve & 8191, Ie = Ve >>> 13, Fe = Z[7] | 0, je = Fe & 8191, Ke = Fe >>> 13, ot = Z[8] | 0, ut = ot & 8191, pt = ot >>> 13, ke = Z[9] | 0, Xe = ke & 8191, at = ke >>> 13, ht = K[0] | 0, We = ht & 8191, tt = ht >>> 13, Te = K[1] | 0, rt = Te & 8191, mt = Te >>> 13, Se = K[2] | 0, et = Se & 8191, Ze = Se >>> 13, Le = K[3] | 0, ze = Le & 8191, Qe = Le >>> 13, _t = K[4] | 0, ft = _t & 8191, dt = _t >>> 13, Mt = K[5] | 0, St = Mt & 8191, $t = Mt >>> 13, At = K[6] | 0, Ae = At & 8191, Ce = At >>> 13, Oe = K[7] | 0, we = Oe & 8191, Ue = Oe >>> 13, Je = K[8] | 0, Ge = Je & 8191, st = Je >>> 13, ct = K[9] | 0, bt = ct & 8191, wt = ct >>> 13;
        J.negative = $.negative ^ O.negative, J.length = 19, D = Math.imul(xe, We), F = Math.imul(xe, tt), F = F + Math.imul(ye, We) | 0, ae = Math.imul(ye, tt);
        var zt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, D = Math.imul(fe, We), F = Math.imul(fe, tt), F = F + Math.imul($e, We) | 0, ae = Math.imul($e, tt), D = D + Math.imul(xe, rt) | 0, F = F + Math.imul(xe, mt) | 0, F = F + Math.imul(ye, rt) | 0, ae = ae + Math.imul(ye, mt) | 0;
        var Tt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, D = Math.imul(be, We), F = Math.imul(be, tt), F = F + Math.imul(ve, We) | 0, ae = Math.imul(ve, tt), D = D + Math.imul(fe, rt) | 0, F = F + Math.imul(fe, mt) | 0, F = F + Math.imul($e, rt) | 0, ae = ae + Math.imul($e, mt) | 0, D = D + Math.imul(xe, et) | 0, F = F + Math.imul(xe, Ze) | 0, F = F + Math.imul(ye, et) | 0, ae = ae + Math.imul(ye, Ze) | 0;
        var Lt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, D = Math.imul(De, We), F = Math.imul(De, tt), F = F + Math.imul(Ye, We) | 0, ae = Math.imul(Ye, tt), D = D + Math.imul(be, rt) | 0, F = F + Math.imul(be, mt) | 0, F = F + Math.imul(ve, rt) | 0, ae = ae + Math.imul(ve, mt) | 0, D = D + Math.imul(fe, et) | 0, F = F + Math.imul(fe, Ze) | 0, F = F + Math.imul($e, et) | 0, ae = ae + Math.imul($e, Ze) | 0, D = D + Math.imul(xe, ze) | 0, F = F + Math.imul(xe, Qe) | 0, F = F + Math.imul(ye, ze) | 0, ae = ae + Math.imul(ye, Qe) | 0;
        var jt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, D = Math.imul(ue, We), F = Math.imul(ue, tt), F = F + Math.imul(de, We) | 0, ae = Math.imul(de, tt), D = D + Math.imul(De, rt) | 0, F = F + Math.imul(De, mt) | 0, F = F + Math.imul(Ye, rt) | 0, ae = ae + Math.imul(Ye, mt) | 0, D = D + Math.imul(be, et) | 0, F = F + Math.imul(be, Ze) | 0, F = F + Math.imul(ve, et) | 0, ae = ae + Math.imul(ve, Ze) | 0, D = D + Math.imul(fe, ze) | 0, F = F + Math.imul(fe, Qe) | 0, F = F + Math.imul($e, ze) | 0, ae = ae + Math.imul($e, Qe) | 0, D = D + Math.imul(xe, ft) | 0, F = F + Math.imul(xe, dt) | 0, F = F + Math.imul(ye, ft) | 0, ae = ae + Math.imul(ye, dt) | 0;
        var Ht = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, D = Math.imul(Pe, We), F = Math.imul(Pe, tt), F = F + Math.imul(He, We) | 0, ae = Math.imul(He, tt), D = D + Math.imul(ue, rt) | 0, F = F + Math.imul(ue, mt) | 0, F = F + Math.imul(de, rt) | 0, ae = ae + Math.imul(de, mt) | 0, D = D + Math.imul(De, et) | 0, F = F + Math.imul(De, Ze) | 0, F = F + Math.imul(Ye, et) | 0, ae = ae + Math.imul(Ye, Ze) | 0, D = D + Math.imul(be, ze) | 0, F = F + Math.imul(be, Qe) | 0, F = F + Math.imul(ve, ze) | 0, ae = ae + Math.imul(ve, Qe) | 0, D = D + Math.imul(fe, ft) | 0, F = F + Math.imul(fe, dt) | 0, F = F + Math.imul($e, ft) | 0, ae = ae + Math.imul($e, dt) | 0, D = D + Math.imul(xe, St) | 0, F = F + Math.imul(xe, $t) | 0, F = F + Math.imul(ye, St) | 0, ae = ae + Math.imul(ye, $t) | 0;
        var Ft = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, D = Math.imul(nt, We), F = Math.imul(nt, tt), F = F + Math.imul(Ie, We) | 0, ae = Math.imul(Ie, tt), D = D + Math.imul(Pe, rt) | 0, F = F + Math.imul(Pe, mt) | 0, F = F + Math.imul(He, rt) | 0, ae = ae + Math.imul(He, mt) | 0, D = D + Math.imul(ue, et) | 0, F = F + Math.imul(ue, Ze) | 0, F = F + Math.imul(de, et) | 0, ae = ae + Math.imul(de, Ze) | 0, D = D + Math.imul(De, ze) | 0, F = F + Math.imul(De, Qe) | 0, F = F + Math.imul(Ye, ze) | 0, ae = ae + Math.imul(Ye, Qe) | 0, D = D + Math.imul(be, ft) | 0, F = F + Math.imul(be, dt) | 0, F = F + Math.imul(ve, ft) | 0, ae = ae + Math.imul(ve, dt) | 0, D = D + Math.imul(fe, St) | 0, F = F + Math.imul(fe, $t) | 0, F = F + Math.imul($e, St) | 0, ae = ae + Math.imul($e, $t) | 0, D = D + Math.imul(xe, Ae) | 0, F = F + Math.imul(xe, Ce) | 0, F = F + Math.imul(ye, Ae) | 0, ae = ae + Math.imul(ye, Ce) | 0;
        var Nt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, D = Math.imul(je, We), F = Math.imul(je, tt), F = F + Math.imul(Ke, We) | 0, ae = Math.imul(Ke, tt), D = D + Math.imul(nt, rt) | 0, F = F + Math.imul(nt, mt) | 0, F = F + Math.imul(Ie, rt) | 0, ae = ae + Math.imul(Ie, mt) | 0, D = D + Math.imul(Pe, et) | 0, F = F + Math.imul(Pe, Ze) | 0, F = F + Math.imul(He, et) | 0, ae = ae + Math.imul(He, Ze) | 0, D = D + Math.imul(ue, ze) | 0, F = F + Math.imul(ue, Qe) | 0, F = F + Math.imul(de, ze) | 0, ae = ae + Math.imul(de, Qe) | 0, D = D + Math.imul(De, ft) | 0, F = F + Math.imul(De, dt) | 0, F = F + Math.imul(Ye, ft) | 0, ae = ae + Math.imul(Ye, dt) | 0, D = D + Math.imul(be, St) | 0, F = F + Math.imul(be, $t) | 0, F = F + Math.imul(ve, St) | 0, ae = ae + Math.imul(ve, $t) | 0, D = D + Math.imul(fe, Ae) | 0, F = F + Math.imul(fe, Ce) | 0, F = F + Math.imul($e, Ae) | 0, ae = ae + Math.imul($e, Ce) | 0, D = D + Math.imul(xe, we) | 0, F = F + Math.imul(xe, Ue) | 0, F = F + Math.imul(ye, we) | 0, ae = ae + Math.imul(ye, Ue) | 0;
        var Dt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, D = Math.imul(ut, We), F = Math.imul(ut, tt), F = F + Math.imul(pt, We) | 0, ae = Math.imul(pt, tt), D = D + Math.imul(je, rt) | 0, F = F + Math.imul(je, mt) | 0, F = F + Math.imul(Ke, rt) | 0, ae = ae + Math.imul(Ke, mt) | 0, D = D + Math.imul(nt, et) | 0, F = F + Math.imul(nt, Ze) | 0, F = F + Math.imul(Ie, et) | 0, ae = ae + Math.imul(Ie, Ze) | 0, D = D + Math.imul(Pe, ze) | 0, F = F + Math.imul(Pe, Qe) | 0, F = F + Math.imul(He, ze) | 0, ae = ae + Math.imul(He, Qe) | 0, D = D + Math.imul(ue, ft) | 0, F = F + Math.imul(ue, dt) | 0, F = F + Math.imul(de, ft) | 0, ae = ae + Math.imul(de, dt) | 0, D = D + Math.imul(De, St) | 0, F = F + Math.imul(De, $t) | 0, F = F + Math.imul(Ye, St) | 0, ae = ae + Math.imul(Ye, $t) | 0, D = D + Math.imul(be, Ae) | 0, F = F + Math.imul(be, Ce) | 0, F = F + Math.imul(ve, Ae) | 0, ae = ae + Math.imul(ve, Ce) | 0, D = D + Math.imul(fe, we) | 0, F = F + Math.imul(fe, Ue) | 0, F = F + Math.imul($e, we) | 0, ae = ae + Math.imul($e, Ue) | 0, D = D + Math.imul(xe, Ge) | 0, F = F + Math.imul(xe, st) | 0, F = F + Math.imul(ye, Ge) | 0, ae = ae + Math.imul(ye, st) | 0;
        var Ut = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, D = Math.imul(Xe, We), F = Math.imul(Xe, tt), F = F + Math.imul(at, We) | 0, ae = Math.imul(at, tt), D = D + Math.imul(ut, rt) | 0, F = F + Math.imul(ut, mt) | 0, F = F + Math.imul(pt, rt) | 0, ae = ae + Math.imul(pt, mt) | 0, D = D + Math.imul(je, et) | 0, F = F + Math.imul(je, Ze) | 0, F = F + Math.imul(Ke, et) | 0, ae = ae + Math.imul(Ke, Ze) | 0, D = D + Math.imul(nt, ze) | 0, F = F + Math.imul(nt, Qe) | 0, F = F + Math.imul(Ie, ze) | 0, ae = ae + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Pe, ft) | 0, F = F + Math.imul(Pe, dt) | 0, F = F + Math.imul(He, ft) | 0, ae = ae + Math.imul(He, dt) | 0, D = D + Math.imul(ue, St) | 0, F = F + Math.imul(ue, $t) | 0, F = F + Math.imul(de, St) | 0, ae = ae + Math.imul(de, $t) | 0, D = D + Math.imul(De, Ae) | 0, F = F + Math.imul(De, Ce) | 0, F = F + Math.imul(Ye, Ae) | 0, ae = ae + Math.imul(Ye, Ce) | 0, D = D + Math.imul(be, we) | 0, F = F + Math.imul(be, Ue) | 0, F = F + Math.imul(ve, we) | 0, ae = ae + Math.imul(ve, Ue) | 0, D = D + Math.imul(fe, Ge) | 0, F = F + Math.imul(fe, st) | 0, F = F + Math.imul($e, Ge) | 0, ae = ae + Math.imul($e, st) | 0, D = D + Math.imul(xe, bt) | 0, F = F + Math.imul(xe, wt) | 0, F = F + Math.imul(ye, bt) | 0, ae = ae + Math.imul(ye, wt) | 0;
        var kt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, D = Math.imul(Xe, rt), F = Math.imul(Xe, mt), F = F + Math.imul(at, rt) | 0, ae = Math.imul(at, mt), D = D + Math.imul(ut, et) | 0, F = F + Math.imul(ut, Ze) | 0, F = F + Math.imul(pt, et) | 0, ae = ae + Math.imul(pt, Ze) | 0, D = D + Math.imul(je, ze) | 0, F = F + Math.imul(je, Qe) | 0, F = F + Math.imul(Ke, ze) | 0, ae = ae + Math.imul(Ke, Qe) | 0, D = D + Math.imul(nt, ft) | 0, F = F + Math.imul(nt, dt) | 0, F = F + Math.imul(Ie, ft) | 0, ae = ae + Math.imul(Ie, dt) | 0, D = D + Math.imul(Pe, St) | 0, F = F + Math.imul(Pe, $t) | 0, F = F + Math.imul(He, St) | 0, ae = ae + Math.imul(He, $t) | 0, D = D + Math.imul(ue, Ae) | 0, F = F + Math.imul(ue, Ce) | 0, F = F + Math.imul(de, Ae) | 0, ae = ae + Math.imul(de, Ce) | 0, D = D + Math.imul(De, we) | 0, F = F + Math.imul(De, Ue) | 0, F = F + Math.imul(Ye, we) | 0, ae = ae + Math.imul(Ye, Ue) | 0, D = D + Math.imul(be, Ge) | 0, F = F + Math.imul(be, st) | 0, F = F + Math.imul(ve, Ge) | 0, ae = ae + Math.imul(ve, st) | 0, D = D + Math.imul(fe, bt) | 0, F = F + Math.imul(fe, wt) | 0, F = F + Math.imul($e, bt) | 0, ae = ae + Math.imul($e, wt) | 0;
        var Ot = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, D = Math.imul(Xe, et), F = Math.imul(Xe, Ze), F = F + Math.imul(at, et) | 0, ae = Math.imul(at, Ze), D = D + Math.imul(ut, ze) | 0, F = F + Math.imul(ut, Qe) | 0, F = F + Math.imul(pt, ze) | 0, ae = ae + Math.imul(pt, Qe) | 0, D = D + Math.imul(je, ft) | 0, F = F + Math.imul(je, dt) | 0, F = F + Math.imul(Ke, ft) | 0, ae = ae + Math.imul(Ke, dt) | 0, D = D + Math.imul(nt, St) | 0, F = F + Math.imul(nt, $t) | 0, F = F + Math.imul(Ie, St) | 0, ae = ae + Math.imul(Ie, $t) | 0, D = D + Math.imul(Pe, Ae) | 0, F = F + Math.imul(Pe, Ce) | 0, F = F + Math.imul(He, Ae) | 0, ae = ae + Math.imul(He, Ce) | 0, D = D + Math.imul(ue, we) | 0, F = F + Math.imul(ue, Ue) | 0, F = F + Math.imul(de, we) | 0, ae = ae + Math.imul(de, Ue) | 0, D = D + Math.imul(De, Ge) | 0, F = F + Math.imul(De, st) | 0, F = F + Math.imul(Ye, Ge) | 0, ae = ae + Math.imul(Ye, st) | 0, D = D + Math.imul(be, bt) | 0, F = F + Math.imul(be, wt) | 0, F = F + Math.imul(ve, bt) | 0, ae = ae + Math.imul(ve, wt) | 0;
        var It = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, D = Math.imul(Xe, ze), F = Math.imul(Xe, Qe), F = F + Math.imul(at, ze) | 0, ae = Math.imul(at, Qe), D = D + Math.imul(ut, ft) | 0, F = F + Math.imul(ut, dt) | 0, F = F + Math.imul(pt, ft) | 0, ae = ae + Math.imul(pt, dt) | 0, D = D + Math.imul(je, St) | 0, F = F + Math.imul(je, $t) | 0, F = F + Math.imul(Ke, St) | 0, ae = ae + Math.imul(Ke, $t) | 0, D = D + Math.imul(nt, Ae) | 0, F = F + Math.imul(nt, Ce) | 0, F = F + Math.imul(Ie, Ae) | 0, ae = ae + Math.imul(Ie, Ce) | 0, D = D + Math.imul(Pe, we) | 0, F = F + Math.imul(Pe, Ue) | 0, F = F + Math.imul(He, we) | 0, ae = ae + Math.imul(He, Ue) | 0, D = D + Math.imul(ue, Ge) | 0, F = F + Math.imul(ue, st) | 0, F = F + Math.imul(de, Ge) | 0, ae = ae + Math.imul(de, st) | 0, D = D + Math.imul(De, bt) | 0, F = F + Math.imul(De, wt) | 0, F = F + Math.imul(Ye, bt) | 0, ae = ae + Math.imul(Ye, wt) | 0;
        var Pt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, D = Math.imul(Xe, ft), F = Math.imul(Xe, dt), F = F + Math.imul(at, ft) | 0, ae = Math.imul(at, dt), D = D + Math.imul(ut, St) | 0, F = F + Math.imul(ut, $t) | 0, F = F + Math.imul(pt, St) | 0, ae = ae + Math.imul(pt, $t) | 0, D = D + Math.imul(je, Ae) | 0, F = F + Math.imul(je, Ce) | 0, F = F + Math.imul(Ke, Ae) | 0, ae = ae + Math.imul(Ke, Ce) | 0, D = D + Math.imul(nt, we) | 0, F = F + Math.imul(nt, Ue) | 0, F = F + Math.imul(Ie, we) | 0, ae = ae + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Pe, Ge) | 0, F = F + Math.imul(Pe, st) | 0, F = F + Math.imul(He, Ge) | 0, ae = ae + Math.imul(He, st) | 0, D = D + Math.imul(ue, bt) | 0, F = F + Math.imul(ue, wt) | 0, F = F + Math.imul(de, bt) | 0, ae = ae + Math.imul(de, wt) | 0;
        var Ct = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, D = Math.imul(Xe, St), F = Math.imul(Xe, $t), F = F + Math.imul(at, St) | 0, ae = Math.imul(at, $t), D = D + Math.imul(ut, Ae) | 0, F = F + Math.imul(ut, Ce) | 0, F = F + Math.imul(pt, Ae) | 0, ae = ae + Math.imul(pt, Ce) | 0, D = D + Math.imul(je, we) | 0, F = F + Math.imul(je, Ue) | 0, F = F + Math.imul(Ke, we) | 0, ae = ae + Math.imul(Ke, Ue) | 0, D = D + Math.imul(nt, Ge) | 0, F = F + Math.imul(nt, st) | 0, F = F + Math.imul(Ie, Ge) | 0, ae = ae + Math.imul(Ie, st) | 0, D = D + Math.imul(Pe, bt) | 0, F = F + Math.imul(Pe, wt) | 0, F = F + Math.imul(He, bt) | 0, ae = ae + Math.imul(He, wt) | 0;
        var Bt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, D = Math.imul(Xe, Ae), F = Math.imul(Xe, Ce), F = F + Math.imul(at, Ae) | 0, ae = Math.imul(at, Ce), D = D + Math.imul(ut, we) | 0, F = F + Math.imul(ut, Ue) | 0, F = F + Math.imul(pt, we) | 0, ae = ae + Math.imul(pt, Ue) | 0, D = D + Math.imul(je, Ge) | 0, F = F + Math.imul(je, st) | 0, F = F + Math.imul(Ke, Ge) | 0, ae = ae + Math.imul(Ke, st) | 0, D = D + Math.imul(nt, bt) | 0, F = F + Math.imul(nt, wt) | 0, F = F + Math.imul(Ie, bt) | 0, ae = ae + Math.imul(Ie, wt) | 0;
        var vt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, D = Math.imul(Xe, we), F = Math.imul(Xe, Ue), F = F + Math.imul(at, we) | 0, ae = Math.imul(at, Ue), D = D + Math.imul(ut, Ge) | 0, F = F + Math.imul(ut, st) | 0, F = F + Math.imul(pt, Ge) | 0, ae = ae + Math.imul(pt, st) | 0, D = D + Math.imul(je, bt) | 0, F = F + Math.imul(je, wt) | 0, F = F + Math.imul(Ke, bt) | 0, ae = ae + Math.imul(Ke, wt) | 0;
        var yt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, D = Math.imul(Xe, Ge), F = Math.imul(Xe, st), F = F + Math.imul(at, Ge) | 0, ae = Math.imul(at, st), D = D + Math.imul(ut, bt) | 0, F = F + Math.imul(ut, wt) | 0, F = F + Math.imul(pt, bt) | 0, ae = ae + Math.imul(pt, wt) | 0;
        var xt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, D = Math.imul(Xe, bt), F = Math.imul(Xe, wt), F = F + Math.imul(at, bt) | 0, ae = Math.imul(at, wt);
        var Et = (G + D | 0) + ((F & 8191) << 13) | 0;
        return G = (ae + (F >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, z[0] = zt, z[1] = Tt, z[2] = Lt, z[3] = jt, z[4] = Ht, z[5] = Ft, z[6] = Nt, z[7] = Dt, z[8] = Ut, z[9] = kt, z[10] = Ot, z[11] = It, z[12] = Pt, z[13] = Ct, z[14] = Bt, z[15] = vt, z[16] = yt, z[17] = xt, z[18] = Et, G !== 0 && (z[19] = G, J.length++), J;
      };
      Math.imul || (se = te);
      function le(M, $, O) {
        O.negative = $.negative ^ M.negative, O.length = M.length + $.length;
        for (var J = 0, Z = 0, K = 0; K < O.length - 1; K++) {
          var z = Z;
          Z = 0;
          for (var G = J & 67108863, D = Math.min(K, $.length - 1), F = Math.max(0, K - M.length + 1); F <= D; F++) {
            var ae = K - F, ge = M.words[ae] | 0, xe = $.words[F] | 0, ye = ge * xe, oe = ye & 67108863;
            z = z + (ye / 67108864 | 0) | 0, oe = oe + G | 0, G = oe & 67108863, z = z + (oe >>> 26) | 0, Z += z >>> 26, z &= 67108863;
          }
          O.words[K] = G, J = z, z = Z;
        }
        return J !== 0 ? O.words[K] = J : O.length--, O._strip();
      }
      function ce(M, $, O) {
        return le(M, $, O);
      }
      h.prototype.mulTo = function($, O) {
        var J, Z = this.length + $.length;
        return this.length === 10 && $.length === 10 ? J = se(this, $, O) : Z < 63 ? J = te(this, $, O) : Z < 1024 ? J = le(this, $, O) : J = ce(this, $, O), J;
      }, h.prototype.mul = function($) {
        var O = new h(null);
        return O.words = new Array(this.length + $.length), this.mulTo($, O);
      }, h.prototype.mulf = function($) {
        var O = new h(null);
        return O.words = new Array(this.length + $.length), ce(this, $, O);
      }, h.prototype.imul = function($) {
        return this.clone().mulTo($, this);
      }, h.prototype.imuln = function($) {
        var O = $ < 0;
        O && ($ = -$), g(typeof $ == "number"), g($ < 67108864);
        for (var J = 0, Z = 0; Z < this.length; Z++) {
          var K = (this.words[Z] | 0) * $, z = (K & 67108863) + (J & 67108863);
          J >>= 26, J += K / 67108864 | 0, J += z >>> 26, this.words[Z] = z & 67108863;
        }
        return J !== 0 && (this.words[Z] = J, this.length++), O ? this.ineg() : this;
      }, h.prototype.muln = function($) {
        return this.clone().imuln($);
      }, h.prototype.sqr = function() {
        return this.mul(this);
      }, h.prototype.isqr = function() {
        return this.imul(this.clone());
      }, h.prototype.pow = function($) {
        var O = ie($);
        if (O.length === 0)
          return new h(1);
        for (var J = this, Z = 0; Z < O.length && O[Z] === 0; Z++, J = J.sqr())
          ;
        if (++Z < O.length)
          for (var K = J.sqr(); Z < O.length; Z++, K = K.sqr())
            O[Z] !== 0 && (J = J.mul(K));
        return J;
      }, h.prototype.iushln = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = $ % 26, J = ($ - O) / 26, Z = 67108863 >>> 26 - O << 26 - O, K;
        if (O !== 0) {
          var z = 0;
          for (K = 0; K < this.length; K++) {
            var G = this.words[K] & Z, D = (this.words[K] | 0) - G << O;
            this.words[K] = D | z, z = G >>> 26 - O;
          }
          z && (this.words[K] = z, this.length++);
        }
        if (J !== 0) {
          for (K = this.length - 1; K >= 0; K--)
            this.words[K + J] = this.words[K];
          for (K = 0; K < J; K++)
            this.words[K] = 0;
          this.length += J;
        }
        return this._strip();
      }, h.prototype.ishln = function($) {
        return g(this.negative === 0), this.iushln($);
      }, h.prototype.iushrn = function($, O, J) {
        g(typeof $ == "number" && $ >= 0);
        var Z;
        O ? Z = (O - O % 26) / 26 : Z = 0;
        var K = $ % 26, z = Math.min(($ - K) / 26, this.length), G = 67108863 ^ 67108863 >>> K << K, D = J;
        if (Z -= z, Z = Math.max(0, Z), D) {
          for (var F = 0; F < z; F++)
            D.words[F] = this.words[F];
          D.length = z;
        }
        if (z !== 0)
          if (this.length > z)
            for (this.length -= z, F = 0; F < this.length; F++)
              this.words[F] = this.words[F + z];
          else
            this.words[0] = 0, this.length = 1;
        var ae = 0;
        for (F = this.length - 1; F >= 0 && (ae !== 0 || F >= Z); F--) {
          var ge = this.words[F] | 0;
          this.words[F] = ae << 26 - K | ge >>> K, ae = ge & G;
        }
        return D && ae !== 0 && (D.words[D.length++] = ae), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, h.prototype.ishrn = function($, O, J) {
        return g(this.negative === 0), this.iushrn($, O, J);
      }, h.prototype.shln = function($) {
        return this.clone().ishln($);
      }, h.prototype.ushln = function($) {
        return this.clone().iushln($);
      }, h.prototype.shrn = function($) {
        return this.clone().ishrn($);
      }, h.prototype.ushrn = function($) {
        return this.clone().iushrn($);
      }, h.prototype.testn = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = $ % 26, J = ($ - O) / 26, Z = 1 << O;
        if (this.length <= J)
          return !1;
        var K = this.words[J];
        return !!(K & Z);
      }, h.prototype.imaskn = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = $ % 26, J = ($ - O) / 26;
        if (g(this.negative === 0, "imaskn works only with positive numbers"), this.length <= J)
          return this;
        if (O !== 0 && J++, this.length = Math.min(J, this.length), O !== 0) {
          var Z = 67108863 ^ 67108863 >>> O << O;
          this.words[this.length - 1] &= Z;
        }
        return this._strip();
      }, h.prototype.maskn = function($) {
        return this.clone().imaskn($);
      }, h.prototype.iaddn = function($) {
        return g(typeof $ == "number"), g($ < 67108864), $ < 0 ? this.isubn(-$) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= $ ? (this.words[0] = $ - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn($), this.negative = 1, this) : this._iaddn($);
      }, h.prototype._iaddn = function($) {
        this.words[0] += $;
        for (var O = 0; O < this.length && this.words[O] >= 67108864; O++)
          this.words[O] -= 67108864, O === this.length - 1 ? this.words[O + 1] = 1 : this.words[O + 1]++;
        return this.length = Math.max(this.length, O + 1), this;
      }, h.prototype.isubn = function($) {
        if (g(typeof $ == "number"), g($ < 67108864), $ < 0)
          return this.iaddn(-$);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn($), this.negative = 1, this;
        if (this.words[0] -= $, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var O = 0; O < this.length && this.words[O] < 0; O++)
            this.words[O] += 67108864, this.words[O + 1] -= 1;
        return this._strip();
      }, h.prototype.addn = function($) {
        return this.clone().iaddn($);
      }, h.prototype.subn = function($) {
        return this.clone().isubn($);
      }, h.prototype.iabs = function() {
        return this.negative = 0, this;
      }, h.prototype.abs = function() {
        return this.clone().iabs();
      }, h.prototype._ishlnsubmul = function($, O, J) {
        var Z = $.length + J, K;
        this._expand(Z);
        var z, G = 0;
        for (K = 0; K < $.length; K++) {
          z = (this.words[K + J] | 0) + G;
          var D = ($.words[K] | 0) * O;
          z -= D & 67108863, G = (z >> 26) - (D / 67108864 | 0), this.words[K + J] = z & 67108863;
        }
        for (; K < this.length - J; K++)
          z = (this.words[K + J] | 0) + G, G = z >> 26, this.words[K + J] = z & 67108863;
        if (G === 0)
          return this._strip();
        for (g(G === -1), G = 0, K = 0; K < this.length; K++)
          z = -(this.words[K] | 0) + G, G = z >> 26, this.words[K] = z & 67108863;
        return this.negative = 1, this._strip();
      }, h.prototype._wordDiv = function($, O) {
        var J = this.length - $.length, Z = this.clone(), K = $, z = K.words[K.length - 1] | 0, G = this._countBits(z);
        J = 26 - G, J !== 0 && (K = K.ushln(J), Z.iushln(J), z = K.words[K.length - 1] | 0);
        var D = Z.length - K.length, F;
        if (O !== "mod") {
          F = new h(null), F.length = D + 1, F.words = new Array(F.length);
          for (var ae = 0; ae < F.length; ae++)
            F.words[ae] = 0;
        }
        var ge = Z.clone()._ishlnsubmul(K, 1, D);
        ge.negative === 0 && (Z = ge, F && (F.words[D] = 1));
        for (var xe = D - 1; xe >= 0; xe--) {
          var ye = (Z.words[K.length + xe] | 0) * 67108864 + (Z.words[K.length + xe - 1] | 0);
          for (ye = Math.min(ye / z | 0, 67108863), Z._ishlnsubmul(K, ye, xe); Z.negative !== 0; )
            ye--, Z.negative = 0, Z._ishlnsubmul(K, 1, xe), Z.isZero() || (Z.negative ^= 1);
          F && (F.words[xe] = ye);
        }
        return F && F._strip(), Z._strip(), O !== "div" && J !== 0 && Z.iushrn(J), {
          div: F || null,
          mod: Z
        };
      }, h.prototype.divmod = function($, O, J) {
        if (g(!$.isZero()), this.isZero())
          return {
            div: new h(0),
            mod: new h(0)
          };
        var Z, K, z;
        return this.negative !== 0 && $.negative === 0 ? (z = this.neg().divmod($, O), O !== "mod" && (Z = z.div.neg()), O !== "div" && (K = z.mod.neg(), J && K.negative !== 0 && K.iadd($)), {
          div: Z,
          mod: K
        }) : this.negative === 0 && $.negative !== 0 ? (z = this.divmod($.neg(), O), O !== "mod" && (Z = z.div.neg()), {
          div: Z,
          mod: z.mod
        }) : this.negative & $.negative ? (z = this.neg().divmod($.neg(), O), O !== "div" && (K = z.mod.neg(), J && K.negative !== 0 && K.isub($)), {
          div: z.div,
          mod: K
        }) : $.length > this.length || this.cmp($) < 0 ? {
          div: new h(0),
          mod: this
        } : $.length === 1 ? O === "div" ? {
          div: this.divn($.words[0]),
          mod: null
        } : O === "mod" ? {
          div: null,
          mod: new h(this.modrn($.words[0]))
        } : {
          div: this.divn($.words[0]),
          mod: new h(this.modrn($.words[0]))
        } : this._wordDiv($, O);
      }, h.prototype.div = function($) {
        return this.divmod($, "div", !1).div;
      }, h.prototype.mod = function($) {
        return this.divmod($, "mod", !1).mod;
      }, h.prototype.umod = function($) {
        return this.divmod($, "mod", !0).mod;
      }, h.prototype.divRound = function($) {
        var O = this.divmod($);
        if (O.mod.isZero())
          return O.div;
        var J = O.div.negative !== 0 ? O.mod.isub($) : O.mod, Z = $.ushrn(1), K = $.andln(1), z = J.cmp(Z);
        return z < 0 || K === 1 && z === 0 ? O.div : O.div.negative !== 0 ? O.div.isubn(1) : O.div.iaddn(1);
      }, h.prototype.modrn = function($) {
        var O = $ < 0;
        O && ($ = -$), g($ <= 67108863);
        for (var J = (1 << 26) % $, Z = 0, K = this.length - 1; K >= 0; K--)
          Z = (J * Z + (this.words[K] | 0)) % $;
        return O ? -Z : Z;
      }, h.prototype.modn = function($) {
        return this.modrn($);
      }, h.prototype.idivn = function($) {
        var O = $ < 0;
        O && ($ = -$), g($ <= 67108863);
        for (var J = 0, Z = this.length - 1; Z >= 0; Z--) {
          var K = (this.words[Z] | 0) + J * 67108864;
          this.words[Z] = K / $ | 0, J = K % $;
        }
        return this._strip(), O ? this.ineg() : this;
      }, h.prototype.divn = function($) {
        return this.clone().idivn($);
      }, h.prototype.egcd = function($) {
        g($.negative === 0), g(!$.isZero());
        var O = this, J = $.clone();
        O.negative !== 0 ? O = O.umod($) : O = O.clone();
        for (var Z = new h(1), K = new h(0), z = new h(0), G = new h(1), D = 0; O.isEven() && J.isEven(); )
          O.iushrn(1), J.iushrn(1), ++D;
        for (var F = J.clone(), ae = O.clone(); !O.isZero(); ) {
          for (var ge = 0, xe = 1; !(O.words[0] & xe) && ge < 26; ++ge, xe <<= 1)
            ;
          if (ge > 0)
            for (O.iushrn(ge); ge-- > 0; )
              (Z.isOdd() || K.isOdd()) && (Z.iadd(F), K.isub(ae)), Z.iushrn(1), K.iushrn(1);
          for (var ye = 0, oe = 1; !(J.words[0] & oe) && ye < 26; ++ye, oe <<= 1)
            ;
          if (ye > 0)
            for (J.iushrn(ye); ye-- > 0; )
              (z.isOdd() || G.isOdd()) && (z.iadd(F), G.isub(ae)), z.iushrn(1), G.iushrn(1);
          O.cmp(J) >= 0 ? (O.isub(J), Z.isub(z), K.isub(G)) : (J.isub(O), z.isub(Z), G.isub(K));
        }
        return {
          a: z,
          b: G,
          gcd: J.iushln(D)
        };
      }, h.prototype._invmp = function($) {
        g($.negative === 0), g(!$.isZero());
        var O = this, J = $.clone();
        O.negative !== 0 ? O = O.umod($) : O = O.clone();
        for (var Z = new h(1), K = new h(0), z = J.clone(); O.cmpn(1) > 0 && J.cmpn(1) > 0; ) {
          for (var G = 0, D = 1; !(O.words[0] & D) && G < 26; ++G, D <<= 1)
            ;
          if (G > 0)
            for (O.iushrn(G); G-- > 0; )
              Z.isOdd() && Z.iadd(z), Z.iushrn(1);
          for (var F = 0, ae = 1; !(J.words[0] & ae) && F < 26; ++F, ae <<= 1)
            ;
          if (F > 0)
            for (J.iushrn(F); F-- > 0; )
              K.isOdd() && K.iadd(z), K.iushrn(1);
          O.cmp(J) >= 0 ? (O.isub(J), Z.isub(K)) : (J.isub(O), K.isub(Z));
        }
        var ge;
        return O.cmpn(1) === 0 ? ge = Z : ge = K, ge.cmpn(0) < 0 && ge.iadd($), ge;
      }, h.prototype.gcd = function($) {
        if (this.isZero())
          return $.abs();
        if ($.isZero())
          return this.abs();
        var O = this.clone(), J = $.clone();
        O.negative = 0, J.negative = 0;
        for (var Z = 0; O.isEven() && J.isEven(); Z++)
          O.iushrn(1), J.iushrn(1);
        do {
          for (; O.isEven(); )
            O.iushrn(1);
          for (; J.isEven(); )
            J.iushrn(1);
          var K = O.cmp(J);
          if (K < 0) {
            var z = O;
            O = J, J = z;
          } else if (K === 0 || J.cmpn(1) === 0)
            break;
          O.isub(J);
        } while (!0);
        return J.iushln(Z);
      }, h.prototype.invm = function($) {
        return this.egcd($).a.umod($);
      }, h.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, h.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, h.prototype.andln = function($) {
        return this.words[0] & $;
      }, h.prototype.bincn = function($) {
        g(typeof $ == "number");
        var O = $ % 26, J = ($ - O) / 26, Z = 1 << O;
        if (this.length <= J)
          return this._expand(J + 1), this.words[J] |= Z, this;
        for (var K = Z, z = J; K !== 0 && z < this.length; z++) {
          var G = this.words[z] | 0;
          G += K, K = G >>> 26, G &= 67108863, this.words[z] = G;
        }
        return K !== 0 && (this.words[z] = K, this.length++), this;
      }, h.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, h.prototype.cmpn = function($) {
        var O = $ < 0;
        if (this.negative !== 0 && !O)
          return -1;
        if (this.negative === 0 && O)
          return 1;
        this._strip();
        var J;
        if (this.length > 1)
          J = 1;
        else {
          O && ($ = -$), g($ <= 67108863, "Number is too big");
          var Z = this.words[0] | 0;
          J = Z === $ ? 0 : Z < $ ? -1 : 1;
        }
        return this.negative !== 0 ? -J | 0 : J;
      }, h.prototype.cmp = function($) {
        if (this.negative !== 0 && $.negative === 0)
          return -1;
        if (this.negative === 0 && $.negative !== 0)
          return 1;
        var O = this.ucmp($);
        return this.negative !== 0 ? -O | 0 : O;
      }, h.prototype.ucmp = function($) {
        if (this.length > $.length)
          return 1;
        if (this.length < $.length)
          return -1;
        for (var O = 0, J = this.length - 1; J >= 0; J--) {
          var Z = this.words[J] | 0, K = $.words[J] | 0;
          if (Z !== K) {
            Z < K ? O = -1 : Z > K && (O = 1);
            break;
          }
        }
        return O;
      }, h.prototype.gtn = function($) {
        return this.cmpn($) === 1;
      }, h.prototype.gt = function($) {
        return this.cmp($) === 1;
      }, h.prototype.gten = function($) {
        return this.cmpn($) >= 0;
      }, h.prototype.gte = function($) {
        return this.cmp($) >= 0;
      }, h.prototype.ltn = function($) {
        return this.cmpn($) === -1;
      }, h.prototype.lt = function($) {
        return this.cmp($) === -1;
      }, h.prototype.lten = function($) {
        return this.cmpn($) <= 0;
      }, h.prototype.lte = function($) {
        return this.cmp($) <= 0;
      }, h.prototype.eqn = function($) {
        return this.cmpn($) === 0;
      }, h.prototype.eq = function($) {
        return this.cmp($) === 0;
      }, h.red = function($) {
        return new ne($);
      }, h.prototype.toRed = function($) {
        return g(!this.red, "Already a number in reduction context"), g(this.negative === 0, "red works only with positives"), $.convertTo(this)._forceRed($);
      }, h.prototype.fromRed = function() {
        return g(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, h.prototype._forceRed = function($) {
        return this.red = $, this;
      }, h.prototype.forceRed = function($) {
        return g(!this.red, "Already a number in reduction context"), this._forceRed($);
      }, h.prototype.redAdd = function($) {
        return g(this.red, "redAdd works only with red numbers"), this.red.add(this, $);
      }, h.prototype.redIAdd = function($) {
        return g(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, $);
      }, h.prototype.redSub = function($) {
        return g(this.red, "redSub works only with red numbers"), this.red.sub(this, $);
      }, h.prototype.redISub = function($) {
        return g(this.red, "redISub works only with red numbers"), this.red.isub(this, $);
      }, h.prototype.redShl = function($) {
        return g(this.red, "redShl works only with red numbers"), this.red.shl(this, $);
      }, h.prototype.redMul = function($) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, $), this.red.mul(this, $);
      }, h.prototype.redIMul = function($) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, $), this.red.imul(this, $);
      }, h.prototype.redSqr = function() {
        return g(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, h.prototype.redISqr = function() {
        return g(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, h.prototype.redSqrt = function() {
        return g(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, h.prototype.redInvm = function() {
        return g(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, h.prototype.redNeg = function() {
        return g(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, h.prototype.redPow = function($) {
        return g(this.red && !$.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, $);
      };
      var pe = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function me(M, $) {
        this.name = M, this.p = new h($, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var $ = new h(null);
        return $.words = new Array(Math.ceil(this.n / 13)), $;
      }, me.prototype.ireduce = function($) {
        var O = $, J;
        do
          this.split(O, this.tmp), O = this.imulK(O), O = O.iadd(this.tmp), J = O.bitLength();
        while (J > this.n);
        var Z = J < this.n ? -1 : O.ucmp(this.p);
        return Z === 0 ? (O.words[0] = 0, O.length = 1) : Z > 0 ? O.isub(this.p) : O.strip !== void 0 ? O.strip() : O._strip(), O;
      }, me.prototype.split = function($, O) {
        $.iushrn(this.n, 0, O);
      }, me.prototype.imulK = function($) {
        return $.imul(this.k);
      };
      function Me() {
        me.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      U(Me, me), Me.prototype.split = function($, O) {
        for (var J = 4194303, Z = Math.min($.length, 9), K = 0; K < Z; K++)
          O.words[K] = $.words[K];
        if (O.length = Z, $.length <= 9) {
          $.words[0] = 0, $.length = 1;
          return;
        }
        var z = $.words[9];
        for (O.words[O.length++] = z & J, K = 10; K < $.length; K++) {
          var G = $.words[K] | 0;
          $.words[K - 10] = (G & J) << 4 | z >>> 22, z = G;
        }
        z >>>= 22, $.words[K - 10] = z, z === 0 && $.length > 10 ? $.length -= 10 : $.length -= 9;
      }, Me.prototype.imulK = function($) {
        $.words[$.length] = 0, $.words[$.length + 1] = 0, $.length += 2;
        for (var O = 0, J = 0; J < $.length; J++) {
          var Z = $.words[J] | 0;
          O += Z * 977, $.words[J] = O & 67108863, O = Z * 64 + (O / 67108864 | 0);
        }
        return $.words[$.length - 1] === 0 && ($.length--, $.words[$.length - 1] === 0 && $.length--), $;
      };
      function Ee() {
        me.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      U(Ee, me);
      function Re() {
        me.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      U(Re, me);
      function Ne() {
        me.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      U(Ne, me), Ne.prototype.imulK = function($) {
        for (var O = 0, J = 0; J < $.length; J++) {
          var Z = ($.words[J] | 0) * 19 + O, K = Z & 67108863;
          Z >>>= 26, $.words[J] = K, O = Z;
        }
        return O !== 0 && ($.words[$.length++] = O), $;
      }, h._prime = function($) {
        if (pe[$])
          return pe[$];
        var O;
        if ($ === "k256")
          O = new Me();
        else if ($ === "p224")
          O = new Ee();
        else if ($ === "p192")
          O = new Re();
        else if ($ === "p25519")
          O = new Ne();
        else
          throw new Error("Unknown prime " + $);
        return pe[$] = O, O;
      };
      function ne(M) {
        if (typeof M == "string") {
          var $ = h._prime(M);
          this.m = $.p, this.prime = $;
        } else
          g(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
      }
      ne.prototype._verify1 = function($) {
        g($.negative === 0, "red works only with positives"), g($.red, "red works only with red numbers");
      }, ne.prototype._verify2 = function($, O) {
        g(($.negative | O.negative) === 0, "red works only with positives"), g(
          $.red && $.red === O.red,
          "red works only with red numbers"
        );
      }, ne.prototype.imod = function($) {
        return this.prime ? this.prime.ireduce($)._forceRed(this) : (B($, $.umod(this.m)._forceRed(this)), $);
      }, ne.prototype.neg = function($) {
        return $.isZero() ? $.clone() : this.m.sub($)._forceRed(this);
      }, ne.prototype.add = function($, O) {
        this._verify2($, O);
        var J = $.add(O);
        return J.cmp(this.m) >= 0 && J.isub(this.m), J._forceRed(this);
      }, ne.prototype.iadd = function($, O) {
        this._verify2($, O);
        var J = $.iadd(O);
        return J.cmp(this.m) >= 0 && J.isub(this.m), J;
      }, ne.prototype.sub = function($, O) {
        this._verify2($, O);
        var J = $.sub(O);
        return J.cmpn(0) < 0 && J.iadd(this.m), J._forceRed(this);
      }, ne.prototype.isub = function($, O) {
        this._verify2($, O);
        var J = $.isub(O);
        return J.cmpn(0) < 0 && J.iadd(this.m), J;
      }, ne.prototype.shl = function($, O) {
        return this._verify1($), this.imod($.ushln(O));
      }, ne.prototype.imul = function($, O) {
        return this._verify2($, O), this.imod($.imul(O));
      }, ne.prototype.mul = function($, O) {
        return this._verify2($, O), this.imod($.mul(O));
      }, ne.prototype.isqr = function($) {
        return this.imul($, $.clone());
      }, ne.prototype.sqr = function($) {
        return this.mul($, $);
      }, ne.prototype.sqrt = function($) {
        if ($.isZero())
          return $.clone();
        var O = this.m.andln(3);
        if (g(O % 2 === 1), O === 3) {
          var J = this.m.add(new h(1)).iushrn(2);
          return this.pow($, J);
        }
        for (var Z = this.m.subn(1), K = 0; !Z.isZero() && Z.andln(1) === 0; )
          K++, Z.iushrn(1);
        g(!Z.isZero());
        var z = new h(1).toRed(this), G = z.redNeg(), D = this.m.subn(1).iushrn(1), F = this.m.bitLength();
        for (F = new h(2 * F * F).toRed(this); this.pow(F, D).cmp(G) !== 0; )
          F.redIAdd(G);
        for (var ae = this.pow(F, Z), ge = this.pow($, Z.addn(1).iushrn(1)), xe = this.pow($, Z), ye = K; xe.cmp(z) !== 0; ) {
          for (var oe = xe, fe = 0; oe.cmp(z) !== 0; fe++)
            oe = oe.redSqr();
          g(fe < ye);
          var $e = this.pow(ae, new h(1).iushln(ye - fe - 1));
          ge = ge.redMul($e), ae = $e.redSqr(), xe = xe.redMul(ae), ye = fe;
        }
        return ge;
      }, ne.prototype.invm = function($) {
        var O = $._invmp(this.m);
        return O.negative !== 0 ? (O.negative = 0, this.imod(O).redNeg()) : this.imod(O);
      }, ne.prototype.pow = function($, O) {
        if (O.isZero())
          return new h(1).toRed(this);
        if (O.cmpn(1) === 0)
          return $.clone();
        var J = 4, Z = new Array(1 << J);
        Z[0] = new h(1).toRed(this), Z[1] = $;
        for (var K = 2; K < Z.length; K++)
          Z[K] = this.mul(Z[K - 1], $);
        var z = Z[0], G = 0, D = 0, F = O.bitLength() % 26;
        for (F === 0 && (F = 26), K = O.length - 1; K >= 0; K--) {
          for (var ae = O.words[K], ge = F - 1; ge >= 0; ge--) {
            var xe = ae >> ge & 1;
            if (z !== Z[0] && (z = this.sqr(z)), xe === 0 && G === 0) {
              D = 0;
              continue;
            }
            G <<= 1, G |= xe, D++, !(D !== J && (K !== 0 || ge !== 0)) && (z = this.mul(z, Z[G]), D = 0, G = 0);
          }
          F = 26;
        }
        return z;
      }, ne.prototype.convertTo = function($) {
        var O = $.umod(this.m);
        return O === $ ? O.clone() : O;
      }, ne.prototype.convertFrom = function($) {
        var O = $.clone();
        return O.red = null, O;
      }, h.mont = function($) {
        return new Y($);
      };
      function Y(M) {
        ne.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      U(Y, ne), Y.prototype.convertTo = function($) {
        return this.imod($.ushln(this.shift));
      }, Y.prototype.convertFrom = function($) {
        var O = this.imod($.mul(this.rinv));
        return O.red = null, O;
      }, Y.prototype.imul = function($, O) {
        if ($.isZero() || O.isZero())
          return $.words[0] = 0, $.length = 1, $;
        var J = $.imul(O), Z = J.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), K = J.isub(Z).iushrn(this.shift), z = K;
        return K.cmp(this.m) >= 0 ? z = K.isub(this.m) : K.cmpn(0) < 0 && (z = K.iadd(this.m)), z._forceRed(this);
      }, Y.prototype.mul = function($, O) {
        if ($.isZero() || O.isZero())
          return new h(0)._forceRed(this);
        var J = $.mul(O), Z = J.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), K = J.isub(Z).iushrn(this.shift), z = K;
        return K.cmp(this.m) >= 0 ? z = K.isub(this.m) : K.cmpn(0) < 0 && (z = K.iadd(this.m)), z._forceRed(this);
      }, Y.prototype.invm = function($) {
        var O = this.imod($._invmp(this.m).mul(this.r2));
        return O._forceRed(this);
      };
    })(e, commonjsGlobal$1);
  }(bn$1)), bn$1.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa)
    return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var e = requireBn$1(), o = requireBrowser$a();
  function S(h) {
    var q = g(h), A = q.toRed(e.mont(h.modulus)).redPow(new e(h.publicExponent)).fromRed();
    return { blinder: A, unblinder: q.invm(h.modulus) };
  }
  function g(h) {
    var q = h.modulus.byteLength(), A;
    do
      A = new e(o(q));
    while (A.cmp(h.modulus) >= 0 || !A.umod(h.prime1) || !A.umod(h.prime2));
    return A;
  }
  function U(h, q) {
    var A = S(q), P = q.modulus.byteLength(), I = new e(h).mul(A.blinder).umod(q.modulus), B = I.toRed(e.mont(q.prime1)), H = I.toRed(e.mont(q.prime2)), V = q.coefficient, X = q.prime1, Q = q.prime2, ee = B.redPow(q.exponent1).fromRed(), ie = H.redPow(q.exponent2).fromRed(), te = ee.isub(ie).imul(V).umod(X).imul(Q);
    return ie.iadd(te).imul(A.unblinder).umod(q.modulus).toArrayLike(buffer$3.Buffer, "be", P);
  }
  return U.getr = g, browserifyRsa = U, browserifyRsa;
}
var elliptic = {};
const name$1 = "elliptic", version$1 = "6.5.5", description$1 = "EC cryptography", main$1 = "lib/elliptic.js", files$1 = [
  "lib"
], scripts$1 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords$1 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author$1 = "Fedor Indutny <fedor@indutny.com>", license$1 = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage$1 = "https://github.com/indutny/elliptic", devDependencies$1 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies$1 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name: name$1,
  version: version$1,
  description: description$1,
  main: main$1,
  files: files$1,
  scripts: scripts$1,
  repository,
  keywords: keywords$1,
  author: author$1,
  license: license$1,
  bugs,
  homepage: homepage$1,
  devDependencies: devDependencies$1,
  dependencies: dependencies$1
};
var utils$2 = {}, utils$1 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(e) {
    var o = e;
    function S(h, q) {
      if (Array.isArray(h))
        return h.slice();
      if (!h)
        return [];
      var A = [];
      if (typeof h != "string") {
        for (var P = 0; P < h.length; P++)
          A[P] = h[P] | 0;
        return A;
      }
      if (q === "hex") {
        h = h.replace(/[^a-z0-9]+/ig, ""), h.length % 2 !== 0 && (h = "0" + h);
        for (var P = 0; P < h.length; P += 2)
          A.push(parseInt(h[P] + h[P + 1], 16));
      } else
        for (var P = 0; P < h.length; P++) {
          var I = h.charCodeAt(P), B = I >> 8, H = I & 255;
          B ? A.push(B, H) : A.push(H);
        }
      return A;
    }
    o.toArray = S;
    function g(h) {
      return h.length === 1 ? "0" + h : h;
    }
    o.zero2 = g;
    function U(h) {
      for (var q = "", A = 0; A < h.length; A++)
        q += g(h[A].toString(16));
      return q;
    }
    o.toHex = U, o.encode = function(q, A) {
      return A === "hex" ? U(q) : q;
    };
  }(utils$1)), utils$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(e) {
    var o = e, S = bnExports, g = requireMinimalisticAssert(), U = requireUtils$2();
    o.assert = g, o.toArray = U.toArray, o.zero2 = U.zero2, o.toHex = U.toHex, o.encode = U.encode;
    function h(B, H, V) {
      var X = new Array(Math.max(B.bitLength(), V) + 1), Q;
      for (Q = 0; Q < X.length; Q += 1)
        X[Q] = 0;
      var ee = 1 << H + 1, ie = B.clone();
      for (Q = 0; Q < X.length; Q++) {
        var te, se = ie.andln(ee - 1);
        ie.isOdd() ? (se > (ee >> 1) - 1 ? te = (ee >> 1) - se : te = se, ie.isubn(te)) : te = 0, X[Q] = te, ie.iushrn(1);
      }
      return X;
    }
    o.getNAF = h;
    function q(B, H) {
      var V = [
        [],
        []
      ];
      B = B.clone(), H = H.clone();
      for (var X = 0, Q = 0, ee; B.cmpn(-X) > 0 || H.cmpn(-Q) > 0; ) {
        var ie = B.andln(3) + X & 3, te = H.andln(3) + Q & 3;
        ie === 3 && (ie = -1), te === 3 && (te = -1);
        var se;
        ie & 1 ? (ee = B.andln(7) + X & 7, (ee === 3 || ee === 5) && te === 2 ? se = -ie : se = ie) : se = 0, V[0].push(se);
        var le;
        te & 1 ? (ee = H.andln(7) + Q & 7, (ee === 3 || ee === 5) && ie === 2 ? le = -te : le = te) : le = 0, V[1].push(le), 2 * X === se + 1 && (X = 1 - X), 2 * Q === le + 1 && (Q = 1 - Q), B.iushrn(1), H.iushrn(1);
      }
      return V;
    }
    o.getJSF = q;
    function A(B, H, V) {
      var X = "_" + H;
      B.prototype[H] = function() {
        return this[X] !== void 0 ? this[X] : this[X] = V.call(this);
      };
    }
    o.cachedProperty = A;
    function P(B) {
      return typeof B == "string" ? o.toArray(B, "hex") : B;
    }
    o.parseBytes = P;
    function I(B) {
      return new S(B, "hex", "le");
    }
    o.intFromLE = I;
  }(utils$2)), utils$2;
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1)
    return base$1;
  hasRequiredBase$1 = 1;
  var e = bnExports, o = requireUtils$1(), S = o.getNAF, g = o.getJSF, U = o.assert;
  function h(A, P) {
    this.type = A, this.p = new e(P.p, 16), this.red = P.prime ? e.red(P.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = P.n && new e(P.n, 16), this.g = P.g && this.pointFromJSON(P.g, P.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var I = this.n && this.p.div(this.n);
    !I || I.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$1 = h, h.prototype.point = function() {
    throw new Error("Not implemented");
  }, h.prototype.validate = function() {
    throw new Error("Not implemented");
  }, h.prototype._fixedNafMul = function(P, I) {
    U(P.precomputed);
    var B = P._getDoubles(), H = S(I, 1, this._bitLength), V = (1 << B.step + 1) - (B.step % 2 === 0 ? 2 : 1);
    V /= 3;
    var X = [], Q, ee;
    for (Q = 0; Q < H.length; Q += B.step) {
      ee = 0;
      for (var ie = Q + B.step - 1; ie >= Q; ie--)
        ee = (ee << 1) + H[ie];
      X.push(ee);
    }
    for (var te = this.jpoint(null, null, null), se = this.jpoint(null, null, null), le = V; le > 0; le--) {
      for (Q = 0; Q < X.length; Q++)
        ee = X[Q], ee === le ? se = se.mixedAdd(B.points[Q]) : ee === -le && (se = se.mixedAdd(B.points[Q].neg()));
      te = te.add(se);
    }
    return te.toP();
  }, h.prototype._wnafMul = function(P, I) {
    var B = 4, H = P._getNAFPoints(B);
    B = H.wnd;
    for (var V = H.points, X = S(I, B, this._bitLength), Q = this.jpoint(null, null, null), ee = X.length - 1; ee >= 0; ee--) {
      for (var ie = 0; ee >= 0 && X[ee] === 0; ee--)
        ie++;
      if (ee >= 0 && ie++, Q = Q.dblp(ie), ee < 0)
        break;
      var te = X[ee];
      U(te !== 0), P.type === "affine" ? te > 0 ? Q = Q.mixedAdd(V[te - 1 >> 1]) : Q = Q.mixedAdd(V[-te - 1 >> 1].neg()) : te > 0 ? Q = Q.add(V[te - 1 >> 1]) : Q = Q.add(V[-te - 1 >> 1].neg());
    }
    return P.type === "affine" ? Q.toP() : Q;
  }, h.prototype._wnafMulAdd = function(P, I, B, H, V) {
    var X = this._wnafT1, Q = this._wnafT2, ee = this._wnafT3, ie = 0, te, se, le;
    for (te = 0; te < H; te++) {
      le = I[te];
      var ce = le._getNAFPoints(P);
      X[te] = ce.wnd, Q[te] = ce.points;
    }
    for (te = H - 1; te >= 1; te -= 2) {
      var pe = te - 1, me = te;
      if (X[pe] !== 1 || X[me] !== 1) {
        ee[pe] = S(B[pe], X[pe], this._bitLength), ee[me] = S(B[me], X[me], this._bitLength), ie = Math.max(ee[pe].length, ie), ie = Math.max(ee[me].length, ie);
        continue;
      }
      var Me = [
        I[pe],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        I[me]
        /* 7 */
      ];
      I[pe].y.cmp(I[me].y) === 0 ? (Me[1] = I[pe].add(I[me]), Me[2] = I[pe].toJ().mixedAdd(I[me].neg())) : I[pe].y.cmp(I[me].y.redNeg()) === 0 ? (Me[1] = I[pe].toJ().mixedAdd(I[me]), Me[2] = I[pe].add(I[me].neg())) : (Me[1] = I[pe].toJ().mixedAdd(I[me]), Me[2] = I[pe].toJ().mixedAdd(I[me].neg()));
      var Ee = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Re = g(B[pe], B[me]);
      for (ie = Math.max(Re[0].length, ie), ee[pe] = new Array(ie), ee[me] = new Array(ie), se = 0; se < ie; se++) {
        var Ne = Re[0][se] | 0, ne = Re[1][se] | 0;
        ee[pe][se] = Ee[(Ne + 1) * 3 + (ne + 1)], ee[me][se] = 0, Q[pe] = Me;
      }
    }
    var Y = this.jpoint(null, null, null), M = this._wnafT4;
    for (te = ie; te >= 0; te--) {
      for (var $ = 0; te >= 0; ) {
        var O = !0;
        for (se = 0; se < H; se++)
          M[se] = ee[se][te] | 0, M[se] !== 0 && (O = !1);
        if (!O)
          break;
        $++, te--;
      }
      if (te >= 0 && $++, Y = Y.dblp($), te < 0)
        break;
      for (se = 0; se < H; se++) {
        var J = M[se];
        J !== 0 && (J > 0 ? le = Q[se][J - 1 >> 1] : J < 0 && (le = Q[se][-J - 1 >> 1].neg()), le.type === "affine" ? Y = Y.mixedAdd(le) : Y = Y.add(le));
      }
    }
    for (te = 0; te < H; te++)
      Q[te] = null;
    return V ? Y : Y.toP();
  };
  function q(A, P) {
    this.curve = A, this.type = P, this.precomputed = null;
  }
  return h.BasePoint = q, q.prototype.eq = function() {
    throw new Error("Not implemented");
  }, q.prototype.validate = function() {
    return this.curve.validate(this);
  }, h.prototype.decodePoint = function(P, I) {
    P = o.toArray(P, I);
    var B = this.p.byteLength();
    if ((P[0] === 4 || P[0] === 6 || P[0] === 7) && P.length - 1 === 2 * B) {
      P[0] === 6 ? U(P[P.length - 1] % 2 === 0) : P[0] === 7 && U(P[P.length - 1] % 2 === 1);
      var H = this.point(
        P.slice(1, 1 + B),
        P.slice(1 + B, 1 + 2 * B)
      );
      return H;
    } else if ((P[0] === 2 || P[0] === 3) && P.length - 1 === B)
      return this.pointFromX(P.slice(1, 1 + B), P[0] === 3);
    throw new Error("Unknown point format");
  }, q.prototype.encodeCompressed = function(P) {
    return this.encode(P, !0);
  }, q.prototype._encode = function(P) {
    var I = this.curve.p.byteLength(), B = this.getX().toArray("be", I);
    return P ? [this.getY().isEven() ? 2 : 3].concat(B) : [4].concat(B, this.getY().toArray("be", I));
  }, q.prototype.encode = function(P, I) {
    return o.encode(this._encode(I), P);
  }, q.prototype.precompute = function(P) {
    if (this.precomputed)
      return this;
    var I = {
      doubles: null,
      naf: null,
      beta: null
    };
    return I.naf = this._getNAFPoints(8), I.doubles = this._getDoubles(4, P), I.beta = this._getBeta(), this.precomputed = I, this;
  }, q.prototype._hasDoubles = function(P) {
    if (!this.precomputed)
      return !1;
    var I = this.precomputed.doubles;
    return I ? I.points.length >= Math.ceil((P.bitLength() + 1) / I.step) : !1;
  }, q.prototype._getDoubles = function(P, I) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var B = [this], H = this, V = 0; V < I; V += P) {
      for (var X = 0; X < P; X++)
        H = H.dbl();
      B.push(H);
    }
    return {
      step: P,
      points: B
    };
  }, q.prototype._getNAFPoints = function(P) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var I = [this], B = (1 << P) - 1, H = B === 1 ? null : this.dbl(), V = 1; V < B; V++)
      I[V] = I[V - 1].add(H);
    return {
      wnd: P,
      points: I
    };
  }, q.prototype._getBeta = function() {
    return null;
  }, q.prototype.dblp = function(P) {
    for (var I = this, B = 0; B < P; B++)
      I = I.dbl();
    return I;
  }, base$1;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort)
    return short;
  hasRequiredShort = 1;
  var e = requireUtils$1(), o = bnExports, S = requireInherits_browser(), g = requireBase$1(), U = e.assert;
  function h(P) {
    g.call(this, "short", P), this.a = new o(P.a, 16).toRed(this.red), this.b = new o(P.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(P), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  S(h, g), short = h, h.prototype._getEndomorphism = function(I) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var B, H;
      if (I.beta)
        B = new o(I.beta, 16).toRed(this.red);
      else {
        var V = this._getEndoRoots(this.p);
        B = V[0].cmp(V[1]) < 0 ? V[0] : V[1], B = B.toRed(this.red);
      }
      if (I.lambda)
        H = new o(I.lambda, 16);
      else {
        var X = this._getEndoRoots(this.n);
        this.g.mul(X[0]).x.cmp(this.g.x.redMul(B)) === 0 ? H = X[0] : (H = X[1], U(this.g.mul(H).x.cmp(this.g.x.redMul(B)) === 0));
      }
      var Q;
      return I.basis ? Q = I.basis.map(function(ee) {
        return {
          a: new o(ee.a, 16),
          b: new o(ee.b, 16)
        };
      }) : Q = this._getEndoBasis(H), {
        beta: B,
        lambda: H,
        basis: Q
      };
    }
  }, h.prototype._getEndoRoots = function(I) {
    var B = I === this.p ? this.red : o.mont(I), H = new o(2).toRed(B).redInvm(), V = H.redNeg(), X = new o(3).toRed(B).redNeg().redSqrt().redMul(H), Q = V.redAdd(X).fromRed(), ee = V.redSub(X).fromRed();
    return [Q, ee];
  }, h.prototype._getEndoBasis = function(I) {
    for (var B = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), H = I, V = this.n.clone(), X = new o(1), Q = new o(0), ee = new o(0), ie = new o(1), te, se, le, ce, pe, me, Me, Ee = 0, Re, Ne; H.cmpn(0) !== 0; ) {
      var ne = V.div(H);
      Re = V.sub(ne.mul(H)), Ne = ee.sub(ne.mul(X));
      var Y = ie.sub(ne.mul(Q));
      if (!le && Re.cmp(B) < 0)
        te = Me.neg(), se = X, le = Re.neg(), ce = Ne;
      else if (le && ++Ee === 2)
        break;
      Me = Re, V = H, H = Re, ee = X, X = Ne, ie = Q, Q = Y;
    }
    pe = Re.neg(), me = Ne;
    var M = le.sqr().add(ce.sqr()), $ = pe.sqr().add(me.sqr());
    return $.cmp(M) >= 0 && (pe = te, me = se), le.negative && (le = le.neg(), ce = ce.neg()), pe.negative && (pe = pe.neg(), me = me.neg()), [
      { a: le, b: ce },
      { a: pe, b: me }
    ];
  }, h.prototype._endoSplit = function(I) {
    var B = this.endo.basis, H = B[0], V = B[1], X = V.b.mul(I).divRound(this.n), Q = H.b.neg().mul(I).divRound(this.n), ee = X.mul(H.a), ie = Q.mul(V.a), te = X.mul(H.b), se = Q.mul(V.b), le = I.sub(ee).sub(ie), ce = te.add(se).neg();
    return { k1: le, k2: ce };
  }, h.prototype.pointFromX = function(I, B) {
    I = new o(I, 16), I.red || (I = I.toRed(this.red));
    var H = I.redSqr().redMul(I).redIAdd(I.redMul(this.a)).redIAdd(this.b), V = H.redSqrt();
    if (V.redSqr().redSub(H).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var X = V.fromRed().isOdd();
    return (B && !X || !B && X) && (V = V.redNeg()), this.point(I, V);
  }, h.prototype.validate = function(I) {
    if (I.inf)
      return !0;
    var B = I.x, H = I.y, V = this.a.redMul(B), X = B.redSqr().redMul(B).redIAdd(V).redIAdd(this.b);
    return H.redSqr().redISub(X).cmpn(0) === 0;
  }, h.prototype._endoWnafMulAdd = function(I, B, H) {
    for (var V = this._endoWnafT1, X = this._endoWnafT2, Q = 0; Q < I.length; Q++) {
      var ee = this._endoSplit(B[Q]), ie = I[Q], te = ie._getBeta();
      ee.k1.negative && (ee.k1.ineg(), ie = ie.neg(!0)), ee.k2.negative && (ee.k2.ineg(), te = te.neg(!0)), V[Q * 2] = ie, V[Q * 2 + 1] = te, X[Q * 2] = ee.k1, X[Q * 2 + 1] = ee.k2;
    }
    for (var se = this._wnafMulAdd(1, V, X, Q * 2, H), le = 0; le < Q * 2; le++)
      V[le] = null, X[le] = null;
    return se;
  };
  function q(P, I, B, H) {
    g.BasePoint.call(this, P, "affine"), I === null && B === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new o(I, 16), this.y = new o(B, 16), H && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  S(q, g.BasePoint), h.prototype.point = function(I, B, H) {
    return new q(this, I, B, H);
  }, h.prototype.pointFromJSON = function(I, B) {
    return q.fromJSON(this, I, B);
  }, q.prototype._getBeta = function() {
    if (this.curve.endo) {
      var I = this.precomputed;
      if (I && I.beta)
        return I.beta;
      var B = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (I) {
        var H = this.curve, V = function(X) {
          return H.point(X.x.redMul(H.endo.beta), X.y);
        };
        I.beta = B, B.precomputed = {
          beta: null,
          naf: I.naf && {
            wnd: I.naf.wnd,
            points: I.naf.points.map(V)
          },
          doubles: I.doubles && {
            step: I.doubles.step,
            points: I.doubles.points.map(V)
          }
        };
      }
      return B;
    }
  }, q.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, q.fromJSON = function(I, B, H) {
    typeof B == "string" && (B = JSON.parse(B));
    var V = I.point(B[0], B[1], H);
    if (!B[2])
      return V;
    function X(ee) {
      return I.point(ee[0], ee[1], H);
    }
    var Q = B[2];
    return V.precomputed = {
      beta: null,
      doubles: Q.doubles && {
        step: Q.doubles.step,
        points: [V].concat(Q.doubles.points.map(X))
      },
      naf: Q.naf && {
        wnd: Q.naf.wnd,
        points: [V].concat(Q.naf.points.map(X))
      }
    }, V;
  }, q.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, q.prototype.isInfinity = function() {
    return this.inf;
  }, q.prototype.add = function(I) {
    if (this.inf)
      return I;
    if (I.inf)
      return this;
    if (this.eq(I))
      return this.dbl();
    if (this.neg().eq(I))
      return this.curve.point(null, null);
    if (this.x.cmp(I.x) === 0)
      return this.curve.point(null, null);
    var B = this.y.redSub(I.y);
    B.cmpn(0) !== 0 && (B = B.redMul(this.x.redSub(I.x).redInvm()));
    var H = B.redSqr().redISub(this.x).redISub(I.x), V = B.redMul(this.x.redSub(H)).redISub(this.y);
    return this.curve.point(H, V);
  }, q.prototype.dbl = function() {
    if (this.inf)
      return this;
    var I = this.y.redAdd(this.y);
    if (I.cmpn(0) === 0)
      return this.curve.point(null, null);
    var B = this.curve.a, H = this.x.redSqr(), V = I.redInvm(), X = H.redAdd(H).redIAdd(H).redIAdd(B).redMul(V), Q = X.redSqr().redISub(this.x.redAdd(this.x)), ee = X.redMul(this.x.redSub(Q)).redISub(this.y);
    return this.curve.point(Q, ee);
  }, q.prototype.getX = function() {
    return this.x.fromRed();
  }, q.prototype.getY = function() {
    return this.y.fromRed();
  }, q.prototype.mul = function(I) {
    return I = new o(I, 16), this.isInfinity() ? this : this._hasDoubles(I) ? this.curve._fixedNafMul(this, I) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [I]) : this.curve._wnafMul(this, I);
  }, q.prototype.mulAdd = function(I, B, H) {
    var V = [this, B], X = [I, H];
    return this.curve.endo ? this.curve._endoWnafMulAdd(V, X) : this.curve._wnafMulAdd(1, V, X, 2);
  }, q.prototype.jmulAdd = function(I, B, H) {
    var V = [this, B], X = [I, H];
    return this.curve.endo ? this.curve._endoWnafMulAdd(V, X, !0) : this.curve._wnafMulAdd(1, V, X, 2, !0);
  }, q.prototype.eq = function(I) {
    return this === I || this.inf === I.inf && (this.inf || this.x.cmp(I.x) === 0 && this.y.cmp(I.y) === 0);
  }, q.prototype.neg = function(I) {
    if (this.inf)
      return this;
    var B = this.curve.point(this.x, this.y.redNeg());
    if (I && this.precomputed) {
      var H = this.precomputed, V = function(X) {
        return X.neg();
      };
      B.precomputed = {
        naf: H.naf && {
          wnd: H.naf.wnd,
          points: H.naf.points.map(V)
        },
        doubles: H.doubles && {
          step: H.doubles.step,
          points: H.doubles.points.map(V)
        }
      };
    }
    return B;
  }, q.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var I = this.curve.jpoint(this.x, this.y, this.curve.one);
    return I;
  };
  function A(P, I, B, H) {
    g.BasePoint.call(this, P, "jacobian"), I === null && B === null && H === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new o(0)) : (this.x = new o(I, 16), this.y = new o(B, 16), this.z = new o(H, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return S(A, g.BasePoint), h.prototype.jpoint = function(I, B, H) {
    return new A(this, I, B, H);
  }, A.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var I = this.z.redInvm(), B = I.redSqr(), H = this.x.redMul(B), V = this.y.redMul(B).redMul(I);
    return this.curve.point(H, V);
  }, A.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, A.prototype.add = function(I) {
    if (this.isInfinity())
      return I;
    if (I.isInfinity())
      return this;
    var B = I.z.redSqr(), H = this.z.redSqr(), V = this.x.redMul(B), X = I.x.redMul(H), Q = this.y.redMul(B.redMul(I.z)), ee = I.y.redMul(H.redMul(this.z)), ie = V.redSub(X), te = Q.redSub(ee);
    if (ie.cmpn(0) === 0)
      return te.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var se = ie.redSqr(), le = se.redMul(ie), ce = V.redMul(se), pe = te.redSqr().redIAdd(le).redISub(ce).redISub(ce), me = te.redMul(ce.redISub(pe)).redISub(Q.redMul(le)), Me = this.z.redMul(I.z).redMul(ie);
    return this.curve.jpoint(pe, me, Me);
  }, A.prototype.mixedAdd = function(I) {
    if (this.isInfinity())
      return I.toJ();
    if (I.isInfinity())
      return this;
    var B = this.z.redSqr(), H = this.x, V = I.x.redMul(B), X = this.y, Q = I.y.redMul(B).redMul(this.z), ee = H.redSub(V), ie = X.redSub(Q);
    if (ee.cmpn(0) === 0)
      return ie.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var te = ee.redSqr(), se = te.redMul(ee), le = H.redMul(te), ce = ie.redSqr().redIAdd(se).redISub(le).redISub(le), pe = ie.redMul(le.redISub(ce)).redISub(X.redMul(se)), me = this.z.redMul(ee);
    return this.curve.jpoint(ce, pe, me);
  }, A.prototype.dblp = function(I) {
    if (I === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!I)
      return this.dbl();
    var B;
    if (this.curve.zeroA || this.curve.threeA) {
      var H = this;
      for (B = 0; B < I; B++)
        H = H.dbl();
      return H;
    }
    var V = this.curve.a, X = this.curve.tinv, Q = this.x, ee = this.y, ie = this.z, te = ie.redSqr().redSqr(), se = ee.redAdd(ee);
    for (B = 0; B < I; B++) {
      var le = Q.redSqr(), ce = se.redSqr(), pe = ce.redSqr(), me = le.redAdd(le).redIAdd(le).redIAdd(V.redMul(te)), Me = Q.redMul(ce), Ee = me.redSqr().redISub(Me.redAdd(Me)), Re = Me.redISub(Ee), Ne = me.redMul(Re);
      Ne = Ne.redIAdd(Ne).redISub(pe);
      var ne = se.redMul(ie);
      B + 1 < I && (te = te.redMul(pe)), Q = Ee, ie = ne, se = Ne;
    }
    return this.curve.jpoint(Q, se.redMul(X), ie);
  }, A.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, A.prototype._zeroDbl = function() {
    var I, B, H;
    if (this.zOne) {
      var V = this.x.redSqr(), X = this.y.redSqr(), Q = X.redSqr(), ee = this.x.redAdd(X).redSqr().redISub(V).redISub(Q);
      ee = ee.redIAdd(ee);
      var ie = V.redAdd(V).redIAdd(V), te = ie.redSqr().redISub(ee).redISub(ee), se = Q.redIAdd(Q);
      se = se.redIAdd(se), se = se.redIAdd(se), I = te, B = ie.redMul(ee.redISub(te)).redISub(se), H = this.y.redAdd(this.y);
    } else {
      var le = this.x.redSqr(), ce = this.y.redSqr(), pe = ce.redSqr(), me = this.x.redAdd(ce).redSqr().redISub(le).redISub(pe);
      me = me.redIAdd(me);
      var Me = le.redAdd(le).redIAdd(le), Ee = Me.redSqr(), Re = pe.redIAdd(pe);
      Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), I = Ee.redISub(me).redISub(me), B = Me.redMul(me.redISub(I)).redISub(Re), H = this.y.redMul(this.z), H = H.redIAdd(H);
    }
    return this.curve.jpoint(I, B, H);
  }, A.prototype._threeDbl = function() {
    var I, B, H;
    if (this.zOne) {
      var V = this.x.redSqr(), X = this.y.redSqr(), Q = X.redSqr(), ee = this.x.redAdd(X).redSqr().redISub(V).redISub(Q);
      ee = ee.redIAdd(ee);
      var ie = V.redAdd(V).redIAdd(V).redIAdd(this.curve.a), te = ie.redSqr().redISub(ee).redISub(ee);
      I = te;
      var se = Q.redIAdd(Q);
      se = se.redIAdd(se), se = se.redIAdd(se), B = ie.redMul(ee.redISub(te)).redISub(se), H = this.y.redAdd(this.y);
    } else {
      var le = this.z.redSqr(), ce = this.y.redSqr(), pe = this.x.redMul(ce), me = this.x.redSub(le).redMul(this.x.redAdd(le));
      me = me.redAdd(me).redIAdd(me);
      var Me = pe.redIAdd(pe);
      Me = Me.redIAdd(Me);
      var Ee = Me.redAdd(Me);
      I = me.redSqr().redISub(Ee), H = this.y.redAdd(this.z).redSqr().redISub(ce).redISub(le);
      var Re = ce.redSqr();
      Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), B = me.redMul(Me.redISub(I)).redISub(Re);
    }
    return this.curve.jpoint(I, B, H);
  }, A.prototype._dbl = function() {
    var I = this.curve.a, B = this.x, H = this.y, V = this.z, X = V.redSqr().redSqr(), Q = B.redSqr(), ee = H.redSqr(), ie = Q.redAdd(Q).redIAdd(Q).redIAdd(I.redMul(X)), te = B.redAdd(B);
    te = te.redIAdd(te);
    var se = te.redMul(ee), le = ie.redSqr().redISub(se.redAdd(se)), ce = se.redISub(le), pe = ee.redSqr();
    pe = pe.redIAdd(pe), pe = pe.redIAdd(pe), pe = pe.redIAdd(pe);
    var me = ie.redMul(ce).redISub(pe), Me = H.redAdd(H).redMul(V);
    return this.curve.jpoint(le, me, Me);
  }, A.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var I = this.x.redSqr(), B = this.y.redSqr(), H = this.z.redSqr(), V = B.redSqr(), X = I.redAdd(I).redIAdd(I), Q = X.redSqr(), ee = this.x.redAdd(B).redSqr().redISub(I).redISub(V);
    ee = ee.redIAdd(ee), ee = ee.redAdd(ee).redIAdd(ee), ee = ee.redISub(Q);
    var ie = ee.redSqr(), te = V.redIAdd(V);
    te = te.redIAdd(te), te = te.redIAdd(te), te = te.redIAdd(te);
    var se = X.redIAdd(ee).redSqr().redISub(Q).redISub(ie).redISub(te), le = B.redMul(se);
    le = le.redIAdd(le), le = le.redIAdd(le);
    var ce = this.x.redMul(ie).redISub(le);
    ce = ce.redIAdd(ce), ce = ce.redIAdd(ce);
    var pe = this.y.redMul(se.redMul(te.redISub(se)).redISub(ee.redMul(ie)));
    pe = pe.redIAdd(pe), pe = pe.redIAdd(pe), pe = pe.redIAdd(pe);
    var me = this.z.redAdd(ee).redSqr().redISub(H).redISub(ie);
    return this.curve.jpoint(ce, pe, me);
  }, A.prototype.mul = function(I, B) {
    return I = new o(I, B), this.curve._wnafMul(this, I);
  }, A.prototype.eq = function(I) {
    if (I.type === "affine")
      return this.eq(I.toJ());
    if (this === I)
      return !0;
    var B = this.z.redSqr(), H = I.z.redSqr();
    if (this.x.redMul(H).redISub(I.x.redMul(B)).cmpn(0) !== 0)
      return !1;
    var V = B.redMul(this.z), X = H.redMul(I.z);
    return this.y.redMul(X).redISub(I.y.redMul(V)).cmpn(0) === 0;
  }, A.prototype.eqXToP = function(I) {
    var B = this.z.redSqr(), H = I.toRed(this.curve.red).redMul(B);
    if (this.x.cmp(H) === 0)
      return !0;
    for (var V = I.clone(), X = this.curve.redN.redMul(B); ; ) {
      if (V.iadd(this.curve.n), V.cmp(this.curve.p) >= 0)
        return !1;
      if (H.redIAdd(X), this.x.cmp(H) === 0)
        return !0;
    }
  }, A.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, A.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont)
    return mont;
  hasRequiredMont = 1;
  var e = bnExports, o = requireInherits_browser(), S = requireBase$1(), g = requireUtils$1();
  function U(q) {
    S.call(this, "mont", q), this.a = new e(q.a, 16).toRed(this.red), this.b = new e(q.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  o(U, S), mont = U, U.prototype.validate = function(A) {
    var P = A.normalize().x, I = P.redSqr(), B = I.redMul(P).redAdd(I.redMul(this.a)).redAdd(P), H = B.redSqrt();
    return H.redSqr().cmp(B) === 0;
  };
  function h(q, A, P) {
    S.BasePoint.call(this, q, "projective"), A === null && P === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(A, 16), this.z = new e(P, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return o(h, S.BasePoint), U.prototype.decodePoint = function(A, P) {
    return this.point(g.toArray(A, P), 1);
  }, U.prototype.point = function(A, P) {
    return new h(this, A, P);
  }, U.prototype.pointFromJSON = function(A) {
    return h.fromJSON(this, A);
  }, h.prototype.precompute = function() {
  }, h.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, h.fromJSON = function(A, P) {
    return new h(A, P[0], P[1] || A.one);
  }, h.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, h.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, h.prototype.dbl = function() {
    var A = this.x.redAdd(this.z), P = A.redSqr(), I = this.x.redSub(this.z), B = I.redSqr(), H = P.redSub(B), V = P.redMul(B), X = H.redMul(B.redAdd(this.curve.a24.redMul(H)));
    return this.curve.point(V, X);
  }, h.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, h.prototype.diffAdd = function(A, P) {
    var I = this.x.redAdd(this.z), B = this.x.redSub(this.z), H = A.x.redAdd(A.z), V = A.x.redSub(A.z), X = V.redMul(I), Q = H.redMul(B), ee = P.z.redMul(X.redAdd(Q).redSqr()), ie = P.x.redMul(X.redISub(Q).redSqr());
    return this.curve.point(ee, ie);
  }, h.prototype.mul = function(A) {
    for (var P = A.clone(), I = this, B = this.curve.point(null, null), H = this, V = []; P.cmpn(0) !== 0; P.iushrn(1))
      V.push(P.andln(1));
    for (var X = V.length - 1; X >= 0; X--)
      V[X] === 0 ? (I = I.diffAdd(B, H), B = B.dbl()) : (B = I.diffAdd(B, H), I = I.dbl());
    return B;
  }, h.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, h.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, h.prototype.eq = function(A) {
    return this.getX().cmp(A.getX()) === 0;
  }, h.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, h.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards)
    return edwards;
  hasRequiredEdwards = 1;
  var e = requireUtils$1(), o = bnExports, S = requireInherits_browser(), g = requireBase$1(), U = e.assert;
  function h(A) {
    this.twisted = (A.a | 0) !== 1, this.mOneA = this.twisted && (A.a | 0) === -1, this.extended = this.mOneA, g.call(this, "edwards", A), this.a = new o(A.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new o(A.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new o(A.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), U(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (A.c | 0) === 1;
  }
  S(h, g), edwards = h, h.prototype._mulA = function(P) {
    return this.mOneA ? P.redNeg() : this.a.redMul(P);
  }, h.prototype._mulC = function(P) {
    return this.oneC ? P : this.c.redMul(P);
  }, h.prototype.jpoint = function(P, I, B, H) {
    return this.point(P, I, B, H);
  }, h.prototype.pointFromX = function(P, I) {
    P = new o(P, 16), P.red || (P = P.toRed(this.red));
    var B = P.redSqr(), H = this.c2.redSub(this.a.redMul(B)), V = this.one.redSub(this.c2.redMul(this.d).redMul(B)), X = H.redMul(V.redInvm()), Q = X.redSqrt();
    if (Q.redSqr().redSub(X).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var ee = Q.fromRed().isOdd();
    return (I && !ee || !I && ee) && (Q = Q.redNeg()), this.point(P, Q);
  }, h.prototype.pointFromY = function(P, I) {
    P = new o(P, 16), P.red || (P = P.toRed(this.red));
    var B = P.redSqr(), H = B.redSub(this.c2), V = B.redMul(this.d).redMul(this.c2).redSub(this.a), X = H.redMul(V.redInvm());
    if (X.cmp(this.zero) === 0) {
      if (I)
        throw new Error("invalid point");
      return this.point(this.zero, P);
    }
    var Q = X.redSqrt();
    if (Q.redSqr().redSub(X).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return Q.fromRed().isOdd() !== I && (Q = Q.redNeg()), this.point(Q, P);
  }, h.prototype.validate = function(P) {
    if (P.isInfinity())
      return !0;
    P.normalize();
    var I = P.x.redSqr(), B = P.y.redSqr(), H = I.redMul(this.a).redAdd(B), V = this.c2.redMul(this.one.redAdd(this.d.redMul(I).redMul(B)));
    return H.cmp(V) === 0;
  };
  function q(A, P, I, B, H) {
    g.BasePoint.call(this, A, "projective"), P === null && I === null && B === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new o(P, 16), this.y = new o(I, 16), this.z = B ? new o(B, 16) : this.curve.one, this.t = H && new o(H, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return S(q, g.BasePoint), h.prototype.pointFromJSON = function(P) {
    return q.fromJSON(this, P);
  }, h.prototype.point = function(P, I, B, H) {
    return new q(this, P, I, B, H);
  }, q.fromJSON = function(P, I) {
    return new q(P, I[0], I[1], I[2]);
  }, q.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, q.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, q.prototype._extDbl = function() {
    var P = this.x.redSqr(), I = this.y.redSqr(), B = this.z.redSqr();
    B = B.redIAdd(B);
    var H = this.curve._mulA(P), V = this.x.redAdd(this.y).redSqr().redISub(P).redISub(I), X = H.redAdd(I), Q = X.redSub(B), ee = H.redSub(I), ie = V.redMul(Q), te = X.redMul(ee), se = V.redMul(ee), le = Q.redMul(X);
    return this.curve.point(ie, te, le, se);
  }, q.prototype._projDbl = function() {
    var P = this.x.redAdd(this.y).redSqr(), I = this.x.redSqr(), B = this.y.redSqr(), H, V, X, Q, ee, ie;
    if (this.curve.twisted) {
      Q = this.curve._mulA(I);
      var te = Q.redAdd(B);
      this.zOne ? (H = P.redSub(I).redSub(B).redMul(te.redSub(this.curve.two)), V = te.redMul(Q.redSub(B)), X = te.redSqr().redSub(te).redSub(te)) : (ee = this.z.redSqr(), ie = te.redSub(ee).redISub(ee), H = P.redSub(I).redISub(B).redMul(ie), V = te.redMul(Q.redSub(B)), X = te.redMul(ie));
    } else
      Q = I.redAdd(B), ee = this.curve._mulC(this.z).redSqr(), ie = Q.redSub(ee).redSub(ee), H = this.curve._mulC(P.redISub(Q)).redMul(ie), V = this.curve._mulC(Q).redMul(I.redISub(B)), X = Q.redMul(ie);
    return this.curve.point(H, V, X);
  }, q.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, q.prototype._extAdd = function(P) {
    var I = this.y.redSub(this.x).redMul(P.y.redSub(P.x)), B = this.y.redAdd(this.x).redMul(P.y.redAdd(P.x)), H = this.t.redMul(this.curve.dd).redMul(P.t), V = this.z.redMul(P.z.redAdd(P.z)), X = B.redSub(I), Q = V.redSub(H), ee = V.redAdd(H), ie = B.redAdd(I), te = X.redMul(Q), se = ee.redMul(ie), le = X.redMul(ie), ce = Q.redMul(ee);
    return this.curve.point(te, se, ce, le);
  }, q.prototype._projAdd = function(P) {
    var I = this.z.redMul(P.z), B = I.redSqr(), H = this.x.redMul(P.x), V = this.y.redMul(P.y), X = this.curve.d.redMul(H).redMul(V), Q = B.redSub(X), ee = B.redAdd(X), ie = this.x.redAdd(this.y).redMul(P.x.redAdd(P.y)).redISub(H).redISub(V), te = I.redMul(Q).redMul(ie), se, le;
    return this.curve.twisted ? (se = I.redMul(ee).redMul(V.redSub(this.curve._mulA(H))), le = Q.redMul(ee)) : (se = I.redMul(ee).redMul(V.redSub(H)), le = this.curve._mulC(Q).redMul(ee)), this.curve.point(te, se, le);
  }, q.prototype.add = function(P) {
    return this.isInfinity() ? P : P.isInfinity() ? this : this.curve.extended ? this._extAdd(P) : this._projAdd(P);
  }, q.prototype.mul = function(P) {
    return this._hasDoubles(P) ? this.curve._fixedNafMul(this, P) : this.curve._wnafMul(this, P);
  }, q.prototype.mulAdd = function(P, I, B) {
    return this.curve._wnafMulAdd(1, [this, I], [P, B], 2, !1);
  }, q.prototype.jmulAdd = function(P, I, B) {
    return this.curve._wnafMulAdd(1, [this, I], [P, B], 2, !0);
  }, q.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var P = this.z.redInvm();
    return this.x = this.x.redMul(P), this.y = this.y.redMul(P), this.t && (this.t = this.t.redMul(P)), this.z = this.curve.one, this.zOne = !0, this;
  }, q.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, q.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, q.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, q.prototype.eq = function(P) {
    return this === P || this.getX().cmp(P.getX()) === 0 && this.getY().cmp(P.getY()) === 0;
  }, q.prototype.eqXToP = function(P) {
    var I = P.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(I) === 0)
      return !0;
    for (var B = P.clone(), H = this.curve.redN.redMul(this.z); ; ) {
      if (B.iadd(this.curve.n), B.cmp(this.curve.p) >= 0)
        return !1;
      if (I.redIAdd(H), this.x.cmp(I) === 0)
        return !0;
    }
  }, q.prototype.toP = q.prototype.normalize, q.prototype.mixedAdd = q.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(e) {
    var o = e;
    o.base = requireBase$1(), o.short = requireShort(), o.mont = requireMont(), o.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  var e = requireMinimalisticAssert(), o = requireInherits_browser();
  utils.inherits = o;
  function S(Y, M) {
    return (Y.charCodeAt(M) & 64512) !== 55296 || M < 0 || M + 1 >= Y.length ? !1 : (Y.charCodeAt(M + 1) & 64512) === 56320;
  }
  function g(Y, M) {
    if (Array.isArray(Y))
      return Y.slice();
    if (!Y)
      return [];
    var $ = [];
    if (typeof Y == "string")
      if (M) {
        if (M === "hex")
          for (Y = Y.replace(/[^a-z0-9]+/ig, ""), Y.length % 2 !== 0 && (Y = "0" + Y), J = 0; J < Y.length; J += 2)
            $.push(parseInt(Y[J] + Y[J + 1], 16));
      } else
        for (var O = 0, J = 0; J < Y.length; J++) {
          var Z = Y.charCodeAt(J);
          Z < 128 ? $[O++] = Z : Z < 2048 ? ($[O++] = Z >> 6 | 192, $[O++] = Z & 63 | 128) : S(Y, J) ? (Z = 65536 + ((Z & 1023) << 10) + (Y.charCodeAt(++J) & 1023), $[O++] = Z >> 18 | 240, $[O++] = Z >> 12 & 63 | 128, $[O++] = Z >> 6 & 63 | 128, $[O++] = Z & 63 | 128) : ($[O++] = Z >> 12 | 224, $[O++] = Z >> 6 & 63 | 128, $[O++] = Z & 63 | 128);
        }
    else
      for (J = 0; J < Y.length; J++)
        $[J] = Y[J] | 0;
    return $;
  }
  utils.toArray = g;
  function U(Y) {
    for (var M = "", $ = 0; $ < Y.length; $++)
      M += A(Y[$].toString(16));
    return M;
  }
  utils.toHex = U;
  function h(Y) {
    var M = Y >>> 24 | Y >>> 8 & 65280 | Y << 8 & 16711680 | (Y & 255) << 24;
    return M >>> 0;
  }
  utils.htonl = h;
  function q(Y, M) {
    for (var $ = "", O = 0; O < Y.length; O++) {
      var J = Y[O];
      M === "little" && (J = h(J)), $ += P(J.toString(16));
    }
    return $;
  }
  utils.toHex32 = q;
  function A(Y) {
    return Y.length === 1 ? "0" + Y : Y;
  }
  utils.zero2 = A;
  function P(Y) {
    return Y.length === 7 ? "0" + Y : Y.length === 6 ? "00" + Y : Y.length === 5 ? "000" + Y : Y.length === 4 ? "0000" + Y : Y.length === 3 ? "00000" + Y : Y.length === 2 ? "000000" + Y : Y.length === 1 ? "0000000" + Y : Y;
  }
  utils.zero8 = P;
  function I(Y, M, $, O) {
    var J = $ - M;
    e(J % 4 === 0);
    for (var Z = new Array(J / 4), K = 0, z = M; K < Z.length; K++, z += 4) {
      var G;
      O === "big" ? G = Y[z] << 24 | Y[z + 1] << 16 | Y[z + 2] << 8 | Y[z + 3] : G = Y[z + 3] << 24 | Y[z + 2] << 16 | Y[z + 1] << 8 | Y[z], Z[K] = G >>> 0;
    }
    return Z;
  }
  utils.join32 = I;
  function B(Y, M) {
    for (var $ = new Array(Y.length * 4), O = 0, J = 0; O < Y.length; O++, J += 4) {
      var Z = Y[O];
      M === "big" ? ($[J] = Z >>> 24, $[J + 1] = Z >>> 16 & 255, $[J + 2] = Z >>> 8 & 255, $[J + 3] = Z & 255) : ($[J + 3] = Z >>> 24, $[J + 2] = Z >>> 16 & 255, $[J + 1] = Z >>> 8 & 255, $[J] = Z & 255);
    }
    return $;
  }
  utils.split32 = B;
  function H(Y, M) {
    return Y >>> M | Y << 32 - M;
  }
  utils.rotr32 = H;
  function V(Y, M) {
    return Y << M | Y >>> 32 - M;
  }
  utils.rotl32 = V;
  function X(Y, M) {
    return Y + M >>> 0;
  }
  utils.sum32 = X;
  function Q(Y, M, $) {
    return Y + M + $ >>> 0;
  }
  utils.sum32_3 = Q;
  function ee(Y, M, $, O) {
    return Y + M + $ + O >>> 0;
  }
  utils.sum32_4 = ee;
  function ie(Y, M, $, O, J) {
    return Y + M + $ + O + J >>> 0;
  }
  utils.sum32_5 = ie;
  function te(Y, M, $, O) {
    var J = Y[M], Z = Y[M + 1], K = O + Z >>> 0, z = (K < O ? 1 : 0) + $ + J;
    Y[M] = z >>> 0, Y[M + 1] = K;
  }
  utils.sum64 = te;
  function se(Y, M, $, O) {
    var J = M + O >>> 0, Z = (J < M ? 1 : 0) + Y + $;
    return Z >>> 0;
  }
  utils.sum64_hi = se;
  function le(Y, M, $, O) {
    var J = M + O;
    return J >>> 0;
  }
  utils.sum64_lo = le;
  function ce(Y, M, $, O, J, Z, K, z) {
    var G = 0, D = M;
    D = D + O >>> 0, G += D < M ? 1 : 0, D = D + Z >>> 0, G += D < Z ? 1 : 0, D = D + z >>> 0, G += D < z ? 1 : 0;
    var F = Y + $ + J + K + G;
    return F >>> 0;
  }
  utils.sum64_4_hi = ce;
  function pe(Y, M, $, O, J, Z, K, z) {
    var G = M + O + Z + z;
    return G >>> 0;
  }
  utils.sum64_4_lo = pe;
  function me(Y, M, $, O, J, Z, K, z, G, D) {
    var F = 0, ae = M;
    ae = ae + O >>> 0, F += ae < M ? 1 : 0, ae = ae + Z >>> 0, F += ae < Z ? 1 : 0, ae = ae + z >>> 0, F += ae < z ? 1 : 0, ae = ae + D >>> 0, F += ae < D ? 1 : 0;
    var ge = Y + $ + J + K + G + F;
    return ge >>> 0;
  }
  utils.sum64_5_hi = me;
  function Me(Y, M, $, O, J, Z, K, z, G, D) {
    var F = M + O + Z + z + D;
    return F >>> 0;
  }
  utils.sum64_5_lo = Me;
  function Ee(Y, M, $) {
    var O = M << 32 - $ | Y >>> $;
    return O >>> 0;
  }
  utils.rotr64_hi = Ee;
  function Re(Y, M, $) {
    var O = Y << 32 - $ | M >>> $;
    return O >>> 0;
  }
  utils.rotr64_lo = Re;
  function Ne(Y, M, $) {
    return Y >>> $;
  }
  utils.shr64_hi = Ne;
  function ne(Y, M, $) {
    var O = Y << 32 - $ | M >>> $;
    return O >>> 0;
  }
  return utils.shr64_lo = ne, utils;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$1;
  hasRequiredCommon$1 = 1;
  var e = requireUtils(), o = requireMinimalisticAssert();
  function S() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = S, S.prototype.update = function(U, h) {
    if (U = e.toArray(U, h), this.pending ? this.pending = this.pending.concat(U) : this.pending = U, this.pendingTotal += U.length, this.pending.length >= this._delta8) {
      U = this.pending;
      var q = U.length % this._delta8;
      this.pending = U.slice(U.length - q, U.length), this.pending.length === 0 && (this.pending = null), U = e.join32(U, 0, U.length - q, this.endian);
      for (var A = 0; A < U.length; A += this._delta32)
        this._update(U, A, A + this._delta32);
    }
    return this;
  }, S.prototype.digest = function(U) {
    return this.update(this._pad()), o(this.pending === null), this._digest(U);
  }, S.prototype._pad = function() {
    var U = this.pendingTotal, h = this._delta8, q = h - (U + this.padLength) % h, A = new Array(q + this.padLength);
    A[0] = 128;
    for (var P = 1; P < q; P++)
      A[P] = 0;
    if (U <<= 3, this.endian === "big") {
      for (var I = 8; I < this.padLength; I++)
        A[P++] = 0;
      A[P++] = 0, A[P++] = 0, A[P++] = 0, A[P++] = 0, A[P++] = U >>> 24 & 255, A[P++] = U >>> 16 & 255, A[P++] = U >>> 8 & 255, A[P++] = U & 255;
    } else
      for (A[P++] = U & 255, A[P++] = U >>> 8 & 255, A[P++] = U >>> 16 & 255, A[P++] = U >>> 24 & 255, A[P++] = 0, A[P++] = 0, A[P++] = 0, A[P++] = 0, I = 8; I < this.padLength; I++)
        A[P++] = 0;
    return A;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  var e = requireUtils(), o = e.rotr32;
  function S(B, H, V, X) {
    if (B === 0)
      return g(H, V, X);
    if (B === 1 || B === 3)
      return h(H, V, X);
    if (B === 2)
      return U(H, V, X);
  }
  common.ft_1 = S;
  function g(B, H, V) {
    return B & H ^ ~B & V;
  }
  common.ch32 = g;
  function U(B, H, V) {
    return B & H ^ B & V ^ H & V;
  }
  common.maj32 = U;
  function h(B, H, V) {
    return B ^ H ^ V;
  }
  common.p32 = h;
  function q(B) {
    return o(B, 2) ^ o(B, 13) ^ o(B, 22);
  }
  common.s0_256 = q;
  function A(B) {
    return o(B, 6) ^ o(B, 11) ^ o(B, 25);
  }
  common.s1_256 = A;
  function P(B) {
    return o(B, 7) ^ o(B, 18) ^ B >>> 3;
  }
  common.g0_256 = P;
  function I(B) {
    return o(B, 17) ^ o(B, 19) ^ B >>> 10;
  }
  return common.g1_256 = I, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1)
    return _1;
  hasRequired_1 = 1;
  var e = requireUtils(), o = requireCommon$1(), S = requireCommon(), g = e.rotl32, U = e.sum32, h = e.sum32_5, q = S.ft_1, A = o.BlockHash, P = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function I() {
    if (!(this instanceof I))
      return new I();
    A.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(I, A), _1 = I, I.blockSize = 512, I.outSize = 160, I.hmacStrength = 80, I.padLength = 64, I.prototype._update = function(H, V) {
    for (var X = this.W, Q = 0; Q < 16; Q++)
      X[Q] = H[V + Q];
    for (; Q < X.length; Q++)
      X[Q] = g(X[Q - 3] ^ X[Q - 8] ^ X[Q - 14] ^ X[Q - 16], 1);
    var ee = this.h[0], ie = this.h[1], te = this.h[2], se = this.h[3], le = this.h[4];
    for (Q = 0; Q < X.length; Q++) {
      var ce = ~~(Q / 20), pe = h(g(ee, 5), q(ce, ie, te, se), le, X[Q], P[ce]);
      le = se, se = te, te = g(ie, 30), ie = ee, ee = pe;
    }
    this.h[0] = U(this.h[0], ee), this.h[1] = U(this.h[1], ie), this.h[2] = U(this.h[2], te), this.h[3] = U(this.h[3], se), this.h[4] = U(this.h[4], le);
  }, I.prototype._digest = function(H) {
    return H === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256)
    return _256;
  hasRequired_256 = 1;
  var e = requireUtils(), o = requireCommon$1(), S = requireCommon(), g = requireMinimalisticAssert(), U = e.sum32, h = e.sum32_4, q = e.sum32_5, A = S.ch32, P = S.maj32, I = S.s0_256, B = S.s1_256, H = S.g0_256, V = S.g1_256, X = o.BlockHash, Q = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ee() {
    if (!(this instanceof ee))
      return new ee();
    X.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = Q, this.W = new Array(64);
  }
  return e.inherits(ee, X), _256 = ee, ee.blockSize = 512, ee.outSize = 256, ee.hmacStrength = 192, ee.padLength = 64, ee.prototype._update = function(te, se) {
    for (var le = this.W, ce = 0; ce < 16; ce++)
      le[ce] = te[se + ce];
    for (; ce < le.length; ce++)
      le[ce] = h(V(le[ce - 2]), le[ce - 7], H(le[ce - 15]), le[ce - 16]);
    var pe = this.h[0], me = this.h[1], Me = this.h[2], Ee = this.h[3], Re = this.h[4], Ne = this.h[5], ne = this.h[6], Y = this.h[7];
    for (g(this.k.length === le.length), ce = 0; ce < le.length; ce++) {
      var M = q(Y, B(Re), A(Re, Ne, ne), this.k[ce], le[ce]), $ = U(I(pe), P(pe, me, Me));
      Y = ne, ne = Ne, Ne = Re, Re = U(Ee, M), Ee = Me, Me = me, me = pe, pe = U(M, $);
    }
    this.h[0] = U(this.h[0], pe), this.h[1] = U(this.h[1], me), this.h[2] = U(this.h[2], Me), this.h[3] = U(this.h[3], Ee), this.h[4] = U(this.h[4], Re), this.h[5] = U(this.h[5], Ne), this.h[6] = U(this.h[6], ne), this.h[7] = U(this.h[7], Y);
  }, ee.prototype._digest = function(te) {
    return te === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224)
    return _224;
  hasRequired_224 = 1;
  var e = requireUtils(), o = require_256();
  function S() {
    if (!(this instanceof S))
      return new S();
    o.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(S, o), _224 = S, S.blockSize = 512, S.outSize = 224, S.hmacStrength = 192, S.padLength = 64, S.prototype._digest = function(U) {
    return U === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512)
    return _512;
  hasRequired_512 = 1;
  var e = requireUtils(), o = requireCommon$1(), S = requireMinimalisticAssert(), g = e.rotr64_hi, U = e.rotr64_lo, h = e.shr64_hi, q = e.shr64_lo, A = e.sum64, P = e.sum64_hi, I = e.sum64_lo, B = e.sum64_4_hi, H = e.sum64_4_lo, V = e.sum64_5_hi, X = e.sum64_5_lo, Q = o.BlockHash, ee = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function ie() {
    if (!(this instanceof ie))
      return new ie();
    Q.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = ee, this.W = new Array(160);
  }
  e.inherits(ie, Q), _512 = ie, ie.blockSize = 1024, ie.outSize = 512, ie.hmacStrength = 192, ie.padLength = 128, ie.prototype._prepareBlock = function($, O) {
    for (var J = this.W, Z = 0; Z < 32; Z++)
      J[Z] = $[O + Z];
    for (; Z < J.length; Z += 2) {
      var K = ne(J[Z - 4], J[Z - 3]), z = Y(J[Z - 4], J[Z - 3]), G = J[Z - 14], D = J[Z - 13], F = Re(J[Z - 30], J[Z - 29]), ae = Ne(J[Z - 30], J[Z - 29]), ge = J[Z - 32], xe = J[Z - 31];
      J[Z] = B(
        K,
        z,
        G,
        D,
        F,
        ae,
        ge,
        xe
      ), J[Z + 1] = H(
        K,
        z,
        G,
        D,
        F,
        ae,
        ge,
        xe
      );
    }
  }, ie.prototype._update = function($, O) {
    this._prepareBlock($, O);
    var J = this.W, Z = this.h[0], K = this.h[1], z = this.h[2], G = this.h[3], D = this.h[4], F = this.h[5], ae = this.h[6], ge = this.h[7], xe = this.h[8], ye = this.h[9], oe = this.h[10], fe = this.h[11], $e = this.h[12], Be = this.h[13], be = this.h[14], ve = this.h[15];
    S(this.k.length === J.length);
    for (var qe = 0; qe < J.length; qe += 2) {
      var De = be, Ye = ve, he = Me(xe, ye), ue = Ee(xe, ye), de = te(xe, ye, oe, fe, $e), _e = se(xe, ye, oe, fe, $e, Be), Pe = this.k[qe], He = this.k[qe + 1], Ve = J[qe], nt = J[qe + 1], Ie = V(
        De,
        Ye,
        he,
        ue,
        de,
        _e,
        Pe,
        He,
        Ve,
        nt
      ), Fe = X(
        De,
        Ye,
        he,
        ue,
        de,
        _e,
        Pe,
        He,
        Ve,
        nt
      );
      De = pe(Z, K), Ye = me(Z, K), he = le(Z, K, z, G, D), ue = ce(Z, K, z, G, D, F);
      var je = P(De, Ye, he, ue), Ke = I(De, Ye, he, ue);
      be = $e, ve = Be, $e = oe, Be = fe, oe = xe, fe = ye, xe = P(ae, ge, Ie, Fe), ye = I(ge, ge, Ie, Fe), ae = D, ge = F, D = z, F = G, z = Z, G = K, Z = P(Ie, Fe, je, Ke), K = I(Ie, Fe, je, Ke);
    }
    A(this.h, 0, Z, K), A(this.h, 2, z, G), A(this.h, 4, D, F), A(this.h, 6, ae, ge), A(this.h, 8, xe, ye), A(this.h, 10, oe, fe), A(this.h, 12, $e, Be), A(this.h, 14, be, ve);
  }, ie.prototype._digest = function($) {
    return $ === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function te(M, $, O, J, Z) {
    var K = M & O ^ ~M & Z;
    return K < 0 && (K += 4294967296), K;
  }
  function se(M, $, O, J, Z, K) {
    var z = $ & J ^ ~$ & K;
    return z < 0 && (z += 4294967296), z;
  }
  function le(M, $, O, J, Z) {
    var K = M & O ^ M & Z ^ O & Z;
    return K < 0 && (K += 4294967296), K;
  }
  function ce(M, $, O, J, Z, K) {
    var z = $ & J ^ $ & K ^ J & K;
    return z < 0 && (z += 4294967296), z;
  }
  function pe(M, $) {
    var O = g(M, $, 28), J = g($, M, 2), Z = g($, M, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function me(M, $) {
    var O = U(M, $, 28), J = U($, M, 2), Z = U($, M, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Me(M, $) {
    var O = g(M, $, 14), J = g(M, $, 18), Z = g($, M, 9), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Ee(M, $) {
    var O = U(M, $, 14), J = U(M, $, 18), Z = U($, M, 9), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Re(M, $) {
    var O = g(M, $, 1), J = g(M, $, 8), Z = h(M, $, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Ne(M, $) {
    var O = U(M, $, 1), J = U(M, $, 8), Z = q(M, $, 7), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function ne(M, $) {
    var O = g(M, $, 19), J = g($, M, 29), Z = h(M, $, 6), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  function Y(M, $) {
    var O = U(M, $, 19), J = U($, M, 29), Z = q(M, $, 6), K = O ^ J ^ Z;
    return K < 0 && (K += 4294967296), K;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384)
    return _384;
  hasRequired_384 = 1;
  var e = requireUtils(), o = require_512();
  function S() {
    if (!(this instanceof S))
      return new S();
    o.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(S, o), _384 = S, S.blockSize = 1024, S.outSize = 384, S.hmacStrength = 192, S.padLength = 128, S.prototype._digest = function(U) {
    return U === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd)
    return ripemd;
  hasRequiredRipemd = 1;
  var e = requireUtils(), o = requireCommon$1(), S = e.rotl32, g = e.sum32, U = e.sum32_3, h = e.sum32_4, q = o.BlockHash;
  function A() {
    if (!(this instanceof A))
      return new A();
    q.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(A, q), ripemd.ripemd160 = A, A.blockSize = 512, A.outSize = 160, A.hmacStrength = 192, A.padLength = 64, A.prototype._update = function(ie, te) {
    for (var se = this.h[0], le = this.h[1], ce = this.h[2], pe = this.h[3], me = this.h[4], Me = se, Ee = le, Re = ce, Ne = pe, ne = me, Y = 0; Y < 80; Y++) {
      var M = g(
        S(
          h(se, P(Y, le, ce, pe), ie[H[Y] + te], I(Y)),
          X[Y]
        ),
        me
      );
      se = me, me = pe, pe = S(ce, 10), ce = le, le = M, M = g(
        S(
          h(Me, P(79 - Y, Ee, Re, Ne), ie[V[Y] + te], B(Y)),
          Q[Y]
        ),
        ne
      ), Me = ne, ne = Ne, Ne = S(Re, 10), Re = Ee, Ee = M;
    }
    M = U(this.h[1], ce, Ne), this.h[1] = U(this.h[2], pe, ne), this.h[2] = U(this.h[3], me, Me), this.h[3] = U(this.h[4], se, Ee), this.h[4] = U(this.h[0], le, Re), this.h[0] = M;
  }, A.prototype._digest = function(ie) {
    return ie === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function P(ee, ie, te, se) {
    return ee <= 15 ? ie ^ te ^ se : ee <= 31 ? ie & te | ~ie & se : ee <= 47 ? (ie | ~te) ^ se : ee <= 63 ? ie & se | te & ~se : ie ^ (te | ~se);
  }
  function I(ee) {
    return ee <= 15 ? 0 : ee <= 31 ? 1518500249 : ee <= 47 ? 1859775393 : ee <= 63 ? 2400959708 : 2840853838;
  }
  function B(ee) {
    return ee <= 15 ? 1352829926 : ee <= 31 ? 1548603684 : ee <= 47 ? 1836072691 : ee <= 63 ? 2053994217 : 0;
  }
  var H = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], V = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], X = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], Q = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac;
  hasRequiredHmac = 1;
  var e = requireUtils(), o = requireMinimalisticAssert();
  function S(g, U, h) {
    if (!(this instanceof S))
      return new S(g, U, h);
    this.Hash = g, this.blockSize = g.blockSize / 8, this.outSize = g.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(U, h));
  }
  return hmac = S, S.prototype._init = function(U) {
    U.length > this.blockSize && (U = new this.Hash().update(U).digest()), o(U.length <= this.blockSize);
    for (var h = U.length; h < this.blockSize; h++)
      U.push(0);
    for (h = 0; h < U.length; h++)
      U[h] ^= 54;
    for (this.inner = new this.Hash().update(U), h = 0; h < U.length; h++)
      U[h] ^= 106;
    this.outer = new this.Hash().update(U);
  }, S.prototype.update = function(U, h) {
    return this.inner.update(U, h), this;
  }, S.prototype.digest = function(U) {
    return this.outer.update(this.inner.digest()), this.outer.digest(U);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(e) {
    var o = e;
    o.utils = requireUtils(), o.common = requireCommon$1(), o.sha = requireSha(), o.ripemd = requireRipemd(), o.hmac = requireHmac(), o.sha1 = o.sha.sha1, o.sha256 = o.sha.sha256, o.sha224 = o.sha.sha224, o.sha384 = o.sha.sha384, o.sha512 = o.sha.sha512, o.ripemd160 = o.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(e) {
    var o = e, S = requireHash(), g = requireCurve(), U = requireUtils$1(), h = U.assert;
    function q(I) {
      I.type === "short" ? this.curve = new g.short(I) : I.type === "edwards" ? this.curve = new g.edwards(I) : this.curve = new g.mont(I), this.g = this.curve.g, this.n = this.curve.n, this.hash = I.hash, h(this.g.validate(), "Invalid curve"), h(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    o.PresetCurve = q;
    function A(I, B) {
      Object.defineProperty(o, I, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var H = new q(B);
          return Object.defineProperty(o, I, {
            configurable: !0,
            enumerable: !0,
            value: H
          }), H;
        }
      });
    }
    A("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: S.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), A("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: S.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), A("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: S.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), A("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: S.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), A("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: S.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), A("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: S.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), A("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: S.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var P;
    try {
      P = requireSecp256k1();
    } catch {
      P = void 0;
    }
    A("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: S.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        P
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg)
    return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var e = requireHash(), o = requireUtils$2(), S = requireMinimalisticAssert();
  function g(U) {
    if (!(this instanceof g))
      return new g(U);
    this.hash = U.hash, this.predResist = !!U.predResist, this.outLen = this.hash.outSize, this.minEntropy = U.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var h = o.toArray(U.entropy, U.entropyEnc || "hex"), q = o.toArray(U.nonce, U.nonceEnc || "hex"), A = o.toArray(U.pers, U.persEnc || "hex");
    S(
      h.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(h, q, A);
  }
  return hmacDrbg = g, g.prototype._init = function(h, q, A) {
    var P = h.concat(q).concat(A);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var I = 0; I < this.V.length; I++)
      this.K[I] = 0, this.V[I] = 1;
    this._update(P), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, g.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, g.prototype._update = function(h) {
    var q = this._hmac().update(this.V).update([0]);
    h && (q = q.update(h)), this.K = q.digest(), this.V = this._hmac().update(this.V).digest(), h && (this.K = this._hmac().update(this.V).update([1]).update(h).digest(), this.V = this._hmac().update(this.V).digest());
  }, g.prototype.reseed = function(h, q, A, P) {
    typeof q != "string" && (P = A, A = q, q = null), h = o.toArray(h, q), A = o.toArray(A, P), S(
      h.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(h.concat(A || [])), this._reseed = 1;
  }, g.prototype.generate = function(h, q, A, P) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof q != "string" && (P = A, A = q, q = null), A && (A = o.toArray(A, P || "hex"), this._update(A));
    for (var I = []; I.length < h; )
      this.V = this._hmac().update(this.V).digest(), I = I.concat(this.V);
    var B = I.slice(0, h);
    return this._update(A), this._reseed++, o.encode(B, q);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1)
    return key$1;
  hasRequiredKey$1 = 1;
  var e = bnExports, o = requireUtils$1(), S = o.assert;
  function g(U, h) {
    this.ec = U, this.priv = null, this.pub = null, h.priv && this._importPrivate(h.priv, h.privEnc), h.pub && this._importPublic(h.pub, h.pubEnc);
  }
  return key$1 = g, g.fromPublic = function(h, q, A) {
    return q instanceof g ? q : new g(h, {
      pub: q,
      pubEnc: A
    });
  }, g.fromPrivate = function(h, q, A) {
    return q instanceof g ? q : new g(h, {
      priv: q,
      privEnc: A
    });
  }, g.prototype.validate = function() {
    var h = this.getPublic();
    return h.isInfinity() ? { result: !1, reason: "Invalid public key" } : h.validate() ? h.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, g.prototype.getPublic = function(h, q) {
    return typeof h == "string" && (q = h, h = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), q ? this.pub.encode(q, h) : this.pub;
  }, g.prototype.getPrivate = function(h) {
    return h === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, g.prototype._importPrivate = function(h, q) {
    this.priv = new e(h, q || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, g.prototype._importPublic = function(h, q) {
    if (h.x || h.y) {
      this.ec.curve.type === "mont" ? S(h.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && S(h.x && h.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(h.x, h.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(h, q);
  }, g.prototype.derive = function(h) {
    return h.validate() || S(h.validate(), "public point not validated"), h.mul(this.priv).getX();
  }, g.prototype.sign = function(h, q, A) {
    return this.ec.sign(h, this, q, A);
  }, g.prototype.verify = function(h, q) {
    return this.ec.verify(h, q, this);
  }, g.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1)
    return signature$1;
  hasRequiredSignature$1 = 1;
  var e = bnExports, o = requireUtils$1(), S = o.assert;
  function g(P, I) {
    if (P instanceof g)
      return P;
    this._importDER(P, I) || (S(P.r && P.s, "Signature without r or s"), this.r = new e(P.r, 16), this.s = new e(P.s, 16), P.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = P.recoveryParam);
  }
  signature$1 = g;
  function U() {
    this.place = 0;
  }
  function h(P, I) {
    var B = P[I.place++];
    if (!(B & 128))
      return B;
    var H = B & 15;
    if (H === 0 || H > 4)
      return !1;
    for (var V = 0, X = 0, Q = I.place; X < H; X++, Q++)
      V <<= 8, V |= P[Q], V >>>= 0;
    return V <= 127 ? !1 : (I.place = Q, V);
  }
  function q(P) {
    for (var I = 0, B = P.length - 1; !P[I] && !(P[I + 1] & 128) && I < B; )
      I++;
    return I === 0 ? P : P.slice(I);
  }
  g.prototype._importDER = function(I, B) {
    I = o.toArray(I, B);
    var H = new U();
    if (I[H.place++] !== 48)
      return !1;
    var V = h(I, H);
    if (V === !1 || V + H.place !== I.length || I[H.place++] !== 2)
      return !1;
    var X = h(I, H);
    if (X === !1)
      return !1;
    var Q = I.slice(H.place, X + H.place);
    if (H.place += X, I[H.place++] !== 2)
      return !1;
    var ee = h(I, H);
    if (ee === !1 || I.length !== ee + H.place)
      return !1;
    var ie = I.slice(H.place, ee + H.place);
    if (Q[0] === 0)
      if (Q[1] & 128)
        Q = Q.slice(1);
      else
        return !1;
    if (ie[0] === 0)
      if (ie[1] & 128)
        ie = ie.slice(1);
      else
        return !1;
    return this.r = new e(Q), this.s = new e(ie), this.recoveryParam = null, !0;
  };
  function A(P, I) {
    if (I < 128) {
      P.push(I);
      return;
    }
    var B = 1 + (Math.log(I) / Math.LN2 >>> 3);
    for (P.push(B | 128); --B; )
      P.push(I >>> (B << 3) & 255);
    P.push(I);
  }
  return g.prototype.toDER = function(I) {
    var B = this.r.toArray(), H = this.s.toArray();
    for (B[0] & 128 && (B = [0].concat(B)), H[0] & 128 && (H = [0].concat(H)), B = q(B), H = q(H); !H[0] && !(H[1] & 128); )
      H = H.slice(1);
    var V = [2];
    A(V, B.length), V = V.concat(B), V.push(2), A(V, H.length);
    var X = V.concat(H), Q = [48];
    return A(Q, X.length), Q = Q.concat(X), o.encode(Q, I);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var e = bnExports, o = requireHmacDrbg(), S = requireUtils$1(), g = requireCurves(), U = requireBrorand(), h = S.assert, q = requireKey$1(), A = requireSignature$1();
  function P(I) {
    if (!(this instanceof P))
      return new P(I);
    typeof I == "string" && (h(
      Object.prototype.hasOwnProperty.call(g, I),
      "Unknown curve " + I
    ), I = g[I]), I instanceof g.PresetCurve && (I = { curve: I }), this.curve = I.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = I.curve.g, this.g.precompute(I.curve.n.bitLength() + 1), this.hash = I.hash || I.curve.hash;
  }
  return ec = P, P.prototype.keyPair = function(B) {
    return new q(this, B);
  }, P.prototype.keyFromPrivate = function(B, H) {
    return q.fromPrivate(this, B, H);
  }, P.prototype.keyFromPublic = function(B, H) {
    return q.fromPublic(this, B, H);
  }, P.prototype.genKeyPair = function(B) {
    B || (B = {});
    for (var H = new o({
      hash: this.hash,
      pers: B.pers,
      persEnc: B.persEnc || "utf8",
      entropy: B.entropy || U(this.hash.hmacStrength),
      entropyEnc: B.entropy && B.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), V = this.n.byteLength(), X = this.n.sub(new e(2)); ; ) {
      var Q = new e(H.generate(V));
      if (!(Q.cmp(X) > 0))
        return Q.iaddn(1), this.keyFromPrivate(Q);
    }
  }, P.prototype._truncateToN = function(B, H) {
    var V = B.byteLength() * 8 - this.n.bitLength();
    return V > 0 && (B = B.ushrn(V)), !H && B.cmp(this.n) >= 0 ? B.sub(this.n) : B;
  }, P.prototype.sign = function(B, H, V, X) {
    typeof V == "object" && (X = V, V = null), X || (X = {}), H = this.keyFromPrivate(H, V), B = this._truncateToN(new e(B, 16));
    for (var Q = this.n.byteLength(), ee = H.getPrivate().toArray("be", Q), ie = B.toArray("be", Q), te = new o({
      hash: this.hash,
      entropy: ee,
      nonce: ie,
      pers: X.pers,
      persEnc: X.persEnc || "utf8"
    }), se = this.n.sub(new e(1)), le = 0; ; le++) {
      var ce = X.k ? X.k(le) : new e(te.generate(this.n.byteLength()));
      if (ce = this._truncateToN(ce, !0), !(ce.cmpn(1) <= 0 || ce.cmp(se) >= 0)) {
        var pe = this.g.mul(ce);
        if (!pe.isInfinity()) {
          var me = pe.getX(), Me = me.umod(this.n);
          if (Me.cmpn(0) !== 0) {
            var Ee = ce.invm(this.n).mul(Me.mul(H.getPrivate()).iadd(B));
            if (Ee = Ee.umod(this.n), Ee.cmpn(0) !== 0) {
              var Re = (pe.getY().isOdd() ? 1 : 0) | (me.cmp(Me) !== 0 ? 2 : 0);
              return X.canonical && Ee.cmp(this.nh) > 0 && (Ee = this.n.sub(Ee), Re ^= 1), new A({ r: Me, s: Ee, recoveryParam: Re });
            }
          }
        }
      }
    }
  }, P.prototype.verify = function(B, H, V, X) {
    B = this._truncateToN(new e(B, 16)), V = this.keyFromPublic(V, X), H = new A(H, "hex");
    var Q = H.r, ee = H.s;
    if (Q.cmpn(1) < 0 || Q.cmp(this.n) >= 0 || ee.cmpn(1) < 0 || ee.cmp(this.n) >= 0)
      return !1;
    var ie = ee.invm(this.n), te = ie.mul(B).umod(this.n), se = ie.mul(Q).umod(this.n), le;
    return this.curve._maxwellTrick ? (le = this.g.jmulAdd(te, V.getPublic(), se), le.isInfinity() ? !1 : le.eqXToP(Q)) : (le = this.g.mulAdd(te, V.getPublic(), se), le.isInfinity() ? !1 : le.getX().umod(this.n).cmp(Q) === 0);
  }, P.prototype.recoverPubKey = function(I, B, H, V) {
    h((3 & H) === H, "The recovery param is more than two bits"), B = new A(B, V);
    var X = this.n, Q = new e(I), ee = B.r, ie = B.s, te = H & 1, se = H >> 1;
    if (ee.cmp(this.curve.p.umod(this.curve.n)) >= 0 && se)
      throw new Error("Unable to find sencond key candinate");
    se ? ee = this.curve.pointFromX(ee.add(this.curve.n), te) : ee = this.curve.pointFromX(ee, te);
    var le = B.r.invm(X), ce = X.sub(Q).mul(le).umod(X), pe = ie.mul(le).umod(X);
    return this.g.mulAdd(ce, ee, pe);
  }, P.prototype.getKeyRecoveryParam = function(I, B, H, V) {
    if (B = new A(B, V), B.recoveryParam !== null)
      return B.recoveryParam;
    for (var X = 0; X < 4; X++) {
      var Q;
      try {
        Q = this.recoverPubKey(I, B, X);
      } catch {
        continue;
      }
      if (Q.eq(H))
        return X;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey)
    return key;
  hasRequiredKey = 1;
  var e = requireUtils$1(), o = e.assert, S = e.parseBytes, g = e.cachedProperty;
  function U(h, q) {
    this.eddsa = h, this._secret = S(q.secret), h.isPoint(q.pub) ? this._pub = q.pub : this._pubBytes = S(q.pub);
  }
  return U.fromPublic = function(q, A) {
    return A instanceof U ? A : new U(q, { pub: A });
  }, U.fromSecret = function(q, A) {
    return A instanceof U ? A : new U(q, { secret: A });
  }, U.prototype.secret = function() {
    return this._secret;
  }, g(U, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), g(U, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), g(U, "privBytes", function() {
    var q = this.eddsa, A = this.hash(), P = q.encodingLength - 1, I = A.slice(0, q.encodingLength);
    return I[0] &= 248, I[P] &= 127, I[P] |= 64, I;
  }), g(U, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), g(U, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), g(U, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), U.prototype.sign = function(q) {
    return o(this._secret, "KeyPair can only verify"), this.eddsa.sign(q, this);
  }, U.prototype.verify = function(q, A) {
    return this.eddsa.verify(q, A, this);
  }, U.prototype.getSecret = function(q) {
    return o(this._secret, "KeyPair is public only"), e.encode(this.secret(), q);
  }, U.prototype.getPublic = function(q) {
    return e.encode(this.pubBytes(), q);
  }, key = U, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature)
    return signature;
  hasRequiredSignature = 1;
  var e = bnExports, o = requireUtils$1(), S = o.assert, g = o.cachedProperty, U = o.parseBytes;
  function h(q, A) {
    this.eddsa = q, typeof A != "object" && (A = U(A)), Array.isArray(A) && (A = {
      R: A.slice(0, q.encodingLength),
      S: A.slice(q.encodingLength)
    }), S(A.R && A.S, "Signature without R or S"), q.isPoint(A.R) && (this._R = A.R), A.S instanceof e && (this._S = A.S), this._Rencoded = Array.isArray(A.R) ? A.R : A.Rencoded, this._Sencoded = Array.isArray(A.S) ? A.S : A.Sencoded;
  }
  return g(h, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), g(h, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), g(h, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), g(h, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), h.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, h.prototype.toHex = function() {
    return o.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = h, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa)
    return eddsa;
  hasRequiredEddsa = 1;
  var e = requireHash(), o = requireCurves(), S = requireUtils$1(), g = S.assert, U = S.parseBytes, h = requireKey(), q = requireSignature();
  function A(P) {
    if (g(P === "ed25519", "only tested with ed25519 so far"), !(this instanceof A))
      return new A(P);
    P = o[P].curve, this.curve = P, this.g = P.g, this.g.precompute(P.n.bitLength() + 1), this.pointClass = P.point().constructor, this.encodingLength = Math.ceil(P.n.bitLength() / 8), this.hash = e.sha512;
  }
  return eddsa = A, A.prototype.sign = function(I, B) {
    I = U(I);
    var H = this.keyFromSecret(B), V = this.hashInt(H.messagePrefix(), I), X = this.g.mul(V), Q = this.encodePoint(X), ee = this.hashInt(Q, H.pubBytes(), I).mul(H.priv()), ie = V.add(ee).umod(this.curve.n);
    return this.makeSignature({ R: X, S: ie, Rencoded: Q });
  }, A.prototype.verify = function(I, B, H) {
    I = U(I), B = this.makeSignature(B);
    var V = this.keyFromPublic(H), X = this.hashInt(B.Rencoded(), V.pubBytes(), I), Q = this.g.mul(B.S()), ee = B.R().add(V.pub().mul(X));
    return ee.eq(Q);
  }, A.prototype.hashInt = function() {
    for (var I = this.hash(), B = 0; B < arguments.length; B++)
      I.update(arguments[B]);
    return S.intFromLE(I.digest()).umod(this.curve.n);
  }, A.prototype.keyFromPublic = function(I) {
    return h.fromPublic(this, I);
  }, A.prototype.keyFromSecret = function(I) {
    return h.fromSecret(this, I);
  }, A.prototype.makeSignature = function(I) {
    return I instanceof q ? I : new q(this, I);
  }, A.prototype.encodePoint = function(I) {
    var B = I.getY().toArray("le", this.encodingLength);
    return B[this.encodingLength - 1] |= I.getX().isOdd() ? 128 : 0, B;
  }, A.prototype.decodePoint = function(I) {
    I = S.parseBytes(I);
    var B = I.length - 1, H = I.slice(0, B).concat(I[B] & -129), V = (I[B] & 128) !== 0, X = S.intFromLE(H);
    return this.curve.pointFromY(X, V);
  }, A.prototype.encodeInt = function(I) {
    return I.toArray("le", this.encodingLength);
  }, A.prototype.decodeInt = function(I) {
    return S.intFromLE(I);
  }, A.prototype.isPoint = function(I) {
    return I instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(e) {
    var o = e;
    o.version = require$$0.version, o.utils = requireUtils$1(), o.rand = requireBrorand(), o.curve = requireCurve(), o.curves = requireCurves(), o.ec = requireEc(), o.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(e) {
    (function(o, S) {
      function g(M, $) {
        if (!M)
          throw new Error($ || "Assertion failed");
      }
      function U(M, $) {
        M.super_ = $;
        var O = function() {
        };
        O.prototype = $.prototype, M.prototype = new O(), M.prototype.constructor = M;
      }
      function h(M, $, O) {
        if (h.isBN(M))
          return M;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && (($ === "le" || $ === "be") && (O = $, $ = 10), this._init(M || 0, $ || 10, O || "be"));
      }
      typeof o == "object" ? o.exports = h : S.BN = h, h.BN = h, h.wordSize = 26;
      var q;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? q = window.Buffer : q = buffer$3.Buffer;
      } catch {
      }
      h.isBN = function($) {
        return $ instanceof h ? !0 : $ !== null && typeof $ == "object" && $.constructor.wordSize === h.wordSize && Array.isArray($.words);
      }, h.max = function($, O) {
        return $.cmp(O) > 0 ? $ : O;
      }, h.min = function($, O) {
        return $.cmp(O) < 0 ? $ : O;
      }, h.prototype._init = function($, O, J) {
        if (typeof $ == "number")
          return this._initNumber($, O, J);
        if (typeof $ == "object")
          return this._initArray($, O, J);
        O === "hex" && (O = 16), g(O === (O | 0) && O >= 2 && O <= 36), $ = $.toString().replace(/\s+/g, "");
        var Z = 0;
        $[0] === "-" && (Z++, this.negative = 1), Z < $.length && (O === 16 ? this._parseHex($, Z, J) : (this._parseBase($, O, Z), J === "le" && this._initArray(this.toArray(), O, J)));
      }, h.prototype._initNumber = function($, O, J) {
        $ < 0 && (this.negative = 1, $ = -$), $ < 67108864 ? (this.words = [$ & 67108863], this.length = 1) : $ < 4503599627370496 ? (this.words = [
          $ & 67108863,
          $ / 67108864 & 67108863
        ], this.length = 2) : (g($ < 9007199254740992), this.words = [
          $ & 67108863,
          $ / 67108864 & 67108863,
          1
        ], this.length = 3), J === "le" && this._initArray(this.toArray(), O, J);
      }, h.prototype._initArray = function($, O, J) {
        if (g(typeof $.length == "number"), $.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil($.length / 3), this.words = new Array(this.length);
        for (var Z = 0; Z < this.length; Z++)
          this.words[Z] = 0;
        var K, z, G = 0;
        if (J === "be")
          for (Z = $.length - 1, K = 0; Z >= 0; Z -= 3)
            z = $[Z] | $[Z - 1] << 8 | $[Z - 2] << 16, this.words[K] |= z << G & 67108863, this.words[K + 1] = z >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, K++);
        else if (J === "le")
          for (Z = 0, K = 0; Z < $.length; Z += 3)
            z = $[Z] | $[Z + 1] << 8 | $[Z + 2] << 16, this.words[K] |= z << G & 67108863, this.words[K + 1] = z >>> 26 - G & 67108863, G += 24, G >= 26 && (G -= 26, K++);
        return this._strip();
      };
      function A(M, $) {
        var O = M.charCodeAt($);
        if (O >= 48 && O <= 57)
          return O - 48;
        if (O >= 65 && O <= 70)
          return O - 55;
        if (O >= 97 && O <= 102)
          return O - 87;
        g(!1, "Invalid character in " + M);
      }
      function P(M, $, O) {
        var J = A(M, O);
        return O - 1 >= $ && (J |= A(M, O - 1) << 4), J;
      }
      h.prototype._parseHex = function($, O, J) {
        this.length = Math.ceil(($.length - O) / 6), this.words = new Array(this.length);
        for (var Z = 0; Z < this.length; Z++)
          this.words[Z] = 0;
        var K = 0, z = 0, G;
        if (J === "be")
          for (Z = $.length - 1; Z >= O; Z -= 2)
            G = P($, O, Z) << K, this.words[z] |= G & 67108863, K >= 18 ? (K -= 18, z += 1, this.words[z] |= G >>> 26) : K += 8;
        else {
          var D = $.length - O;
          for (Z = D % 2 === 0 ? O + 1 : O; Z < $.length; Z += 2)
            G = P($, O, Z) << K, this.words[z] |= G & 67108863, K >= 18 ? (K -= 18, z += 1, this.words[z] |= G >>> 26) : K += 8;
        }
        this._strip();
      };
      function I(M, $, O, J) {
        for (var Z = 0, K = 0, z = Math.min(M.length, O), G = $; G < z; G++) {
          var D = M.charCodeAt(G) - 48;
          Z *= J, D >= 49 ? K = D - 49 + 10 : D >= 17 ? K = D - 17 + 10 : K = D, g(D >= 0 && K < J, "Invalid character"), Z += K;
        }
        return Z;
      }
      h.prototype._parseBase = function($, O, J) {
        this.words = [0], this.length = 1;
        for (var Z = 0, K = 1; K <= 67108863; K *= O)
          Z++;
        Z--, K = K / O | 0;
        for (var z = $.length - J, G = z % Z, D = Math.min(z, z - G) + J, F = 0, ae = J; ae < D; ae += Z)
          F = I($, ae, ae + Z, O), this.imuln(K), this.words[0] + F < 67108864 ? this.words[0] += F : this._iaddn(F);
        if (G !== 0) {
          var ge = 1;
          for (F = I($, ae, $.length, O), ae = 0; ae < G; ae++)
            ge *= O;
          this.imuln(ge), this.words[0] + F < 67108864 ? this.words[0] += F : this._iaddn(F);
        }
        this._strip();
      }, h.prototype.copy = function($) {
        $.words = new Array(this.length);
        for (var O = 0; O < this.length; O++)
          $.words[O] = this.words[O];
        $.length = this.length, $.negative = this.negative, $.red = this.red;
      };
      function B(M, $) {
        M.words = $.words, M.length = $.length, M.negative = $.negative, M.red = $.red;
      }
      if (h.prototype._move = function($) {
        B($, this);
      }, h.prototype.clone = function() {
        var $ = new h(null);
        return this.copy($), $;
      }, h.prototype._expand = function($) {
        for (; this.length < $; )
          this.words[this.length++] = 0;
        return this;
      }, h.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, h.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          h.prototype[Symbol.for("nodejs.util.inspect.custom")] = H;
        } catch {
          h.prototype.inspect = H;
        }
      else
        h.prototype.inspect = H;
      function H() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var V = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], X = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Q = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      h.prototype.toString = function($, O) {
        $ = $ || 10, O = O | 0 || 1;
        var J;
        if ($ === 16 || $ === "hex") {
          J = "";
          for (var Z = 0, K = 0, z = 0; z < this.length; z++) {
            var G = this.words[z], D = ((G << Z | K) & 16777215).toString(16);
            K = G >>> 24 - Z & 16777215, Z += 2, Z >= 26 && (Z -= 26, z--), K !== 0 || z !== this.length - 1 ? J = V[6 - D.length] + D + J : J = D + J;
          }
          for (K !== 0 && (J = K.toString(16) + J); J.length % O !== 0; )
            J = "0" + J;
          return this.negative !== 0 && (J = "-" + J), J;
        }
        if ($ === ($ | 0) && $ >= 2 && $ <= 36) {
          var F = X[$], ae = Q[$];
          J = "";
          var ge = this.clone();
          for (ge.negative = 0; !ge.isZero(); ) {
            var xe = ge.modrn(ae).toString($);
            ge = ge.idivn(ae), ge.isZero() ? J = xe + J : J = V[F - xe.length] + xe + J;
          }
          for (this.isZero() && (J = "0" + J); J.length % O !== 0; )
            J = "0" + J;
          return this.negative !== 0 && (J = "-" + J), J;
        }
        g(!1, "Base should be between 2 and 36");
      }, h.prototype.toNumber = function() {
        var $ = this.words[0];
        return this.length === 2 ? $ += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? $ += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && g(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -$ : $;
      }, h.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, q && (h.prototype.toBuffer = function($, O) {
        return this.toArrayLike(q, $, O);
      }), h.prototype.toArray = function($, O) {
        return this.toArrayLike(Array, $, O);
      };
      var ee = function($, O) {
        return $.allocUnsafe ? $.allocUnsafe(O) : new $(O);
      };
      h.prototype.toArrayLike = function($, O, J) {
        this._strip();
        var Z = this.byteLength(), K = J || Math.max(1, Z);
        g(Z <= K, "byte array longer than desired length"), g(K > 0, "Requested array length <= 0");
        var z = ee($, K), G = O === "le" ? "LE" : "BE";
        return this["_toArrayLike" + G](z, Z), z;
      }, h.prototype._toArrayLikeLE = function($, O) {
        for (var J = 0, Z = 0, K = 0, z = 0; K < this.length; K++) {
          var G = this.words[K] << z | Z;
          $[J++] = G & 255, J < $.length && ($[J++] = G >> 8 & 255), J < $.length && ($[J++] = G >> 16 & 255), z === 6 ? (J < $.length && ($[J++] = G >> 24 & 255), Z = 0, z = 0) : (Z = G >>> 24, z += 2);
        }
        if (J < $.length)
          for ($[J++] = Z; J < $.length; )
            $[J++] = 0;
      }, h.prototype._toArrayLikeBE = function($, O) {
        for (var J = $.length - 1, Z = 0, K = 0, z = 0; K < this.length; K++) {
          var G = this.words[K] << z | Z;
          $[J--] = G & 255, J >= 0 && ($[J--] = G >> 8 & 255), J >= 0 && ($[J--] = G >> 16 & 255), z === 6 ? (J >= 0 && ($[J--] = G >> 24 & 255), Z = 0, z = 0) : (Z = G >>> 24, z += 2);
        }
        if (J >= 0)
          for ($[J--] = Z; J >= 0; )
            $[J--] = 0;
      }, Math.clz32 ? h.prototype._countBits = function($) {
        return 32 - Math.clz32($);
      } : h.prototype._countBits = function($) {
        var O = $, J = 0;
        return O >= 4096 && (J += 13, O >>>= 13), O >= 64 && (J += 7, O >>>= 7), O >= 8 && (J += 4, O >>>= 4), O >= 2 && (J += 2, O >>>= 2), J + O;
      }, h.prototype._zeroBits = function($) {
        if ($ === 0)
          return 26;
        var O = $, J = 0;
        return O & 8191 || (J += 13, O >>>= 13), O & 127 || (J += 7, O >>>= 7), O & 15 || (J += 4, O >>>= 4), O & 3 || (J += 2, O >>>= 2), O & 1 || J++, J;
      }, h.prototype.bitLength = function() {
        var $ = this.words[this.length - 1], O = this._countBits($);
        return (this.length - 1) * 26 + O;
      };
      function ie(M) {
        for (var $ = new Array(M.bitLength()), O = 0; O < $.length; O++) {
          var J = O / 26 | 0, Z = O % 26;
          $[O] = M.words[J] >>> Z & 1;
        }
        return $;
      }
      h.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var $ = 0, O = 0; O < this.length; O++) {
          var J = this._zeroBits(this.words[O]);
          if ($ += J, J !== 26)
            break;
        }
        return $;
      }, h.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, h.prototype.toTwos = function($) {
        return this.negative !== 0 ? this.abs().inotn($).iaddn(1) : this.clone();
      }, h.prototype.fromTwos = function($) {
        return this.testn($ - 1) ? this.notn($).iaddn(1).ineg() : this.clone();
      }, h.prototype.isNeg = function() {
        return this.negative !== 0;
      }, h.prototype.neg = function() {
        return this.clone().ineg();
      }, h.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, h.prototype.iuor = function($) {
        for (; this.length < $.length; )
          this.words[this.length++] = 0;
        for (var O = 0; O < $.length; O++)
          this.words[O] = this.words[O] | $.words[O];
        return this._strip();
      }, h.prototype.ior = function($) {
        return g((this.negative | $.negative) === 0), this.iuor($);
      }, h.prototype.or = function($) {
        return this.length > $.length ? this.clone().ior($) : $.clone().ior(this);
      }, h.prototype.uor = function($) {
        return this.length > $.length ? this.clone().iuor($) : $.clone().iuor(this);
      }, h.prototype.iuand = function($) {
        var O;
        this.length > $.length ? O = $ : O = this;
        for (var J = 0; J < O.length; J++)
          this.words[J] = this.words[J] & $.words[J];
        return this.length = O.length, this._strip();
      }, h.prototype.iand = function($) {
        return g((this.negative | $.negative) === 0), this.iuand($);
      }, h.prototype.and = function($) {
        return this.length > $.length ? this.clone().iand($) : $.clone().iand(this);
      }, h.prototype.uand = function($) {
        return this.length > $.length ? this.clone().iuand($) : $.clone().iuand(this);
      }, h.prototype.iuxor = function($) {
        var O, J;
        this.length > $.length ? (O = this, J = $) : (O = $, J = this);
        for (var Z = 0; Z < J.length; Z++)
          this.words[Z] = O.words[Z] ^ J.words[Z];
        if (this !== O)
          for (; Z < O.length; Z++)
            this.words[Z] = O.words[Z];
        return this.length = O.length, this._strip();
      }, h.prototype.ixor = function($) {
        return g((this.negative | $.negative) === 0), this.iuxor($);
      }, h.prototype.xor = function($) {
        return this.length > $.length ? this.clone().ixor($) : $.clone().ixor(this);
      }, h.prototype.uxor = function($) {
        return this.length > $.length ? this.clone().iuxor($) : $.clone().iuxor(this);
      }, h.prototype.inotn = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = Math.ceil($ / 26) | 0, J = $ % 26;
        this._expand(O), J > 0 && O--;
        for (var Z = 0; Z < O; Z++)
          this.words[Z] = ~this.words[Z] & 67108863;
        return J > 0 && (this.words[Z] = ~this.words[Z] & 67108863 >> 26 - J), this._strip();
      }, h.prototype.notn = function($) {
        return this.clone().inotn($);
      }, h.prototype.setn = function($, O) {
        g(typeof $ == "number" && $ >= 0);
        var J = $ / 26 | 0, Z = $ % 26;
        return this._expand(J + 1), O ? this.words[J] = this.words[J] | 1 << Z : this.words[J] = this.words[J] & ~(1 << Z), this._strip();
      }, h.prototype.iadd = function($) {
        var O;
        if (this.negative !== 0 && $.negative === 0)
          return this.negative = 0, O = this.isub($), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && $.negative !== 0)
          return $.negative = 0, O = this.isub($), $.negative = 1, O._normSign();
        var J, Z;
        this.length > $.length ? (J = this, Z = $) : (J = $, Z = this);
        for (var K = 0, z = 0; z < Z.length; z++)
          O = (J.words[z] | 0) + (Z.words[z] | 0) + K, this.words[z] = O & 67108863, K = O >>> 26;
        for (; K !== 0 && z < J.length; z++)
          O = (J.words[z] | 0) + K, this.words[z] = O & 67108863, K = O >>> 26;
        if (this.length = J.length, K !== 0)
          this.words[this.length] = K, this.length++;
        else if (J !== this)
          for (; z < J.length; z++)
            this.words[z] = J.words[z];
        return this;
      }, h.prototype.add = function($) {
        var O;
        return $.negative !== 0 && this.negative === 0 ? ($.negative = 0, O = this.sub($), $.negative ^= 1, O) : $.negative === 0 && this.negative !== 0 ? (this.negative = 0, O = $.sub(this), this.negative = 1, O) : this.length > $.length ? this.clone().iadd($) : $.clone().iadd(this);
      }, h.prototype.isub = function($) {
        if ($.negative !== 0) {
          $.negative = 0;
          var O = this.iadd($);
          return $.negative = 1, O._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd($), this.negative = 1, this._normSign();
        var J = this.cmp($);
        if (J === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var Z, K;
        J > 0 ? (Z = this, K = $) : (Z = $, K = this);
        for (var z = 0, G = 0; G < K.length; G++)
          O = (Z.words[G] | 0) - (K.words[G] | 0) + z, z = O >> 26, this.words[G] = O & 67108863;
        for (; z !== 0 && G < Z.length; G++)
          O = (Z.words[G] | 0) + z, z = O >> 26, this.words[G] = O & 67108863;
        if (z === 0 && G < Z.length && Z !== this)
          for (; G < Z.length; G++)
            this.words[G] = Z.words[G];
        return this.length = Math.max(this.length, G), Z !== this && (this.negative = 1), this._strip();
      }, h.prototype.sub = function($) {
        return this.clone().isub($);
      };
      function te(M, $, O) {
        O.negative = $.negative ^ M.negative;
        var J = M.length + $.length | 0;
        O.length = J, J = J - 1 | 0;
        var Z = M.words[0] | 0, K = $.words[0] | 0, z = Z * K, G = z & 67108863, D = z / 67108864 | 0;
        O.words[0] = G;
        for (var F = 1; F < J; F++) {
          for (var ae = D >>> 26, ge = D & 67108863, xe = Math.min(F, $.length - 1), ye = Math.max(0, F - M.length + 1); ye <= xe; ye++) {
            var oe = F - ye | 0;
            Z = M.words[oe] | 0, K = $.words[ye] | 0, z = Z * K + ge, ae += z / 67108864 | 0, ge = z & 67108863;
          }
          O.words[F] = ge | 0, D = ae | 0;
        }
        return D !== 0 ? O.words[F] = D | 0 : O.length--, O._strip();
      }
      var se = function($, O, J) {
        var Z = $.words, K = O.words, z = J.words, G = 0, D, F, ae, ge = Z[0] | 0, xe = ge & 8191, ye = ge >>> 13, oe = Z[1] | 0, fe = oe & 8191, $e = oe >>> 13, Be = Z[2] | 0, be = Be & 8191, ve = Be >>> 13, qe = Z[3] | 0, De = qe & 8191, Ye = qe >>> 13, he = Z[4] | 0, ue = he & 8191, de = he >>> 13, _e = Z[5] | 0, Pe = _e & 8191, He = _e >>> 13, Ve = Z[6] | 0, nt = Ve & 8191, Ie = Ve >>> 13, Fe = Z[7] | 0, je = Fe & 8191, Ke = Fe >>> 13, ot = Z[8] | 0, ut = ot & 8191, pt = ot >>> 13, ke = Z[9] | 0, Xe = ke & 8191, at = ke >>> 13, ht = K[0] | 0, We = ht & 8191, tt = ht >>> 13, Te = K[1] | 0, rt = Te & 8191, mt = Te >>> 13, Se = K[2] | 0, et = Se & 8191, Ze = Se >>> 13, Le = K[3] | 0, ze = Le & 8191, Qe = Le >>> 13, _t = K[4] | 0, ft = _t & 8191, dt = _t >>> 13, Mt = K[5] | 0, St = Mt & 8191, $t = Mt >>> 13, At = K[6] | 0, Ae = At & 8191, Ce = At >>> 13, Oe = K[7] | 0, we = Oe & 8191, Ue = Oe >>> 13, Je = K[8] | 0, Ge = Je & 8191, st = Je >>> 13, ct = K[9] | 0, bt = ct & 8191, wt = ct >>> 13;
        J.negative = $.negative ^ O.negative, J.length = 19, D = Math.imul(xe, We), F = Math.imul(xe, tt), F = F + Math.imul(ye, We) | 0, ae = Math.imul(ye, tt);
        var zt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, D = Math.imul(fe, We), F = Math.imul(fe, tt), F = F + Math.imul($e, We) | 0, ae = Math.imul($e, tt), D = D + Math.imul(xe, rt) | 0, F = F + Math.imul(xe, mt) | 0, F = F + Math.imul(ye, rt) | 0, ae = ae + Math.imul(ye, mt) | 0;
        var Tt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, D = Math.imul(be, We), F = Math.imul(be, tt), F = F + Math.imul(ve, We) | 0, ae = Math.imul(ve, tt), D = D + Math.imul(fe, rt) | 0, F = F + Math.imul(fe, mt) | 0, F = F + Math.imul($e, rt) | 0, ae = ae + Math.imul($e, mt) | 0, D = D + Math.imul(xe, et) | 0, F = F + Math.imul(xe, Ze) | 0, F = F + Math.imul(ye, et) | 0, ae = ae + Math.imul(ye, Ze) | 0;
        var Lt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, D = Math.imul(De, We), F = Math.imul(De, tt), F = F + Math.imul(Ye, We) | 0, ae = Math.imul(Ye, tt), D = D + Math.imul(be, rt) | 0, F = F + Math.imul(be, mt) | 0, F = F + Math.imul(ve, rt) | 0, ae = ae + Math.imul(ve, mt) | 0, D = D + Math.imul(fe, et) | 0, F = F + Math.imul(fe, Ze) | 0, F = F + Math.imul($e, et) | 0, ae = ae + Math.imul($e, Ze) | 0, D = D + Math.imul(xe, ze) | 0, F = F + Math.imul(xe, Qe) | 0, F = F + Math.imul(ye, ze) | 0, ae = ae + Math.imul(ye, Qe) | 0;
        var jt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (jt >>> 26) | 0, jt &= 67108863, D = Math.imul(ue, We), F = Math.imul(ue, tt), F = F + Math.imul(de, We) | 0, ae = Math.imul(de, tt), D = D + Math.imul(De, rt) | 0, F = F + Math.imul(De, mt) | 0, F = F + Math.imul(Ye, rt) | 0, ae = ae + Math.imul(Ye, mt) | 0, D = D + Math.imul(be, et) | 0, F = F + Math.imul(be, Ze) | 0, F = F + Math.imul(ve, et) | 0, ae = ae + Math.imul(ve, Ze) | 0, D = D + Math.imul(fe, ze) | 0, F = F + Math.imul(fe, Qe) | 0, F = F + Math.imul($e, ze) | 0, ae = ae + Math.imul($e, Qe) | 0, D = D + Math.imul(xe, ft) | 0, F = F + Math.imul(xe, dt) | 0, F = F + Math.imul(ye, ft) | 0, ae = ae + Math.imul(ye, dt) | 0;
        var Ht = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, D = Math.imul(Pe, We), F = Math.imul(Pe, tt), F = F + Math.imul(He, We) | 0, ae = Math.imul(He, tt), D = D + Math.imul(ue, rt) | 0, F = F + Math.imul(ue, mt) | 0, F = F + Math.imul(de, rt) | 0, ae = ae + Math.imul(de, mt) | 0, D = D + Math.imul(De, et) | 0, F = F + Math.imul(De, Ze) | 0, F = F + Math.imul(Ye, et) | 0, ae = ae + Math.imul(Ye, Ze) | 0, D = D + Math.imul(be, ze) | 0, F = F + Math.imul(be, Qe) | 0, F = F + Math.imul(ve, ze) | 0, ae = ae + Math.imul(ve, Qe) | 0, D = D + Math.imul(fe, ft) | 0, F = F + Math.imul(fe, dt) | 0, F = F + Math.imul($e, ft) | 0, ae = ae + Math.imul($e, dt) | 0, D = D + Math.imul(xe, St) | 0, F = F + Math.imul(xe, $t) | 0, F = F + Math.imul(ye, St) | 0, ae = ae + Math.imul(ye, $t) | 0;
        var Ft = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ft >>> 26) | 0, Ft &= 67108863, D = Math.imul(nt, We), F = Math.imul(nt, tt), F = F + Math.imul(Ie, We) | 0, ae = Math.imul(Ie, tt), D = D + Math.imul(Pe, rt) | 0, F = F + Math.imul(Pe, mt) | 0, F = F + Math.imul(He, rt) | 0, ae = ae + Math.imul(He, mt) | 0, D = D + Math.imul(ue, et) | 0, F = F + Math.imul(ue, Ze) | 0, F = F + Math.imul(de, et) | 0, ae = ae + Math.imul(de, Ze) | 0, D = D + Math.imul(De, ze) | 0, F = F + Math.imul(De, Qe) | 0, F = F + Math.imul(Ye, ze) | 0, ae = ae + Math.imul(Ye, Qe) | 0, D = D + Math.imul(be, ft) | 0, F = F + Math.imul(be, dt) | 0, F = F + Math.imul(ve, ft) | 0, ae = ae + Math.imul(ve, dt) | 0, D = D + Math.imul(fe, St) | 0, F = F + Math.imul(fe, $t) | 0, F = F + Math.imul($e, St) | 0, ae = ae + Math.imul($e, $t) | 0, D = D + Math.imul(xe, Ae) | 0, F = F + Math.imul(xe, Ce) | 0, F = F + Math.imul(ye, Ae) | 0, ae = ae + Math.imul(ye, Ce) | 0;
        var Nt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, D = Math.imul(je, We), F = Math.imul(je, tt), F = F + Math.imul(Ke, We) | 0, ae = Math.imul(Ke, tt), D = D + Math.imul(nt, rt) | 0, F = F + Math.imul(nt, mt) | 0, F = F + Math.imul(Ie, rt) | 0, ae = ae + Math.imul(Ie, mt) | 0, D = D + Math.imul(Pe, et) | 0, F = F + Math.imul(Pe, Ze) | 0, F = F + Math.imul(He, et) | 0, ae = ae + Math.imul(He, Ze) | 0, D = D + Math.imul(ue, ze) | 0, F = F + Math.imul(ue, Qe) | 0, F = F + Math.imul(de, ze) | 0, ae = ae + Math.imul(de, Qe) | 0, D = D + Math.imul(De, ft) | 0, F = F + Math.imul(De, dt) | 0, F = F + Math.imul(Ye, ft) | 0, ae = ae + Math.imul(Ye, dt) | 0, D = D + Math.imul(be, St) | 0, F = F + Math.imul(be, $t) | 0, F = F + Math.imul(ve, St) | 0, ae = ae + Math.imul(ve, $t) | 0, D = D + Math.imul(fe, Ae) | 0, F = F + Math.imul(fe, Ce) | 0, F = F + Math.imul($e, Ae) | 0, ae = ae + Math.imul($e, Ce) | 0, D = D + Math.imul(xe, we) | 0, F = F + Math.imul(xe, Ue) | 0, F = F + Math.imul(ye, we) | 0, ae = ae + Math.imul(ye, Ue) | 0;
        var Dt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, D = Math.imul(ut, We), F = Math.imul(ut, tt), F = F + Math.imul(pt, We) | 0, ae = Math.imul(pt, tt), D = D + Math.imul(je, rt) | 0, F = F + Math.imul(je, mt) | 0, F = F + Math.imul(Ke, rt) | 0, ae = ae + Math.imul(Ke, mt) | 0, D = D + Math.imul(nt, et) | 0, F = F + Math.imul(nt, Ze) | 0, F = F + Math.imul(Ie, et) | 0, ae = ae + Math.imul(Ie, Ze) | 0, D = D + Math.imul(Pe, ze) | 0, F = F + Math.imul(Pe, Qe) | 0, F = F + Math.imul(He, ze) | 0, ae = ae + Math.imul(He, Qe) | 0, D = D + Math.imul(ue, ft) | 0, F = F + Math.imul(ue, dt) | 0, F = F + Math.imul(de, ft) | 0, ae = ae + Math.imul(de, dt) | 0, D = D + Math.imul(De, St) | 0, F = F + Math.imul(De, $t) | 0, F = F + Math.imul(Ye, St) | 0, ae = ae + Math.imul(Ye, $t) | 0, D = D + Math.imul(be, Ae) | 0, F = F + Math.imul(be, Ce) | 0, F = F + Math.imul(ve, Ae) | 0, ae = ae + Math.imul(ve, Ce) | 0, D = D + Math.imul(fe, we) | 0, F = F + Math.imul(fe, Ue) | 0, F = F + Math.imul($e, we) | 0, ae = ae + Math.imul($e, Ue) | 0, D = D + Math.imul(xe, Ge) | 0, F = F + Math.imul(xe, st) | 0, F = F + Math.imul(ye, Ge) | 0, ae = ae + Math.imul(ye, st) | 0;
        var Ut = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, D = Math.imul(Xe, We), F = Math.imul(Xe, tt), F = F + Math.imul(at, We) | 0, ae = Math.imul(at, tt), D = D + Math.imul(ut, rt) | 0, F = F + Math.imul(ut, mt) | 0, F = F + Math.imul(pt, rt) | 0, ae = ae + Math.imul(pt, mt) | 0, D = D + Math.imul(je, et) | 0, F = F + Math.imul(je, Ze) | 0, F = F + Math.imul(Ke, et) | 0, ae = ae + Math.imul(Ke, Ze) | 0, D = D + Math.imul(nt, ze) | 0, F = F + Math.imul(nt, Qe) | 0, F = F + Math.imul(Ie, ze) | 0, ae = ae + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Pe, ft) | 0, F = F + Math.imul(Pe, dt) | 0, F = F + Math.imul(He, ft) | 0, ae = ae + Math.imul(He, dt) | 0, D = D + Math.imul(ue, St) | 0, F = F + Math.imul(ue, $t) | 0, F = F + Math.imul(de, St) | 0, ae = ae + Math.imul(de, $t) | 0, D = D + Math.imul(De, Ae) | 0, F = F + Math.imul(De, Ce) | 0, F = F + Math.imul(Ye, Ae) | 0, ae = ae + Math.imul(Ye, Ce) | 0, D = D + Math.imul(be, we) | 0, F = F + Math.imul(be, Ue) | 0, F = F + Math.imul(ve, we) | 0, ae = ae + Math.imul(ve, Ue) | 0, D = D + Math.imul(fe, Ge) | 0, F = F + Math.imul(fe, st) | 0, F = F + Math.imul($e, Ge) | 0, ae = ae + Math.imul($e, st) | 0, D = D + Math.imul(xe, bt) | 0, F = F + Math.imul(xe, wt) | 0, F = F + Math.imul(ye, bt) | 0, ae = ae + Math.imul(ye, wt) | 0;
        var kt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, D = Math.imul(Xe, rt), F = Math.imul(Xe, mt), F = F + Math.imul(at, rt) | 0, ae = Math.imul(at, mt), D = D + Math.imul(ut, et) | 0, F = F + Math.imul(ut, Ze) | 0, F = F + Math.imul(pt, et) | 0, ae = ae + Math.imul(pt, Ze) | 0, D = D + Math.imul(je, ze) | 0, F = F + Math.imul(je, Qe) | 0, F = F + Math.imul(Ke, ze) | 0, ae = ae + Math.imul(Ke, Qe) | 0, D = D + Math.imul(nt, ft) | 0, F = F + Math.imul(nt, dt) | 0, F = F + Math.imul(Ie, ft) | 0, ae = ae + Math.imul(Ie, dt) | 0, D = D + Math.imul(Pe, St) | 0, F = F + Math.imul(Pe, $t) | 0, F = F + Math.imul(He, St) | 0, ae = ae + Math.imul(He, $t) | 0, D = D + Math.imul(ue, Ae) | 0, F = F + Math.imul(ue, Ce) | 0, F = F + Math.imul(de, Ae) | 0, ae = ae + Math.imul(de, Ce) | 0, D = D + Math.imul(De, we) | 0, F = F + Math.imul(De, Ue) | 0, F = F + Math.imul(Ye, we) | 0, ae = ae + Math.imul(Ye, Ue) | 0, D = D + Math.imul(be, Ge) | 0, F = F + Math.imul(be, st) | 0, F = F + Math.imul(ve, Ge) | 0, ae = ae + Math.imul(ve, st) | 0, D = D + Math.imul(fe, bt) | 0, F = F + Math.imul(fe, wt) | 0, F = F + Math.imul($e, bt) | 0, ae = ae + Math.imul($e, wt) | 0;
        var Ot = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, D = Math.imul(Xe, et), F = Math.imul(Xe, Ze), F = F + Math.imul(at, et) | 0, ae = Math.imul(at, Ze), D = D + Math.imul(ut, ze) | 0, F = F + Math.imul(ut, Qe) | 0, F = F + Math.imul(pt, ze) | 0, ae = ae + Math.imul(pt, Qe) | 0, D = D + Math.imul(je, ft) | 0, F = F + Math.imul(je, dt) | 0, F = F + Math.imul(Ke, ft) | 0, ae = ae + Math.imul(Ke, dt) | 0, D = D + Math.imul(nt, St) | 0, F = F + Math.imul(nt, $t) | 0, F = F + Math.imul(Ie, St) | 0, ae = ae + Math.imul(Ie, $t) | 0, D = D + Math.imul(Pe, Ae) | 0, F = F + Math.imul(Pe, Ce) | 0, F = F + Math.imul(He, Ae) | 0, ae = ae + Math.imul(He, Ce) | 0, D = D + Math.imul(ue, we) | 0, F = F + Math.imul(ue, Ue) | 0, F = F + Math.imul(de, we) | 0, ae = ae + Math.imul(de, Ue) | 0, D = D + Math.imul(De, Ge) | 0, F = F + Math.imul(De, st) | 0, F = F + Math.imul(Ye, Ge) | 0, ae = ae + Math.imul(Ye, st) | 0, D = D + Math.imul(be, bt) | 0, F = F + Math.imul(be, wt) | 0, F = F + Math.imul(ve, bt) | 0, ae = ae + Math.imul(ve, wt) | 0;
        var It = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, D = Math.imul(Xe, ze), F = Math.imul(Xe, Qe), F = F + Math.imul(at, ze) | 0, ae = Math.imul(at, Qe), D = D + Math.imul(ut, ft) | 0, F = F + Math.imul(ut, dt) | 0, F = F + Math.imul(pt, ft) | 0, ae = ae + Math.imul(pt, dt) | 0, D = D + Math.imul(je, St) | 0, F = F + Math.imul(je, $t) | 0, F = F + Math.imul(Ke, St) | 0, ae = ae + Math.imul(Ke, $t) | 0, D = D + Math.imul(nt, Ae) | 0, F = F + Math.imul(nt, Ce) | 0, F = F + Math.imul(Ie, Ae) | 0, ae = ae + Math.imul(Ie, Ce) | 0, D = D + Math.imul(Pe, we) | 0, F = F + Math.imul(Pe, Ue) | 0, F = F + Math.imul(He, we) | 0, ae = ae + Math.imul(He, Ue) | 0, D = D + Math.imul(ue, Ge) | 0, F = F + Math.imul(ue, st) | 0, F = F + Math.imul(de, Ge) | 0, ae = ae + Math.imul(de, st) | 0, D = D + Math.imul(De, bt) | 0, F = F + Math.imul(De, wt) | 0, F = F + Math.imul(Ye, bt) | 0, ae = ae + Math.imul(Ye, wt) | 0;
        var Pt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, D = Math.imul(Xe, ft), F = Math.imul(Xe, dt), F = F + Math.imul(at, ft) | 0, ae = Math.imul(at, dt), D = D + Math.imul(ut, St) | 0, F = F + Math.imul(ut, $t) | 0, F = F + Math.imul(pt, St) | 0, ae = ae + Math.imul(pt, $t) | 0, D = D + Math.imul(je, Ae) | 0, F = F + Math.imul(je, Ce) | 0, F = F + Math.imul(Ke, Ae) | 0, ae = ae + Math.imul(Ke, Ce) | 0, D = D + Math.imul(nt, we) | 0, F = F + Math.imul(nt, Ue) | 0, F = F + Math.imul(Ie, we) | 0, ae = ae + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Pe, Ge) | 0, F = F + Math.imul(Pe, st) | 0, F = F + Math.imul(He, Ge) | 0, ae = ae + Math.imul(He, st) | 0, D = D + Math.imul(ue, bt) | 0, F = F + Math.imul(ue, wt) | 0, F = F + Math.imul(de, bt) | 0, ae = ae + Math.imul(de, wt) | 0;
        var Ct = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, D = Math.imul(Xe, St), F = Math.imul(Xe, $t), F = F + Math.imul(at, St) | 0, ae = Math.imul(at, $t), D = D + Math.imul(ut, Ae) | 0, F = F + Math.imul(ut, Ce) | 0, F = F + Math.imul(pt, Ae) | 0, ae = ae + Math.imul(pt, Ce) | 0, D = D + Math.imul(je, we) | 0, F = F + Math.imul(je, Ue) | 0, F = F + Math.imul(Ke, we) | 0, ae = ae + Math.imul(Ke, Ue) | 0, D = D + Math.imul(nt, Ge) | 0, F = F + Math.imul(nt, st) | 0, F = F + Math.imul(Ie, Ge) | 0, ae = ae + Math.imul(Ie, st) | 0, D = D + Math.imul(Pe, bt) | 0, F = F + Math.imul(Pe, wt) | 0, F = F + Math.imul(He, bt) | 0, ae = ae + Math.imul(He, wt) | 0;
        var Bt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, D = Math.imul(Xe, Ae), F = Math.imul(Xe, Ce), F = F + Math.imul(at, Ae) | 0, ae = Math.imul(at, Ce), D = D + Math.imul(ut, we) | 0, F = F + Math.imul(ut, Ue) | 0, F = F + Math.imul(pt, we) | 0, ae = ae + Math.imul(pt, Ue) | 0, D = D + Math.imul(je, Ge) | 0, F = F + Math.imul(je, st) | 0, F = F + Math.imul(Ke, Ge) | 0, ae = ae + Math.imul(Ke, st) | 0, D = D + Math.imul(nt, bt) | 0, F = F + Math.imul(nt, wt) | 0, F = F + Math.imul(Ie, bt) | 0, ae = ae + Math.imul(Ie, wt) | 0;
        var vt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, D = Math.imul(Xe, we), F = Math.imul(Xe, Ue), F = F + Math.imul(at, we) | 0, ae = Math.imul(at, Ue), D = D + Math.imul(ut, Ge) | 0, F = F + Math.imul(ut, st) | 0, F = F + Math.imul(pt, Ge) | 0, ae = ae + Math.imul(pt, st) | 0, D = D + Math.imul(je, bt) | 0, F = F + Math.imul(je, wt) | 0, F = F + Math.imul(Ke, bt) | 0, ae = ae + Math.imul(Ke, wt) | 0;
        var yt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, D = Math.imul(Xe, Ge), F = Math.imul(Xe, st), F = F + Math.imul(at, Ge) | 0, ae = Math.imul(at, st), D = D + Math.imul(ut, bt) | 0, F = F + Math.imul(ut, wt) | 0, F = F + Math.imul(pt, bt) | 0, ae = ae + Math.imul(pt, wt) | 0;
        var xt = (G + D | 0) + ((F & 8191) << 13) | 0;
        G = (ae + (F >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, D = Math.imul(Xe, bt), F = Math.imul(Xe, wt), F = F + Math.imul(at, bt) | 0, ae = Math.imul(at, wt);
        var Et = (G + D | 0) + ((F & 8191) << 13) | 0;
        return G = (ae + (F >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, z[0] = zt, z[1] = Tt, z[2] = Lt, z[3] = jt, z[4] = Ht, z[5] = Ft, z[6] = Nt, z[7] = Dt, z[8] = Ut, z[9] = kt, z[10] = Ot, z[11] = It, z[12] = Pt, z[13] = Ct, z[14] = Bt, z[15] = vt, z[16] = yt, z[17] = xt, z[18] = Et, G !== 0 && (z[19] = G, J.length++), J;
      };
      Math.imul || (se = te);
      function le(M, $, O) {
        O.negative = $.negative ^ M.negative, O.length = M.length + $.length;
        for (var J = 0, Z = 0, K = 0; K < O.length - 1; K++) {
          var z = Z;
          Z = 0;
          for (var G = J & 67108863, D = Math.min(K, $.length - 1), F = Math.max(0, K - M.length + 1); F <= D; F++) {
            var ae = K - F, ge = M.words[ae] | 0, xe = $.words[F] | 0, ye = ge * xe, oe = ye & 67108863;
            z = z + (ye / 67108864 | 0) | 0, oe = oe + G | 0, G = oe & 67108863, z = z + (oe >>> 26) | 0, Z += z >>> 26, z &= 67108863;
          }
          O.words[K] = G, J = z, z = Z;
        }
        return J !== 0 ? O.words[K] = J : O.length--, O._strip();
      }
      function ce(M, $, O) {
        return le(M, $, O);
      }
      h.prototype.mulTo = function($, O) {
        var J, Z = this.length + $.length;
        return this.length === 10 && $.length === 10 ? J = se(this, $, O) : Z < 63 ? J = te(this, $, O) : Z < 1024 ? J = le(this, $, O) : J = ce(this, $, O), J;
      }, h.prototype.mul = function($) {
        var O = new h(null);
        return O.words = new Array(this.length + $.length), this.mulTo($, O);
      }, h.prototype.mulf = function($) {
        var O = new h(null);
        return O.words = new Array(this.length + $.length), ce(this, $, O);
      }, h.prototype.imul = function($) {
        return this.clone().mulTo($, this);
      }, h.prototype.imuln = function($) {
        var O = $ < 0;
        O && ($ = -$), g(typeof $ == "number"), g($ < 67108864);
        for (var J = 0, Z = 0; Z < this.length; Z++) {
          var K = (this.words[Z] | 0) * $, z = (K & 67108863) + (J & 67108863);
          J >>= 26, J += K / 67108864 | 0, J += z >>> 26, this.words[Z] = z & 67108863;
        }
        return J !== 0 && (this.words[Z] = J, this.length++), O ? this.ineg() : this;
      }, h.prototype.muln = function($) {
        return this.clone().imuln($);
      }, h.prototype.sqr = function() {
        return this.mul(this);
      }, h.prototype.isqr = function() {
        return this.imul(this.clone());
      }, h.prototype.pow = function($) {
        var O = ie($);
        if (O.length === 0)
          return new h(1);
        for (var J = this, Z = 0; Z < O.length && O[Z] === 0; Z++, J = J.sqr())
          ;
        if (++Z < O.length)
          for (var K = J.sqr(); Z < O.length; Z++, K = K.sqr())
            O[Z] !== 0 && (J = J.mul(K));
        return J;
      }, h.prototype.iushln = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = $ % 26, J = ($ - O) / 26, Z = 67108863 >>> 26 - O << 26 - O, K;
        if (O !== 0) {
          var z = 0;
          for (K = 0; K < this.length; K++) {
            var G = this.words[K] & Z, D = (this.words[K] | 0) - G << O;
            this.words[K] = D | z, z = G >>> 26 - O;
          }
          z && (this.words[K] = z, this.length++);
        }
        if (J !== 0) {
          for (K = this.length - 1; K >= 0; K--)
            this.words[K + J] = this.words[K];
          for (K = 0; K < J; K++)
            this.words[K] = 0;
          this.length += J;
        }
        return this._strip();
      }, h.prototype.ishln = function($) {
        return g(this.negative === 0), this.iushln($);
      }, h.prototype.iushrn = function($, O, J) {
        g(typeof $ == "number" && $ >= 0);
        var Z;
        O ? Z = (O - O % 26) / 26 : Z = 0;
        var K = $ % 26, z = Math.min(($ - K) / 26, this.length), G = 67108863 ^ 67108863 >>> K << K, D = J;
        if (Z -= z, Z = Math.max(0, Z), D) {
          for (var F = 0; F < z; F++)
            D.words[F] = this.words[F];
          D.length = z;
        }
        if (z !== 0)
          if (this.length > z)
            for (this.length -= z, F = 0; F < this.length; F++)
              this.words[F] = this.words[F + z];
          else
            this.words[0] = 0, this.length = 1;
        var ae = 0;
        for (F = this.length - 1; F >= 0 && (ae !== 0 || F >= Z); F--) {
          var ge = this.words[F] | 0;
          this.words[F] = ae << 26 - K | ge >>> K, ae = ge & G;
        }
        return D && ae !== 0 && (D.words[D.length++] = ae), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, h.prototype.ishrn = function($, O, J) {
        return g(this.negative === 0), this.iushrn($, O, J);
      }, h.prototype.shln = function($) {
        return this.clone().ishln($);
      }, h.prototype.ushln = function($) {
        return this.clone().iushln($);
      }, h.prototype.shrn = function($) {
        return this.clone().ishrn($);
      }, h.prototype.ushrn = function($) {
        return this.clone().iushrn($);
      }, h.prototype.testn = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = $ % 26, J = ($ - O) / 26, Z = 1 << O;
        if (this.length <= J)
          return !1;
        var K = this.words[J];
        return !!(K & Z);
      }, h.prototype.imaskn = function($) {
        g(typeof $ == "number" && $ >= 0);
        var O = $ % 26, J = ($ - O) / 26;
        if (g(this.negative === 0, "imaskn works only with positive numbers"), this.length <= J)
          return this;
        if (O !== 0 && J++, this.length = Math.min(J, this.length), O !== 0) {
          var Z = 67108863 ^ 67108863 >>> O << O;
          this.words[this.length - 1] &= Z;
        }
        return this._strip();
      }, h.prototype.maskn = function($) {
        return this.clone().imaskn($);
      }, h.prototype.iaddn = function($) {
        return g(typeof $ == "number"), g($ < 67108864), $ < 0 ? this.isubn(-$) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= $ ? (this.words[0] = $ - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn($), this.negative = 1, this) : this._iaddn($);
      }, h.prototype._iaddn = function($) {
        this.words[0] += $;
        for (var O = 0; O < this.length && this.words[O] >= 67108864; O++)
          this.words[O] -= 67108864, O === this.length - 1 ? this.words[O + 1] = 1 : this.words[O + 1]++;
        return this.length = Math.max(this.length, O + 1), this;
      }, h.prototype.isubn = function($) {
        if (g(typeof $ == "number"), g($ < 67108864), $ < 0)
          return this.iaddn(-$);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn($), this.negative = 1, this;
        if (this.words[0] -= $, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var O = 0; O < this.length && this.words[O] < 0; O++)
            this.words[O] += 67108864, this.words[O + 1] -= 1;
        return this._strip();
      }, h.prototype.addn = function($) {
        return this.clone().iaddn($);
      }, h.prototype.subn = function($) {
        return this.clone().isubn($);
      }, h.prototype.iabs = function() {
        return this.negative = 0, this;
      }, h.prototype.abs = function() {
        return this.clone().iabs();
      }, h.prototype._ishlnsubmul = function($, O, J) {
        var Z = $.length + J, K;
        this._expand(Z);
        var z, G = 0;
        for (K = 0; K < $.length; K++) {
          z = (this.words[K + J] | 0) + G;
          var D = ($.words[K] | 0) * O;
          z -= D & 67108863, G = (z >> 26) - (D / 67108864 | 0), this.words[K + J] = z & 67108863;
        }
        for (; K < this.length - J; K++)
          z = (this.words[K + J] | 0) + G, G = z >> 26, this.words[K + J] = z & 67108863;
        if (G === 0)
          return this._strip();
        for (g(G === -1), G = 0, K = 0; K < this.length; K++)
          z = -(this.words[K] | 0) + G, G = z >> 26, this.words[K] = z & 67108863;
        return this.negative = 1, this._strip();
      }, h.prototype._wordDiv = function($, O) {
        var J = this.length - $.length, Z = this.clone(), K = $, z = K.words[K.length - 1] | 0, G = this._countBits(z);
        J = 26 - G, J !== 0 && (K = K.ushln(J), Z.iushln(J), z = K.words[K.length - 1] | 0);
        var D = Z.length - K.length, F;
        if (O !== "mod") {
          F = new h(null), F.length = D + 1, F.words = new Array(F.length);
          for (var ae = 0; ae < F.length; ae++)
            F.words[ae] = 0;
        }
        var ge = Z.clone()._ishlnsubmul(K, 1, D);
        ge.negative === 0 && (Z = ge, F && (F.words[D] = 1));
        for (var xe = D - 1; xe >= 0; xe--) {
          var ye = (Z.words[K.length + xe] | 0) * 67108864 + (Z.words[K.length + xe - 1] | 0);
          for (ye = Math.min(ye / z | 0, 67108863), Z._ishlnsubmul(K, ye, xe); Z.negative !== 0; )
            ye--, Z.negative = 0, Z._ishlnsubmul(K, 1, xe), Z.isZero() || (Z.negative ^= 1);
          F && (F.words[xe] = ye);
        }
        return F && F._strip(), Z._strip(), O !== "div" && J !== 0 && Z.iushrn(J), {
          div: F || null,
          mod: Z
        };
      }, h.prototype.divmod = function($, O, J) {
        if (g(!$.isZero()), this.isZero())
          return {
            div: new h(0),
            mod: new h(0)
          };
        var Z, K, z;
        return this.negative !== 0 && $.negative === 0 ? (z = this.neg().divmod($, O), O !== "mod" && (Z = z.div.neg()), O !== "div" && (K = z.mod.neg(), J && K.negative !== 0 && K.iadd($)), {
          div: Z,
          mod: K
        }) : this.negative === 0 && $.negative !== 0 ? (z = this.divmod($.neg(), O), O !== "mod" && (Z = z.div.neg()), {
          div: Z,
          mod: z.mod
        }) : this.negative & $.negative ? (z = this.neg().divmod($.neg(), O), O !== "div" && (K = z.mod.neg(), J && K.negative !== 0 && K.isub($)), {
          div: z.div,
          mod: K
        }) : $.length > this.length || this.cmp($) < 0 ? {
          div: new h(0),
          mod: this
        } : $.length === 1 ? O === "div" ? {
          div: this.divn($.words[0]),
          mod: null
        } : O === "mod" ? {
          div: null,
          mod: new h(this.modrn($.words[0]))
        } : {
          div: this.divn($.words[0]),
          mod: new h(this.modrn($.words[0]))
        } : this._wordDiv($, O);
      }, h.prototype.div = function($) {
        return this.divmod($, "div", !1).div;
      }, h.prototype.mod = function($) {
        return this.divmod($, "mod", !1).mod;
      }, h.prototype.umod = function($) {
        return this.divmod($, "mod", !0).mod;
      }, h.prototype.divRound = function($) {
        var O = this.divmod($);
        if (O.mod.isZero())
          return O.div;
        var J = O.div.negative !== 0 ? O.mod.isub($) : O.mod, Z = $.ushrn(1), K = $.andln(1), z = J.cmp(Z);
        return z < 0 || K === 1 && z === 0 ? O.div : O.div.negative !== 0 ? O.div.isubn(1) : O.div.iaddn(1);
      }, h.prototype.modrn = function($) {
        var O = $ < 0;
        O && ($ = -$), g($ <= 67108863);
        for (var J = (1 << 26) % $, Z = 0, K = this.length - 1; K >= 0; K--)
          Z = (J * Z + (this.words[K] | 0)) % $;
        return O ? -Z : Z;
      }, h.prototype.modn = function($) {
        return this.modrn($);
      }, h.prototype.idivn = function($) {
        var O = $ < 0;
        O && ($ = -$), g($ <= 67108863);
        for (var J = 0, Z = this.length - 1; Z >= 0; Z--) {
          var K = (this.words[Z] | 0) + J * 67108864;
          this.words[Z] = K / $ | 0, J = K % $;
        }
        return this._strip(), O ? this.ineg() : this;
      }, h.prototype.divn = function($) {
        return this.clone().idivn($);
      }, h.prototype.egcd = function($) {
        g($.negative === 0), g(!$.isZero());
        var O = this, J = $.clone();
        O.negative !== 0 ? O = O.umod($) : O = O.clone();
        for (var Z = new h(1), K = new h(0), z = new h(0), G = new h(1), D = 0; O.isEven() && J.isEven(); )
          O.iushrn(1), J.iushrn(1), ++D;
        for (var F = J.clone(), ae = O.clone(); !O.isZero(); ) {
          for (var ge = 0, xe = 1; !(O.words[0] & xe) && ge < 26; ++ge, xe <<= 1)
            ;
          if (ge > 0)
            for (O.iushrn(ge); ge-- > 0; )
              (Z.isOdd() || K.isOdd()) && (Z.iadd(F), K.isub(ae)), Z.iushrn(1), K.iushrn(1);
          for (var ye = 0, oe = 1; !(J.words[0] & oe) && ye < 26; ++ye, oe <<= 1)
            ;
          if (ye > 0)
            for (J.iushrn(ye); ye-- > 0; )
              (z.isOdd() || G.isOdd()) && (z.iadd(F), G.isub(ae)), z.iushrn(1), G.iushrn(1);
          O.cmp(J) >= 0 ? (O.isub(J), Z.isub(z), K.isub(G)) : (J.isub(O), z.isub(Z), G.isub(K));
        }
        return {
          a: z,
          b: G,
          gcd: J.iushln(D)
        };
      }, h.prototype._invmp = function($) {
        g($.negative === 0), g(!$.isZero());
        var O = this, J = $.clone();
        O.negative !== 0 ? O = O.umod($) : O = O.clone();
        for (var Z = new h(1), K = new h(0), z = J.clone(); O.cmpn(1) > 0 && J.cmpn(1) > 0; ) {
          for (var G = 0, D = 1; !(O.words[0] & D) && G < 26; ++G, D <<= 1)
            ;
          if (G > 0)
            for (O.iushrn(G); G-- > 0; )
              Z.isOdd() && Z.iadd(z), Z.iushrn(1);
          for (var F = 0, ae = 1; !(J.words[0] & ae) && F < 26; ++F, ae <<= 1)
            ;
          if (F > 0)
            for (J.iushrn(F); F-- > 0; )
              K.isOdd() && K.iadd(z), K.iushrn(1);
          O.cmp(J) >= 0 ? (O.isub(J), Z.isub(K)) : (J.isub(O), K.isub(Z));
        }
        var ge;
        return O.cmpn(1) === 0 ? ge = Z : ge = K, ge.cmpn(0) < 0 && ge.iadd($), ge;
      }, h.prototype.gcd = function($) {
        if (this.isZero())
          return $.abs();
        if ($.isZero())
          return this.abs();
        var O = this.clone(), J = $.clone();
        O.negative = 0, J.negative = 0;
        for (var Z = 0; O.isEven() && J.isEven(); Z++)
          O.iushrn(1), J.iushrn(1);
        do {
          for (; O.isEven(); )
            O.iushrn(1);
          for (; J.isEven(); )
            J.iushrn(1);
          var K = O.cmp(J);
          if (K < 0) {
            var z = O;
            O = J, J = z;
          } else if (K === 0 || J.cmpn(1) === 0)
            break;
          O.isub(J);
        } while (!0);
        return J.iushln(Z);
      }, h.prototype.invm = function($) {
        return this.egcd($).a.umod($);
      }, h.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, h.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, h.prototype.andln = function($) {
        return this.words[0] & $;
      }, h.prototype.bincn = function($) {
        g(typeof $ == "number");
        var O = $ % 26, J = ($ - O) / 26, Z = 1 << O;
        if (this.length <= J)
          return this._expand(J + 1), this.words[J] |= Z, this;
        for (var K = Z, z = J; K !== 0 && z < this.length; z++) {
          var G = this.words[z] | 0;
          G += K, K = G >>> 26, G &= 67108863, this.words[z] = G;
        }
        return K !== 0 && (this.words[z] = K, this.length++), this;
      }, h.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, h.prototype.cmpn = function($) {
        var O = $ < 0;
        if (this.negative !== 0 && !O)
          return -1;
        if (this.negative === 0 && O)
          return 1;
        this._strip();
        var J;
        if (this.length > 1)
          J = 1;
        else {
          O && ($ = -$), g($ <= 67108863, "Number is too big");
          var Z = this.words[0] | 0;
          J = Z === $ ? 0 : Z < $ ? -1 : 1;
        }
        return this.negative !== 0 ? -J | 0 : J;
      }, h.prototype.cmp = function($) {
        if (this.negative !== 0 && $.negative === 0)
          return -1;
        if (this.negative === 0 && $.negative !== 0)
          return 1;
        var O = this.ucmp($);
        return this.negative !== 0 ? -O | 0 : O;
      }, h.prototype.ucmp = function($) {
        if (this.length > $.length)
          return 1;
        if (this.length < $.length)
          return -1;
        for (var O = 0, J = this.length - 1; J >= 0; J--) {
          var Z = this.words[J] | 0, K = $.words[J] | 0;
          if (Z !== K) {
            Z < K ? O = -1 : Z > K && (O = 1);
            break;
          }
        }
        return O;
      }, h.prototype.gtn = function($) {
        return this.cmpn($) === 1;
      }, h.prototype.gt = function($) {
        return this.cmp($) === 1;
      }, h.prototype.gten = function($) {
        return this.cmpn($) >= 0;
      }, h.prototype.gte = function($) {
        return this.cmp($) >= 0;
      }, h.prototype.ltn = function($) {
        return this.cmpn($) === -1;
      }, h.prototype.lt = function($) {
        return this.cmp($) === -1;
      }, h.prototype.lten = function($) {
        return this.cmpn($) <= 0;
      }, h.prototype.lte = function($) {
        return this.cmp($) <= 0;
      }, h.prototype.eqn = function($) {
        return this.cmpn($) === 0;
      }, h.prototype.eq = function($) {
        return this.cmp($) === 0;
      }, h.red = function($) {
        return new ne($);
      }, h.prototype.toRed = function($) {
        return g(!this.red, "Already a number in reduction context"), g(this.negative === 0, "red works only with positives"), $.convertTo(this)._forceRed($);
      }, h.prototype.fromRed = function() {
        return g(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, h.prototype._forceRed = function($) {
        return this.red = $, this;
      }, h.prototype.forceRed = function($) {
        return g(!this.red, "Already a number in reduction context"), this._forceRed($);
      }, h.prototype.redAdd = function($) {
        return g(this.red, "redAdd works only with red numbers"), this.red.add(this, $);
      }, h.prototype.redIAdd = function($) {
        return g(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, $);
      }, h.prototype.redSub = function($) {
        return g(this.red, "redSub works only with red numbers"), this.red.sub(this, $);
      }, h.prototype.redISub = function($) {
        return g(this.red, "redISub works only with red numbers"), this.red.isub(this, $);
      }, h.prototype.redShl = function($) {
        return g(this.red, "redShl works only with red numbers"), this.red.shl(this, $);
      }, h.prototype.redMul = function($) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, $), this.red.mul(this, $);
      }, h.prototype.redIMul = function($) {
        return g(this.red, "redMul works only with red numbers"), this.red._verify2(this, $), this.red.imul(this, $);
      }, h.prototype.redSqr = function() {
        return g(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, h.prototype.redISqr = function() {
        return g(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, h.prototype.redSqrt = function() {
        return g(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, h.prototype.redInvm = function() {
        return g(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, h.prototype.redNeg = function() {
        return g(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, h.prototype.redPow = function($) {
        return g(this.red && !$.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, $);
      };
      var pe = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function me(M, $) {
        this.name = M, this.p = new h($, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      me.prototype._tmp = function() {
        var $ = new h(null);
        return $.words = new Array(Math.ceil(this.n / 13)), $;
      }, me.prototype.ireduce = function($) {
        var O = $, J;
        do
          this.split(O, this.tmp), O = this.imulK(O), O = O.iadd(this.tmp), J = O.bitLength();
        while (J > this.n);
        var Z = J < this.n ? -1 : O.ucmp(this.p);
        return Z === 0 ? (O.words[0] = 0, O.length = 1) : Z > 0 ? O.isub(this.p) : O.strip !== void 0 ? O.strip() : O._strip(), O;
      }, me.prototype.split = function($, O) {
        $.iushrn(this.n, 0, O);
      }, me.prototype.imulK = function($) {
        return $.imul(this.k);
      };
      function Me() {
        me.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      U(Me, me), Me.prototype.split = function($, O) {
        for (var J = 4194303, Z = Math.min($.length, 9), K = 0; K < Z; K++)
          O.words[K] = $.words[K];
        if (O.length = Z, $.length <= 9) {
          $.words[0] = 0, $.length = 1;
          return;
        }
        var z = $.words[9];
        for (O.words[O.length++] = z & J, K = 10; K < $.length; K++) {
          var G = $.words[K] | 0;
          $.words[K - 10] = (G & J) << 4 | z >>> 22, z = G;
        }
        z >>>= 22, $.words[K - 10] = z, z === 0 && $.length > 10 ? $.length -= 10 : $.length -= 9;
      }, Me.prototype.imulK = function($) {
        $.words[$.length] = 0, $.words[$.length + 1] = 0, $.length += 2;
        for (var O = 0, J = 0; J < $.length; J++) {
          var Z = $.words[J] | 0;
          O += Z * 977, $.words[J] = O & 67108863, O = Z * 64 + (O / 67108864 | 0);
        }
        return $.words[$.length - 1] === 0 && ($.length--, $.words[$.length - 1] === 0 && $.length--), $;
      };
      function Ee() {
        me.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      U(Ee, me);
      function Re() {
        me.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      U(Re, me);
      function Ne() {
        me.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      U(Ne, me), Ne.prototype.imulK = function($) {
        for (var O = 0, J = 0; J < $.length; J++) {
          var Z = ($.words[J] | 0) * 19 + O, K = Z & 67108863;
          Z >>>= 26, $.words[J] = K, O = Z;
        }
        return O !== 0 && ($.words[$.length++] = O), $;
      }, h._prime = function($) {
        if (pe[$])
          return pe[$];
        var O;
        if ($ === "k256")
          O = new Me();
        else if ($ === "p224")
          O = new Ee();
        else if ($ === "p192")
          O = new Re();
        else if ($ === "p25519")
          O = new Ne();
        else
          throw new Error("Unknown prime " + $);
        return pe[$] = O, O;
      };
      function ne(M) {
        if (typeof M == "string") {
          var $ = h._prime(M);
          this.m = $.p, this.prime = $;
        } else
          g(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
      }
      ne.prototype._verify1 = function($) {
        g($.negative === 0, "red works only with positives"), g($.red, "red works only with red numbers");
      }, ne.prototype._verify2 = function($, O) {
        g(($.negative | O.negative) === 0, "red works only with positives"), g(
          $.red && $.red === O.red,
          "red works only with red numbers"
        );
      }, ne.prototype.imod = function($) {
        return this.prime ? this.prime.ireduce($)._forceRed(this) : (B($, $.umod(this.m)._forceRed(this)), $);
      }, ne.prototype.neg = function($) {
        return $.isZero() ? $.clone() : this.m.sub($)._forceRed(this);
      }, ne.prototype.add = function($, O) {
        this._verify2($, O);
        var J = $.add(O);
        return J.cmp(this.m) >= 0 && J.isub(this.m), J._forceRed(this);
      }, ne.prototype.iadd = function($, O) {
        this._verify2($, O);
        var J = $.iadd(O);
        return J.cmp(this.m) >= 0 && J.isub(this.m), J;
      }, ne.prototype.sub = function($, O) {
        this._verify2($, O);
        var J = $.sub(O);
        return J.cmpn(0) < 0 && J.iadd(this.m), J._forceRed(this);
      }, ne.prototype.isub = function($, O) {
        this._verify2($, O);
        var J = $.isub(O);
        return J.cmpn(0) < 0 && J.iadd(this.m), J;
      }, ne.prototype.shl = function($, O) {
        return this._verify1($), this.imod($.ushln(O));
      }, ne.prototype.imul = function($, O) {
        return this._verify2($, O), this.imod($.imul(O));
      }, ne.prototype.mul = function($, O) {
        return this._verify2($, O), this.imod($.mul(O));
      }, ne.prototype.isqr = function($) {
        return this.imul($, $.clone());
      }, ne.prototype.sqr = function($) {
        return this.mul($, $);
      }, ne.prototype.sqrt = function($) {
        if ($.isZero())
          return $.clone();
        var O = this.m.andln(3);
        if (g(O % 2 === 1), O === 3) {
          var J = this.m.add(new h(1)).iushrn(2);
          return this.pow($, J);
        }
        for (var Z = this.m.subn(1), K = 0; !Z.isZero() && Z.andln(1) === 0; )
          K++, Z.iushrn(1);
        g(!Z.isZero());
        var z = new h(1).toRed(this), G = z.redNeg(), D = this.m.subn(1).iushrn(1), F = this.m.bitLength();
        for (F = new h(2 * F * F).toRed(this); this.pow(F, D).cmp(G) !== 0; )
          F.redIAdd(G);
        for (var ae = this.pow(F, Z), ge = this.pow($, Z.addn(1).iushrn(1)), xe = this.pow($, Z), ye = K; xe.cmp(z) !== 0; ) {
          for (var oe = xe, fe = 0; oe.cmp(z) !== 0; fe++)
            oe = oe.redSqr();
          g(fe < ye);
          var $e = this.pow(ae, new h(1).iushln(ye - fe - 1));
          ge = ge.redMul($e), ae = $e.redSqr(), xe = xe.redMul(ae), ye = fe;
        }
        return ge;
      }, ne.prototype.invm = function($) {
        var O = $._invmp(this.m);
        return O.negative !== 0 ? (O.negative = 0, this.imod(O).redNeg()) : this.imod(O);
      }, ne.prototype.pow = function($, O) {
        if (O.isZero())
          return new h(1).toRed(this);
        if (O.cmpn(1) === 0)
          return $.clone();
        var J = 4, Z = new Array(1 << J);
        Z[0] = new h(1).toRed(this), Z[1] = $;
        for (var K = 2; K < Z.length; K++)
          Z[K] = this.mul(Z[K - 1], $);
        var z = Z[0], G = 0, D = 0, F = O.bitLength() % 26;
        for (F === 0 && (F = 26), K = O.length - 1; K >= 0; K--) {
          for (var ae = O.words[K], ge = F - 1; ge >= 0; ge--) {
            var xe = ae >> ge & 1;
            if (z !== Z[0] && (z = this.sqr(z)), xe === 0 && G === 0) {
              D = 0;
              continue;
            }
            G <<= 1, G |= xe, D++, !(D !== J && (K !== 0 || ge !== 0)) && (z = this.mul(z, Z[G]), D = 0, G = 0);
          }
          F = 26;
        }
        return z;
      }, ne.prototype.convertTo = function($) {
        var O = $.umod(this.m);
        return O === $ ? O.clone() : O;
      }, ne.prototype.convertFrom = function($) {
        var O = $.clone();
        return O.red = null, O;
      }, h.mont = function($) {
        return new Y($);
      };
      function Y(M) {
        ne.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      U(Y, ne), Y.prototype.convertTo = function($) {
        return this.imod($.ushln(this.shift));
      }, Y.prototype.convertFrom = function($) {
        var O = this.imod($.mul(this.rinv));
        return O.red = null, O;
      }, Y.prototype.imul = function($, O) {
        if ($.isZero() || O.isZero())
          return $.words[0] = 0, $.length = 1, $;
        var J = $.imul(O), Z = J.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), K = J.isub(Z).iushrn(this.shift), z = K;
        return K.cmp(this.m) >= 0 ? z = K.isub(this.m) : K.cmpn(0) < 0 && (z = K.iadd(this.m)), z._forceRed(this);
      }, Y.prototype.mul = function($, O) {
        if ($.isZero() || O.isZero())
          return new h(0)._forceRed(this);
        var J = $.mul(O), Z = J.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), K = J.isub(Z).iushrn(this.shift), z = K;
        return K.cmp(this.m) >= 0 ? z = K.isub(this.m) : K.cmpn(0) < 0 && (z = K.iadd(this.m)), z._forceRed(this);
      }, Y.prototype.invm = function($) {
        var O = this.imod($._invmp(this.m).mul(this.r2));
        return O._forceRed(this);
      };
    })(e, commonjsGlobal$1);
  }(bn)), bn.exports;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(e, o) {
      if (e.indexOf)
        return e.indexOf(o);
      for (var S = 0; S < e.length; S++)
        if (e[S] === o)
          return S;
      return -1;
    }, Object_keys = function(e) {
      if (Object.keys)
        return Object.keys(e);
      var o = [];
      for (var S in e)
        o.push(S);
      return o;
    }, forEach = function(e, o) {
      if (e.forEach)
        return e.forEach(o);
      for (var S = 0; S < e.length; S++)
        o(e[S], S, e);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(e, o, S) {
          Object.defineProperty(e, o, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: S
          });
        };
      } catch {
        return function(o, S, g) {
          o[S] = g;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(o) {
      if (!(this instanceof Script))
        return new Script(o);
      this.code = o;
    };
    Script.prototype.runInContext = function(e) {
      if (!(e instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var o = document.createElement("iframe");
      o.style || (o.style = {}), o.style.display = "none", document.body.appendChild(o);
      var S = o.contentWindow, g = S.eval, U = S.execScript;
      !g && U && (U.call(S, "null"), g = S.eval), forEach(Object_keys(e), function(A) {
        S[A] = e[A];
      }), forEach(globals, function(A) {
        e[A] && (S[A] = e[A]);
      });
      var h = Object_keys(S), q = g.call(S, this.code);
      return forEach(Object_keys(S), function(A) {
        (A in e || indexOf(h, A) === -1) && (e[A] = S[A]);
      }), forEach(globals, function(A) {
        A in e || defineProp(e, A, S[A]);
      }), document.body.removeChild(o), q;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(e) {
      var o = Script.createContext(e), S = this.runInContext(o);
      return e && forEach(Object_keys(o), function(g) {
        e[g] = o[g];
      }), S;
    }, forEach(Object_keys(Script.prototype), function(e) {
      exports[e] = Script[e] = function(o) {
        var S = Script(o);
        return S[e].apply(S, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(e) {
      return e instanceof Context;
    }, exports.createScript = function(e) {
      return exports.Script(e);
    }, exports.createContext = Script.createContext = function(e) {
      var o = new Context();
      return typeof e == "object" && forEach(Object_keys(e), function(S) {
        o[S] = e[S];
      }), o;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(e) {
    var o = requireAsn1$1(), S = requireInherits_browser(), g = e;
    g.define = function(q, A) {
      return new U(q, A);
    };
    function U(h, q) {
      this.name = h, this.body = q, this.decoders = {}, this.encoders = {};
    }
    U.prototype._createNamed = function(q) {
      var A;
      try {
        A = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        A = function(I) {
          this._initNamed(I);
        };
      }
      return S(A, q), A.prototype._initNamed = function(I) {
        q.call(this, I);
      }, new A(this);
    }, U.prototype._getDecoder = function(q) {
      return q = q || "der", this.decoders.hasOwnProperty(q) || (this.decoders[q] = this._createNamed(o.decoders[q])), this.decoders[q];
    }, U.prototype.decode = function(q, A, P) {
      return this._getDecoder(A).decode(q, P);
    }, U.prototype._getEncoder = function(q) {
      return q = q || "der", this.encoders.hasOwnProperty(q) || (this.encoders[q] = this._createNamed(o.encoders[q])), this.encoders[q];
    }, U.prototype.encode = function(q, A, P) {
      return this._getEncoder(A).encode(q, P);
    };
  }(api)), api;
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter)
    return reporter;
  hasRequiredReporter = 1;
  var e = requireInherits_browser();
  function o(g) {
    this._reporterState = {
      obj: null,
      path: [],
      options: g || {},
      errors: []
    };
  }
  reporter.Reporter = o, o.prototype.isError = function(U) {
    return U instanceof S;
  }, o.prototype.save = function() {
    var U = this._reporterState;
    return { obj: U.obj, pathLen: U.path.length };
  }, o.prototype.restore = function(U) {
    var h = this._reporterState;
    h.obj = U.obj, h.path = h.path.slice(0, U.pathLen);
  }, o.prototype.enterKey = function(U) {
    return this._reporterState.path.push(U);
  }, o.prototype.exitKey = function(U) {
    var h = this._reporterState;
    h.path = h.path.slice(0, U - 1);
  }, o.prototype.leaveKey = function(U, h, q) {
    var A = this._reporterState;
    this.exitKey(U), A.obj !== null && (A.obj[h] = q);
  }, o.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, o.prototype.enterObject = function() {
    var U = this._reporterState, h = U.obj;
    return U.obj = {}, h;
  }, o.prototype.leaveObject = function(U) {
    var h = this._reporterState, q = h.obj;
    return h.obj = U, q;
  }, o.prototype.error = function(U) {
    var h, q = this._reporterState, A = U instanceof S;
    if (A ? h = U : h = new S(q.path.map(function(P) {
      return "[" + JSON.stringify(P) + "]";
    }).join(""), U.message || U, U.stack), !q.options.partial)
      throw h;
    return A || q.errors.push(h), h;
  }, o.prototype.wrapResult = function(U) {
    var h = this._reporterState;
    return h.options.partial ? {
      result: this.isError(U) ? null : U,
      errors: h.errors
    } : U;
  };
  function S(g, U) {
    this.path = g, this.rethrow(U);
  }
  return e(S, Error), S.prototype.rethrow = function(U) {
    if (this.message = U + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, S), !this.stack)
      try {
        throw new Error(this.message);
      } catch (h) {
        this.stack = h.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer)
    return buffer;
  hasRequiredBuffer = 1;
  var e = requireInherits_browser(), o = requireBase().Reporter, S = buffer$3.Buffer;
  function g(h, q) {
    if (o.call(this, q), !S.isBuffer(h)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = h, this.offset = 0, this.length = h.length;
  }
  e(g, o), buffer.DecoderBuffer = g, g.prototype.save = function() {
    return { offset: this.offset, reporter: o.prototype.save.call(this) };
  }, g.prototype.restore = function(q) {
    var A = new g(this.base);
    return A.offset = q.offset, A.length = this.offset, this.offset = q.offset, o.prototype.restore.call(this, q.reporter), A;
  }, g.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, g.prototype.readUInt8 = function(q) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(q || "DecoderBuffer overrun");
  }, g.prototype.skip = function(q, A) {
    if (!(this.offset + q <= this.length))
      return this.error(A || "DecoderBuffer overrun");
    var P = new g(this.base);
    return P._reporterState = this._reporterState, P.offset = this.offset, P.length = this.offset + q, this.offset += q, P;
  }, g.prototype.raw = function(q) {
    return this.base.slice(q ? q.offset : this.offset, this.length);
  };
  function U(h, q) {
    if (Array.isArray(h))
      this.length = 0, this.value = h.map(function(A) {
        return A instanceof U || (A = new U(A, q)), this.length += A.length, A;
      }, this);
    else if (typeof h == "number") {
      if (!(0 <= h && h <= 255))
        return q.error("non-byte EncoderBuffer value");
      this.value = h, this.length = 1;
    } else if (typeof h == "string")
      this.value = h, this.length = S.byteLength(h);
    else if (S.isBuffer(h))
      this.value = h, this.length = h.length;
    else
      return q.error("Unsupported type: " + typeof h);
  }
  return buffer.EncoderBuffer = U, U.prototype.join = function(q, A) {
    return q || (q = new S(this.length)), A || (A = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(P) {
      P.join(q, A), A += P.length;
    }) : (typeof this.value == "number" ? q[A] = this.value : typeof this.value == "string" ? q.write(this.value, A) : S.isBuffer(this.value) && this.value.copy(q, A), A += this.length)), q;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node;
  hasRequiredNode = 1;
  var e = requireBase().Reporter, o = requireBase().EncoderBuffer, S = requireBase().DecoderBuffer, g = requireMinimalisticAssert(), U = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], h = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(U), q = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function A(I, B) {
    var H = {};
    this._baseState = H, H.enc = I, H.parent = B || null, H.children = null, H.tag = null, H.args = null, H.reverseArgs = null, H.choice = null, H.optional = !1, H.any = !1, H.obj = !1, H.use = null, H.useDecoder = null, H.key = null, H.default = null, H.explicit = null, H.implicit = null, H.contains = null, H.parent || (H.children = [], this._wrap());
  }
  node = A;
  var P = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return A.prototype.clone = function() {
    var B = this._baseState, H = {};
    P.forEach(function(X) {
      H[X] = B[X];
    });
    var V = new this.constructor(H.parent);
    return V._baseState = H, V;
  }, A.prototype._wrap = function() {
    var B = this._baseState;
    h.forEach(function(H) {
      this[H] = function() {
        var X = new this.constructor(this);
        return B.children.push(X), X[H].apply(X, arguments);
      };
    }, this);
  }, A.prototype._init = function(B) {
    var H = this._baseState;
    g(H.parent === null), B.call(this), H.children = H.children.filter(function(V) {
      return V._baseState.parent === this;
    }, this), g.equal(H.children.length, 1, "Root node can have only one child");
  }, A.prototype._useArgs = function(B) {
    var H = this._baseState, V = B.filter(function(X) {
      return X instanceof this.constructor;
    }, this);
    B = B.filter(function(X) {
      return !(X instanceof this.constructor);
    }, this), V.length !== 0 && (g(H.children === null), H.children = V, V.forEach(function(X) {
      X._baseState.parent = this;
    }, this)), B.length !== 0 && (g(H.args === null), H.args = B, H.reverseArgs = B.map(function(X) {
      if (typeof X != "object" || X.constructor !== Object)
        return X;
      var Q = {};
      return Object.keys(X).forEach(function(ee) {
        ee == (ee | 0) && (ee |= 0);
        var ie = X[ee];
        Q[ie] = ee;
      }), Q;
    }));
  }, q.forEach(function(I) {
    A.prototype[I] = function() {
      var H = this._baseState;
      throw new Error(I + " not implemented for encoding: " + H.enc);
    };
  }), U.forEach(function(I) {
    A.prototype[I] = function() {
      var H = this._baseState, V = Array.prototype.slice.call(arguments);
      return g(H.tag === null), H.tag = I, this._useArgs(V), this;
    };
  }), A.prototype.use = function(B) {
    g(B);
    var H = this._baseState;
    return g(H.use === null), H.use = B, this;
  }, A.prototype.optional = function() {
    var B = this._baseState;
    return B.optional = !0, this;
  }, A.prototype.def = function(B) {
    var H = this._baseState;
    return g(H.default === null), H.default = B, H.optional = !0, this;
  }, A.prototype.explicit = function(B) {
    var H = this._baseState;
    return g(H.explicit === null && H.implicit === null), H.explicit = B, this;
  }, A.prototype.implicit = function(B) {
    var H = this._baseState;
    return g(H.explicit === null && H.implicit === null), H.implicit = B, this;
  }, A.prototype.obj = function() {
    var B = this._baseState, H = Array.prototype.slice.call(arguments);
    return B.obj = !0, H.length !== 0 && this._useArgs(H), this;
  }, A.prototype.key = function(B) {
    var H = this._baseState;
    return g(H.key === null), H.key = B, this;
  }, A.prototype.any = function() {
    var B = this._baseState;
    return B.any = !0, this;
  }, A.prototype.choice = function(B) {
    var H = this._baseState;
    return g(H.choice === null), H.choice = B, this._useArgs(Object.keys(B).map(function(V) {
      return B[V];
    })), this;
  }, A.prototype.contains = function(B) {
    var H = this._baseState;
    return g(H.use === null), H.contains = B, this;
  }, A.prototype._decode = function(B, H) {
    var V = this._baseState;
    if (V.parent === null)
      return B.wrapResult(V.children[0]._decode(B, H));
    var X = V.default, Q = !0, ee = null;
    if (V.key !== null && (ee = B.enterKey(V.key)), V.optional) {
      var ie = null;
      if (V.explicit !== null ? ie = V.explicit : V.implicit !== null ? ie = V.implicit : V.tag !== null && (ie = V.tag), ie === null && !V.any) {
        var te = B.save();
        try {
          V.choice === null ? this._decodeGeneric(V.tag, B, H) : this._decodeChoice(B, H), Q = !0;
        } catch {
          Q = !1;
        }
        B.restore(te);
      } else if (Q = this._peekTag(B, ie, V.any), B.isError(Q))
        return Q;
    }
    var se;
    if (V.obj && Q && (se = B.enterObject()), Q) {
      if (V.explicit !== null) {
        var le = this._decodeTag(B, V.explicit);
        if (B.isError(le))
          return le;
        B = le;
      }
      var ce = B.offset;
      if (V.use === null && V.choice === null) {
        if (V.any)
          var te = B.save();
        var pe = this._decodeTag(
          B,
          V.implicit !== null ? V.implicit : V.tag,
          V.any
        );
        if (B.isError(pe))
          return pe;
        V.any ? X = B.raw(te) : B = pe;
      }
      if (H && H.track && V.tag !== null && H.track(B.path(), ce, B.length, "tagged"), H && H.track && V.tag !== null && H.track(B.path(), B.offset, B.length, "content"), V.any ? X = X : V.choice === null ? X = this._decodeGeneric(V.tag, B, H) : X = this._decodeChoice(B, H), B.isError(X))
        return X;
      if (!V.any && V.choice === null && V.children !== null && V.children.forEach(function(Ee) {
        Ee._decode(B, H);
      }), V.contains && (V.tag === "octstr" || V.tag === "bitstr")) {
        var me = new S(X);
        X = this._getUse(V.contains, B._reporterState.obj)._decode(me, H);
      }
    }
    return V.obj && Q && (X = B.leaveObject(se)), V.key !== null && (X !== null || Q === !0) ? B.leaveKey(ee, V.key, X) : ee !== null && B.exitKey(ee), X;
  }, A.prototype._decodeGeneric = function(B, H, V) {
    var X = this._baseState;
    return B === "seq" || B === "set" ? null : B === "seqof" || B === "setof" ? this._decodeList(H, B, X.args[0], V) : /str$/.test(B) ? this._decodeStr(H, B, V) : B === "objid" && X.args ? this._decodeObjid(H, X.args[0], X.args[1], V) : B === "objid" ? this._decodeObjid(H, null, null, V) : B === "gentime" || B === "utctime" ? this._decodeTime(H, B, V) : B === "null_" ? this._decodeNull(H, V) : B === "bool" ? this._decodeBool(H, V) : B === "objDesc" ? this._decodeStr(H, B, V) : B === "int" || B === "enum" ? this._decodeInt(H, X.args && X.args[0], V) : X.use !== null ? this._getUse(X.use, H._reporterState.obj)._decode(H, V) : H.error("unknown tag: " + B);
  }, A.prototype._getUse = function(B, H) {
    var V = this._baseState;
    return V.useDecoder = this._use(B, H), g(V.useDecoder._baseState.parent === null), V.useDecoder = V.useDecoder._baseState.children[0], V.implicit !== V.useDecoder._baseState.implicit && (V.useDecoder = V.useDecoder.clone(), V.useDecoder._baseState.implicit = V.implicit), V.useDecoder;
  }, A.prototype._decodeChoice = function(B, H) {
    var V = this._baseState, X = null, Q = !1;
    return Object.keys(V.choice).some(function(ee) {
      var ie = B.save(), te = V.choice[ee];
      try {
        var se = te._decode(B, H);
        if (B.isError(se))
          return !1;
        X = { type: ee, value: se }, Q = !0;
      } catch {
        return B.restore(ie), !1;
      }
      return !0;
    }, this), Q ? X : B.error("Choice not matched");
  }, A.prototype._createEncoderBuffer = function(B) {
    return new o(B, this.reporter);
  }, A.prototype._encode = function(B, H, V) {
    var X = this._baseState;
    if (!(X.default !== null && X.default === B)) {
      var Q = this._encodeValue(B, H, V);
      if (Q !== void 0 && !this._skipDefault(Q, H, V))
        return Q;
    }
  }, A.prototype._encodeValue = function(B, H, V) {
    var X = this._baseState;
    if (X.parent === null)
      return X.children[0]._encode(B, H || new e());
    var te = null;
    if (this.reporter = H, X.optional && B === void 0)
      if (X.default !== null)
        B = X.default;
      else
        return;
    var Q = null, ee = !1;
    if (X.any)
      te = this._createEncoderBuffer(B);
    else if (X.choice)
      te = this._encodeChoice(B, H);
    else if (X.contains)
      Q = this._getUse(X.contains, V)._encode(B, H), ee = !0;
    else if (X.children)
      Q = X.children.map(function(ce) {
        if (ce._baseState.tag === "null_")
          return ce._encode(null, H, B);
        if (ce._baseState.key === null)
          return H.error("Child should have a key");
        var pe = H.enterKey(ce._baseState.key);
        if (typeof B != "object")
          return H.error("Child expected, but input is not object");
        var me = ce._encode(B[ce._baseState.key], H, B);
        return H.leaveKey(pe), me;
      }, this).filter(function(ce) {
        return ce;
      }), Q = this._createEncoderBuffer(Q);
    else if (X.tag === "seqof" || X.tag === "setof") {
      if (!(X.args && X.args.length === 1))
        return H.error("Too many args for : " + X.tag);
      if (!Array.isArray(B))
        return H.error("seqof/setof, but data is not Array");
      var ie = this.clone();
      ie._baseState.implicit = null, Q = this._createEncoderBuffer(B.map(function(ce) {
        var pe = this._baseState;
        return this._getUse(pe.args[0], B)._encode(ce, H);
      }, ie));
    } else
      X.use !== null ? te = this._getUse(X.use, V)._encode(B, H) : (Q = this._encodePrimitive(X.tag, B), ee = !0);
    var te;
    if (!X.any && X.choice === null) {
      var se = X.implicit !== null ? X.implicit : X.tag, le = X.implicit === null ? "universal" : "context";
      se === null ? X.use === null && H.error("Tag could be omitted only for .use()") : X.use === null && (te = this._encodeComposite(se, ee, le, Q));
    }
    return X.explicit !== null && (te = this._encodeComposite(X.explicit, !1, "context", te)), te;
  }, A.prototype._encodeChoice = function(B, H) {
    var V = this._baseState, X = V.choice[B.type];
    return X || g(
      !1,
      B.type + " not found in " + JSON.stringify(Object.keys(V.choice))
    ), X._encode(B.value, H);
  }, A.prototype._encodePrimitive = function(B, H) {
    var V = this._baseState;
    if (/str$/.test(B))
      return this._encodeStr(H, B);
    if (B === "objid" && V.args)
      return this._encodeObjid(H, V.reverseArgs[0], V.args[1]);
    if (B === "objid")
      return this._encodeObjid(H, null, null);
    if (B === "gentime" || B === "utctime")
      return this._encodeTime(H, B);
    if (B === "null_")
      return this._encodeNull();
    if (B === "int" || B === "enum")
      return this._encodeInt(H, V.args && V.reverseArgs[0]);
    if (B === "bool")
      return this._encodeBool(H);
    if (B === "objDesc")
      return this._encodeStr(H, B);
    throw new Error("Unsupported tag: " + B);
  }, A.prototype._isNumstr = function(B) {
    return /^[0-9 ]*$/.test(B);
  }, A.prototype._isPrintstr = function(B) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(B);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(e) {
    var o = e;
    o.Reporter = requireReporter().Reporter, o.DecoderBuffer = requireBuffer().DecoderBuffer, o.EncoderBuffer = requireBuffer().EncoderBuffer, o.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(e) {
    var o = requireConstants();
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = o._reverse(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = o._reverse(e.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(e) {
    var o = e;
    o._reverse = function(g) {
      var U = {};
      return Object.keys(g).forEach(function(h) {
        (h | 0) == h && (h = h | 0);
        var q = g[h];
        U[q] = h;
      }), U;
    }, o.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1)
    return der_1$1;
  hasRequiredDer$1 = 1;
  var e = requireInherits_browser(), o = requireAsn1$1(), S = o.base, g = o.bignum, U = o.constants.der;
  function h(I) {
    this.enc = "der", this.name = I.name, this.entity = I, this.tree = new q(), this.tree._init(I.body);
  }
  der_1$1 = h, h.prototype.decode = function(B, H) {
    return B instanceof S.DecoderBuffer || (B = new S.DecoderBuffer(B, H)), this.tree._decode(B, H);
  };
  function q(I) {
    S.Node.call(this, "der", I);
  }
  e(q, S.Node), q.prototype._peekTag = function(B, H, V) {
    if (B.isEmpty())
      return !1;
    var X = B.save(), Q = A(B, 'Failed to peek tag: "' + H + '"');
    return B.isError(Q) ? Q : (B.restore(X), Q.tag === H || Q.tagStr === H || Q.tagStr + "of" === H || V);
  }, q.prototype._decodeTag = function(B, H, V) {
    var X = A(
      B,
      'Failed to decode tag of "' + H + '"'
    );
    if (B.isError(X))
      return X;
    var Q = P(
      B,
      X.primitive,
      'Failed to get length of "' + H + '"'
    );
    if (B.isError(Q))
      return Q;
    if (!V && X.tag !== H && X.tagStr !== H && X.tagStr + "of" !== H)
      return B.error('Failed to match tag: "' + H + '"');
    if (X.primitive || Q !== null)
      return B.skip(Q, 'Failed to match body of: "' + H + '"');
    var ee = B.save(), ie = this._skipUntilEnd(
      B,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return B.isError(ie) ? ie : (Q = B.offset - ee.offset, B.restore(ee), B.skip(Q, 'Failed to match body of: "' + H + '"'));
  }, q.prototype._skipUntilEnd = function(B, H) {
    for (; ; ) {
      var V = A(B, H);
      if (B.isError(V))
        return V;
      var X = P(B, V.primitive, H);
      if (B.isError(X))
        return X;
      var Q;
      if (V.primitive || X !== null ? Q = B.skip(X) : Q = this._skipUntilEnd(B, H), B.isError(Q))
        return Q;
      if (V.tagStr === "end")
        break;
    }
  }, q.prototype._decodeList = function(B, H, V, X) {
    for (var Q = []; !B.isEmpty(); ) {
      var ee = this._peekTag(B, "end");
      if (B.isError(ee))
        return ee;
      var ie = V.decode(B, "der", X);
      if (B.isError(ie) && ee)
        break;
      Q.push(ie);
    }
    return Q;
  }, q.prototype._decodeStr = function(B, H) {
    if (H === "bitstr") {
      var V = B.readUInt8();
      return B.isError(V) ? V : { unused: V, data: B.raw() };
    } else if (H === "bmpstr") {
      var X = B.raw();
      if (X.length % 2 === 1)
        return B.error("Decoding of string type: bmpstr length mismatch");
      for (var Q = "", ee = 0; ee < X.length / 2; ee++)
        Q += String.fromCharCode(X.readUInt16BE(ee * 2));
      return Q;
    } else if (H === "numstr") {
      var ie = B.raw().toString("ascii");
      return this._isNumstr(ie) ? ie : B.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (H === "octstr")
        return B.raw();
      if (H === "objDesc")
        return B.raw();
      if (H === "printstr") {
        var te = B.raw().toString("ascii");
        return this._isPrintstr(te) ? te : B.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(H) ? B.raw().toString() : B.error("Decoding of string type: " + H + " unsupported");
    }
  }, q.prototype._decodeObjid = function(B, H, V) {
    for (var X, Q = [], ee = 0; !B.isEmpty(); ) {
      var ie = B.readUInt8();
      ee <<= 7, ee |= ie & 127, ie & 128 || (Q.push(ee), ee = 0);
    }
    ie & 128 && Q.push(ee);
    var te = Q[0] / 40 | 0, se = Q[0] % 40;
    if (V ? X = Q : X = [te, se].concat(Q.slice(1)), H) {
      var le = H[X.join(" ")];
      le === void 0 && (le = H[X.join(".")]), le !== void 0 && (X = le);
    }
    return X;
  }, q.prototype._decodeTime = function(B, H) {
    var V = B.raw().toString();
    if (H === "gentime")
      var X = V.slice(0, 4) | 0, Q = V.slice(4, 6) | 0, ee = V.slice(6, 8) | 0, ie = V.slice(8, 10) | 0, te = V.slice(10, 12) | 0, se = V.slice(12, 14) | 0;
    else if (H === "utctime") {
      var X = V.slice(0, 2) | 0, Q = V.slice(2, 4) | 0, ee = V.slice(4, 6) | 0, ie = V.slice(6, 8) | 0, te = V.slice(8, 10) | 0, se = V.slice(10, 12) | 0;
      X < 70 ? X = 2e3 + X : X = 1900 + X;
    } else
      return B.error("Decoding " + H + " time is not supported yet");
    return Date.UTC(X, Q - 1, ee, ie, te, se, 0);
  }, q.prototype._decodeNull = function(B) {
    return null;
  }, q.prototype._decodeBool = function(B) {
    var H = B.readUInt8();
    return B.isError(H) ? H : H !== 0;
  }, q.prototype._decodeInt = function(B, H) {
    var V = B.raw(), X = new g(V);
    return H && (X = H[X.toString(10)] || X), X;
  }, q.prototype._use = function(B, H) {
    return typeof B == "function" && (B = B(H)), B._getDecoder("der").tree;
  };
  function A(I, B) {
    var H = I.readUInt8(B);
    if (I.isError(H))
      return H;
    var V = U.tagClass[H >> 6], X = (H & 32) === 0;
    if ((H & 31) === 31) {
      var Q = H;
      for (H = 0; (Q & 128) === 128; ) {
        if (Q = I.readUInt8(B), I.isError(Q))
          return Q;
        H <<= 7, H |= Q & 127;
      }
    } else
      H &= 31;
    var ee = U.tag[H];
    return {
      cls: V,
      primitive: X,
      tag: H,
      tagStr: ee
    };
  }
  function P(I, B, H) {
    var V = I.readUInt8(H);
    if (I.isError(V))
      return V;
    if (!B && V === 128)
      return null;
    if (!(V & 128))
      return V;
    var X = V & 127;
    if (X > 4)
      return I.error("length octect is too long");
    V = 0;
    for (var Q = 0; Q < X; Q++) {
      V <<= 8;
      var ee = I.readUInt8(H);
      if (I.isError(ee))
        return ee;
      V |= ee;
    }
    return V;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1)
    return pem$1;
  hasRequiredPem$1 = 1;
  var e = requireInherits_browser(), o = buffer$3.Buffer, S = requireDer$1();
  function g(U) {
    S.call(this, U), this.enc = "pem";
  }
  return e(g, S), pem$1 = g, g.prototype.decode = function(h, q) {
    for (var A = h.toString().split(/[\r\n]+/g), P = q.label.toUpperCase(), I = /^-----(BEGIN|END) ([^-]+)-----$/, B = -1, H = -1, V = 0; V < A.length; V++) {
      var X = A[V].match(I);
      if (X !== null && X[2] === P)
        if (B === -1) {
          if (X[1] !== "BEGIN")
            break;
          B = V;
        } else {
          if (X[1] !== "END")
            break;
          H = V;
          break;
        }
    }
    if (B === -1 || H === -1)
      throw new Error("PEM section not found for: " + P);
    var Q = A.slice(B + 1, H).join("");
    Q.replace(/[^a-z0-9\+\/=]+/gi, "");
    var ee = new o(Q, "base64");
    return S.prototype.decode.call(this, ee, q);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(e) {
    var o = e;
    o.der = requireDer$1(), o.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer)
    return der_1;
  hasRequiredDer = 1;
  var e = requireInherits_browser(), o = buffer$3.Buffer, S = requireAsn1$1(), g = S.base, U = S.constants.der;
  function h(I) {
    this.enc = "der", this.name = I.name, this.entity = I, this.tree = new q(), this.tree._init(I.body);
  }
  der_1 = h, h.prototype.encode = function(B, H) {
    return this.tree._encode(B, H).join();
  };
  function q(I) {
    g.Node.call(this, "der", I);
  }
  e(q, g.Node), q.prototype._encodeComposite = function(B, H, V, X) {
    var Q = P(B, H, V, this.reporter);
    if (X.length < 128) {
      var te = new o(2);
      return te[0] = Q, te[1] = X.length, this._createEncoderBuffer([te, X]);
    }
    for (var ee = 1, ie = X.length; ie >= 256; ie >>= 8)
      ee++;
    var te = new o(2 + ee);
    te[0] = Q, te[1] = 128 | ee;
    for (var ie = 1 + ee, se = X.length; se > 0; ie--, se >>= 8)
      te[ie] = se & 255;
    return this._createEncoderBuffer([te, X]);
  }, q.prototype._encodeStr = function(B, H) {
    if (H === "bitstr")
      return this._createEncoderBuffer([B.unused | 0, B.data]);
    if (H === "bmpstr") {
      for (var V = new o(B.length * 2), X = 0; X < B.length; X++)
        V.writeUInt16BE(B.charCodeAt(X), X * 2);
      return this._createEncoderBuffer(V);
    } else
      return H === "numstr" ? this._isNumstr(B) ? this._createEncoderBuffer(B) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : H === "printstr" ? this._isPrintstr(B) ? this._createEncoderBuffer(B) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(H) ? this._createEncoderBuffer(B) : H === "objDesc" ? this._createEncoderBuffer(B) : this.reporter.error("Encoding of string type: " + H + " unsupported");
  }, q.prototype._encodeObjid = function(B, H, V) {
    if (typeof B == "string") {
      if (!H)
        return this.reporter.error("string objid given, but no values map found");
      if (!H.hasOwnProperty(B))
        return this.reporter.error("objid not found in values map");
      B = H[B].split(/[\s\.]+/g);
      for (var X = 0; X < B.length; X++)
        B[X] |= 0;
    } else if (Array.isArray(B)) {
      B = B.slice();
      for (var X = 0; X < B.length; X++)
        B[X] |= 0;
    }
    if (!Array.isArray(B))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(B));
    if (!V) {
      if (B[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      B.splice(0, 2, B[0] * 40 + B[1]);
    }
    for (var Q = 0, X = 0; X < B.length; X++) {
      var ee = B[X];
      for (Q++; ee >= 128; ee >>= 7)
        Q++;
    }
    for (var ie = new o(Q), te = ie.length - 1, X = B.length - 1; X >= 0; X--) {
      var ee = B[X];
      for (ie[te--] = ee & 127; (ee >>= 7) > 0; )
        ie[te--] = 128 | ee & 127;
    }
    return this._createEncoderBuffer(ie);
  };
  function A(I) {
    return I < 10 ? "0" + I : I;
  }
  q.prototype._encodeTime = function(B, H) {
    var V, X = new Date(B);
    return H === "gentime" ? V = [
      A(X.getFullYear()),
      A(X.getUTCMonth() + 1),
      A(X.getUTCDate()),
      A(X.getUTCHours()),
      A(X.getUTCMinutes()),
      A(X.getUTCSeconds()),
      "Z"
    ].join("") : H === "utctime" ? V = [
      A(X.getFullYear() % 100),
      A(X.getUTCMonth() + 1),
      A(X.getUTCDate()),
      A(X.getUTCHours()),
      A(X.getUTCMinutes()),
      A(X.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + H + " time is not supported yet"), this._encodeStr(V, "octstr");
  }, q.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, q.prototype._encodeInt = function(B, H) {
    if (typeof B == "string") {
      if (!H)
        return this.reporter.error("String int or enum given, but no values map");
      if (!H.hasOwnProperty(B))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(B));
      B = H[B];
    }
    if (typeof B != "number" && !o.isBuffer(B)) {
      var V = B.toArray();
      !B.sign && V[0] & 128 && V.unshift(0), B = new o(V);
    }
    if (o.isBuffer(B)) {
      var X = B.length;
      B.length === 0 && X++;
      var ee = new o(X);
      return B.copy(ee), B.length === 0 && (ee[0] = 0), this._createEncoderBuffer(ee);
    }
    if (B < 128)
      return this._createEncoderBuffer(B);
    if (B < 256)
      return this._createEncoderBuffer([0, B]);
    for (var X = 1, Q = B; Q >= 256; Q >>= 8)
      X++;
    for (var ee = new Array(X), Q = ee.length - 1; Q >= 0; Q--)
      ee[Q] = B & 255, B >>= 8;
    return ee[0] & 128 && ee.unshift(0), this._createEncoderBuffer(new o(ee));
  }, q.prototype._encodeBool = function(B) {
    return this._createEncoderBuffer(B ? 255 : 0);
  }, q.prototype._use = function(B, H) {
    return typeof B == "function" && (B = B(H)), B._getEncoder("der").tree;
  }, q.prototype._skipDefault = function(B, H, V) {
    var X = this._baseState, Q;
    if (X.default === null)
      return !1;
    var ee = B.join();
    if (X.defaultBuffer === void 0 && (X.defaultBuffer = this._encodeValue(X.default, H, V).join()), ee.length !== X.defaultBuffer.length)
      return !1;
    for (Q = 0; Q < ee.length; Q++)
      if (ee[Q] !== X.defaultBuffer[Q])
        return !1;
    return !0;
  };
  function P(I, B, H, V) {
    var X;
    if (I === "seqof" ? I = "seq" : I === "setof" && (I = "set"), U.tagByName.hasOwnProperty(I))
      X = U.tagByName[I];
    else if (typeof I == "number" && (I | 0) === I)
      X = I;
    else
      return V.error("Unknown tag: " + I);
    return X >= 31 ? V.error("Multi-octet tag encoding unsupported") : (B || (X |= 32), X |= U.tagClassByName[H || "universal"] << 6, X);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem)
    return pem;
  hasRequiredPem = 1;
  var e = requireInherits_browser(), o = requireDer();
  function S(g) {
    o.call(this, g), this.enc = "pem";
  }
  return e(S, o), pem = S, S.prototype.encode = function(U, h) {
    for (var q = o.prototype.encode.call(this, U), A = q.toString("base64"), P = ["-----BEGIN " + h.label + "-----"], I = 0; I < A.length; I += 64)
      P.push(A.slice(I, I + 64));
    return P.push("-----END " + h.label + "-----"), P.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(e) {
    var o = e;
    o.der = requireDer(), o.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(e) {
    var o = e;
    o.bignum = bnExports, o.define = requireApi().define, o.base = requireBase(), o.constants = requireConstants(), o.decoders = requireDecoders(), o.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate)
    return certificate;
  hasRequiredCertificate = 1;
  var e = requireAsn1$1(), o = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), S = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), g = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), U = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(g),
      this.key("subjectPublicKey").bitstr()
    );
  }), h = e.define("RelativeDistinguishedName", function() {
    this.setof(S);
  }), q = e.define("RDNSequence", function() {
    this.seqof(h);
  }), A = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(q)
    });
  }), P = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(o),
      this.key("notAfter").use(o)
    );
  }), I = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), B = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(g),
      this.key("issuer").use(A),
      this.key("validity").use(P),
      this.key("subject").use(A),
      this.key("subjectPublicKeyInfo").use(U),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(I).optional()
    );
  }), H = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(B),
      this.key("signatureAlgorithm").use(g),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = H, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1)
    return asn1$1;
  hasRequiredAsn1 = 1;
  var e = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var o = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = o;
  var S = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = S;
  var g = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), U = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(g),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = U;
  var h = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(g),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = h;
  var q = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = q;
  var A = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = A, asn1$1.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var P = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), I = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(P),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = I, asn1$1.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc)
    return fixProc;
  hasRequiredFixProc = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, S = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, g = requireEvp_bytestokey(), U = requireBrowser$6(), h = requireSafeBuffer$1().Buffer;
  return fixProc = function(q, A) {
    var P = q.toString(), I = P.match(e), B;
    if (I) {
      var V = "aes" + I[1], X = h.from(I[2], "hex"), Q = h.from(I[3].replace(/[\r\n]/g, ""), "base64"), ee = g(A, X.slice(0, 8), parseInt(I[1], 10)).key, ie = [], te = U.createDecipheriv(V, ee, X);
      ie.push(te.update(Q)), ie.push(te.final()), B = h.concat(ie);
    } else {
      var H = P.match(S);
      B = h.from(H[2].replace(/[\r\n]/g, ""), "base64");
    }
    var se = P.match(o)[1];
    return {
      tag: se,
      data: B
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1)
    return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var e = requireAsn1(), o = require$$1, S = requireFixProc(), g = requireBrowser$6(), U = requireBrowser$7(), h = requireSafeBuffer$1().Buffer;
  function q(P, I) {
    var B = P.algorithm.decrypt.kde.kdeparams.salt, H = parseInt(P.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), V = o[P.algorithm.decrypt.cipher.algo.join(".")], X = P.algorithm.decrypt.cipher.iv, Q = P.subjectPrivateKey, ee = parseInt(V.split("-")[1], 10) / 8, ie = U.pbkdf2Sync(I, B, H, ee, "sha1"), te = g.createDecipheriv(V, ie, X), se = [];
    return se.push(te.update(Q)), se.push(te.final()), h.concat(se);
  }
  function A(P) {
    var I;
    typeof P == "object" && !h.isBuffer(P) && (I = P.passphrase, P = P.key), typeof P == "string" && (P = h.from(P));
    var B = S(P, I), H = B.tag, V = B.data, X, Q;
    switch (H) {
      case "CERTIFICATE":
        Q = e.certificate.decode(V, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (Q || (Q = e.PublicKey.decode(V, "der")), X = Q.algorithm.algorithm.join("."), X) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(Q.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return Q.subjectPrivateKey = Q.subjectPublicKey, {
              type: "ec",
              data: Q
            };
          case "1.2.840.10040.4.1":
            return Q.algorithm.params.pub_key = e.DSAparam.decode(Q.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: Q.algorithm.params
            };
          default:
            throw new Error("unknown key id " + X);
        }
      case "ENCRYPTED PRIVATE KEY":
        V = e.EncryptedPrivateKey.decode(V, "der"), V = q(V, I);
      case "PRIVATE KEY":
        switch (Q = e.PrivateKey.decode(V, "der"), X = Q.algorithm.algorithm.join("."), X) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(Q.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: Q.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(Q.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return Q.algorithm.params.priv_key = e.DSAparam.decode(Q.subjectPrivateKey, "der"), {
              type: "dsa",
              params: Q.algorithm.params
            };
          default:
            throw new Error("unknown key id " + X);
        }
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(V, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(V, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(V, "der")
        };
      case "EC PRIVATE KEY":
        return V = e.ECPrivateKey.decode(V, "der"), {
          curve: V.parameters.value,
          privateKey: V.privateKey
        };
      default:
        throw new Error("unknown key type " + H);
    }
  }
  return A.signature = e.signature, parseAsn1 = A, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign$1.exports;
  hasRequiredSign = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireBrowser$8(), S = requireBrowserifyRsa(), g = requireElliptic().ec, U = requireBn(), h = requireParseAsn1(), q = require$$4, A = 1;
  function P(te, se, le, ce, pe) {
    var me = h(se);
    if (me.curve) {
      if (ce !== "ecdsa" && ce !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return I(te, me);
    } else if (me.type === "dsa") {
      if (ce !== "dsa")
        throw new Error("wrong private key type");
      return B(te, me, le);
    }
    if (ce !== "rsa" && ce !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (se.padding !== void 0 && se.padding !== A)
      throw new Error("illegal or unsupported padding mode");
    te = e.concat([pe, te]);
    for (var Me = me.modulus.byteLength(), Ee = [0, 1]; te.length + Ee.length + 1 < Me; )
      Ee.push(255);
    Ee.push(0);
    for (var Re = -1; ++Re < te.length; )
      Ee.push(te[Re]);
    var Ne = S(Ee, me);
    return Ne;
  }
  function I(te, se) {
    var le = q[se.curve.join(".")];
    if (!le)
      throw new Error("unknown curve " + se.curve.join("."));
    var ce = new g(le), pe = ce.keyFromPrivate(se.privateKey), me = pe.sign(te);
    return e.from(me.toDER());
  }
  function B(te, se, le) {
    for (var ce = se.params.priv_key, pe = se.params.p, me = se.params.q, Me = se.params.g, Ee = new U(0), Re, Ne = X(te, me).mod(me), ne = !1, Y = V(ce, me, te, le); ne === !1; )
      Re = ee(me, Y, le), Ee = ie(Me, Re, pe, me), ne = Re.invm(me).imul(Ne.add(ce.mul(Ee))).mod(me), ne.cmpn(0) === 0 && (ne = !1, Ee = new U(0));
    return H(Ee, ne);
  }
  function H(te, se) {
    te = te.toArray(), se = se.toArray(), te[0] & 128 && (te = [0].concat(te)), se[0] & 128 && (se = [0].concat(se));
    var le = te.length + se.length + 4, ce = [
      48,
      le,
      2,
      te.length
    ];
    return ce = ce.concat(te, [2, se.length], se), e.from(ce);
  }
  function V(te, se, le, ce) {
    if (te = e.from(te.toArray()), te.length < se.byteLength()) {
      var pe = e.alloc(se.byteLength() - te.length);
      te = e.concat([pe, te]);
    }
    var me = le.length, Me = Q(le, se), Ee = e.alloc(me);
    Ee.fill(1);
    var Re = e.alloc(me);
    return Re = o(ce, Re).update(Ee).update(e.from([0])).update(te).update(Me).digest(), Ee = o(ce, Re).update(Ee).digest(), Re = o(ce, Re).update(Ee).update(e.from([1])).update(te).update(Me).digest(), Ee = o(ce, Re).update(Ee).digest(), { k: Re, v: Ee };
  }
  function X(te, se) {
    var le = new U(te), ce = (te.length << 3) - se.bitLength();
    return ce > 0 && le.ishrn(ce), le;
  }
  function Q(te, se) {
    te = X(te, se), te = te.mod(se);
    var le = e.from(te.toArray());
    if (le.length < se.byteLength()) {
      var ce = e.alloc(se.byteLength() - le.length);
      le = e.concat([ce, le]);
    }
    return le;
  }
  function ee(te, se, le) {
    var ce, pe;
    do {
      for (ce = e.alloc(0); ce.length * 8 < te.bitLength(); )
        se.v = o(le, se.k).update(se.v).digest(), ce = e.concat([ce, se.v]);
      pe = X(ce, te), se.k = o(le, se.k).update(se.v).update(e.from([0])).digest(), se.v = o(le, se.k).update(se.v).digest();
    } while (pe.cmp(te) !== -1);
    return pe;
  }
  function ie(te, se, le, ce) {
    return te.toRed(U.mont(le)).redPow(se).fromRed().mod(ce);
  }
  return sign$1.exports = P, sign$1.exports.getKey = V, sign$1.exports.makeKey = ee, sign$1.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireBn(), S = requireElliptic().ec, g = requireParseAsn1(), U = require$$4;
  function h(I, B, H, V, X) {
    var Q = g(H);
    if (Q.type === "ec") {
      if (V !== "ecdsa" && V !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return q(I, B, Q);
    } else if (Q.type === "dsa") {
      if (V !== "dsa")
        throw new Error("wrong public key type");
      return A(I, B, Q);
    }
    if (V !== "rsa" && V !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    B = e.concat([X, B]);
    for (var ee = Q.modulus.byteLength(), ie = [1], te = 0; B.length + ie.length + 2 < ee; )
      ie.push(255), te += 1;
    ie.push(0);
    for (var se = -1; ++se < B.length; )
      ie.push(B[se]);
    ie = e.from(ie);
    var le = o.mont(Q.modulus);
    I = new o(I).toRed(le), I = I.redPow(new o(Q.publicExponent)), I = e.from(I.fromRed().toArray());
    var ce = te < 8 ? 1 : 0;
    for (ee = Math.min(I.length, ie.length), I.length !== ie.length && (ce = 1), se = -1; ++se < ee; )
      ce |= I[se] ^ ie[se];
    return ce === 0;
  }
  function q(I, B, H) {
    var V = U[H.data.algorithm.curve.join(".")];
    if (!V)
      throw new Error("unknown curve " + H.data.algorithm.curve.join("."));
    var X = new S(V), Q = H.data.subjectPrivateKey.data;
    return X.verify(B, I, Q);
  }
  function A(I, B, H) {
    var V = H.data.p, X = H.data.q, Q = H.data.g, ee = H.data.pub_key, ie = g.signature.decode(I, "der"), te = ie.s, se = ie.r;
    P(te, X), P(se, X);
    var le = o.mont(V), ce = te.invm(X), pe = Q.toRed(le).redPow(new o(B).mul(ce).mod(X)).fromRed().mul(ee.toRed(le).redPow(se.mul(ce).mod(X)).fromRed()).mod(V).mod(X);
    return pe.cmp(se) === 0;
  }
  function P(I, B) {
    if (I.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (I.cmp(B) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = h, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3)
    return browser$3;
  hasRequiredBrowser$3 = 1;
  var e = requireSafeBuffer$1().Buffer, o = requireBrowser$9(), S = requireReadableBrowser(), g = requireInherits_browser(), U = requireSign(), h = requireVerify(), q = require$$6;
  Object.keys(q).forEach(function(H) {
    q[H].id = e.from(q[H].id, "hex"), q[H.toLowerCase()] = q[H];
  });
  function A(H) {
    S.Writable.call(this);
    var V = q[H];
    if (!V)
      throw new Error("Unknown message digest");
    this._hashType = V.hash, this._hash = o(V.hash), this._tag = V.id, this._signType = V.sign;
  }
  g(A, S.Writable), A.prototype._write = function(V, X, Q) {
    this._hash.update(V), Q();
  }, A.prototype.update = function(V, X) {
    return this._hash.update(typeof V == "string" ? e.from(V, X) : V), this;
  }, A.prototype.sign = function(V, X) {
    this.end();
    var Q = this._hash.digest(), ee = U(Q, V, this._hashType, this._signType, this._tag);
    return X ? ee.toString(X) : ee;
  };
  function P(H) {
    S.Writable.call(this);
    var V = q[H];
    if (!V)
      throw new Error("Unknown message digest");
    this._hash = o(V.hash), this._tag = V.id, this._signType = V.sign;
  }
  g(P, S.Writable), P.prototype._write = function(V, X, Q) {
    this._hash.update(V), Q();
  }, P.prototype.update = function(V, X) {
    return this._hash.update(typeof V == "string" ? e.from(V, X) : V), this;
  }, P.prototype.verify = function(V, X, Q) {
    var ee = typeof X == "string" ? e.from(X, Q) : X;
    this.end();
    var ie = this._hash.digest();
    return h(ee, ie, V, this._signType, this._tag);
  };
  function I(H) {
    return new A(H);
  }
  function B(H) {
    return new P(H);
  }
  return browser$3 = {
    Sign: I,
    Verify: B,
    createSign: I,
    createVerify: B
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$2;
  hasRequiredBrowser$2 = 1;
  var e = requireElliptic(), o = bnExports;
  browser$2 = function(q) {
    return new g(q);
  };
  var S = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  S.p224 = S.secp224r1, S.p256 = S.secp256r1 = S.prime256v1, S.p192 = S.secp192r1 = S.prime192v1, S.p384 = S.secp384r1, S.p521 = S.secp521r1;
  function g(h) {
    this.curveType = S[h], this.curveType || (this.curveType = {
      name: h
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  g.prototype.generateKeys = function(h, q) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(h, q);
  }, g.prototype.computeSecret = function(h, q, A) {
    q = q || "utf8", buffer$3.Buffer.isBuffer(h) || (h = new buffer$3.Buffer(h, q));
    var P = this.curve.keyFromPublic(h).getPublic(), I = P.mul(this.keys.getPrivate()).getX();
    return U(I, A, this.curveType.byteLength);
  }, g.prototype.getPublicKey = function(h, q) {
    var A = this.keys.getPublic(q === "compressed", !0);
    return q === "hybrid" && (A[A.length - 1] % 2 ? A[0] = 7 : A[0] = 6), U(A, h);
  }, g.prototype.getPrivateKey = function(h) {
    return U(this.keys.getPrivate(), h);
  }, g.prototype.setPublicKey = function(h, q) {
    return q = q || "utf8", buffer$3.Buffer.isBuffer(h) || (h = new buffer$3.Buffer(h, q)), this.keys._importPublic(h), this;
  }, g.prototype.setPrivateKey = function(h, q) {
    q = q || "utf8", buffer$3.Buffer.isBuffer(h) || (h = new buffer$3.Buffer(h, q));
    var A = new o(h);
    return A = A.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(A), this;
  };
  function U(h, q, A) {
    Array.isArray(h) || (h = h.toArray());
    var P = new buffer$3.Buffer(h);
    if (A && P.length < A) {
      var I = new buffer$3.Buffer(A - P.length);
      I.fill(0), P = buffer$3.Buffer.concat([I, P]);
    }
    return q ? P.toString(q) : P;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf)
    return mgf;
  hasRequiredMgf = 1;
  var e = requireBrowser$9(), o = requireSafeBuffer$1().Buffer;
  mgf = function(g, U) {
    for (var h = o.alloc(0), q = 0, A; h.length < U; )
      A = S(q++), h = o.concat([h, e("sha1").update(g).update(A).digest()]);
    return h.slice(0, U);
  };
  function S(g) {
    var U = o.allocUnsafe(4);
    return U.writeUInt32BE(g, 0), U;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(o, S) {
    for (var g = o.length, U = -1; ++U < g; )
      o[U] ^= S[U];
    return o;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic)
    return withPublic_1;
  hasRequiredWithPublic = 1;
  var e = bnExports, o = requireSafeBuffer$1().Buffer;
  function S(g, U) {
    return o.from(g.toRed(e.mont(U.modulus)).redPow(new e(U.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = S, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt)
    return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var e = requireParseAsn1(), o = requireBrowser$a(), S = requireBrowser$9(), g = requireMgf(), U = requireXor(), h = bnExports, q = requireWithPublic(), A = requireBrowserifyRsa(), P = requireSafeBuffer$1().Buffer;
  publicEncrypt = function(X, Q, ee) {
    var ie;
    X.padding ? ie = X.padding : ee ? ie = 1 : ie = 4;
    var te = e(X), se;
    if (ie === 4)
      se = I(te, Q);
    else if (ie === 1)
      se = B(te, Q, ee);
    else if (ie === 3) {
      if (se = new h(Q), se.cmp(te.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return ee ? A(se, te) : q(se, te);
  };
  function I(V, X) {
    var Q = V.modulus.byteLength(), ee = X.length, ie = S("sha1").update(P.alloc(0)).digest(), te = ie.length, se = 2 * te;
    if (ee > Q - se - 2)
      throw new Error("message too long");
    var le = P.alloc(Q - ee - se - 2), ce = Q - te - 1, pe = o(te), me = U(P.concat([ie, le, P.alloc(1, 1), X], ce), g(pe, ce)), Me = U(pe, g(me, te));
    return new h(P.concat([P.alloc(1), Me, me], Q));
  }
  function B(V, X, Q) {
    var ee = X.length, ie = V.modulus.byteLength();
    if (ee > ie - 11)
      throw new Error("message too long");
    var te;
    return Q ? te = P.alloc(ie - ee - 3, 255) : te = H(ie - ee - 3), new h(P.concat([P.from([0, Q ? 1 : 2]), te, P.alloc(1), X], ie));
  }
  function H(V) {
    for (var X = P.allocUnsafe(V), Q = 0, ee = o(V * 2), ie = 0, te; Q < V; )
      ie === ee.length && (ee = o(V * 2), ie = 0), te = ee[ie++], te && (X[Q++] = te);
    return X;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt)
    return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var e = requireParseAsn1(), o = requireMgf(), S = requireXor(), g = bnExports, U = requireBrowserifyRsa(), h = requireBrowser$9(), q = requireWithPublic(), A = requireSafeBuffer$1().Buffer;
  privateDecrypt = function(V, X, Q) {
    var ee;
    V.padding ? ee = V.padding : Q ? ee = 1 : ee = 4;
    var ie = e(V), te = ie.modulus.byteLength();
    if (X.length > te || new g(X).cmp(ie.modulus) >= 0)
      throw new Error("decryption error");
    var se;
    Q ? se = q(new g(X), ie) : se = U(X, ie);
    var le = A.alloc(te - se.length);
    if (se = A.concat([le, se], te), ee === 4)
      return P(ie, se);
    if (ee === 1)
      return I(ie, se, Q);
    if (ee === 3)
      return se;
    throw new Error("unknown padding");
  };
  function P(H, V) {
    var X = H.modulus.byteLength(), Q = h("sha1").update(A.alloc(0)).digest(), ee = Q.length;
    if (V[0] !== 0)
      throw new Error("decryption error");
    var ie = V.slice(1, ee + 1), te = V.slice(ee + 1), se = S(ie, o(te, ee)), le = S(te, o(se, X - ee - 1));
    if (B(Q, le.slice(0, ee)))
      throw new Error("decryption error");
    for (var ce = ee; le[ce] === 0; )
      ce++;
    if (le[ce++] !== 1)
      throw new Error("decryption error");
    return le.slice(ce);
  }
  function I(H, V, X) {
    for (var Q = V.slice(0, 2), ee = 2, ie = 0; V[ee++] !== 0; )
      if (ee >= V.length) {
        ie++;
        break;
      }
    var te = V.slice(2, ee - 1);
    if ((Q.toString("hex") !== "0002" && !X || Q.toString("hex") !== "0001" && X) && ie++, te.length < 8 && ie++, ie)
      throw new Error("decryption error");
    return V.slice(ee);
  }
  function B(H, V) {
    H = A.from(H), V = A.from(V);
    var X = 0, Q = H.length;
    H.length !== V.length && (X++, Q = Math.min(H.length, V.length));
    for (var ee = -1; ++ee < Q; )
      X += H[ee] ^ V[ee];
    return X;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(e) {
    e.publicEncrypt = requirePublicEncrypt(), e.privateDecrypt = requirePrivateDecrypt(), e.privateEncrypt = function(S, g) {
      return e.publicEncrypt(S, g, !0);
    }, e.publicDecrypt = function(S, g) {
      return e.privateDecrypt(S, g, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var o = requireSafeBuffer$1(), S = requireBrowser$a(), g = o.Buffer, U = o.kMaxLength, h = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto, q = Math.pow(2, 32) - 1;
  function A(V, X) {
    if (typeof V != "number" || V !== V)
      throw new TypeError("offset must be a number");
    if (V > q || V < 0)
      throw new TypeError("offset must be a uint32");
    if (V > U || V > X)
      throw new RangeError("offset out of range");
  }
  function P(V, X, Q) {
    if (typeof V != "number" || V !== V)
      throw new TypeError("size must be a number");
    if (V > q || V < 0)
      throw new TypeError("size must be a uint32");
    if (V + X > Q || V > U)
      throw new RangeError("buffer too small");
  }
  h && h.getRandomValues || !process$3.browser ? (browser.randomFill = I, browser.randomFillSync = H) : (browser.randomFill = e, browser.randomFillSync = e);
  function I(V, X, Q, ee) {
    if (!g.isBuffer(V) && !(V instanceof commonjsGlobal$1.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof X == "function")
      ee = X, X = 0, Q = V.length;
    else if (typeof Q == "function")
      ee = Q, Q = V.length - X;
    else if (typeof ee != "function")
      throw new TypeError('"cb" argument must be a function');
    return A(X, V.length), P(Q, X, V.length), B(V, X, Q, ee);
  }
  function B(V, X, Q, ee) {
    if (process$3.browser) {
      var ie = V.buffer, te = new Uint8Array(ie, X, Q);
      if (h.getRandomValues(te), ee) {
        process$3.nextTick(function() {
          ee(null, V);
        });
        return;
      }
      return V;
    }
    if (ee) {
      S(Q, function(le, ce) {
        if (le)
          return ee(le);
        ce.copy(V, X), ee(null, V);
      });
      return;
    }
    var se = S(Q);
    return se.copy(V, X), V;
  }
  function H(V, X, Q) {
    if (typeof X > "u" && (X = 0), !g.isBuffer(V) && !(V instanceof commonjsGlobal$1.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return A(X, V.length), Q === void 0 && (Q = V.length - X), P(Q, X, V.length), B(V, X, Q);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$a(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var e = requireAlgos(), o = Object.keys(e), S = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(o);
  cryptoBrowserify.getHashes = function() {
    return S;
  };
  var g = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = g.pbkdf2, cryptoBrowserify.pbkdf2Sync = g.pbkdf2Sync;
  var U = requireBrowser$5();
  cryptoBrowserify.Cipher = U.Cipher, cryptoBrowserify.createCipher = U.createCipher, cryptoBrowserify.Cipheriv = U.Cipheriv, cryptoBrowserify.createCipheriv = U.createCipheriv, cryptoBrowserify.Decipher = U.Decipher, cryptoBrowserify.createDecipher = U.createDecipher, cryptoBrowserify.Decipheriv = U.Decipheriv, cryptoBrowserify.createDecipheriv = U.createDecipheriv, cryptoBrowserify.getCiphers = U.getCiphers, cryptoBrowserify.listCiphers = U.listCiphers;
  var h = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = h.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = h.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = h.getDiffieHellman, cryptoBrowserify.createDiffieHellman = h.createDiffieHellman, cryptoBrowserify.DiffieHellman = h.DiffieHellman;
  var q = requireBrowser$3();
  cryptoBrowserify.createSign = q.createSign, cryptoBrowserify.Sign = q.Sign, cryptoBrowserify.createVerify = q.createVerify, cryptoBrowserify.Verify = q.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var A = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = A.publicEncrypt, cryptoBrowserify.privateEncrypt = A.privateEncrypt, cryptoBrowserify.publicDecrypt = A.publicDecrypt, cryptoBrowserify.privateDecrypt = A.privateDecrypt;
  var P = requireBrowser();
  return cryptoBrowserify.randomFill = P.randomFill, cryptoBrowserify.randomFillSync = P.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(e) {
  (function(o) {
    var S = function(Ae) {
      var Ce, Oe = new Float64Array(16);
      if (Ae)
        for (Ce = 0; Ce < Ae.length; Ce++)
          Oe[Ce] = Ae[Ce];
      return Oe;
    }, g = function() {
      throw new Error("no PRNG");
    }, U = new Uint8Array(16), h = new Uint8Array(32);
    h[0] = 9;
    var q = S(), A = S([1]), P = S([56129, 1]), I = S([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), B = S([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), H = S([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), V = S([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), X = S([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function Q(Ae, Ce, Oe, we) {
      Ae[Ce] = Oe >> 24 & 255, Ae[Ce + 1] = Oe >> 16 & 255, Ae[Ce + 2] = Oe >> 8 & 255, Ae[Ce + 3] = Oe & 255, Ae[Ce + 4] = we >> 24 & 255, Ae[Ce + 5] = we >> 16 & 255, Ae[Ce + 6] = we >> 8 & 255, Ae[Ce + 7] = we & 255;
    }
    function ee(Ae, Ce, Oe, we, Ue) {
      var Je, Ge = 0;
      for (Je = 0; Je < Ue; Je++)
        Ge |= Ae[Ce + Je] ^ Oe[we + Je];
      return (1 & Ge - 1 >>> 8) - 1;
    }
    function ie(Ae, Ce, Oe, we) {
      return ee(Ae, Ce, Oe, we, 16);
    }
    function te(Ae, Ce, Oe, we) {
      return ee(Ae, Ce, Oe, we, 32);
    }
    function se(Ae, Ce, Oe, we) {
      for (var Ue = we[0] & 255 | (we[1] & 255) << 8 | (we[2] & 255) << 16 | (we[3] & 255) << 24, Je = Oe[0] & 255 | (Oe[1] & 255) << 8 | (Oe[2] & 255) << 16 | (Oe[3] & 255) << 24, Ge = Oe[4] & 255 | (Oe[5] & 255) << 8 | (Oe[6] & 255) << 16 | (Oe[7] & 255) << 24, st = Oe[8] & 255 | (Oe[9] & 255) << 8 | (Oe[10] & 255) << 16 | (Oe[11] & 255) << 24, ct = Oe[12] & 255 | (Oe[13] & 255) << 8 | (Oe[14] & 255) << 16 | (Oe[15] & 255) << 24, bt = we[4] & 255 | (we[5] & 255) << 8 | (we[6] & 255) << 16 | (we[7] & 255) << 24, wt = Ce[0] & 255 | (Ce[1] & 255) << 8 | (Ce[2] & 255) << 16 | (Ce[3] & 255) << 24, zt = Ce[4] & 255 | (Ce[5] & 255) << 8 | (Ce[6] & 255) << 16 | (Ce[7] & 255) << 24, Tt = Ce[8] & 255 | (Ce[9] & 255) << 8 | (Ce[10] & 255) << 16 | (Ce[11] & 255) << 24, Lt = Ce[12] & 255 | (Ce[13] & 255) << 8 | (Ce[14] & 255) << 16 | (Ce[15] & 255) << 24, jt = we[8] & 255 | (we[9] & 255) << 8 | (we[10] & 255) << 16 | (we[11] & 255) << 24, Ht = Oe[16] & 255 | (Oe[17] & 255) << 8 | (Oe[18] & 255) << 16 | (Oe[19] & 255) << 24, Ft = Oe[20] & 255 | (Oe[21] & 255) << 8 | (Oe[22] & 255) << 16 | (Oe[23] & 255) << 24, Nt = Oe[24] & 255 | (Oe[25] & 255) << 8 | (Oe[26] & 255) << 16 | (Oe[27] & 255) << 24, Dt = Oe[28] & 255 | (Oe[29] & 255) << 8 | (Oe[30] & 255) << 16 | (Oe[31] & 255) << 24, Ut = we[12] & 255 | (we[13] & 255) << 8 | (we[14] & 255) << 16 | (we[15] & 255) << 24, kt = Ue, Ot = Je, It = Ge, Pt = st, Ct = ct, Bt = bt, vt = wt, yt = zt, xt = Tt, Et = Lt, Rt = jt, qt = Ht, Wt = Ft, Vt = Nt, Kt = Dt, Gt = Ut, it, Jt = 0; Jt < 20; Jt += 2)
        it = kt + Wt | 0, Ct ^= it << 7 | it >>> 25, it = Ct + kt | 0, xt ^= it << 9 | it >>> 23, it = xt + Ct | 0, Wt ^= it << 13 | it >>> 19, it = Wt + xt | 0, kt ^= it << 18 | it >>> 14, it = Bt + Ot | 0, Et ^= it << 7 | it >>> 25, it = Et + Bt | 0, Vt ^= it << 9 | it >>> 23, it = Vt + Et | 0, Ot ^= it << 13 | it >>> 19, it = Ot + Vt | 0, Bt ^= it << 18 | it >>> 14, it = Rt + vt | 0, Kt ^= it << 7 | it >>> 25, it = Kt + Rt | 0, It ^= it << 9 | it >>> 23, it = It + Kt | 0, vt ^= it << 13 | it >>> 19, it = vt + It | 0, Rt ^= it << 18 | it >>> 14, it = Gt + qt | 0, Pt ^= it << 7 | it >>> 25, it = Pt + Gt | 0, yt ^= it << 9 | it >>> 23, it = yt + Pt | 0, qt ^= it << 13 | it >>> 19, it = qt + yt | 0, Gt ^= it << 18 | it >>> 14, it = kt + Pt | 0, Ot ^= it << 7 | it >>> 25, it = Ot + kt | 0, It ^= it << 9 | it >>> 23, it = It + Ot | 0, Pt ^= it << 13 | it >>> 19, it = Pt + It | 0, kt ^= it << 18 | it >>> 14, it = Bt + Ct | 0, vt ^= it << 7 | it >>> 25, it = vt + Bt | 0, yt ^= it << 9 | it >>> 23, it = yt + vt | 0, Ct ^= it << 13 | it >>> 19, it = Ct + yt | 0, Bt ^= it << 18 | it >>> 14, it = Rt + Et | 0, qt ^= it << 7 | it >>> 25, it = qt + Rt | 0, xt ^= it << 9 | it >>> 23, it = xt + qt | 0, Et ^= it << 13 | it >>> 19, it = Et + xt | 0, Rt ^= it << 18 | it >>> 14, it = Gt + Kt | 0, Wt ^= it << 7 | it >>> 25, it = Wt + Gt | 0, Vt ^= it << 9 | it >>> 23, it = Vt + Wt | 0, Kt ^= it << 13 | it >>> 19, it = Kt + Vt | 0, Gt ^= it << 18 | it >>> 14;
      kt = kt + Ue | 0, Ot = Ot + Je | 0, It = It + Ge | 0, Pt = Pt + st | 0, Ct = Ct + ct | 0, Bt = Bt + bt | 0, vt = vt + wt | 0, yt = yt + zt | 0, xt = xt + Tt | 0, Et = Et + Lt | 0, Rt = Rt + jt | 0, qt = qt + Ht | 0, Wt = Wt + Ft | 0, Vt = Vt + Nt | 0, Kt = Kt + Dt | 0, Gt = Gt + Ut | 0, Ae[0] = kt >>> 0 & 255, Ae[1] = kt >>> 8 & 255, Ae[2] = kt >>> 16 & 255, Ae[3] = kt >>> 24 & 255, Ae[4] = Ot >>> 0 & 255, Ae[5] = Ot >>> 8 & 255, Ae[6] = Ot >>> 16 & 255, Ae[7] = Ot >>> 24 & 255, Ae[8] = It >>> 0 & 255, Ae[9] = It >>> 8 & 255, Ae[10] = It >>> 16 & 255, Ae[11] = It >>> 24 & 255, Ae[12] = Pt >>> 0 & 255, Ae[13] = Pt >>> 8 & 255, Ae[14] = Pt >>> 16 & 255, Ae[15] = Pt >>> 24 & 255, Ae[16] = Ct >>> 0 & 255, Ae[17] = Ct >>> 8 & 255, Ae[18] = Ct >>> 16 & 255, Ae[19] = Ct >>> 24 & 255, Ae[20] = Bt >>> 0 & 255, Ae[21] = Bt >>> 8 & 255, Ae[22] = Bt >>> 16 & 255, Ae[23] = Bt >>> 24 & 255, Ae[24] = vt >>> 0 & 255, Ae[25] = vt >>> 8 & 255, Ae[26] = vt >>> 16 & 255, Ae[27] = vt >>> 24 & 255, Ae[28] = yt >>> 0 & 255, Ae[29] = yt >>> 8 & 255, Ae[30] = yt >>> 16 & 255, Ae[31] = yt >>> 24 & 255, Ae[32] = xt >>> 0 & 255, Ae[33] = xt >>> 8 & 255, Ae[34] = xt >>> 16 & 255, Ae[35] = xt >>> 24 & 255, Ae[36] = Et >>> 0 & 255, Ae[37] = Et >>> 8 & 255, Ae[38] = Et >>> 16 & 255, Ae[39] = Et >>> 24 & 255, Ae[40] = Rt >>> 0 & 255, Ae[41] = Rt >>> 8 & 255, Ae[42] = Rt >>> 16 & 255, Ae[43] = Rt >>> 24 & 255, Ae[44] = qt >>> 0 & 255, Ae[45] = qt >>> 8 & 255, Ae[46] = qt >>> 16 & 255, Ae[47] = qt >>> 24 & 255, Ae[48] = Wt >>> 0 & 255, Ae[49] = Wt >>> 8 & 255, Ae[50] = Wt >>> 16 & 255, Ae[51] = Wt >>> 24 & 255, Ae[52] = Vt >>> 0 & 255, Ae[53] = Vt >>> 8 & 255, Ae[54] = Vt >>> 16 & 255, Ae[55] = Vt >>> 24 & 255, Ae[56] = Kt >>> 0 & 255, Ae[57] = Kt >>> 8 & 255, Ae[58] = Kt >>> 16 & 255, Ae[59] = Kt >>> 24 & 255, Ae[60] = Gt >>> 0 & 255, Ae[61] = Gt >>> 8 & 255, Ae[62] = Gt >>> 16 & 255, Ae[63] = Gt >>> 24 & 255;
    }
    function le(Ae, Ce, Oe, we) {
      for (var Ue = we[0] & 255 | (we[1] & 255) << 8 | (we[2] & 255) << 16 | (we[3] & 255) << 24, Je = Oe[0] & 255 | (Oe[1] & 255) << 8 | (Oe[2] & 255) << 16 | (Oe[3] & 255) << 24, Ge = Oe[4] & 255 | (Oe[5] & 255) << 8 | (Oe[6] & 255) << 16 | (Oe[7] & 255) << 24, st = Oe[8] & 255 | (Oe[9] & 255) << 8 | (Oe[10] & 255) << 16 | (Oe[11] & 255) << 24, ct = Oe[12] & 255 | (Oe[13] & 255) << 8 | (Oe[14] & 255) << 16 | (Oe[15] & 255) << 24, bt = we[4] & 255 | (we[5] & 255) << 8 | (we[6] & 255) << 16 | (we[7] & 255) << 24, wt = Ce[0] & 255 | (Ce[1] & 255) << 8 | (Ce[2] & 255) << 16 | (Ce[3] & 255) << 24, zt = Ce[4] & 255 | (Ce[5] & 255) << 8 | (Ce[6] & 255) << 16 | (Ce[7] & 255) << 24, Tt = Ce[8] & 255 | (Ce[9] & 255) << 8 | (Ce[10] & 255) << 16 | (Ce[11] & 255) << 24, Lt = Ce[12] & 255 | (Ce[13] & 255) << 8 | (Ce[14] & 255) << 16 | (Ce[15] & 255) << 24, jt = we[8] & 255 | (we[9] & 255) << 8 | (we[10] & 255) << 16 | (we[11] & 255) << 24, Ht = Oe[16] & 255 | (Oe[17] & 255) << 8 | (Oe[18] & 255) << 16 | (Oe[19] & 255) << 24, Ft = Oe[20] & 255 | (Oe[21] & 255) << 8 | (Oe[22] & 255) << 16 | (Oe[23] & 255) << 24, Nt = Oe[24] & 255 | (Oe[25] & 255) << 8 | (Oe[26] & 255) << 16 | (Oe[27] & 255) << 24, Dt = Oe[28] & 255 | (Oe[29] & 255) << 8 | (Oe[30] & 255) << 16 | (Oe[31] & 255) << 24, Ut = we[12] & 255 | (we[13] & 255) << 8 | (we[14] & 255) << 16 | (we[15] & 255) << 24, kt = Ue, Ot = Je, It = Ge, Pt = st, Ct = ct, Bt = bt, vt = wt, yt = zt, xt = Tt, Et = Lt, Rt = jt, qt = Ht, Wt = Ft, Vt = Nt, Kt = Dt, Gt = Ut, it, Jt = 0; Jt < 20; Jt += 2)
        it = kt + Wt | 0, Ct ^= it << 7 | it >>> 25, it = Ct + kt | 0, xt ^= it << 9 | it >>> 23, it = xt + Ct | 0, Wt ^= it << 13 | it >>> 19, it = Wt + xt | 0, kt ^= it << 18 | it >>> 14, it = Bt + Ot | 0, Et ^= it << 7 | it >>> 25, it = Et + Bt | 0, Vt ^= it << 9 | it >>> 23, it = Vt + Et | 0, Ot ^= it << 13 | it >>> 19, it = Ot + Vt | 0, Bt ^= it << 18 | it >>> 14, it = Rt + vt | 0, Kt ^= it << 7 | it >>> 25, it = Kt + Rt | 0, It ^= it << 9 | it >>> 23, it = It + Kt | 0, vt ^= it << 13 | it >>> 19, it = vt + It | 0, Rt ^= it << 18 | it >>> 14, it = Gt + qt | 0, Pt ^= it << 7 | it >>> 25, it = Pt + Gt | 0, yt ^= it << 9 | it >>> 23, it = yt + Pt | 0, qt ^= it << 13 | it >>> 19, it = qt + yt | 0, Gt ^= it << 18 | it >>> 14, it = kt + Pt | 0, Ot ^= it << 7 | it >>> 25, it = Ot + kt | 0, It ^= it << 9 | it >>> 23, it = It + Ot | 0, Pt ^= it << 13 | it >>> 19, it = Pt + It | 0, kt ^= it << 18 | it >>> 14, it = Bt + Ct | 0, vt ^= it << 7 | it >>> 25, it = vt + Bt | 0, yt ^= it << 9 | it >>> 23, it = yt + vt | 0, Ct ^= it << 13 | it >>> 19, it = Ct + yt | 0, Bt ^= it << 18 | it >>> 14, it = Rt + Et | 0, qt ^= it << 7 | it >>> 25, it = qt + Rt | 0, xt ^= it << 9 | it >>> 23, it = xt + qt | 0, Et ^= it << 13 | it >>> 19, it = Et + xt | 0, Rt ^= it << 18 | it >>> 14, it = Gt + Kt | 0, Wt ^= it << 7 | it >>> 25, it = Wt + Gt | 0, Vt ^= it << 9 | it >>> 23, it = Vt + Wt | 0, Kt ^= it << 13 | it >>> 19, it = Kt + Vt | 0, Gt ^= it << 18 | it >>> 14;
      Ae[0] = kt >>> 0 & 255, Ae[1] = kt >>> 8 & 255, Ae[2] = kt >>> 16 & 255, Ae[3] = kt >>> 24 & 255, Ae[4] = Bt >>> 0 & 255, Ae[5] = Bt >>> 8 & 255, Ae[6] = Bt >>> 16 & 255, Ae[7] = Bt >>> 24 & 255, Ae[8] = Rt >>> 0 & 255, Ae[9] = Rt >>> 8 & 255, Ae[10] = Rt >>> 16 & 255, Ae[11] = Rt >>> 24 & 255, Ae[12] = Gt >>> 0 & 255, Ae[13] = Gt >>> 8 & 255, Ae[14] = Gt >>> 16 & 255, Ae[15] = Gt >>> 24 & 255, Ae[16] = vt >>> 0 & 255, Ae[17] = vt >>> 8 & 255, Ae[18] = vt >>> 16 & 255, Ae[19] = vt >>> 24 & 255, Ae[20] = yt >>> 0 & 255, Ae[21] = yt >>> 8 & 255, Ae[22] = yt >>> 16 & 255, Ae[23] = yt >>> 24 & 255, Ae[24] = xt >>> 0 & 255, Ae[25] = xt >>> 8 & 255, Ae[26] = xt >>> 16 & 255, Ae[27] = xt >>> 24 & 255, Ae[28] = Et >>> 0 & 255, Ae[29] = Et >>> 8 & 255, Ae[30] = Et >>> 16 & 255, Ae[31] = Et >>> 24 & 255;
    }
    function ce(Ae, Ce, Oe, we) {
      se(Ae, Ce, Oe, we);
    }
    function pe(Ae, Ce, Oe, we) {
      le(Ae, Ce, Oe, we);
    }
    var me = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Me(Ae, Ce, Oe, we, Ue, Je, Ge) {
      var st = new Uint8Array(16), ct = new Uint8Array(64), bt, wt;
      for (wt = 0; wt < 16; wt++)
        st[wt] = 0;
      for (wt = 0; wt < 8; wt++)
        st[wt] = Je[wt];
      for (; Ue >= 64; ) {
        for (ce(ct, st, Ge, me), wt = 0; wt < 64; wt++)
          Ae[Ce + wt] = Oe[we + wt] ^ ct[wt];
        for (bt = 1, wt = 8; wt < 16; wt++)
          bt = bt + (st[wt] & 255) | 0, st[wt] = bt & 255, bt >>>= 8;
        Ue -= 64, Ce += 64, we += 64;
      }
      if (Ue > 0)
        for (ce(ct, st, Ge, me), wt = 0; wt < Ue; wt++)
          Ae[Ce + wt] = Oe[we + wt] ^ ct[wt];
      return 0;
    }
    function Ee(Ae, Ce, Oe, we, Ue) {
      var Je = new Uint8Array(16), Ge = new Uint8Array(64), st, ct;
      for (ct = 0; ct < 16; ct++)
        Je[ct] = 0;
      for (ct = 0; ct < 8; ct++)
        Je[ct] = we[ct];
      for (; Oe >= 64; ) {
        for (ce(Ge, Je, Ue, me), ct = 0; ct < 64; ct++)
          Ae[Ce + ct] = Ge[ct];
        for (st = 1, ct = 8; ct < 16; ct++)
          st = st + (Je[ct] & 255) | 0, Je[ct] = st & 255, st >>>= 8;
        Oe -= 64, Ce += 64;
      }
      if (Oe > 0)
        for (ce(Ge, Je, Ue, me), ct = 0; ct < Oe; ct++)
          Ae[Ce + ct] = Ge[ct];
      return 0;
    }
    function Re(Ae, Ce, Oe, we, Ue) {
      var Je = new Uint8Array(32);
      pe(Je, we, Ue, me);
      for (var Ge = new Uint8Array(8), st = 0; st < 8; st++)
        Ge[st] = we[st + 16];
      return Ee(Ae, Ce, Oe, Ge, Je);
    }
    function Ne(Ae, Ce, Oe, we, Ue, Je, Ge) {
      var st = new Uint8Array(32);
      pe(st, Je, Ge, me);
      for (var ct = new Uint8Array(8), bt = 0; bt < 8; bt++)
        ct[bt] = Je[bt + 16];
      return Me(Ae, Ce, Oe, we, Ue, ct, st);
    }
    var ne = function(Ae) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var Ce, Oe, we, Ue, Je, Ge, st, ct;
      Ce = Ae[0] & 255 | (Ae[1] & 255) << 8, this.r[0] = Ce & 8191, Oe = Ae[2] & 255 | (Ae[3] & 255) << 8, this.r[1] = (Ce >>> 13 | Oe << 3) & 8191, we = Ae[4] & 255 | (Ae[5] & 255) << 8, this.r[2] = (Oe >>> 10 | we << 6) & 7939, Ue = Ae[6] & 255 | (Ae[7] & 255) << 8, this.r[3] = (we >>> 7 | Ue << 9) & 8191, Je = Ae[8] & 255 | (Ae[9] & 255) << 8, this.r[4] = (Ue >>> 4 | Je << 12) & 255, this.r[5] = Je >>> 1 & 8190, Ge = Ae[10] & 255 | (Ae[11] & 255) << 8, this.r[6] = (Je >>> 14 | Ge << 2) & 8191, st = Ae[12] & 255 | (Ae[13] & 255) << 8, this.r[7] = (Ge >>> 11 | st << 5) & 8065, ct = Ae[14] & 255 | (Ae[15] & 255) << 8, this.r[8] = (st >>> 8 | ct << 8) & 8191, this.r[9] = ct >>> 5 & 127, this.pad[0] = Ae[16] & 255 | (Ae[17] & 255) << 8, this.pad[1] = Ae[18] & 255 | (Ae[19] & 255) << 8, this.pad[2] = Ae[20] & 255 | (Ae[21] & 255) << 8, this.pad[3] = Ae[22] & 255 | (Ae[23] & 255) << 8, this.pad[4] = Ae[24] & 255 | (Ae[25] & 255) << 8, this.pad[5] = Ae[26] & 255 | (Ae[27] & 255) << 8, this.pad[6] = Ae[28] & 255 | (Ae[29] & 255) << 8, this.pad[7] = Ae[30] & 255 | (Ae[31] & 255) << 8;
    };
    ne.prototype.blocks = function(Ae, Ce, Oe) {
      for (var we = this.fin ? 0 : 2048, Ue, Je, Ge, st, ct, bt, wt, zt, Tt, Lt, jt, Ht, Ft, Nt, Dt, Ut, kt, Ot, It, Pt = this.h[0], Ct = this.h[1], Bt = this.h[2], vt = this.h[3], yt = this.h[4], xt = this.h[5], Et = this.h[6], Rt = this.h[7], qt = this.h[8], Wt = this.h[9], Vt = this.r[0], Kt = this.r[1], Gt = this.r[2], it = this.r[3], Jt = this.r[4], Qt = this.r[5], er = this.r[6], Zt = this.r[7], Xt = this.r[8], Yt = this.r[9]; Oe >= 16; )
        Ue = Ae[Ce + 0] & 255 | (Ae[Ce + 1] & 255) << 8, Pt += Ue & 8191, Je = Ae[Ce + 2] & 255 | (Ae[Ce + 3] & 255) << 8, Ct += (Ue >>> 13 | Je << 3) & 8191, Ge = Ae[Ce + 4] & 255 | (Ae[Ce + 5] & 255) << 8, Bt += (Je >>> 10 | Ge << 6) & 8191, st = Ae[Ce + 6] & 255 | (Ae[Ce + 7] & 255) << 8, vt += (Ge >>> 7 | st << 9) & 8191, ct = Ae[Ce + 8] & 255 | (Ae[Ce + 9] & 255) << 8, yt += (st >>> 4 | ct << 12) & 8191, xt += ct >>> 1 & 8191, bt = Ae[Ce + 10] & 255 | (Ae[Ce + 11] & 255) << 8, Et += (ct >>> 14 | bt << 2) & 8191, wt = Ae[Ce + 12] & 255 | (Ae[Ce + 13] & 255) << 8, Rt += (bt >>> 11 | wt << 5) & 8191, zt = Ae[Ce + 14] & 255 | (Ae[Ce + 15] & 255) << 8, qt += (wt >>> 8 | zt << 8) & 8191, Wt += zt >>> 5 | we, Tt = 0, Lt = Tt, Lt += Pt * Vt, Lt += Ct * (5 * Yt), Lt += Bt * (5 * Xt), Lt += vt * (5 * Zt), Lt += yt * (5 * er), Tt = Lt >>> 13, Lt &= 8191, Lt += xt * (5 * Qt), Lt += Et * (5 * Jt), Lt += Rt * (5 * it), Lt += qt * (5 * Gt), Lt += Wt * (5 * Kt), Tt += Lt >>> 13, Lt &= 8191, jt = Tt, jt += Pt * Kt, jt += Ct * Vt, jt += Bt * (5 * Yt), jt += vt * (5 * Xt), jt += yt * (5 * Zt), Tt = jt >>> 13, jt &= 8191, jt += xt * (5 * er), jt += Et * (5 * Qt), jt += Rt * (5 * Jt), jt += qt * (5 * it), jt += Wt * (5 * Gt), Tt += jt >>> 13, jt &= 8191, Ht = Tt, Ht += Pt * Gt, Ht += Ct * Kt, Ht += Bt * Vt, Ht += vt * (5 * Yt), Ht += yt * (5 * Xt), Tt = Ht >>> 13, Ht &= 8191, Ht += xt * (5 * Zt), Ht += Et * (5 * er), Ht += Rt * (5 * Qt), Ht += qt * (5 * Jt), Ht += Wt * (5 * it), Tt += Ht >>> 13, Ht &= 8191, Ft = Tt, Ft += Pt * it, Ft += Ct * Gt, Ft += Bt * Kt, Ft += vt * Vt, Ft += yt * (5 * Yt), Tt = Ft >>> 13, Ft &= 8191, Ft += xt * (5 * Xt), Ft += Et * (5 * Zt), Ft += Rt * (5 * er), Ft += qt * (5 * Qt), Ft += Wt * (5 * Jt), Tt += Ft >>> 13, Ft &= 8191, Nt = Tt, Nt += Pt * Jt, Nt += Ct * it, Nt += Bt * Gt, Nt += vt * Kt, Nt += yt * Vt, Tt = Nt >>> 13, Nt &= 8191, Nt += xt * (5 * Yt), Nt += Et * (5 * Xt), Nt += Rt * (5 * Zt), Nt += qt * (5 * er), Nt += Wt * (5 * Qt), Tt += Nt >>> 13, Nt &= 8191, Dt = Tt, Dt += Pt * Qt, Dt += Ct * Jt, Dt += Bt * it, Dt += vt * Gt, Dt += yt * Kt, Tt = Dt >>> 13, Dt &= 8191, Dt += xt * Vt, Dt += Et * (5 * Yt), Dt += Rt * (5 * Xt), Dt += qt * (5 * Zt), Dt += Wt * (5 * er), Tt += Dt >>> 13, Dt &= 8191, Ut = Tt, Ut += Pt * er, Ut += Ct * Qt, Ut += Bt * Jt, Ut += vt * it, Ut += yt * Gt, Tt = Ut >>> 13, Ut &= 8191, Ut += xt * Kt, Ut += Et * Vt, Ut += Rt * (5 * Yt), Ut += qt * (5 * Xt), Ut += Wt * (5 * Zt), Tt += Ut >>> 13, Ut &= 8191, kt = Tt, kt += Pt * Zt, kt += Ct * er, kt += Bt * Qt, kt += vt * Jt, kt += yt * it, Tt = kt >>> 13, kt &= 8191, kt += xt * Gt, kt += Et * Kt, kt += Rt * Vt, kt += qt * (5 * Yt), kt += Wt * (5 * Xt), Tt += kt >>> 13, kt &= 8191, Ot = Tt, Ot += Pt * Xt, Ot += Ct * Zt, Ot += Bt * er, Ot += vt * Qt, Ot += yt * Jt, Tt = Ot >>> 13, Ot &= 8191, Ot += xt * it, Ot += Et * Gt, Ot += Rt * Kt, Ot += qt * Vt, Ot += Wt * (5 * Yt), Tt += Ot >>> 13, Ot &= 8191, It = Tt, It += Pt * Yt, It += Ct * Xt, It += Bt * Zt, It += vt * er, It += yt * Qt, Tt = It >>> 13, It &= 8191, It += xt * Jt, It += Et * it, It += Rt * Gt, It += qt * Kt, It += Wt * Vt, Tt += It >>> 13, It &= 8191, Tt = (Tt << 2) + Tt | 0, Tt = Tt + Lt | 0, Lt = Tt & 8191, Tt = Tt >>> 13, jt += Tt, Pt = Lt, Ct = jt, Bt = Ht, vt = Ft, yt = Nt, xt = Dt, Et = Ut, Rt = kt, qt = Ot, Wt = It, Ce += 16, Oe -= 16;
      this.h[0] = Pt, this.h[1] = Ct, this.h[2] = Bt, this.h[3] = vt, this.h[4] = yt, this.h[5] = xt, this.h[6] = Et, this.h[7] = Rt, this.h[8] = qt, this.h[9] = Wt;
    }, ne.prototype.finish = function(Ae, Ce) {
      var Oe = new Uint16Array(10), we, Ue, Je, Ge;
      if (this.leftover) {
        for (Ge = this.leftover, this.buffer[Ge++] = 1; Ge < 16; Ge++)
          this.buffer[Ge] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (we = this.h[1] >>> 13, this.h[1] &= 8191, Ge = 2; Ge < 10; Ge++)
        this.h[Ge] += we, we = this.h[Ge] >>> 13, this.h[Ge] &= 8191;
      for (this.h[0] += we * 5, we = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += we, we = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += we, Oe[0] = this.h[0] + 5, we = Oe[0] >>> 13, Oe[0] &= 8191, Ge = 1; Ge < 10; Ge++)
        Oe[Ge] = this.h[Ge] + we, we = Oe[Ge] >>> 13, Oe[Ge] &= 8191;
      for (Oe[9] -= 8192, Ue = (we ^ 1) - 1, Ge = 0; Ge < 10; Ge++)
        Oe[Ge] &= Ue;
      for (Ue = ~Ue, Ge = 0; Ge < 10; Ge++)
        this.h[Ge] = this.h[Ge] & Ue | Oe[Ge];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Je = this.h[0] + this.pad[0], this.h[0] = Je & 65535, Ge = 1; Ge < 8; Ge++)
        Je = (this.h[Ge] + this.pad[Ge] | 0) + (Je >>> 16) | 0, this.h[Ge] = Je & 65535;
      Ae[Ce + 0] = this.h[0] >>> 0 & 255, Ae[Ce + 1] = this.h[0] >>> 8 & 255, Ae[Ce + 2] = this.h[1] >>> 0 & 255, Ae[Ce + 3] = this.h[1] >>> 8 & 255, Ae[Ce + 4] = this.h[2] >>> 0 & 255, Ae[Ce + 5] = this.h[2] >>> 8 & 255, Ae[Ce + 6] = this.h[3] >>> 0 & 255, Ae[Ce + 7] = this.h[3] >>> 8 & 255, Ae[Ce + 8] = this.h[4] >>> 0 & 255, Ae[Ce + 9] = this.h[4] >>> 8 & 255, Ae[Ce + 10] = this.h[5] >>> 0 & 255, Ae[Ce + 11] = this.h[5] >>> 8 & 255, Ae[Ce + 12] = this.h[6] >>> 0 & 255, Ae[Ce + 13] = this.h[6] >>> 8 & 255, Ae[Ce + 14] = this.h[7] >>> 0 & 255, Ae[Ce + 15] = this.h[7] >>> 8 & 255;
    }, ne.prototype.update = function(Ae, Ce, Oe) {
      var we, Ue;
      if (this.leftover) {
        for (Ue = 16 - this.leftover, Ue > Oe && (Ue = Oe), we = 0; we < Ue; we++)
          this.buffer[this.leftover + we] = Ae[Ce + we];
        if (Oe -= Ue, Ce += Ue, this.leftover += Ue, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (Oe >= 16 && (Ue = Oe - Oe % 16, this.blocks(Ae, Ce, Ue), Ce += Ue, Oe -= Ue), Oe) {
        for (we = 0; we < Oe; we++)
          this.buffer[this.leftover + we] = Ae[Ce + we];
        this.leftover += Oe;
      }
    };
    function Y(Ae, Ce, Oe, we, Ue, Je) {
      var Ge = new ne(Je);
      return Ge.update(Oe, we, Ue), Ge.finish(Ae, Ce), 0;
    }
    function M(Ae, Ce, Oe, we, Ue, Je) {
      var Ge = new Uint8Array(16);
      return Y(Ge, 0, Oe, we, Ue, Je), ie(Ae, Ce, Ge, 0);
    }
    function $(Ae, Ce, Oe, we, Ue) {
      var Je;
      if (Oe < 32)
        return -1;
      for (Ne(Ae, 0, Ce, 0, Oe, we, Ue), Y(Ae, 16, Ae, 32, Oe - 32, Ae), Je = 0; Je < 16; Je++)
        Ae[Je] = 0;
      return 0;
    }
    function O(Ae, Ce, Oe, we, Ue) {
      var Je, Ge = new Uint8Array(32);
      if (Oe < 32 || (Re(Ge, 0, 32, we, Ue), M(Ce, 16, Ce, 32, Oe - 32, Ge) !== 0))
        return -1;
      for (Ne(Ae, 0, Ce, 0, Oe, we, Ue), Je = 0; Je < 32; Je++)
        Ae[Je] = 0;
      return 0;
    }
    function J(Ae, Ce) {
      var Oe;
      for (Oe = 0; Oe < 16; Oe++)
        Ae[Oe] = Ce[Oe] | 0;
    }
    function Z(Ae) {
      var Ce, Oe, we = 1;
      for (Ce = 0; Ce < 16; Ce++)
        Oe = Ae[Ce] + we + 65535, we = Math.floor(Oe / 65536), Ae[Ce] = Oe - we * 65536;
      Ae[0] += we - 1 + 37 * (we - 1);
    }
    function K(Ae, Ce, Oe) {
      for (var we, Ue = ~(Oe - 1), Je = 0; Je < 16; Je++)
        we = Ue & (Ae[Je] ^ Ce[Je]), Ae[Je] ^= we, Ce[Je] ^= we;
    }
    function z(Ae, Ce) {
      var Oe, we, Ue, Je = S(), Ge = S();
      for (Oe = 0; Oe < 16; Oe++)
        Ge[Oe] = Ce[Oe];
      for (Z(Ge), Z(Ge), Z(Ge), we = 0; we < 2; we++) {
        for (Je[0] = Ge[0] - 65517, Oe = 1; Oe < 15; Oe++)
          Je[Oe] = Ge[Oe] - 65535 - (Je[Oe - 1] >> 16 & 1), Je[Oe - 1] &= 65535;
        Je[15] = Ge[15] - 32767 - (Je[14] >> 16 & 1), Ue = Je[15] >> 16 & 1, Je[14] &= 65535, K(Ge, Je, 1 - Ue);
      }
      for (Oe = 0; Oe < 16; Oe++)
        Ae[2 * Oe] = Ge[Oe] & 255, Ae[2 * Oe + 1] = Ge[Oe] >> 8;
    }
    function G(Ae, Ce) {
      var Oe = new Uint8Array(32), we = new Uint8Array(32);
      return z(Oe, Ae), z(we, Ce), te(Oe, 0, we, 0);
    }
    function D(Ae) {
      var Ce = new Uint8Array(32);
      return z(Ce, Ae), Ce[0] & 1;
    }
    function F(Ae, Ce) {
      var Oe;
      for (Oe = 0; Oe < 16; Oe++)
        Ae[Oe] = Ce[2 * Oe] + (Ce[2 * Oe + 1] << 8);
      Ae[15] &= 32767;
    }
    function ae(Ae, Ce, Oe) {
      for (var we = 0; we < 16; we++)
        Ae[we] = Ce[we] + Oe[we];
    }
    function ge(Ae, Ce, Oe) {
      for (var we = 0; we < 16; we++)
        Ae[we] = Ce[we] - Oe[we];
    }
    function xe(Ae, Ce, Oe) {
      var we, Ue, Je = 0, Ge = 0, st = 0, ct = 0, bt = 0, wt = 0, zt = 0, Tt = 0, Lt = 0, jt = 0, Ht = 0, Ft = 0, Nt = 0, Dt = 0, Ut = 0, kt = 0, Ot = 0, It = 0, Pt = 0, Ct = 0, Bt = 0, vt = 0, yt = 0, xt = 0, Et = 0, Rt = 0, qt = 0, Wt = 0, Vt = 0, Kt = 0, Gt = 0, it = Oe[0], Jt = Oe[1], Qt = Oe[2], er = Oe[3], Zt = Oe[4], Xt = Oe[5], Yt = Oe[6], ar = Oe[7], tr = Oe[8], rr = Oe[9], ir = Oe[10], nr = Oe[11], sr = Oe[12], or = Oe[13], fr = Oe[14], ur = Oe[15];
      we = Ce[0], Je += we * it, Ge += we * Jt, st += we * Qt, ct += we * er, bt += we * Zt, wt += we * Xt, zt += we * Yt, Tt += we * ar, Lt += we * tr, jt += we * rr, Ht += we * ir, Ft += we * nr, Nt += we * sr, Dt += we * or, Ut += we * fr, kt += we * ur, we = Ce[1], Ge += we * it, st += we * Jt, ct += we * Qt, bt += we * er, wt += we * Zt, zt += we * Xt, Tt += we * Yt, Lt += we * ar, jt += we * tr, Ht += we * rr, Ft += we * ir, Nt += we * nr, Dt += we * sr, Ut += we * or, kt += we * fr, Ot += we * ur, we = Ce[2], st += we * it, ct += we * Jt, bt += we * Qt, wt += we * er, zt += we * Zt, Tt += we * Xt, Lt += we * Yt, jt += we * ar, Ht += we * tr, Ft += we * rr, Nt += we * ir, Dt += we * nr, Ut += we * sr, kt += we * or, Ot += we * fr, It += we * ur, we = Ce[3], ct += we * it, bt += we * Jt, wt += we * Qt, zt += we * er, Tt += we * Zt, Lt += we * Xt, jt += we * Yt, Ht += we * ar, Ft += we * tr, Nt += we * rr, Dt += we * ir, Ut += we * nr, kt += we * sr, Ot += we * or, It += we * fr, Pt += we * ur, we = Ce[4], bt += we * it, wt += we * Jt, zt += we * Qt, Tt += we * er, Lt += we * Zt, jt += we * Xt, Ht += we * Yt, Ft += we * ar, Nt += we * tr, Dt += we * rr, Ut += we * ir, kt += we * nr, Ot += we * sr, It += we * or, Pt += we * fr, Ct += we * ur, we = Ce[5], wt += we * it, zt += we * Jt, Tt += we * Qt, Lt += we * er, jt += we * Zt, Ht += we * Xt, Ft += we * Yt, Nt += we * ar, Dt += we * tr, Ut += we * rr, kt += we * ir, Ot += we * nr, It += we * sr, Pt += we * or, Ct += we * fr, Bt += we * ur, we = Ce[6], zt += we * it, Tt += we * Jt, Lt += we * Qt, jt += we * er, Ht += we * Zt, Ft += we * Xt, Nt += we * Yt, Dt += we * ar, Ut += we * tr, kt += we * rr, Ot += we * ir, It += we * nr, Pt += we * sr, Ct += we * or, Bt += we * fr, vt += we * ur, we = Ce[7], Tt += we * it, Lt += we * Jt, jt += we * Qt, Ht += we * er, Ft += we * Zt, Nt += we * Xt, Dt += we * Yt, Ut += we * ar, kt += we * tr, Ot += we * rr, It += we * ir, Pt += we * nr, Ct += we * sr, Bt += we * or, vt += we * fr, yt += we * ur, we = Ce[8], Lt += we * it, jt += we * Jt, Ht += we * Qt, Ft += we * er, Nt += we * Zt, Dt += we * Xt, Ut += we * Yt, kt += we * ar, Ot += we * tr, It += we * rr, Pt += we * ir, Ct += we * nr, Bt += we * sr, vt += we * or, yt += we * fr, xt += we * ur, we = Ce[9], jt += we * it, Ht += we * Jt, Ft += we * Qt, Nt += we * er, Dt += we * Zt, Ut += we * Xt, kt += we * Yt, Ot += we * ar, It += we * tr, Pt += we * rr, Ct += we * ir, Bt += we * nr, vt += we * sr, yt += we * or, xt += we * fr, Et += we * ur, we = Ce[10], Ht += we * it, Ft += we * Jt, Nt += we * Qt, Dt += we * er, Ut += we * Zt, kt += we * Xt, Ot += we * Yt, It += we * ar, Pt += we * tr, Ct += we * rr, Bt += we * ir, vt += we * nr, yt += we * sr, xt += we * or, Et += we * fr, Rt += we * ur, we = Ce[11], Ft += we * it, Nt += we * Jt, Dt += we * Qt, Ut += we * er, kt += we * Zt, Ot += we * Xt, It += we * Yt, Pt += we * ar, Ct += we * tr, Bt += we * rr, vt += we * ir, yt += we * nr, xt += we * sr, Et += we * or, Rt += we * fr, qt += we * ur, we = Ce[12], Nt += we * it, Dt += we * Jt, Ut += we * Qt, kt += we * er, Ot += we * Zt, It += we * Xt, Pt += we * Yt, Ct += we * ar, Bt += we * tr, vt += we * rr, yt += we * ir, xt += we * nr, Et += we * sr, Rt += we * or, qt += we * fr, Wt += we * ur, we = Ce[13], Dt += we * it, Ut += we * Jt, kt += we * Qt, Ot += we * er, It += we * Zt, Pt += we * Xt, Ct += we * Yt, Bt += we * ar, vt += we * tr, yt += we * rr, xt += we * ir, Et += we * nr, Rt += we * sr, qt += we * or, Wt += we * fr, Vt += we * ur, we = Ce[14], Ut += we * it, kt += we * Jt, Ot += we * Qt, It += we * er, Pt += we * Zt, Ct += we * Xt, Bt += we * Yt, vt += we * ar, yt += we * tr, xt += we * rr, Et += we * ir, Rt += we * nr, qt += we * sr, Wt += we * or, Vt += we * fr, Kt += we * ur, we = Ce[15], kt += we * it, Ot += we * Jt, It += we * Qt, Pt += we * er, Ct += we * Zt, Bt += we * Xt, vt += we * Yt, yt += we * ar, xt += we * tr, Et += we * rr, Rt += we * ir, qt += we * nr, Wt += we * sr, Vt += we * or, Kt += we * fr, Gt += we * ur, Je += 38 * Ot, Ge += 38 * It, st += 38 * Pt, ct += 38 * Ct, bt += 38 * Bt, wt += 38 * vt, zt += 38 * yt, Tt += 38 * xt, Lt += 38 * Et, jt += 38 * Rt, Ht += 38 * qt, Ft += 38 * Wt, Nt += 38 * Vt, Dt += 38 * Kt, Ut += 38 * Gt, Ue = 1, we = Je + Ue + 65535, Ue = Math.floor(we / 65536), Je = we - Ue * 65536, we = Ge + Ue + 65535, Ue = Math.floor(we / 65536), Ge = we - Ue * 65536, we = st + Ue + 65535, Ue = Math.floor(we / 65536), st = we - Ue * 65536, we = ct + Ue + 65535, Ue = Math.floor(we / 65536), ct = we - Ue * 65536, we = bt + Ue + 65535, Ue = Math.floor(we / 65536), bt = we - Ue * 65536, we = wt + Ue + 65535, Ue = Math.floor(we / 65536), wt = we - Ue * 65536, we = zt + Ue + 65535, Ue = Math.floor(we / 65536), zt = we - Ue * 65536, we = Tt + Ue + 65535, Ue = Math.floor(we / 65536), Tt = we - Ue * 65536, we = Lt + Ue + 65535, Ue = Math.floor(we / 65536), Lt = we - Ue * 65536, we = jt + Ue + 65535, Ue = Math.floor(we / 65536), jt = we - Ue * 65536, we = Ht + Ue + 65535, Ue = Math.floor(we / 65536), Ht = we - Ue * 65536, we = Ft + Ue + 65535, Ue = Math.floor(we / 65536), Ft = we - Ue * 65536, we = Nt + Ue + 65535, Ue = Math.floor(we / 65536), Nt = we - Ue * 65536, we = Dt + Ue + 65535, Ue = Math.floor(we / 65536), Dt = we - Ue * 65536, we = Ut + Ue + 65535, Ue = Math.floor(we / 65536), Ut = we - Ue * 65536, we = kt + Ue + 65535, Ue = Math.floor(we / 65536), kt = we - Ue * 65536, Je += Ue - 1 + 37 * (Ue - 1), Ue = 1, we = Je + Ue + 65535, Ue = Math.floor(we / 65536), Je = we - Ue * 65536, we = Ge + Ue + 65535, Ue = Math.floor(we / 65536), Ge = we - Ue * 65536, we = st + Ue + 65535, Ue = Math.floor(we / 65536), st = we - Ue * 65536, we = ct + Ue + 65535, Ue = Math.floor(we / 65536), ct = we - Ue * 65536, we = bt + Ue + 65535, Ue = Math.floor(we / 65536), bt = we - Ue * 65536, we = wt + Ue + 65535, Ue = Math.floor(we / 65536), wt = we - Ue * 65536, we = zt + Ue + 65535, Ue = Math.floor(we / 65536), zt = we - Ue * 65536, we = Tt + Ue + 65535, Ue = Math.floor(we / 65536), Tt = we - Ue * 65536, we = Lt + Ue + 65535, Ue = Math.floor(we / 65536), Lt = we - Ue * 65536, we = jt + Ue + 65535, Ue = Math.floor(we / 65536), jt = we - Ue * 65536, we = Ht + Ue + 65535, Ue = Math.floor(we / 65536), Ht = we - Ue * 65536, we = Ft + Ue + 65535, Ue = Math.floor(we / 65536), Ft = we - Ue * 65536, we = Nt + Ue + 65535, Ue = Math.floor(we / 65536), Nt = we - Ue * 65536, we = Dt + Ue + 65535, Ue = Math.floor(we / 65536), Dt = we - Ue * 65536, we = Ut + Ue + 65535, Ue = Math.floor(we / 65536), Ut = we - Ue * 65536, we = kt + Ue + 65535, Ue = Math.floor(we / 65536), kt = we - Ue * 65536, Je += Ue - 1 + 37 * (Ue - 1), Ae[0] = Je, Ae[1] = Ge, Ae[2] = st, Ae[3] = ct, Ae[4] = bt, Ae[5] = wt, Ae[6] = zt, Ae[7] = Tt, Ae[8] = Lt, Ae[9] = jt, Ae[10] = Ht, Ae[11] = Ft, Ae[12] = Nt, Ae[13] = Dt, Ae[14] = Ut, Ae[15] = kt;
    }
    function ye(Ae, Ce) {
      xe(Ae, Ce, Ce);
    }
    function oe(Ae, Ce) {
      var Oe = S(), we;
      for (we = 0; we < 16; we++)
        Oe[we] = Ce[we];
      for (we = 253; we >= 0; we--)
        ye(Oe, Oe), we !== 2 && we !== 4 && xe(Oe, Oe, Ce);
      for (we = 0; we < 16; we++)
        Ae[we] = Oe[we];
    }
    function fe(Ae, Ce) {
      var Oe = S(), we;
      for (we = 0; we < 16; we++)
        Oe[we] = Ce[we];
      for (we = 250; we >= 0; we--)
        ye(Oe, Oe), we !== 1 && xe(Oe, Oe, Ce);
      for (we = 0; we < 16; we++)
        Ae[we] = Oe[we];
    }
    function $e(Ae, Ce, Oe) {
      var we = new Uint8Array(32), Ue = new Float64Array(80), Je, Ge, st = S(), ct = S(), bt = S(), wt = S(), zt = S(), Tt = S();
      for (Ge = 0; Ge < 31; Ge++)
        we[Ge] = Ce[Ge];
      for (we[31] = Ce[31] & 127 | 64, we[0] &= 248, F(Ue, Oe), Ge = 0; Ge < 16; Ge++)
        ct[Ge] = Ue[Ge], wt[Ge] = st[Ge] = bt[Ge] = 0;
      for (st[0] = wt[0] = 1, Ge = 254; Ge >= 0; --Ge)
        Je = we[Ge >>> 3] >>> (Ge & 7) & 1, K(st, ct, Je), K(bt, wt, Je), ae(zt, st, bt), ge(st, st, bt), ae(bt, ct, wt), ge(ct, ct, wt), ye(wt, zt), ye(Tt, st), xe(st, bt, st), xe(bt, ct, zt), ae(zt, st, bt), ge(st, st, bt), ye(ct, st), ge(bt, wt, Tt), xe(st, bt, P), ae(st, st, wt), xe(bt, bt, st), xe(st, wt, Tt), xe(wt, ct, Ue), ye(ct, zt), K(st, ct, Je), K(bt, wt, Je);
      for (Ge = 0; Ge < 16; Ge++)
        Ue[Ge + 16] = st[Ge], Ue[Ge + 32] = bt[Ge], Ue[Ge + 48] = ct[Ge], Ue[Ge + 64] = wt[Ge];
      var Lt = Ue.subarray(32), jt = Ue.subarray(16);
      return oe(Lt, Lt), xe(jt, jt, Lt), z(Ae, jt), 0;
    }
    function Be(Ae, Ce) {
      return $e(Ae, Ce, h);
    }
    function be(Ae, Ce) {
      return g(Ce, 32), Be(Ae, Ce);
    }
    function ve(Ae, Ce, Oe) {
      var we = new Uint8Array(32);
      return $e(we, Oe, Ce), pe(Ae, U, we, me);
    }
    var qe = $, De = O;
    function Ye(Ae, Ce, Oe, we, Ue, Je) {
      var Ge = new Uint8Array(32);
      return ve(Ge, Ue, Je), qe(Ae, Ce, Oe, we, Ge);
    }
    function he(Ae, Ce, Oe, we, Ue, Je) {
      var Ge = new Uint8Array(32);
      return ve(Ge, Ue, Je), De(Ae, Ce, Oe, we, Ge);
    }
    var ue = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function de(Ae, Ce, Oe, we) {
      for (var Ue = new Int32Array(16), Je = new Int32Array(16), Ge, st, ct, bt, wt, zt, Tt, Lt, jt, Ht, Ft, Nt, Dt, Ut, kt, Ot, It, Pt, Ct, Bt, vt, yt, xt, Et, Rt, qt, Wt = Ae[0], Vt = Ae[1], Kt = Ae[2], Gt = Ae[3], it = Ae[4], Jt = Ae[5], Qt = Ae[6], er = Ae[7], Zt = Ce[0], Xt = Ce[1], Yt = Ce[2], ar = Ce[3], tr = Ce[4], rr = Ce[5], ir = Ce[6], nr = Ce[7], sr = 0; we >= 128; ) {
        for (Ct = 0; Ct < 16; Ct++)
          Bt = 8 * Ct + sr, Ue[Ct] = Oe[Bt + 0] << 24 | Oe[Bt + 1] << 16 | Oe[Bt + 2] << 8 | Oe[Bt + 3], Je[Ct] = Oe[Bt + 4] << 24 | Oe[Bt + 5] << 16 | Oe[Bt + 6] << 8 | Oe[Bt + 7];
        for (Ct = 0; Ct < 80; Ct++)
          if (Ge = Wt, st = Vt, ct = Kt, bt = Gt, wt = it, zt = Jt, Tt = Qt, Lt = er, jt = Zt, Ht = Xt, Ft = Yt, Nt = ar, Dt = tr, Ut = rr, kt = ir, Ot = nr, vt = er, yt = nr, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = (it >>> 14 | tr << 18) ^ (it >>> 18 | tr << 14) ^ (tr >>> 9 | it << 23), yt = (tr >>> 14 | it << 18) ^ (tr >>> 18 | it << 14) ^ (it >>> 9 | tr << 23), xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, vt = it & Jt ^ ~it & Qt, yt = tr & rr ^ ~tr & ir, xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, vt = ue[Ct * 2], yt = ue[Ct * 2 + 1], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, vt = Ue[Ct % 16], yt = Je[Ct % 16], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, It = Rt & 65535 | qt << 16, Pt = xt & 65535 | Et << 16, vt = It, yt = Pt, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = (Wt >>> 28 | Zt << 4) ^ (Zt >>> 2 | Wt << 30) ^ (Zt >>> 7 | Wt << 25), yt = (Zt >>> 28 | Wt << 4) ^ (Wt >>> 2 | Zt << 30) ^ (Wt >>> 7 | Zt << 25), xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, vt = Wt & Vt ^ Wt & Kt ^ Vt & Kt, yt = Zt & Xt ^ Zt & Yt ^ Xt & Yt, xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Lt = Rt & 65535 | qt << 16, Ot = xt & 65535 | Et << 16, vt = bt, yt = Nt, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = It, yt = Pt, xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, bt = Rt & 65535 | qt << 16, Nt = xt & 65535 | Et << 16, Vt = Ge, Kt = st, Gt = ct, it = bt, Jt = wt, Qt = zt, er = Tt, Wt = Lt, Xt = jt, Yt = Ht, ar = Ft, tr = Nt, rr = Dt, ir = Ut, nr = kt, Zt = Ot, Ct % 16 === 15)
            for (Bt = 0; Bt < 16; Bt++)
              vt = Ue[Bt], yt = Je[Bt], xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ue[(Bt + 9) % 16], yt = Je[(Bt + 9) % 16], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, It = Ue[(Bt + 1) % 16], Pt = Je[(Bt + 1) % 16], vt = (It >>> 1 | Pt << 31) ^ (It >>> 8 | Pt << 24) ^ It >>> 7, yt = (Pt >>> 1 | It << 31) ^ (Pt >>> 8 | It << 24) ^ (Pt >>> 7 | It << 25), xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, It = Ue[(Bt + 14) % 16], Pt = Je[(Bt + 14) % 16], vt = (It >>> 19 | Pt << 13) ^ (Pt >>> 29 | It << 3) ^ It >>> 6, yt = (Pt >>> 19 | It << 13) ^ (It >>> 29 | Pt << 3) ^ (Pt >>> 6 | It << 26), xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ue[Bt] = Rt & 65535 | qt << 16, Je[Bt] = xt & 65535 | Et << 16;
        vt = Wt, yt = Zt, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[0], yt = Ce[0], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[0] = Wt = Rt & 65535 | qt << 16, Ce[0] = Zt = xt & 65535 | Et << 16, vt = Vt, yt = Xt, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[1], yt = Ce[1], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[1] = Vt = Rt & 65535 | qt << 16, Ce[1] = Xt = xt & 65535 | Et << 16, vt = Kt, yt = Yt, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[2], yt = Ce[2], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[2] = Kt = Rt & 65535 | qt << 16, Ce[2] = Yt = xt & 65535 | Et << 16, vt = Gt, yt = ar, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[3], yt = Ce[3], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[3] = Gt = Rt & 65535 | qt << 16, Ce[3] = ar = xt & 65535 | Et << 16, vt = it, yt = tr, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[4], yt = Ce[4], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[4] = it = Rt & 65535 | qt << 16, Ce[4] = tr = xt & 65535 | Et << 16, vt = Jt, yt = rr, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[5], yt = Ce[5], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[5] = Jt = Rt & 65535 | qt << 16, Ce[5] = rr = xt & 65535 | Et << 16, vt = Qt, yt = ir, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[6], yt = Ce[6], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[6] = Qt = Rt & 65535 | qt << 16, Ce[6] = ir = xt & 65535 | Et << 16, vt = er, yt = nr, xt = yt & 65535, Et = yt >>> 16, Rt = vt & 65535, qt = vt >>> 16, vt = Ae[7], yt = Ce[7], xt += yt & 65535, Et += yt >>> 16, Rt += vt & 65535, qt += vt >>> 16, Et += xt >>> 16, Rt += Et >>> 16, qt += Rt >>> 16, Ae[7] = er = Rt & 65535 | qt << 16, Ce[7] = nr = xt & 65535 | Et << 16, sr += 128, we -= 128;
      }
      return we;
    }
    function _e(Ae, Ce, Oe) {
      var we = new Int32Array(8), Ue = new Int32Array(8), Je = new Uint8Array(256), Ge, st = Oe;
      for (we[0] = 1779033703, we[1] = 3144134277, we[2] = 1013904242, we[3] = 2773480762, we[4] = 1359893119, we[5] = 2600822924, we[6] = 528734635, we[7] = 1541459225, Ue[0] = 4089235720, Ue[1] = 2227873595, Ue[2] = 4271175723, Ue[3] = 1595750129, Ue[4] = 2917565137, Ue[5] = 725511199, Ue[6] = 4215389547, Ue[7] = 327033209, de(we, Ue, Ce, Oe), Oe %= 128, Ge = 0; Ge < Oe; Ge++)
        Je[Ge] = Ce[st - Oe + Ge];
      for (Je[Oe] = 128, Oe = 256 - 128 * (Oe < 112 ? 1 : 0), Je[Oe - 9] = 0, Q(Je, Oe - 8, st / 536870912 | 0, st << 3), de(we, Ue, Je, Oe), Ge = 0; Ge < 8; Ge++)
        Q(Ae, 8 * Ge, we[Ge], Ue[Ge]);
      return 0;
    }
    function Pe(Ae, Ce) {
      var Oe = S(), we = S(), Ue = S(), Je = S(), Ge = S(), st = S(), ct = S(), bt = S(), wt = S();
      ge(Oe, Ae[1], Ae[0]), ge(wt, Ce[1], Ce[0]), xe(Oe, Oe, wt), ae(we, Ae[0], Ae[1]), ae(wt, Ce[0], Ce[1]), xe(we, we, wt), xe(Ue, Ae[3], Ce[3]), xe(Ue, Ue, B), xe(Je, Ae[2], Ce[2]), ae(Je, Je, Je), ge(Ge, we, Oe), ge(st, Je, Ue), ae(ct, Je, Ue), ae(bt, we, Oe), xe(Ae[0], Ge, st), xe(Ae[1], bt, ct), xe(Ae[2], ct, st), xe(Ae[3], Ge, bt);
    }
    function He(Ae, Ce, Oe) {
      var we;
      for (we = 0; we < 4; we++)
        K(Ae[we], Ce[we], Oe);
    }
    function Ve(Ae, Ce) {
      var Oe = S(), we = S(), Ue = S();
      oe(Ue, Ce[2]), xe(Oe, Ce[0], Ue), xe(we, Ce[1], Ue), z(Ae, we), Ae[31] ^= D(Oe) << 7;
    }
    function nt(Ae, Ce, Oe) {
      var we, Ue;
      for (J(Ae[0], q), J(Ae[1], A), J(Ae[2], A), J(Ae[3], q), Ue = 255; Ue >= 0; --Ue)
        we = Oe[Ue / 8 | 0] >> (Ue & 7) & 1, He(Ae, Ce, we), Pe(Ce, Ae), Pe(Ae, Ae), He(Ae, Ce, we);
    }
    function Ie(Ae, Ce) {
      var Oe = [S(), S(), S(), S()];
      J(Oe[0], H), J(Oe[1], V), J(Oe[2], A), xe(Oe[3], H, V), nt(Ae, Oe, Ce);
    }
    function Fe(Ae, Ce, Oe) {
      var we = new Uint8Array(64), Ue = [S(), S(), S(), S()], Je;
      for (Oe || g(Ce, 32), _e(we, Ce, 32), we[0] &= 248, we[31] &= 127, we[31] |= 64, Ie(Ue, we), Ve(Ae, Ue), Je = 0; Je < 32; Je++)
        Ce[Je + 32] = Ae[Je];
      return 0;
    }
    var je = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Ke(Ae, Ce) {
      var Oe, we, Ue, Je;
      for (we = 63; we >= 32; --we) {
        for (Oe = 0, Ue = we - 32, Je = we - 12; Ue < Je; ++Ue)
          Ce[Ue] += Oe - 16 * Ce[we] * je[Ue - (we - 32)], Oe = Math.floor((Ce[Ue] + 128) / 256), Ce[Ue] -= Oe * 256;
        Ce[Ue] += Oe, Ce[we] = 0;
      }
      for (Oe = 0, Ue = 0; Ue < 32; Ue++)
        Ce[Ue] += Oe - (Ce[31] >> 4) * je[Ue], Oe = Ce[Ue] >> 8, Ce[Ue] &= 255;
      for (Ue = 0; Ue < 32; Ue++)
        Ce[Ue] -= Oe * je[Ue];
      for (we = 0; we < 32; we++)
        Ce[we + 1] += Ce[we] >> 8, Ae[we] = Ce[we] & 255;
    }
    function ot(Ae) {
      var Ce = new Float64Array(64), Oe;
      for (Oe = 0; Oe < 64; Oe++)
        Ce[Oe] = Ae[Oe];
      for (Oe = 0; Oe < 64; Oe++)
        Ae[Oe] = 0;
      Ke(Ae, Ce);
    }
    function ut(Ae, Ce, Oe, we) {
      var Ue = new Uint8Array(64), Je = new Uint8Array(64), Ge = new Uint8Array(64), st, ct, bt = new Float64Array(64), wt = [S(), S(), S(), S()];
      _e(Ue, we, 32), Ue[0] &= 248, Ue[31] &= 127, Ue[31] |= 64;
      var zt = Oe + 64;
      for (st = 0; st < Oe; st++)
        Ae[64 + st] = Ce[st];
      for (st = 0; st < 32; st++)
        Ae[32 + st] = Ue[32 + st];
      for (_e(Ge, Ae.subarray(32), Oe + 32), ot(Ge), Ie(wt, Ge), Ve(Ae, wt), st = 32; st < 64; st++)
        Ae[st] = we[st];
      for (_e(Je, Ae, Oe + 64), ot(Je), st = 0; st < 64; st++)
        bt[st] = 0;
      for (st = 0; st < 32; st++)
        bt[st] = Ge[st];
      for (st = 0; st < 32; st++)
        for (ct = 0; ct < 32; ct++)
          bt[st + ct] += Je[st] * Ue[ct];
      return Ke(Ae.subarray(32), bt), zt;
    }
    function pt(Ae, Ce) {
      var Oe = S(), we = S(), Ue = S(), Je = S(), Ge = S(), st = S(), ct = S();
      return J(Ae[2], A), F(Ae[1], Ce), ye(Ue, Ae[1]), xe(Je, Ue, I), ge(Ue, Ue, Ae[2]), ae(Je, Ae[2], Je), ye(Ge, Je), ye(st, Ge), xe(ct, st, Ge), xe(Oe, ct, Ue), xe(Oe, Oe, Je), fe(Oe, Oe), xe(Oe, Oe, Ue), xe(Oe, Oe, Je), xe(Oe, Oe, Je), xe(Ae[0], Oe, Je), ye(we, Ae[0]), xe(we, we, Je), G(we, Ue) && xe(Ae[0], Ae[0], X), ye(we, Ae[0]), xe(we, we, Je), G(we, Ue) ? -1 : (D(Ae[0]) === Ce[31] >> 7 && ge(Ae[0], q, Ae[0]), xe(Ae[3], Ae[0], Ae[1]), 0);
    }
    function ke(Ae, Ce, Oe, we) {
      var Ue, Je = new Uint8Array(32), Ge = new Uint8Array(64), st = [S(), S(), S(), S()], ct = [S(), S(), S(), S()];
      if (Oe < 64 || pt(ct, we))
        return -1;
      for (Ue = 0; Ue < Oe; Ue++)
        Ae[Ue] = Ce[Ue];
      for (Ue = 0; Ue < 32; Ue++)
        Ae[Ue + 32] = we[Ue];
      if (_e(Ge, Ae, Oe), ot(Ge), nt(st, ct, Ge), Ie(ct, Ce.subarray(32)), Pe(st, ct), Ve(Je, st), Oe -= 64, te(Ce, 0, Je, 0)) {
        for (Ue = 0; Ue < Oe; Ue++)
          Ae[Ue] = 0;
        return -1;
      }
      for (Ue = 0; Ue < Oe; Ue++)
        Ae[Ue] = Ce[Ue + 64];
      return Oe;
    }
    var Xe = 32, at = 24, ht = 32, We = 16, tt = 32, Te = 32, rt = 32, mt = 32, Se = 32, et = at, Ze = ht, Le = We, ze = 64, Qe = 32, _t = 64, ft = 32, dt = 64;
    o.lowlevel = {
      crypto_core_hsalsa20: pe,
      crypto_stream_xor: Ne,
      crypto_stream: Re,
      crypto_stream_salsa20_xor: Me,
      crypto_stream_salsa20: Ee,
      crypto_onetimeauth: Y,
      crypto_onetimeauth_verify: M,
      crypto_verify_16: ie,
      crypto_verify_32: te,
      crypto_secretbox: $,
      crypto_secretbox_open: O,
      crypto_scalarmult: $e,
      crypto_scalarmult_base: Be,
      crypto_box_beforenm: ve,
      crypto_box_afternm: qe,
      crypto_box: Ye,
      crypto_box_open: he,
      crypto_box_keypair: be,
      crypto_hash: _e,
      crypto_sign: ut,
      crypto_sign_keypair: Fe,
      crypto_sign_open: ke,
      crypto_secretbox_KEYBYTES: Xe,
      crypto_secretbox_NONCEBYTES: at,
      crypto_secretbox_ZEROBYTES: ht,
      crypto_secretbox_BOXZEROBYTES: We,
      crypto_scalarmult_BYTES: tt,
      crypto_scalarmult_SCALARBYTES: Te,
      crypto_box_PUBLICKEYBYTES: rt,
      crypto_box_SECRETKEYBYTES: mt,
      crypto_box_BEFORENMBYTES: Se,
      crypto_box_NONCEBYTES: et,
      crypto_box_ZEROBYTES: Ze,
      crypto_box_BOXZEROBYTES: Le,
      crypto_sign_BYTES: ze,
      crypto_sign_PUBLICKEYBYTES: Qe,
      crypto_sign_SECRETKEYBYTES: _t,
      crypto_sign_SEEDBYTES: ft,
      crypto_hash_BYTES: dt,
      gf: S,
      D: I,
      L: je,
      pack25519: z,
      unpack25519: F,
      M: xe,
      A: ae,
      S: ye,
      Z: ge,
      pow2523: fe,
      add: Pe,
      set25519: J,
      modL: Ke,
      scalarmult: nt,
      scalarbase: Ie
    };
    function Mt(Ae, Ce) {
      if (Ae.length !== Xe)
        throw new Error("bad key size");
      if (Ce.length !== at)
        throw new Error("bad nonce size");
    }
    function St(Ae, Ce) {
      if (Ae.length !== rt)
        throw new Error("bad public key size");
      if (Ce.length !== mt)
        throw new Error("bad secret key size");
    }
    function $t() {
      for (var Ae = 0; Ae < arguments.length; Ae++)
        if (!(arguments[Ae] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function At(Ae) {
      for (var Ce = 0; Ce < Ae.length; Ce++)
        Ae[Ce] = 0;
    }
    o.randomBytes = function(Ae) {
      var Ce = new Uint8Array(Ae);
      return g(Ce, Ae), Ce;
    }, o.secretbox = function(Ae, Ce, Oe) {
      $t(Ae, Ce, Oe), Mt(Oe, Ce);
      for (var we = new Uint8Array(ht + Ae.length), Ue = new Uint8Array(we.length), Je = 0; Je < Ae.length; Je++)
        we[Je + ht] = Ae[Je];
      return $(Ue, we, we.length, Ce, Oe), Ue.subarray(We);
    }, o.secretbox.open = function(Ae, Ce, Oe) {
      $t(Ae, Ce, Oe), Mt(Oe, Ce);
      for (var we = new Uint8Array(We + Ae.length), Ue = new Uint8Array(we.length), Je = 0; Je < Ae.length; Je++)
        we[Je + We] = Ae[Je];
      return we.length < 32 || O(Ue, we, we.length, Ce, Oe) !== 0 ? null : Ue.subarray(ht);
    }, o.secretbox.keyLength = Xe, o.secretbox.nonceLength = at, o.secretbox.overheadLength = We, o.scalarMult = function(Ae, Ce) {
      if ($t(Ae, Ce), Ae.length !== Te)
        throw new Error("bad n size");
      if (Ce.length !== tt)
        throw new Error("bad p size");
      var Oe = new Uint8Array(tt);
      return $e(Oe, Ae, Ce), Oe;
    }, o.scalarMult.base = function(Ae) {
      if ($t(Ae), Ae.length !== Te)
        throw new Error("bad n size");
      var Ce = new Uint8Array(tt);
      return Be(Ce, Ae), Ce;
    }, o.scalarMult.scalarLength = Te, o.scalarMult.groupElementLength = tt, o.box = function(Ae, Ce, Oe, we) {
      var Ue = o.box.before(Oe, we);
      return o.secretbox(Ae, Ce, Ue);
    }, o.box.before = function(Ae, Ce) {
      $t(Ae, Ce), St(Ae, Ce);
      var Oe = new Uint8Array(Se);
      return ve(Oe, Ae, Ce), Oe;
    }, o.box.after = o.secretbox, o.box.open = function(Ae, Ce, Oe, we) {
      var Ue = o.box.before(Oe, we);
      return o.secretbox.open(Ae, Ce, Ue);
    }, o.box.open.after = o.secretbox.open, o.box.keyPair = function() {
      var Ae = new Uint8Array(rt), Ce = new Uint8Array(mt);
      return be(Ae, Ce), { publicKey: Ae, secretKey: Ce };
    }, o.box.keyPair.fromSecretKey = function(Ae) {
      if ($t(Ae), Ae.length !== mt)
        throw new Error("bad secret key size");
      var Ce = new Uint8Array(rt);
      return Be(Ce, Ae), { publicKey: Ce, secretKey: new Uint8Array(Ae) };
    }, o.box.publicKeyLength = rt, o.box.secretKeyLength = mt, o.box.sharedKeyLength = Se, o.box.nonceLength = et, o.box.overheadLength = o.secretbox.overheadLength, o.sign = function(Ae, Ce) {
      if ($t(Ae, Ce), Ce.length !== _t)
        throw new Error("bad secret key size");
      var Oe = new Uint8Array(ze + Ae.length);
      return ut(Oe, Ae, Ae.length, Ce), Oe;
    }, o.sign.open = function(Ae, Ce) {
      if ($t(Ae, Ce), Ce.length !== Qe)
        throw new Error("bad public key size");
      var Oe = new Uint8Array(Ae.length), we = ke(Oe, Ae, Ae.length, Ce);
      if (we < 0)
        return null;
      for (var Ue = new Uint8Array(we), Je = 0; Je < Ue.length; Je++)
        Ue[Je] = Oe[Je];
      return Ue;
    }, o.sign.detached = function(Ae, Ce) {
      for (var Oe = o.sign(Ae, Ce), we = new Uint8Array(ze), Ue = 0; Ue < we.length; Ue++)
        we[Ue] = Oe[Ue];
      return we;
    }, o.sign.detached.verify = function(Ae, Ce, Oe) {
      if ($t(Ae, Ce, Oe), Ce.length !== ze)
        throw new Error("bad signature size");
      if (Oe.length !== Qe)
        throw new Error("bad public key size");
      var we = new Uint8Array(ze + Ae.length), Ue = new Uint8Array(ze + Ae.length), Je;
      for (Je = 0; Je < ze; Je++)
        we[Je] = Ce[Je];
      for (Je = 0; Je < Ae.length; Je++)
        we[Je + ze] = Ae[Je];
      return ke(Ue, we, we.length, Oe) >= 0;
    }, o.sign.keyPair = function() {
      var Ae = new Uint8Array(Qe), Ce = new Uint8Array(_t);
      return Fe(Ae, Ce), { publicKey: Ae, secretKey: Ce };
    }, o.sign.keyPair.fromSecretKey = function(Ae) {
      if ($t(Ae), Ae.length !== _t)
        throw new Error("bad secret key size");
      for (var Ce = new Uint8Array(Qe), Oe = 0; Oe < Ce.length; Oe++)
        Ce[Oe] = Ae[32 + Oe];
      return { publicKey: Ce, secretKey: new Uint8Array(Ae) };
    }, o.sign.keyPair.fromSeed = function(Ae) {
      if ($t(Ae), Ae.length !== ft)
        throw new Error("bad seed size");
      for (var Ce = new Uint8Array(Qe), Oe = new Uint8Array(_t), we = 0; we < 32; we++)
        Oe[we] = Ae[we];
      return Fe(Ce, Oe, !0), { publicKey: Ce, secretKey: Oe };
    }, o.sign.publicKeyLength = Qe, o.sign.secretKeyLength = _t, o.sign.seedLength = ft, o.sign.signatureLength = ze, o.hash = function(Ae) {
      $t(Ae);
      var Ce = new Uint8Array(dt);
      return _e(Ce, Ae, Ae.length), Ce;
    }, o.hash.hashLength = dt, o.verify = function(Ae, Ce) {
      return $t(Ae, Ce), Ae.length === 0 || Ce.length === 0 || Ae.length !== Ce.length ? !1 : ee(Ae, 0, Ce, 0, Ae.length) === 0;
    }, o.setPRNG = function(Ae) {
      g = Ae;
    }, function() {
      var Ae = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (Ae && Ae.getRandomValues) {
        var Ce = 65536;
        o.setPRNG(function(Oe, we) {
          var Ue, Je = new Uint8Array(we);
          for (Ue = 0; Ue < we; Ue += Ce)
            Ae.getRandomValues(Je.subarray(Ue, Ue + Math.min(we - Ue, Ce)));
          for (Ue = 0; Ue < we; Ue++)
            Oe[Ue] = Je[Ue];
          At(Je);
        });
      } else
        typeof commonjsRequire < "u" && (Ae = requireCryptoBrowserify(), Ae && Ae.randomBytes && o.setPRNG(function(Oe, we) {
          var Ue, Je = Ae.randomBytes(we);
          for (Ue = 0; Ue < we; Ue++)
            Oe[Ue] = Je[Ue];
          At(Je);
        }));
    }();
  })(e.exports ? e.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports, naclUtil$1 = { exports: {} };
(function(e) {
  (function(o, S) {
    e.exports ? e.exports = S() : (o.nacl || (o.nacl = {}), o.nacl.util = S());
  })(commonjsGlobal$1, function() {
    var o = {};
    function S(g) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(g))
        throw new TypeError("invalid encoding");
    }
    return o.decodeUTF8 = function(g) {
      if (typeof g != "string")
        throw new TypeError("expected string");
      var U, h = unescape(encodeURIComponent(g)), q = new Uint8Array(h.length);
      for (U = 0; U < h.length; U++)
        q[U] = h.charCodeAt(U);
      return q;
    }, o.encodeUTF8 = function(g) {
      var U, h = [];
      for (U = 0; U < g.length; U++)
        h.push(String.fromCharCode(g[U]));
      return decodeURIComponent(escape(h.join("")));
    }, typeof atob > "u" ? typeof buffer$3.Buffer.from < "u" ? (o.encodeBase64 = function(g) {
      return buffer$3.Buffer.from(g).toString("base64");
    }, o.decodeBase64 = function(g) {
      return S(g), new Uint8Array(Array.prototype.slice.call(buffer$3.Buffer.from(g, "base64"), 0));
    }) : (o.encodeBase64 = function(g) {
      return new buffer$3.Buffer(g).toString("base64");
    }, o.decodeBase64 = function(g) {
      return S(g), new Uint8Array(Array.prototype.slice.call(new buffer$3.Buffer(g, "base64"), 0));
    }) : (o.encodeBase64 = function(g) {
      var U, h = [], q = g.length;
      for (U = 0; U < q; U++)
        h.push(String.fromCharCode(g[U]));
      return btoa(h.join(""));
    }, o.decodeBase64 = function(g) {
      S(g);
      var U, h = atob(g), q = new Uint8Array(h.length);
      for (U = 0; U < h.length; U++)
        q[U] = h.charCodeAt(U);
      return q;
    }), o;
  });
})(naclUtil$1);
var naclUtilExports = naclUtil$1.exports, __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(e, o, S, g) {
  g === void 0 && (g = S);
  var U = Object.getOwnPropertyDescriptor(o, S);
  (!U || ("get" in U ? !o.__esModule : U.writable || U.configurable)) && (U = { enumerable: !0, get: function() {
    return o[S];
  } }), Object.defineProperty(e, g, U);
} : function(e, o, S, g) {
  g === void 0 && (g = S), e[g] = o[S];
}), __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var S in e)
      S !== "default" && Object.prototype.hasOwnProperty.call(e, S) && __createBinding$1(o, e, S);
  return __setModuleDefault$1(o, e), o;
};
Object.defineProperty(encryption, "__esModule", { value: !0 });
encryption.getEncryptionPublicKey = encryption.decryptSafely = encryption.decrypt = encryption.encryptSafely = encryption.encrypt = void 0;
const nacl = __importStar$1(naclFastExports), naclUtil = __importStar$1(naclUtilExports), utils_1 = utils$4;
function encrypt({ publicKey: e, data: o, version: S }) {
  if ((0, utils_1.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, utils_1.isNullish)(o))
    throw new Error("Missing data parameter");
  if ((0, utils_1.isNullish)(S))
    throw new Error("Missing version parameter");
  switch (S) {
    case "x25519-xsalsa20-poly1305": {
      if (typeof o != "string")
        throw new Error("Message data must be given as a string");
      const g = nacl.box.keyPair();
      let U;
      try {
        U = naclUtil.decodeBase64(e);
      } catch {
        throw new Error("Bad public key");
      }
      const h = naclUtil.decodeUTF8(o), q = nacl.randomBytes(nacl.box.nonceLength), A = nacl.box(h, q, U, g.secretKey);
      return {
        version: "x25519-xsalsa20-poly1305",
        nonce: naclUtil.encodeBase64(q),
        ephemPublicKey: naclUtil.encodeBase64(g.publicKey),
        ciphertext: naclUtil.encodeBase64(A)
      };
    }
    default:
      throw new Error("Encryption type/version not supported");
  }
}
encryption.encrypt = encrypt;
function encryptSafely({ publicKey: e, data: o, version: S }) {
  if ((0, utils_1.isNullish)(e))
    throw new Error("Missing publicKey parameter");
  if ((0, utils_1.isNullish)(o))
    throw new Error("Missing data parameter");
  if ((0, utils_1.isNullish)(S))
    throw new Error("Missing version parameter");
  const g = 2 ** 11, U = 16;
  if (typeof o == "object" && o && "toJSON" in o)
    throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
  const h = {
    data: o,
    padding: ""
  }, A = buffer$3.Buffer.byteLength(JSON.stringify(h), "utf-8") % g;
  let P = 0;
  A > 0 && (P = g - A - U), h.padding = "0".repeat(P);
  const I = JSON.stringify(h);
  return encrypt({ publicKey: e, data: I, version: S });
}
encryption.encryptSafely = encryptSafely;
function decrypt({ encryptedData: e, privateKey: o }) {
  if ((0, utils_1.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, utils_1.isNullish)(o))
    throw new Error("Missing privateKey parameter");
  switch (e.version) {
    case "x25519-xsalsa20-poly1305": {
      const S = naclDecodeHex(o), g = nacl.box.keyPair.fromSecretKey(S).secretKey, U = naclUtil.decodeBase64(e.nonce), h = naclUtil.decodeBase64(e.ciphertext), q = naclUtil.decodeBase64(e.ephemPublicKey), A = nacl.box.open(h, U, q, g);
      try {
        if (!A)
          throw new Error();
        const P = naclUtil.encodeUTF8(A);
        if (!P)
          throw new Error();
        return P;
      } catch (P) {
        throw P && typeof P.message == "string" && P.message.length ? new Error(`Decryption failed: ${P.message}`) : new Error("Decryption failed.");
      }
    }
    default:
      throw new Error("Encryption type/version not supported.");
  }
}
encryption.decrypt = decrypt;
function decryptSafely({ encryptedData: e, privateKey: o }) {
  if ((0, utils_1.isNullish)(e))
    throw new Error("Missing encryptedData parameter");
  if ((0, utils_1.isNullish)(o))
    throw new Error("Missing privateKey parameter");
  return JSON.parse(decrypt({ encryptedData: e, privateKey: o })).data;
}
encryption.decryptSafely = decryptSafely;
function getEncryptionPublicKey(e) {
  const o = naclDecodeHex(e), S = nacl.box.keyPair.fromSecretKey(o).publicKey;
  return naclUtil.encodeBase64(S);
}
encryption.getEncryptionPublicKey = getEncryptionPublicKey;
function naclDecodeHex(e) {
  const o = buffer$3.Buffer.from(e, "hex").toString("base64");
  return naclUtil.decodeBase64(o);
}
(function(e) {
  var o = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(U, h, q, A) {
    A === void 0 && (A = q);
    var P = Object.getOwnPropertyDescriptor(h, q);
    (!P || ("get" in P ? !h.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
      return h[q];
    } }), Object.defineProperty(U, A, P);
  } : function(U, h, q, A) {
    A === void 0 && (A = q), U[A] = h[q];
  }), S = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(U, h) {
    for (var q in U)
      q !== "default" && !Object.prototype.hasOwnProperty.call(h, q) && o(h, U, q);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.normalize = e.concatSig = void 0, S(personalSign$1, e), S(signTypedData$1, e), S(encryption, e);
  var g = utils$4;
  Object.defineProperty(e, "concatSig", { enumerable: !0, get: function() {
    return g.concatSig;
  } }), Object.defineProperty(e, "normalize", { enumerable: !0, get: function() {
    return g.normalize;
  } });
})(dist$2);
var __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(e, o, S, g) {
  g === void 0 && (g = S), Object.defineProperty(e, g, { enumerable: !0, get: function() {
    return o[S];
  } });
} : function(e, o, S, g) {
  g === void 0 && (g = S), e[g] = o[S];
}), __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(e, o) {
  Object.defineProperty(e, "default", { enumerable: !0, value: o });
} : function(e, o) {
  e.default = o;
}), __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var o = {};
  if (e != null)
    for (var S in e)
      S !== "default" && Object.prototype.hasOwnProperty.call(e, S) && __createBinding(o, e, S);
  return __setModuleDefault(o, e), o;
};
Object.defineProperty(wallet, "__esModule", { value: !0 });
wallet.createWalletMiddleware = void 0;
const json_rpc_engine_1 = dist$6, sigUtil = __importStar(dist$2), eth_rpc_errors_1 = dist$7;
function createWalletMiddleware({ getAccounts: e, processDecryptMessage: o, processEncryptionPublicKey: S, processEthSignMessage: g, processPersonalMessage: U, processTransaction: h, processSignTransaction: q, processTypedMessage: A, processTypedMessageV3: P, processTypedMessageV4: I }) {
  if (!e)
    throw new Error("opts.getAccounts is required");
  return json_rpc_engine_1.createScaffoldMiddleware({
    // account lookups
    eth_accounts: json_rpc_engine_1.createAsyncMiddleware(B),
    eth_coinbase: json_rpc_engine_1.createAsyncMiddleware(H),
    // tx signatures
    eth_sendTransaction: json_rpc_engine_1.createAsyncMiddleware(V),
    eth_signTransaction: json_rpc_engine_1.createAsyncMiddleware(X),
    // message signatures
    eth_sign: json_rpc_engine_1.createAsyncMiddleware(Q),
    eth_signTypedData: json_rpc_engine_1.createAsyncMiddleware(ee),
    eth_signTypedData_v3: json_rpc_engine_1.createAsyncMiddleware(ie),
    eth_signTypedData_v4: json_rpc_engine_1.createAsyncMiddleware(te),
    personal_sign: json_rpc_engine_1.createAsyncMiddleware(se),
    eth_getEncryptionPublicKey: json_rpc_engine_1.createAsyncMiddleware(ce),
    eth_decrypt: json_rpc_engine_1.createAsyncMiddleware(pe),
    personal_ecRecover: json_rpc_engine_1.createAsyncMiddleware(le)
  });
  async function B(Me, Ee) {
    Ee.result = await e(Me);
  }
  async function H(Me, Ee) {
    const Re = await e(Me);
    Ee.result = Re[0] || null;
  }
  async function V(Me, Ee) {
    if (!h)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = Me.params[0] || {};
    Re.from = await me(Re.from, Me), Ee.result = await h(Re, Me);
  }
  async function X(Me, Ee) {
    if (!q)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = Me.params[0] || {};
    Re.from = await me(Re.from, Me), Ee.result = await q(Re, Me);
  }
  async function Q(Me, Ee) {
    if (!g)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = await me(Me.params[0], Me), Ne = Me.params[1], ne = Me.params[2] || {}, Y = Object.assign(Object.assign({}, ne), { from: Re, data: Ne });
    Ee.result = await g(Y, Me);
  }
  async function ee(Me, Ee) {
    if (!A)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = Me.params[0], Ne = await me(Me.params[1], Me), ne = "V1", Y = Me.params[2] || {}, M = Object.assign(Object.assign({}, Y), { from: Ne, data: Re });
    Ee.result = await A(M, Me, ne);
  }
  async function ie(Me, Ee) {
    if (!P)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = await me(Me.params[0], Me), Ne = Me.params[1], ne = "V3", Y = {
      data: Ne,
      from: Re,
      version: ne
    };
    Ee.result = await P(Y, Me, ne);
  }
  async function te(Me, Ee) {
    if (!I)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = await me(Me.params[0], Me), Ne = Me.params[1], ne = "V4", Y = {
      data: Ne,
      from: Re,
      version: ne
    };
    Ee.result = await I(Y, Me, ne);
  }
  async function se(Me, Ee) {
    if (!U)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = Me.params[0], Ne = Me.params[1], ne = Me.params[2] || {};
    let Y, M;
    if (resemblesAddress(Re) && !resemblesAddress(Ne)) {
      let O = "The eth_personalSign method requires params ordered ";
      O += "[message, address]. This was previously handled incorrectly, ", O += "and has been corrected automatically. ", O += "Please switch this param order for smooth behavior in the future.", Ee.warning = O, Y = Re, M = Ne;
    } else
      M = Re, Y = Ne;
    Y = await me(Y, Me);
    const $ = Object.assign(Object.assign({}, ne), { from: Y, data: M });
    Ee.result = await U($, Me);
  }
  async function le(Me, Ee) {
    const Re = Me.params[0], Ne = Me.params[1], ne = sigUtil.recoverPersonalSignature({
      data: Re,
      signature: Ne
    });
    Ee.result = ne;
  }
  async function ce(Me, Ee) {
    if (!S)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = await me(Me.params[0], Me);
    Ee.result = await S(Re, Me);
  }
  async function pe(Me, Ee) {
    if (!o)
      throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
    const Re = Me.params[0], Ne = await me(Me.params[1], Me), ne = Me.params[2] || {}, Y = Object.assign(Object.assign({}, ne), { from: Ne, data: Re });
    Ee.result = await o(Y, Me);
  }
  async function me(Me, Ee) {
    if (typeof Me == "string" && Me.length > 0 && resemblesAddress(Me)) {
      const Ne = (await e(Ee, {
        suppressUnauthorized: !1
      })).map((Y) => Y.toLowerCase()), ne = Me.toLowerCase();
      if (Ne.includes(ne))
        return ne;
      throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
    }
    throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
      message: "Invalid parameters: must provide an Ethereum address."
    });
  }
}
wallet.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(e) {
  return e.length === 2 + 20 * 2;
}
(function(e) {
  var o = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(g, U, h, q) {
    q === void 0 && (q = h), Object.defineProperty(g, q, { enumerable: !0, get: function() {
      return U[h];
    } });
  } : function(g, U, h, q) {
    q === void 0 && (q = h), g[q] = U[h];
  }), S = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(g, U) {
    for (var h in g)
      h !== "default" && !Object.prototype.hasOwnProperty.call(U, h) && o(U, g, h);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), S(blockCache, e), S(blockRefRewrite, e), S(blockRef, e), S(blockTrackerInspector, e), S(fetch$2, e), S(inflightCache, e), S(providerAsMiddleware$1, e), S(providerFromEngine$1, e), S(providerFromMiddleware$1, e), S(retryOnEmpty, e), S(wallet, e);
})(dist$5);
const makeRequestID = () => (/* @__PURE__ */ new Date()).getTime(), requestFactory = ({
  wepinProvider: e,
  network: o,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  req: S,
  res: g,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  next: U,
  end: h,
  command: q,
  parameter: A
}) => {
  var B;
  const P = makeRequestID();
  e.once(P.toString(), async (H) => {
    var V;
    if (H.body.data === "User Cancel")
      e.queue.shift(), h(dist$7.ethErrors.provider.userRejectedRequest());
    else {
      if (g.result = H.body.data === "User Cancel" ? "" : H.body.data, H.body.command === "request_enable") {
        const X = (V = g.result) == null ? void 0 : V[0];
        setSelectedAddress(
          e.wepinStorage,
          e.wepinAppId,
          o,
          X
        );
      }
      H.body.command === "wallet_switchEthereumChain" && (g.result.rpcUrl = JSON.parse(g.result.rpcUrl), g.result.wepinProvider = e), h();
    }
  });
  const I = {
    header: {
      request_from: "web",
      request_to: "wepin_widget",
      id: P
    },
    body: {
      command: q,
      parameter: A
    }
  };
  try {
    e.queue.push(I), (B = e.wepinWidget) != null && B.isOpen || e.openModal().catch((H) => {
      h(H);
    });
  } catch (H) {
    h(H);
  }
}, requestAccounts = ({ wepinProvider: e, network: o }) => (S, g, U, h) => {
  var P;
  if (!e._isInitialized) {
    h(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  const q = {
    network: o
  }, A = (P = getSelectedAddress(
    e.wepinStorage,
    e.wepinAppId,
    o
  )) == null ? void 0 : P.address;
  A ? (window.evmproviders.Wepin.selectedAddress = A, g.result = [A], h()) : requestFactory({
    wepinProvider: e,
    network: o,
    req: S,
    res: g,
    next: U,
    end: h,
    command: "request_enable",
    parameter: q
  });
}, signTransaction = ({ wepinProvider: e, network: o }) => (S, g, U, h) => {
  var B;
  if (!e._isInitialized) {
    h(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  let q = !1;
  const A = Array.isArray(S.params) ? S.params[0] : S.params;
  Object.values(A).forEach((H) => {
    H && !H.startsWith("0x") && (console.error(`${H} is not start with '0x'`), h(dist$7.ethErrors.rpc.invalidParams()), q = !0);
  });
  const P = S.params[0].from;
  if (((B = getSelectedAddress(
    e.wepinStorage,
    e.wepinAppId,
    o
  )) == null ? void 0 : B.address) !== (P == null ? void 0 : P.toLowerCase())) {
    h(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  if (!q) {
    const H = {
      account: {
        address: S.params[0].from,
        network: o
      },
      ...S.params[0]
    };
    requestFactory({
      wepinProvider: e,
      network: o,
      req: S,
      res: g,
      next: U,
      end: h,
      command: "sign_transaction",
      parameter: H
    });
  }
}, sendTransaction = ({ wepinProvider: e, network: o }) => (S, g, U, h) => {
  var B;
  if (!e._isInitialized) {
    h(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  const q = Array.isArray(S.params) ? S.params[0] : S.params;
  let A = !1;
  Object.values(q).forEach((H) => {
    H && !H.startsWith("0x") && (console.error(`${H} is not start with '0x'`), h(dist$7.ethErrors.rpc.invalidParams()), A = !0);
  });
  const P = S.params[0].from;
  if (((B = getSelectedAddress(
    e.wepinStorage,
    e.wepinAppId,
    o
  )) == null ? void 0 : B.address) !== (P == null ? void 0 : P.toLowerCase())) {
    h(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  A || requestFactory({
    wepinProvider: e,
    network: o,
    req: S,
    res: g,
    next: U,
    end: h,
    command: "send_transaction",
    parameter: {
      account: {
        address: P,
        network: o
      },
      ...S.params[0]
    }
  });
}, signTypedData = ({
  wepinProvider: e,
  network: o,
  version: S
}) => (g, U, h, q) => {
  var H;
  if (!e._isInitialized) {
    q(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  if (g.params.length !== 2) {
    q(dist$7.ethErrors.rpc.invalidParams());
    return;
  }
  const [A, P] = g.params;
  if (((H = getSelectedAddress(
    e.wepinStorage,
    e.wepinAppId,
    o
  )) == null ? void 0 : H.address) !== (A == null ? void 0 : A.toLowerCase())) {
    q(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  requestFactory({
    wepinProvider: e,
    network: o,
    req: g,
    res: U,
    next: h,
    end: q,
    command: "sign_typed_data",
    parameter: {
      account: {
        network: o,
        address: A
      },
      data: P,
      version: S
    }
  });
}, sign = ({
  wepinProvider: e,
  network: o,
  isPersonal: S
}) => (g, U, h, q) => {
  var X;
  if (!e._isInitialized) {
    q(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  if (g.params.length !== 2) {
    q(dist$7.ethErrors.rpc.invalidParams());
    return;
  }
  const [A, P] = g.params, [I, B] = S ? [P, A] : [A, P];
  if (((X = getSelectedAddress(
    e.wepinStorage,
    e.wepinAppId,
    o
  )) == null ? void 0 : X.address) !== (I == null ? void 0 : I.toLowerCase())) {
    q(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  requestFactory({
    wepinProvider: e,
    network: o,
    req: g,
    res: U,
    next: h,
    end: q,
    command: "sign",
    parameter: {
      account: {
        address: I,
        network: o
      },
      data: B
    }
  });
}, switchEthereumChain = ({ wepinProvider: e, network: o }) => (S, g, U, h) => {
  if (!e._isInitialized) {
    h(dist$7.ethErrors.provider.unauthorized());
    return;
  }
  const q = Array.isArray(S.params) ? S.params[0] : S.params;
  if (!(q != null && q.chainId) || !(q != null && q.chainId.startsWith("0x"))) {
    h(dist$7.ethErrors.rpc.invalidParams());
    return;
  }
  if (!isValidChainId(q.chainId))
    return h(dist$7.ethErrors.rpc.invalidParams());
  const A = {
    account: {
      network: o
    },
    ...S.params[0]
  };
  requestFactory({
    wepinProvider: e,
    network: o,
    req: S,
    res: g,
    next: U,
    end: h,
    command: "wallet_switchEthereumChain",
    parameter: A
  });
}, createWepinMiddleware$1 = ({
  wepinProvider: e,
  network: o
}) => dist$6.createScaffoldMiddleware({
  eth_requestAccounts: requestAccounts({ wepinProvider: e, network: o }),
  eth_accounts: requestAccounts({ wepinProvider: e, network: o }),
  eth_signTransaction: signTransaction({ wepinProvider: e, network: o }),
  eth_sendTransaction: sendTransaction({ wepinProvider: e, network: o }),
  eth_signTypedData_v1: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V1"
  }),
  eth_signTypedData_v3: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V3"
  }),
  eth_signTypedData_v4: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V4"
  }),
  eth_sign: sign({ wepinProvider: e, network: o, isPersonal: !1 }),
  personal_sign: sign({ wepinProvider: e, network: o, isPersonal: !0 }),
  wallet_switchEthereumChain: switchEthereumChain({ wepinProvider: e, network: o })
}), createWepinMiddleware = ({
  wepinProvider: e,
  network: o
}) => dist$6.createScaffoldMiddleware({
  //for web3, ethers
  eth_requestAccounts: requestAccounts({ wepinProvider: e, network: o }),
  eth_accounts: requestAccounts({ wepinProvider: e, network: o }),
  eth_signTransaction: signTransaction({ wepinProvider: e, network: o }),
  eth_sendTransaction: sendTransaction({ wepinProvider: e, network: o }),
  eth_signTypedData_v1: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V1"
  }),
  eth_signTypedData_v3: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V3"
  }),
  eth_signTypedData_v4: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V4"
  }),
  eth_sign: sign({ wepinProvider: e, network: o, isPersonal: !1 }),
  //for caver
  klay_requestAccounts: requestAccounts({ wepinProvider: e, network: o }),
  klay_accounts: requestAccounts({ wepinProvider: e, network: o }),
  klay_signTransaction: signTransaction({ wepinProvider: e, network: o }),
  klay_sendTransaction: sendTransaction({ wepinProvider: e, network: o }),
  klay_signTypedData_v1: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V1"
  }),
  klay_signTypedData_v3: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V3"
  }),
  klay_signTypedData_v4: signTypedData({
    wepinProvider: e,
    network: o,
    version: "V4"
  }),
  klay_sign: sign({ wepinProvider: e, network: o, isPersonal: !1 }),
  personal_sign: sign({ wepinProvider: e, network: o, isPersonal: !0 }),
  wallet_switchEthereumChain: switchEthereumChain({ wepinProvider: e, network: o })
}), gatewayUrl = {
  Gateway: "https://gateway.wepin.io"
}, lr = class lr extends SafeEventEmitter {
  constructor({
    logger: o = console,
    maxEventListeners: S = 100,
    rpcMiddleware: g = []
  } = {}) {
    super(), this.uuid = "wepinprovider", this.name = "Wepin", this._log = o, this.setMaxListeners(S), this._state = {
      ...lr._defaultState
    }, this.selectedAddress = null, this.chainId = null, this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);
    const U = new dist$6.JsonRpcEngine();
    g.forEach((h) => U.push(h)), this._rpcEngine = U;
  }
  async request(o) {
    if (!o || typeof o != "object" || Array.isArray(o))
      throw dist$7.ethErrors.rpc.invalidRequest({
        message: "Invalid request arguments",
        data: o
      });
    this._log.debug("[RPC Request]: requesting args", o);
    const { method: S, params: g, id: U = (/* @__PURE__ */ new Date()).getTime() } = o;
    if (typeof S != "string" || S.length === 0)
      throw dist$7.ethErrors.rpc.invalidRequest({
        message: "Invalid request methods",
        data: o
      });
    if (g !== void 0 && !Array.isArray(g) && (typeof g != "object" || g === null))
      throw dist$7.ethErrors.rpc.invalidRequest({
        message: "Invalid request params",
        data: o
      });
    return new Promise((h, q) => {
      this._rpcRequest(
        { method: S, params: g, id: U },
        getRpcPromiseCallback(h, q)
      );
    });
  }
  /**
   * Initialize provider
   *
   * @param initialState
   */
  _initializeState(o) {
    if (this._state.initialized === !0)
      throw new Error("Provider already initialized.");
    if (o) {
      const { accounts: S, chainId: g, networkVersion: U } = o;
      this._handleConnect(g), this._handleChainChanged({ chainId: g, networkVersion: U }), this._handleAccountsChanged(S);
    }
    this._state.initialized = !0, this.emit("_initialized");
  }
  _rpcRequest(o, S) {
    let g = S;
    return Array.isArray(o) ? this._rpcEngine.handle(o, g) : (o.jsonrpc || (o.jsonrpc = "2.0"), (o.method === "eth_accounts" || o.method === "klay_accounts" || o.method === "eth_requestAccounts" || o.method === "klay_requestAccounts") && (g = (U, h) => {
      this._log.debug("_rpcRequest to handler account changes", U, h), this._handleAccountsChanged(h.result || []), S(U, h);
    }), o.method === "wallet_switchEthereumChain" && (g = (U, h) => {
      var I, B, H;
      this._log.debug("_rpcRequest to handler chain changes", U, h);
      const { rpcUrl: q, wepinProvider: A, ...P } = h.result;
      try {
        this.changeChain({
          wepinProvider: A,
          rpcUrl: q,
          network: (I = h.result) == null ? void 0 : I.network,
          address: (B = h.result) == null ? void 0 : B.address
        });
      } catch (V) {
        U = V;
      }
      h.result = P, (H = h.result) != null && H.chainId && this._handleChainChanged({ chainId: h.result.chainId }), S(U, h);
    }), this._rpcEngine.handle(o, g));
  }
  setRpcEngine(o) {
    const S = new dist$6.JsonRpcEngine();
    o.forEach((g) => S.push(g)), this._rpcEngine = S;
  }
  changeChain({
    wepinProvider: o,
    network: S,
    rpcUrl: g,
    address: U
  }) {
    const h = [];
    this._log.debug("changeChain rpcMiddlewareList", h);
    const q = S.toLowerCase();
    if (q.startsWith("evm") || q === "ethereum") {
      const A = createWepinMiddleware$1({
        wepinProvider: o,
        network: S
      }), P = [];
      P.push(A), g == null || g.forEach((I) => {
        let B = I.url;
        I.type === "internal" && (B = gatewayUrl.Gateway + I.url), P.push(dist$5.createFetchMiddleware({ rpcUrl: B }));
      }), this.setRpcEngine(P), this.selectedAddress = U == null ? void 0 : U.toLowerCase(), setSelectedAddress(
        o.wepinStorage,
        o.wepinAppId,
        S,
        U
      );
    } else if (q.startsWith("klaytn")) {
      const A = createWepinMiddleware({
        wepinProvider: o,
        network: S
      }), P = [];
      P.push(A), g == null || g.forEach((I) => {
        let B = I.url;
        I.type === "internal" && (B = gatewayUrl.Gateway + I.url), P.push(dist$5.createFetchMiddleware({ rpcUrl: B }));
      }), this._log.debug("changeChain middlewareList", P), this.setRpcEngine(P), this.selectedAddress = U == null ? void 0 : U.toLowerCase(), setSelectedAddress(
        o.wepinStorage,
        o.wepinAppId,
        S,
        U
      );
    } else
      throw new Error(`Can not resolve network name: ${S}`);
  }
  _handleConnect(o) {
    this._state.isConnected || (this._state.isConnected = !0, this.emit("connect", { chainId: o }));
  }
  _handleDisconnect(o, S) {
    if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !o) {
      this._state.isConnected = !1;
      let g;
      o ? (g = new dist$7.EthereumRpcError(
        1013,
        // Try again later
        S || "Provider disconnected"
      ), this._log.debug(g)) : (g = new dist$7.EthereumRpcError(
        1011,
        // Internal error
        S || "Provider permanently disconnected"
      ), this._log.error(g), this.chainId = null, this._state.accounts = null, this.selectedAddress = null, this._state.isPermanentlyDisconnected = !0), this.emit("disconnect", g);
    }
  }
  _handleChainChanged({
    chainId: o
  } = {}) {
    if (!isValidChainId(o)) {
      this._log.error("Invalid network params", { chainId: o });
      return;
    }
    this._handleConnect(o), o !== this.chainId && (this.chainId = o, this._state.initialized && this.emit("chainChanged", this.chainId));
  }
  _handleAccountsChanged(o) {
    let S = o;
    Array.isArray(o) || (this._log.error(
      "Received invalid accounts parameter. Please report this bug.",
      o
    ), S = []);
    for (const g of o)
      if (typeof g != "string") {
        this._log.error(
          "Received non-string account. Please report this bug.",
          o
        ), S = [];
        break;
      }
    equal(this._state.accounts, S) || (this._state.accounts = S, this.selectedAddress !== S[0] && (this.selectedAddress = S[0] || null), this._state.initialized && this.emit("accountsChanged", S));
  }
};
lr._defaultState = {
  accounts: null,
  isConnected: !1,
  initialized: !1,
  isPermanentlyDisconnected: !1
};
let BaseProvider = lr, InPageProvider$1 = class br extends BaseProvider {
  constructor({
    network: o,
    rpcUrl: S,
    chainId: g,
    wepinProvider: U
  }) {
    const h = [], q = createWepinMiddleware$1({ wepinProvider: U, network: o });
    h.push(q), S.forEach((A) => {
      let P = A.url;
      A.type === "internal" && (P = gatewayUrl.Gateway + A.url), h.push(dist$5.createFetchMiddleware({ rpcUrl: P }));
    }), super({ rpcMiddleware: h }), this._initializeState({
      accounts: [],
      chainId: g
    });
  }
  static async generate(o) {
    var h;
    const { rpcUrl: S, chainId: g } = await getNetworkInfoByName(o.network), U = new br({
      network: o.network,
      rpcUrl: S,
      chainId: g,
      wepinProvider: o.wepinProvider
    });
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[U.name] = U, window.evmproviders[U.name].selectedAddress = (h = o.address) == null ? void 0 : h.toLowerCase(), U;
  }
};
class InPageProvider extends BaseProvider {
  constructor({
    network: o,
    rpcUrl: S,
    chainId: g,
    wepinProvider: U
  }) {
    const h = [], q = createWepinMiddleware({ wepinProvider: U, network: o });
    h.push(q), S.forEach((A) => {
      let P = A.url;
      A.type === "internal" && (P = gatewayUrl.Gateway + A.url), h.push(dist$5.createFetchMiddleware({ rpcUrl: P }));
    }), super({ rpcMiddleware: h }), this._initializeState({
      accounts: [],
      chainId: g
    });
  }
  static async generate(o) {
    var h;
    const { rpcUrl: S, chainId: g } = await getNetworkInfoByName(o.network), U = new InPageProvider({
      network: o.network,
      rpcUrl: S,
      chainId: g,
      wepinProvider: o.wepinProvider
    });
    return window.evmproviders = window.evmproviders || {}, window.evmproviders[U.name] = U, window.evmproviders[U.name].selectedAddress = (h = o.address) == null ? void 0 : h.toLowerCase(), U;
  }
}
const name = "@wepin/provider-js", version = "0.0.1", description = "Wepin Widget Javascript SDK for Web", author = "IoTrust, Co., Ltd.", homepage = "https://github.com/WepinWallet/wepin-web-sdk-v1/", license = "MIT", main = "./dist/wepin-provider-js.mjs", jsdelivr = "./dist/wepin-provider-js.umd.js", types = "./dist/src/index.d.ts", files = [
  "dist"
], scripts = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, keywords = [
  "wepin",
  "wepinwallet",
  "wallet",
  "web3",
  "provider"
], dependencies = {
  "@wepin/fetch-js": "link:../fetch",
  "@wepin/modal-js": "link:../modal",
  "@wepin/storage-js": "link:../storage",
  "@wepin/utils": "^1.0.3",
  "eth-json-rpc-middleware": "^9.0.1",
  events: "^3.3.0",
  "json-rpc-engine": "^6.1.0",
  "jwt-decode": "^4.0.0"
}, devDependencies = {
  "@types/events": "^3.0.3"
}, PackageJson = {
  name,
  version,
  description,
  author,
  homepage,
  license,
  main,
  jsdelivr,
  types,
  files,
  scripts,
  keywords,
  dependencies,
  devDependencies
};
var Platform = /* @__PURE__ */ ((e) => (e[e.web = 1] = "web", e[e.android = 2] = "android", e[e.ios = 3] = "ios", e))(Platform || {});
const WebviewRequestHandler = (e, o, S) => {
  var h;
  const g = {
    header: {
      response_from: "web",
      response_to: "wepin_widget",
      id: e.header.id
    }
  };
  let U = S.appKey;
  switch (S.appKey.slice(0, 13) === "local_ak_dev_" ? U = S.appKey.slice(6) : U = S.appKey, e.body.command) {
    case "ready_to_widget":
      {
        const q = Object.assign({}, o.wepinAppAttributes);
        g.body = {
          command: "ready_to_widget",
          state: "SUCCESS",
          data: {
            appKey: U,
            appId: S.appId,
            domain: o.wepinDomain,
            platform: Platform[o.type],
            attributes: q,
            //Object.assign({}, wepinSDK.wepinAppAttributes),
            type: `${o.type}-provider`,
            version: o.version.includes("-alpha") ? o.version.substring(
              0,
              o.version.indexOf("-")
            ) : o.version,
            localDate: o.wepinStorage.getAllLocalStorage(S.appId) ?? {}
          }
        };
      }
      break;
    case "close_wepin_widget":
      o.wepinWidget.close();
      break;
    case "dequeue_request":
      if (o.queue[0]) {
        const q = proxyToObject(o.queue[0]);
        g.body = {
          command: e.body.command,
          state: "SUCCESS",
          data: q
          // data: {
          //   body: {
          //     command: wepinProvider.queue[0].body.command,
          //     parameter: Object.assign(
          //       {},
          //       wepinProvider.queue[0].body.parameter,
          //     ),
          //   },
          //   header: Object.assign({}, wepinProvider.queue[0].header),
          // }, //Object.assign({}, wepinProvider.queue[0]), //        dequeue  .
        };
      } else
        g.body = {
          command: e.body.command,
          state: "ERROR",
          data: null
        };
      break;
    case "set_local_storage":
      o.wepinStorage.setAllLocalStorage(
        S.appId,
        e.body.parameter.data
      ), g.body = {
        command: "set_local_storage",
        state: "SUCCESS",
        data: ""
      };
      break;
    default:
      throw new Error(`Command ${e.body.command} is not supported.`);
  }
  (h = o.wepinWidget) != null && h.isOpen && o.wepinWidget.response(g);
}, WebviewResponseHandler = (e, o) => {
  o.queue.shift(), o.emit(e.header.id.toString(), e);
}, getEventListener = (e, o) => {
  const S = (g) => !(!(e.wepinWidget.url.includes("/wepin-sdk-login") || e.wepinWidget.url.includes(g.origin)) && g.origin !== e.wepinWidget.url || !Object.prototype.hasOwnProperty.call(g.data, "header") || !Object.prototype.hasOwnProperty.call(g.data, "body"));
  return (g) => {
    S(g) && handleMessage(
      g.data,
      e,
      o
    );
  };
}, handleMessage = (e, o, S) => {
  e.header.request_to === "web" ? WebviewRequestHandler(
    e,
    o,
    S
  ) : e.header.response_to === "web" ? WebviewResponseHandler(e, o) : console.error("Failed to handle message:", e);
};
class WepinProvider extends SafeEventEmitter {
  constructor({
    appId: o,
    appKey: S,
    modal: g,
    storage: U
  }) {
    super(), this._isInitialized = !1, this.wepinAppId = o, this._wepinAppKey = S, this.version = PackageJson.version, this._wepinModal = g ?? new k(), this._wepinStorage = U ?? c, this.type = this._wepinStorage.platform, this.wepinDomain = this._wepinModal.domain;
  }
  get wepinStorage() {
    return this._wepinStorage;
  }
  _initQueue() {
    this.queue = new Proxy([], {
      set: (o, S, g) => {
        const U = Reflect.set(o, S, g);
        return this._widget && this._widget.isOpen && this._widget.request({
          header: {
            request_from: "web",
            request_to: "wepin_widget",
            id: (/* @__PURE__ */ new Date()).getTime()
            // default
          },
          body: {
            command: "provider_request",
            parameter: ""
          }
        }), U;
      }
    });
  }
  get wepinModal() {
    return this._wepinModal;
  }
  get wepinWidget() {
    return this._widget;
  }
  set wepinWidget(o) {
    this._widget = o;
  }
  changeLanguage(o) {
    this.wepinAppAttributes = {
      defaultLanguage: o.language,
      defaultCurrency: o.currency
    };
  }
  async init(o) {
    var g;
    this._wepinFetch = new WepinFetch({
      appId: this.wepinAppId,
      appKey: this._wepinAppKey,
      domain: this.wepinDomain,
      sdk: { version: this.version, type: `${this.type}-provider` },
      storage: this._wepinStorage
    }), await this._wepinFetch.init();
    const S = await this._wepinFetch.wepinApi.app.getAppInfo({
      platform: ProjectPlatformKind[this.type],
      withNetwork: !1
    });
    if (isErrorResponse(S))
      throw new Error(S.message);
    this.wepinAppId = this._wepinFetch.appId = S.appInfo.id, this._url = (g = getBaseUrl(this._wepinAppKey)) == null ? void 0 : g.toString(), this._isInitialized = !0, this._EL = getEventListener(this, {
      appKey: this._wepinAppKey,
      appId: this.wepinAppId
    }), this.wepinAppAttributes = o ?? {
      defaultCurrency: "USD",
      defaultLanguage: "en"
    }, this._initQueue();
  }
  isInitialized() {
    return this._isInitialized;
  }
  async checkExpiredToken() {
    try {
      const o = this._wepinStorage.getLocalStorage(
        this.wepinAppId,
        "wepin:connectUser"
      );
      if (!o)
        return !0;
      if (jwtDecode(o.accessToken).exp < Math.floor(Date.now() / 1e3) + 60) {
        this._wepinFetch.setToken(o);
        const g = await this._wepinFetch.wepinApi.user.refreshToken();
        return isErrorResponse(g) ? !0 : (o.accessToken = g.token, this._wepinStorage.setLocalStorage(
          this.wepinAppId,
          "wepin:connectUser",
          o
        ), !1);
      } else
        return !1;
    } catch {
      return !0;
    }
  }
  /**
   * It returns a Provider by given network, chainId.
   *
   * @reference https://docs.wepin.io/kr/wepin/supported-blockchain
   * @param network - Available chains Wepin helps provide.
   *  It should be lowercase.
   * @returns A EIP-1193 provider
   */
  async getProvider(o) {
    var g, U, h, q, A;
    if (this._isInitialized === !1)
      throw new Error(
        "WepinProvider is not initialized yet. Please call init() method first."
      );
    if ((g = window.evmproviders) != null && g.Wepin) {
      const P = (U = window.evmproviders) == null ? void 0 : U.Wepin.chainId, I = await getNetworkByChainId(P), B = (q = (h = window.evmproviders) == null ? void 0 : h.Wepin.selectedAddress) == null ? void 0 : q.toLowerCase();
      if (!await this.checkExpiredToken()) {
        const H = this._wepinStorage.getLocalStorage(
          this.wepinAppId,
          "wallet_id"
        ), V = this._wepinStorage.getLocalStorage(
          this.wepinAppId,
          "user_id"
        ), X = await this._wepinFetch.wepinApi.account.getAppAccountList({
          walletId: H,
          userId: V,
          localeId: this.wepinAppAttributes.defaultLanguage === "ko" ? 1 : 2
        });
        if (!isErrorResponse(X) && ((A = X.aa_accounts) != null && A.length ? X.accounts.concat(X.aa_accounts) : X.accounts ?? []).filter(
          (ie) => {
            var te;
            return ((te = ie.address) == null ? void 0 : te.toLowerCase()) === B && ie.network.toLowerCase() === I;
          }
        ).length)
          return window.evmproviders.Wepin;
      }
    }
    const S = o.toLowerCase();
    if (S.startsWith("evm") || S === "ethereum")
      return await InPageProvider$1.generate({
        network: S,
        wepinProvider: this
      });
    if (S.startsWith("klaytn"))
      return await InPageProvider.generate({
        network: S,
        wepinProvider: this
      });
    throw new Error(`Can not resolve network name: ${o}`);
  }
  async openModal() {
    this._widget = await this.wepinModal.openModal(this._url, this._EL);
  }
  finalize() {
    this._wepinStorage.clearLocalStorage(
      PROVIDER_COOKIE_NAME + this.wepinAppId,
      "selectedAddress"
    ), this._initQueue();
  }
}
export {
  WepinProvider,
  getNetworkByChainId,
  getNetworkInfoByName
};
